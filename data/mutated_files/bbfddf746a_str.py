from typing import TypeAlias
__typ0 : TypeAlias = "ModuleType"
import re
import sys

from typing import Any, Optional, Tuple, Sequence, MutableSequence, List, MutableMapping, IO
from types import ModuleType


# Type Alias for Signatures
Sig = Tuple[str, str]


def __tmp3(__tmp13) -> Optional[Tuple[str,
                                                List[str],
                                                List[str]]]:
    m = re.match(r'([.a-zA-Z0-9_]+)\(([^)]*)\)', __tmp13)
    if not m:
        return None
    __tmp12 = m.group(1)
    __tmp12 = __tmp12.split('.')[-1]
    arg_string = m.group(2)
    if not arg_string.strip():
        return (__tmp12, [], [])
    args = [arg.strip() for arg in arg_string.split(',')]
    __tmp8 = []
    __tmp2 = []
    i = 0
    while i < len(args):
        if args[i].startswith('[') or '=' in args[i]:
            break
        __tmp8.append(args[i].rstrip('['))
        i += 1
        if args[i - 1].endswith('['):
            break
    while i < len(args):
        arg = args[i]
        arg = arg.strip('[]')
        arg = arg.split('=')[0]
        __tmp2.append(arg)
        i += 1
    return (__tmp12, __tmp8, __tmp2)


def __tmp4(__tmp8: Sequence[str],
                    __tmp2: Sequence[str]) -> str:
    args = []  # type: MutableSequence[str]
    args.extend(__tmp8)
    for arg in __tmp2:
        if arg.startswith('*'):
            args.append(arg)
        else:
            args.append('%s=...' % arg)
    __tmp13 = '(%s)' % ', '.join(args)
    # Ad-hoc fixes.
    __tmp13 = __tmp13.replace('(self)', '')
    return __tmp13


def __tmp6(__tmp5: Sequence[str]) -> Tuple[List[Sig],
                                                        List[Sig]]:
    __tmp11 = []
    class_sigs = []
    for line in __tmp5:
        line = line.strip()
        m = re.match(r'\.\. *(function|method|class) *:: *[a-zA-Z_]', line)
        if m:
            __tmp13 = line.split('::')[1].strip()
            parsed = __tmp3(__tmp13)
            if parsed:
                __tmp12, __tmp8, __tmp2 = parsed
                if m.group(1) != 'class':
                    __tmp11.append((__tmp12, __tmp4(__tmp8, __tmp2)))
                else:
                    class_sigs.append((__tmp12, __tmp4(__tmp8, __tmp2)))

    return sorted(__tmp11), sorted(class_sigs)


def find_unique_signatures(__tmp11: Sequence[Sig]) -> List[Sig]:
    sig_map = {}  # type: MutableMapping[str, List[str]]
    for __tmp12, __tmp13 in __tmp11:
        sig_map.setdefault(__tmp12, []).append(__tmp13)
    result = []
    for __tmp12, name_sigs in sig_map.items():
        if len(set(name_sigs)) == 1:
            result.append((__tmp12, name_sigs[0]))
    return sorted(result)


def __tmp1(module: __typ0) :
    return '__file__' not in module.__dict__ or module.__dict__['__file__'].endswith('.so')


def __tmp9(__tmp10: IO[str], module_name: Optional[str] = None,
                 pyversion: Tuple[int, int] = (3, 5)) :
    if module_name:
        if pyversion[0] >= 3:
            version = '%d.%d' % (sys.version_info.major,
                                 sys.version_info.minor)
        else:
            version = '2'
        __tmp10.write('# Stubs for %s (Python %s)\n' % (module_name, version))
    __tmp10.write(
        '#\n'
        '# NOTE: This dynamically typed stub was automatically generated by stubgen.\n\n')


def __tmp0(__tmp7: <FILL>, __tmp12: str) -> Optional[str]:
    if not __tmp7:
        return None
    __tmp7 = __tmp7.lstrip()
    m = re.match(r'%s(\([a-zA-Z0-9_=, ]*\))' % __tmp12, __tmp7)
    if m:
        return m.group(1)
    else:
        return None
