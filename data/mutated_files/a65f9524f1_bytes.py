from typing import TypeAlias
__typ4 : TypeAlias = "Response"
__typ0 : TypeAlias = "Text"
__typ1 : TypeAlias = "StateApps"
__typ2 : TypeAlias = "str"
# -*- coding: utf-8 -*-
# Generated by Django 1.10.5 on 2017-03-09 05:23

import io
import logging
import os
import urllib
from mimetypes import guess_type
from typing import Dict, Optional, Text, Tuple, Union

import requests
from boto.s3.connection import S3Connection
from boto.s3.key import Key
from django.conf import settings
from django.db import migrations, models
from django.db.backends.postgresql_psycopg2.schema import DatabaseSchemaEditor
from django.db.migrations.state import StateApps
from PIL import Image, ImageOps
from requests import ConnectionError, Response

def force_str(s, encoding: __typ0='utf-8') -> __typ2:
    """converts a string to a native string"""
    if isinstance(s, __typ2):
        return s
    elif isinstance(s, __typ0):
        return s.encode(__typ2(encoding))
    elif isinstance(s, bytes):
        return s.decode(encoding)
    else:
        raise TypeError("force_str expects a string type")


class __typ3:
    def __init__(__tmp0) -> None:
        __tmp0.path_template = "{realm_id}/emoji/{emoji_file_name}"
        __tmp0.emoji_size = (64, 64)

    def upload_files(__tmp0, __tmp1: __typ4, __tmp2: bytes,
                     dst_path_id: __typ0) -> None:
        raise NotImplementedError()

    def get_dst_path_id(__tmp0, realm_id: int, url: __typ0, emoji_name: __typ0) :
        _, image_ext = os.path.splitext(url)
        file_name = ''.join((emoji_name, image_ext))
        return file_name, __tmp0.path_template.format(realm_id=realm_id, emoji_file_name=file_name)

    def resize_emoji(__tmp0, image_data: <FILL>) -> Optional[bytes]:
        im = Image.open(io.BytesIO(image_data))
        format_ = im.format
        if format_ == 'GIF' and im.is_animated:
            return None
        im = ImageOps.fit(im, __tmp0.emoji_size, Image.ANTIALIAS)
        out = io.BytesIO()
        im.save(out, format_)
        return out.getvalue()

    def upload_emoji(__tmp0, realm_id: int, image_url: __typ0,
                     emoji_name: __typ0) -> Optional[__typ0]:
        file_name, dst_path_id = __tmp0.get_dst_path_id(realm_id, image_url, emoji_name)
        if image_url.startswith("/"):
            # Handle relative URLs.
            image_url = urllib.parse.urljoin(settings.EXTERNAL_HOST, image_url)
        try:
            __tmp1 = requests.get(image_url, stream=True)
        except ConnectionError:
            return None
        if __tmp1.status_code != 200:
            return None
        try:
            __tmp2 = __tmp0.resize_emoji(__tmp1.content)
        except IOError:
            return None
        __tmp0.upload_files(__tmp1, __tmp2, dst_path_id)
        return file_name


class LocalUploader(__typ3):
    def __init__(__tmp0) -> None:
        super().__init__()

    @staticmethod
    def mkdirs(path) -> None:
        dirname = os.path.dirname(path)
        if not os.path.isdir(dirname):
            os.makedirs(dirname)

    def write_local_file(__tmp0, path: __typ0, file_data: bytes) -> None:
        __tmp0.mkdirs(path)
        with open(path, 'wb') as f:
            f.write(file_data)

    def upload_files(__tmp0, __tmp1: __typ4, __tmp2: bytes,
                     dst_path_id: __typ0) -> None:
        dst_file = os.path.join(settings.LOCAL_UPLOADS_DIR, 'avatars', dst_path_id)
        if __tmp2:
            __tmp0.write_local_file(dst_file, __tmp2)
        else:
            __tmp0.write_local_file(dst_file, __tmp1.content)
        __tmp0.write_local_file('.'.join((dst_file, 'original')), __tmp1.content)


class S3Uploader(__typ3):
    def __init__(__tmp0) -> None:
        super().__init__()
        conn = S3Connection(settings.S3_KEY, settings.S3_SECRET_KEY)
        bucket_name = settings.S3_AVATAR_BUCKET
        __tmp0.bucket = conn.get_bucket(bucket_name, validate=False)

    def upload_to_s3(__tmp0, path: __typ0, file_data: bytes,
                     headers: Optional[Dict[__typ0, __typ0]]) -> None:
        key = Key(__tmp0.bucket)
        key.key = path
        key.set_contents_from_string(force_str(file_data), headers=headers)

    def upload_files(__tmp0, __tmp1: __typ4, __tmp2: bytes,
                     dst_path_id: __typ0) -> None:
        headers = None  # type: Optional[Dict[Text, Text]]
        content_type = __tmp1.headers.get(__typ2("Content-Type")) or guess_type(dst_path_id)[0]
        if content_type:
            headers = {'Content-Type': content_type}
        if __tmp2:
            __tmp0.upload_to_s3(dst_path_id, __tmp2, headers)
        else:
            __tmp0.upload_to_s3(dst_path_id, __tmp1.content, headers)
        __tmp0.upload_to_s3('.'.join((dst_path_id, 'original')), __tmp1.content, headers)

def get_uploader() -> __typ3:
    if settings.LOCAL_UPLOADS_DIR is None:
        return S3Uploader()
    return LocalUploader()


def upload_emoji_to_storage(apps: __typ1, schema_editor: DatabaseSchemaEditor) -> None:
    realm_emoji_model = apps.get_model('zerver', 'RealmEmoji')
    uploader = get_uploader()  # type: Uploader
    for emoji in realm_emoji_model.objects.all():
        file_name = uploader.upload_emoji(emoji.realm_id, emoji.img_url, emoji.name)
        if file_name is None:
            logging.warning("ERROR: Could not download emoji %s; please reupload manually" %
                            (emoji,))
        emoji.file_name = file_name
        emoji.save()


class Migration(migrations.Migration):
    dependencies = [
        ('zerver', '0076_userprofile_emojiset'),
    ]

    operations = [
        migrations.AddField(
            model_name='realmemoji',
            name='file_name',
            field=models.TextField(db_index=True, null=True),
        ),
        migrations.RunPython(upload_emoji_to_storage),
        migrations.RemoveField(
            model_name='realmemoji',
            name='img_url',
        ),
    ]
