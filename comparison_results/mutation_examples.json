[
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>def is_equal_to_sum_even(n: int) -> bool:\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    >>> is_equal_to_sum_even(4)\n    False\n    >>> is_equal_to_sum_even(6)\n    False\n    >>> is_equal_to_sum_even(8)\n    True\n    \"\"\"\n    if n < 8:\n        return False<fim_suffix>\n<fim_middle>",
    "mutated_program": "def __tmp0(__tmp1: int) -> bool:\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive even numbers\n    Example\n    >>> is_equal_to_sum_even(4)\n    False\n    >>> is_equal_to_sum_even(6)\n    False\n    >>> is_equal_to_sum_even(8)\n    True\n    \"\"\"\n    if n < 8:\n        return False_CodetraceSpecialPlaceholder_\n",
    "original_prediction": "return is_equal_to_sum_",
    "mutated_prediction": "return is_equal_to_sum_",
    "original_correct": false,
    "mutated_correct": false
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True<fim_suffix>\n<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp1(__tmp0: List[float], __tmp2: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True_CodetraceSpecialPlaceholder_\n",
    "original_prediction": "return False\n\nif __name__ ==",
    "mutated_prediction": "return False\n\nif __name__ ==",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>def encode(message: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    def swap_case(ch: str) -> str:\n        if ch.isupper():<fim_suffix>        else:\n            return ch.upper()\n    def encode_vowel(ch: str) -> str:\n        if ch.lower() in 'aeiou':\n            if ch.lower() in 'wxyz':\n                return ch.lower()\n            return chr(ord(ch) + 2)\n        return ch\n    return ''.join(map(lambda ch: encode_vowel(swap_case(ch)), message))\n<fim_middle>",
    "mutated_program": "def __tmp1(__tmp0: str) -> str:\n    \"\"\"\n    Write a function that takes a message, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> encode('test')\n    'TGST'\n    >>> encode('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    def __tmp3(__tmp4: str) -> str:\n        if ch.isupper():_CodetraceSpecialPlaceholder_        else:\n            return ch.upper()\n    def __tmp2(__tmp4: str) -> str:\n        if ch.lower() in 'aeiou':\n            if ch.lower() in 'wxyz':\n                return ch.lower()\n            return chr(ord(ch) + 2)\n        return ch\n    return ''.join(map(lambda ch: encode_vowel(swap_case(ch)), message))\n",
    "original_prediction": "return ch.lower()",
    "mutated_prediction": "return ch.lower()",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>from typing import Union\n\ndef compare_one(a: Union[int, float, str], b: Union[int, float, str]) -> Union[int, float, str, None]:\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    >>> compare_one(1, 2.5)\n    2.5\n    >>> compare_one(1, '2,3')\n    '2,3'\n    >>> compare_one('5,1', '6')\n    '6'\n    >>> compare_one('1', 1)\n    None\n    \"\"\"\n    if isinstance(a, int) and isinstance(b, int):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, float) and isinstance(b, float):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, str):\n        a_tmp = a.replace(',', '.')\n        b_tmp = b.replace(',', '.')\n        if float(a_tmp) > float(b_tmp):\n            return a\n        elif float(a_tmp) < float(b_tmp):\n            return b\n        else:\n            return None\n    elif isinstance(a, int) and isinstance(b, float):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, float) and isinstance(b, int):\n        if a > b:\n            return a<fim_suffix>            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, int):\n        a_tmp = a.replace(',', '.')\n        if float(a_tmp) > b:\n            return a\n        elif float(a_tmp) < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, int) and isinstance(b, str):\n        b_tmp = b.replace(',', '.')\n        if a > float(b_tmp):\n            return a\n        elif a < float(b_tmp):\n            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, float):\n        a_tmp = a.replace(',', '.')\n        if float(a_tmp) > b:\n            return a\n        elif float(a_tmp) < b:\n            return b<fim_middle>",
    "mutated_program": "from typing import Union\n\ndef __tmp0(__tmp2: Union[int, float, str], __tmp1: Union[int, float, str]) -> Union[int, float, str, None]:\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    >>> compare_one(1, 2.5)\n    2.5\n    >>> compare_one(1, '2,3')\n    '2,3'\n    >>> compare_one('5,1', '6')\n    '6'\n    >>> compare_one('1', 1)\n    None\n    \"\"\"\n    if isinstance(a, int) and isinstance(b, int):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, float) and isinstance(b, float):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, str):\n        a_tmp = a.replace(',', '.')\n        b_tmp = b.replace(',', '.')\n        if float(a_tmp) > float(b_tmp):\n            return a\n        elif float(a_tmp) < float(b_tmp):\n            return b\n        else:\n            return None\n    elif isinstance(a, int) and isinstance(b, float):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, float) and isinstance(b, int):\n        if a > b:\n            return a_CodetraceSpecialPlaceholder_            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, int):\n        a_tmp = a.replace(',', '.')\n        if float(a_tmp) > b:\n            return a\n        elif float(a_tmp) < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, int) and isinstance(b, str):\n        b_tmp = b.replace(',', '.')\n        if a > float(b_tmp):\n            return a\n        elif a < float(b_tmp):\n            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, float):\n        a_tmp = a.replace(',', '.')\n        if float(a_tmp) > b:\n            return a\n        elif float(a_tmp) < b:\n            return b",
    "original_prediction": "elif a < b:",
    "mutated_prediction": "elif a < b:",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>from typing import List, Optional\n\ndef prod_signs(arr: List[int]) -> Optional[int]:\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n    >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    None\n    \"\"\"\n    def product(lst: List[int]) -> int:\n        out = 1\n        for item in lst:\n            out *= item\n        return out\n\n    if len(arr) == 0:\n        return None\n    else:\n        sign_arr = []\n        for num in arr:\n            if num > 0:<fim_suffix>            elif num < 0:\n                sign_arr.append(-1)\n            else:\n                sign_arr.append(0)\n        return sum(map(abs, arr)) * product(sign_arr)<fim_middle>",
    "mutated_program": "from typing import List, Optional\n\ndef __tmp2(__tmp3: List[int]) -> Optional[int]:\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs([1, 2, 2, -4])\n    9\n    >>> prod_signs([0, 1])\n    0\n    >>> prod_signs([])\n    None\n    \"\"\"\n    def __tmp1(__tmp0: List[int]) -> int:\n        out = 1\n        for item in lst:\n            out *= item\n        return out\n\n    if len(arr) == 0:\n        return None\n    else:\n        sign_arr = []\n        for num in arr:\n            if num > 0:_CodetraceSpecialPlaceholder_            elif num < 0:\n                sign_arr.append(-1)\n            else:\n                sign_arr.append(0)\n        return sum(map(abs, arr)) * product(sign_arr)",
    "original_prediction": "sign_arr.append(1)",
    "mutated_prediction": "sign_arr.append(1)",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>from typing import Union\n\ndef rounded_avg(n: int, m: int) -> Union[str, int]:\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    >>> rounded_avg(1, 5)\n    '0b11'\n    >>> rounded_avg(7, 5)\n    -1\n    >>> rounded_avg(10, 20)\n    '0b1111'\n    >>> rounded_avg(20, 33)\n    '0b11010'\n    \"\"\"\n    if n <= m:\n        rounded_avg = round(((n + m) / 2))<fim_suffix>    else:\n        return(-1)<fim_middle>",
    "mutated_program": "from typing import Union\n\ndef __tmp2(__tmp0: int, __tmp1: int) -> Union[str, int]:\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    >>> rounded_avg(1, 5)\n    '0b11'\n    >>> rounded_avg(7, 5)\n    -1\n    >>> rounded_avg(10, 20)\n    '0b1111'\n    >>> rounded_avg(20, 33)\n    '0b11010'\n    \"\"\"\n    if n <= m:\n        rounded_avg = round(((n + m) / 2))_CodetraceSpecialPlaceholder_    else:\n        return(-1)",
    "original_prediction": "return(bin(rounded_avg))",
    "mutated_prediction": "return(bin(rounded_avg))",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>from typing import List\n\ndef select_words(s: str, n: int) -> List[str]:\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    >>> select_words('Mary had a little lamb', 4)\n    ['little']\n    >>> select_words('Mary had a little lamb', 3)\n    ['Mary', 'lamb']\n    >>> select_words('simple white space', 2)\n    []\n    >>> select_words('Hello world', 4)\n    ['world']\n    >>> select_words('Uncle sam', 3)\n    ['Uncle']\n    \"\"\"\n    CONSONANTS = 'bcdfghjklmnpqrstvwxyz'<fim_suffix>    result = []\n    for word in words:\n        count = 0\n        for char in word:\n            if char.lower() in CONSONANTS:\n                count += 1\n        if count == n:\n            result.append(word)\n    return result\n<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp0(__tmp1: str, __tmp2: int) -> List[str]:\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    >>> select_words('Mary had a little lamb', 4)\n    ['little']\n    >>> select_words('Mary had a little lamb', 3)\n    ['Mary', 'lamb']\n    >>> select_words('simple white space', 2)\n    []\n    >>> select_words('Hello world', 4)\n    ['world']\n    >>> select_words('Uncle sam', 3)\n    ['Uncle']\n    \"\"\"\n    CONSONANTS = 'bcdfghjklmnpqrstvwxyz'_CodetraceSpecialPlaceholder_    result = []\n    for word in words:\n        count = 0\n        for char in word:\n            if char.lower() in CONSONANTS:\n                count += 1\n        if count == n:\n            result.append(word)\n    return result\n",
    "original_prediction": "words = s.split()",
    "mutated_prediction": "words = s.split()",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>from typing import List\n\ndef unique_digits(x: List[int]) -> List[int]:\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    s=[]<fim_suffix>        temp=i\n        while temp:\n            if temp%2==0:\n                s.append(i)\n                break\n            temp=temp//10\n    for i in s:\n        x.remove(i)\n    return sorted(x)\n<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp0(__tmp1: List[int]) -> List[int]:\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    s=[]_CodetraceSpecialPlaceholder_        temp=i\n        while temp:\n            if temp%2==0:\n                s.append(i)\n                break\n            temp=temp//10\n    for i in s:\n        x.remove(i)\n    return sorted(x)\n",
    "original_prediction": "for i in x:",
    "mutated_prediction": "for i in x:",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>from typing import Tuple\n\ndef even_odd_palindrome(n: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n    >>> even_odd_palindrome(3)\n    (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n    >>> even_odd_palindrome(12)\n    (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    return (\n        sum(1 for i in range(1, n + 1) if str(i) == str(i)[::-1] and i % 2 == 0),\n        sum(1 for i in range(1, n + 1) if str(i) == str(i)[::-1] and i % 2 != 0)<fim_suffix><fim_middle>",
    "mutated_program": "from typing import Tuple\n\ndef __tmp0(__tmp1: int) -> Tuple[int, int]:\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n    >>> even_odd_palindrome(3)\n    (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n    >>> even_odd_palindrome(12)\n    (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    return (\n        sum(1 for i in range(1, n + 1) if str(i) == str(i)[::-1] and i % 2 == 0),\n        sum(1 for i in range(1, n + 1) if str(i) == str(i)[::-1] and i % 2 != 0)_CodetraceSpecialPlaceholder_",
    "original_prediction": ")\n\nif __name__ == \"__",
    "mutated_prediction": ")\n\nif __name__ == \"__",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "expected_type": "prefix",
    "original_program": "<fim_prefix>def count_upper(s: str) -> int:\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    >>> count_upper('aBCdEf')\n    1\n    >>> count_upper('abcdefg')\n    0\n    >>> count_upper('dBBE')\n    0\n    \"\"\"\n    vowel_set = set('AEIOU')\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in vowel_set:\n            count += 1\n    return count\n<fim_suffix>D.1 Recursion\nGiven a positive integer n, write a recursive function that returns the sum of the squares of the \npositive odd integers smaller than n. Assume n is greater than or equal to 3.\n\"\"\"<fim_middle>",
    "mutated_program": "def __tmp1(__tmp0: str) -> int:\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    >>> count_upper('aBCdEf')\n    1\n    >>> count_upper('abcdefg')\n    0\n    >>> count_upper('dBBE')\n    0\n    \"\"\"\n    vowel_set = set('AEIOU')\n    count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in vowel_set:\n            count += 1\n    return count\n_CodetraceSpecialPlaceholder_D.1 Recursion\nGiven a positive integer n, write a recursive function that returns the sum of the squares of the \npositive odd integers smaller than n. Assume n is greater than or equal to 3.\n\"\"\"",
    "original_prediction": "\"\"\"",
    "mutated_prediction": "\"\"\"",
    "original_correct": true,
    "mutated_correct": true
  }
]