,Unnamed: 0.6,Unnamed: 0.5,Unnamed: 0.4,Unnamed: 0.3,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,generated,solution,hexsha,prompt,correctness,id
0,0,0,0,0,0,0,0,a,A,aa0b04568df03138dc24e8c7c363decf2bd5ba4f,"<fim_prefix>export type Arrow<A extends any[] = any, B = any> = (...args) => B

export function pipe<A>(a)
export function pipe<A, B>(a, ab)
export function pipe<A, B, C>(a, ab, bc)
export function pipe<A, B, C, D>(a, ab, bc, cd)
export function pipe<A, B, C, D, E>(a, ab, bc, cd, de)
export function pipe<A, B, C, D, E, F>(
  a,
  ab,
  bc,
  cd,
  de,
  ef
)
export function pipe<A, B, C, D, E, F, G>(
  a: <fim_suffix>,
  ab,
  bc,
  cd,
  de,
  ef,
  fg
)
export function pipe<A, B, C, D, E, F, G, H>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh
)
export function pipe<A, B, C, D, E, F, G, H, I>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi
)
export function pipe<A, B, C, D, E, F, G, H, I, J>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs,
  st
)
export function pipe(
  a,
  ab?,
  bc?,
  cd?,
  de?,
  ef?,
  fg?,
  gh?,
  hi?
) {
  switch (arguments.length) {
    case 1:
      return a
    case 2:
      return ab!(a)
    case 3:
      return bc!(ab!(a))
    case 4:
      return cd!(bc!(ab!(a)))
    case 5:
      return de!(cd!(bc!(ab!(a))))
    case 6:
      return ef!(de!(cd!(bc!(ab!(a)))))
    case 7:
      return fg!(ef!(de!(cd!(bc!(ab!(a))))))
    case 8:
      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))
    case 9:
      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))
    default:
      // eslint-disable-next-line prefer-rest-params,no-case-declarations
      let ret = arguments[0]
      for (let i = 1; i < arguments.length; i++) {
        // eslint-disable-next-line prefer-rest-params
        ret = arguments[i](ret)
      }
      return ret
  }
}
<fim_middle>",incorrect,1583
1,1,1,1,1,1,1,1,a,A,aa0b04568df03138dc24e8c7c363decf2bd5ba4f,"<fim_prefix>export type Arrow<A extends any[] = any, B = any> = (...args) => B

export function pipe<A>(a)
export function pipe<A, B>(a, ab)
export function pipe<A, B, C>(a, ab, bc)
export function pipe<A, B, C, D>(a, ab, bc, cd)
export function pipe<A, B, C, D, E>(a, ab, bc, cd, de)
export function pipe<A, B, C, D, E, F>(
  a: <fim_suffix>,
  ab,
  bc,
  cd,
  de,
  ef
)
export function pipe<A, B, C, D, E, F, G>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg
)
export function pipe<A, B, C, D, E, F, G, H>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh
)
export function pipe<A, B, C, D, E, F, G, H, I>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi
)
export function pipe<A, B, C, D, E, F, G, H, I, J>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs,
  st
)
export function pipe(
  a,
  ab?,
  bc?,
  cd?,
  de?,
  ef?,
  fg?,
  gh?,
  hi?
) {
  switch (arguments.length) {
    case 1:
      return a
    case 2:
      return ab!(a)
    case 3:
      return bc!(ab!(a))
    case 4:
      return cd!(bc!(ab!(a)))
    case 5:
      return de!(cd!(bc!(ab!(a))))
    case 6:
      return ef!(de!(cd!(bc!(ab!(a)))))
    case 7:
      return fg!(ef!(de!(cd!(bc!(ab!(a))))))
    case 8:
      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))
    case 9:
      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))
    default:
      // eslint-disable-next-line prefer-rest-params,no-case-declarations
      let ret = arguments[0]
      for (let i = 1; i < arguments.length; i++) {
        // eslint-disable-next-line prefer-rest-params
        ret = arguments[i](ret)
      }
      return ret
  }
}
<fim_middle>",incorrect,1590
2,2,2,2,2,2,2,2,a,A,aa0b04568df03138dc24e8c7c363decf2bd5ba4f,"<fim_prefix>export type Arrow<A extends any[] = any, B = any> = (...args) => B

export function pipe<A>(a)
export function pipe<A, B>(a, ab)
export function pipe<A, B, C>(a, ab, bc)
export function pipe<A, B, C, D>(a, ab, bc, cd)
export function pipe<A, B, C, D, E>(a: <fim_suffix>, ab, bc, cd, de)
export function pipe<A, B, C, D, E, F>(
  a,
  ab,
  bc,
  cd,
  de,
  ef
)
export function pipe<A, B, C, D, E, F, G>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg
)
export function pipe<A, B, C, D, E, F, G, H>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh
)
export function pipe<A, B, C, D, E, F, G, H, I>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi
)
export function pipe<A, B, C, D, E, F, G, H, I, J>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs,
  st
)
export function pipe(
  a,
  ab?,
  bc?,
  cd?,
  de?,
  ef?,
  fg?,
  gh?,
  hi?
) {
  switch (arguments.length) {
    case 1:
      return a
    case 2:
      return ab!(a)
    case 3:
      return bc!(ab!(a))
    case 4:
      return cd!(bc!(ab!(a)))
    case 5:
      return de!(cd!(bc!(ab!(a))))
    case 6:
      return ef!(de!(cd!(bc!(ab!(a)))))
    case 7:
      return fg!(ef!(de!(cd!(bc!(ab!(a))))))
    case 8:
      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))
    case 9:
      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))
    default:
      // eslint-disable-next-line prefer-rest-params,no-case-declarations
      let ret = arguments[0]
      for (let i = 1; i < arguments.length; i++) {
        // eslint-disable-next-line prefer-rest-params
        ret = arguments[i](ret)
      }
      return ret
  }
}
<fim_middle>",incorrect,1596
3,3,3,3,3,3,3,3,ab,A,aa0b04568df03138dc24e8c7c363decf2bd5ba4f,"<fim_prefix>export type Arrow<A extends any[] = any, B = any> = (...args) => B

export function pipe<A>(a)
export function pipe<A, B>(a, ab)
export function pipe<A, B, C>(a, ab, bc)
export function pipe<A, B, C, D>(a: <fim_suffix>, ab, bc, cd)
export function pipe<A, B, C, D, E>(a, ab, bc, cd, de)
export function pipe<A, B, C, D, E, F>(
  a,
  ab,
  bc,
  cd,
  de,
  ef
)
export function pipe<A, B, C, D, E, F, G>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg
)
export function pipe<A, B, C, D, E, F, G, H>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh
)
export function pipe<A, B, C, D, E, F, G, H, I>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi
)
export function pipe<A, B, C, D, E, F, G, H, I, J>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn
)
export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs
)

export function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(
  a,
  ab,
  bc,
  cd,
  de,
  ef,
  fg,
  gh,
  hi,
  ij,
  jk,
  kl,
  lm,
  mn,
  no,
  op,
  pq,
  qr,
  rs,
  st
)
export function pipe(
  a,
  ab?,
  bc?,
  cd?,
  de?,
  ef?,
  fg?,
  gh?,
  hi?
) {
  switch (arguments.length) {
    case 1:
      return a
    case 2:
      return ab!(a)
    case 3:
      return bc!(ab!(a))
    case 4:
      return cd!(bc!(ab!(a)))
    case 5:
      return de!(cd!(bc!(ab!(a))))
    case 6:
      return ef!(de!(cd!(bc!(ab!(a)))))
    case 7:
      return fg!(ef!(de!(cd!(bc!(ab!(a))))))
    case 8:
      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))
    case 9:
      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))
    default:
      // eslint-disable-next-line prefer-rest-params,no-case-declarations
      let ret = arguments[0]
      for (let i = 1; i < arguments.length; i++) {
        // eslint-disable-next-line prefer-rest-params
        ret = arguments[i](ret)
      }
      return ret
  }
}
<fim_middle>",incorrect,1601
4,4,4,4,4,4,4,4,Uint8Array,ArrayBuffer,c3a638642c61e9f2f6f40ae6a71cdbf67fc9c4a0,"<fim_prefix>const INDEX_BIT_COUNT = 12;
const LENGTH_BIT_COUNT = 4;
const RAW_LOOK_AHEAD_SIZE = 1 << LENGTH_BIT_COUNT;
const MAX_OFFSET = (1 << INDEX_BIT_COUNT) + 1;
const TREE_ROOT = MAX_OFFSET;
const UNUSED = -1;

enum Child {
  Smaller = 0,
  Larger = 1,
}

interface DefTree {
  parent: number;
  children: [number, number];
  which_child: number;
}

const tree: DefTree[] = (() => {
  const t = new Array<DefTree>(MAX_OFFSET + 2);
  for (let i = 0; i < t.length; i++) {
    t[i] = { parent: 0, children: [0, 0], which_child: 0 };
  }
  return t;
})();

function initTree() {
  tree[0].parent = 0;
  tree[0].children[0] = 0;
  tree[0].children[1] = 0;
  tree[0].which_child = 0;
  for (let i = 1; i < tree.length; i++) {
    tree[i].parent = UNUSED;
    tree[i].children[0] = UNUSED;
    tree[i].children[1] = UNUSED;
    tree[i].which_child = UNUSED;
  }
}

function copyNode(src, tgt) {
  tree[tgt].parent = tree[src].parent;
  tree[tgt].children[0] = tree[src].children[0];
  tree[tgt].children[1] = tree[src].children[1];
  tree[tgt].which_child = tree[src].which_child;
}

function replaceParents(node) {
  tree[tree[node + 1].children[Child.Smaller] + 1].parent = node;
  tree[tree[node + 1].children[Child.Larger] + 1].parent = node;
}

function replace_node(old_node, new_node) {
  copyNode(old_node + 1, new_node + 1);

  replaceParents(new_node);

  tree[tree[old_node + 1].parent + 1].children[tree[old_node + 1].which_child] =
    new_node;
}

function updateParent(node, parent, which_child) {
  tree[node + 1].parent = parent;
  tree[node + 1].which_child = which_child;
}

function findNextNode(node) {
  let next = tree[node + 1].children[Child.Smaller];

  if (tree[next + 1].children[Child.Larger] === UNUSED)
    tree[node + 1].children[Child.Smaller] =
      tree[next + 1].children[Child.Smaller];
  else {
    while (tree[next + 1].children[Child.Larger] !== UNUSED)
      next = tree[next + 1].children[Child.Larger];
    tree[tree[next + 1].parent + 1].children[Child.Larger] =
      tree[next + 1].children[Child.Smaller];
  }

  return next;
}

function updateChild(src_tree, which_child) {
  if (tree[src_tree + 1].children[which_child] !== UNUSED)
    updateParent(
      tree[src_tree + 1].children[which_child],
      tree[src_tree + 1].parent,
      tree[src_tree + 1].which_child
    );

  tree[tree[src_tree + 1].parent + 1].children[tree[src_tree + 1].which_child] =
    tree[src_tree + 1].children[which_child];
}

// Adapted from:
// https://github.com/OBattler/lbatools-c/blob/master/compress/lzmit.c
export function compressLZSS_LBA_type_2(data): <fim_suffix> {
  let val = 0;
  let src_off = 0;
  let out_len = 1;
  let offset_off = 0;
  let flag_bit = 0;
  let best_match = 1;
  let best_node = 0;

  const length = data.byteLength;

  if (length <= RAW_LOOK_AHEAD_SIZE) {
    return data;
  }

  const input = new Uint8Array(data);
  const output = new Uint8Array(length);

  initTree();

  while (best_match + src_off - 1 < length) {
    let i = best_match;
    while (i > 0) {
      const src_tree = src_off % MAX_OFFSET;

      if (tree[src_tree + 1].parent !== UNUSED) {
        if (
          tree[src_tree + 1].children[Child.Smaller] !== UNUSED &&
          tree[src_tree + 1].children[Child.Larger] !== UNUSED
        ) {
          const replacement = findNextNode(src_tree);
          updateParent(
            tree[replacement + 1].children[Child.Smaller],
            tree[replacement + 1].parent,
            tree[replacement + 1].which_child
          );
          replace_node(src_tree, replacement);
        } else {
          updateChild(
            src_tree,
            tree[src_tree + 1].children[Child.Smaller] === UNUSED
              ? Child.Larger
              : Child.Smaller
          );
        }
      }

      tree[src_tree + 1].children[Child.Larger] = UNUSED;
      tree[src_tree + 1].children[Child.Smaller] = UNUSED;

      let cur_node = tree[TREE_ROOT + 1].children[Child.Smaller];

      if (cur_node < 0) {
        best_match = 0;
        best_node = 0;

        updateParent(src_tree, TREE_ROOT, 0);
        tree[TREE_ROOT + 1].children[Child.Smaller] = src_tree;
      } else {
        best_match = 2;

        // eslint-disable-next-line no-constant-condition
        while (true) {
          let cur_string = src_off;
          let cmp_string =
            cur_string - ((src_tree - cur_node + MAX_OFFSET) % MAX_OFFSET);
          const node = cur_node;
          let j = RAW_LOOK_AHEAD_SIZE + 2;
          cur_node = j - 1;

          let diff: number;
          do diff = input[cur_string++] - input[cmp_string++];
          while (--j !== 0 && diff === 0);

          if (j !== 0 || diff !== 0) {
            cur_node -= j;
            if (cur_node > best_match) {
              best_match = cur_node;
              best_node = node;
            }

            j = diff >= 0 ? 1 : 0;
            cur_node = tree[node + 1].children[j];

            if (cur_node < 0) {
              updateParent(src_tree, node, j);
              tree[node + 1].children[j] = src_tree;
              break;
            }
          } else {
            replace_node(node, src_tree);
            tree[node + 1].parent = UNUSED;
            best_match = RAW_LOOK_AHEAD_SIZE + 2;
            best_node = node;
            break;
          }
        }
      }

      if (--i > 0) src_off++;
    }

    if (out_len >= length - RAW_LOOK_AHEAD_SIZE - 1) {
      return data;
    }

    val >>= 1;

    if (best_match > 2 && src_off + best_match <= length) {
      const temp =
        (best_match - 3) |
        ((src_off - best_node - 1 + MAX_OFFSET) % MAX_OFFSET <<
          LENGTH_BIT_COUNT);
      output[out_len] = temp & 0xff;
      output[out_len + 1] = temp >> 8;
      out_len += 2;
    } else {
      output[out_len++] = input[src_off];
      val |= 0x80;
      best_match = 1;
    }

    flag_bit++;
    if (flag_bit >= 8) {
      flag_bit = 0;
      output[offset_off] = val & 0xff;
      offset_off = out_len;
      out_len++;
    }

    src_off++;
  }

  if (flag_bit === 0) out_len--;
  else if (flag_bit < 8) output[offset_off] = val >> (8 - flag_bit);

  return output.buffer.slice(0, out_len);
}
<fim_middle>",incorrect,3712
5,5,5,5,5,5,5,5,Uint8Array,ArrayBuffer,c3a638642c61e9f2f6f40ae6a71cdbf67fc9c4a0,"<fim_prefix>const INDEX_BIT_COUNT = 12;
const LENGTH_BIT_COUNT = 4;
const RAW_LOOK_AHEAD_SIZE = 1 << LENGTH_BIT_COUNT;
const MAX_OFFSET = (1 << INDEX_BIT_COUNT) + 1;
const TREE_ROOT = MAX_OFFSET;
const UNUSED = -1;

enum Child {
  Smaller = 0,
  Larger = 1,
}

interface DefTree {
  parent: number;
  children: [number, number];
  which_child: number;
}

const tree: DefTree[] = (() => {
  const t = new Array<DefTree>(MAX_OFFSET + 2);
  for (let i = 0; i < t.length; i++) {
    t[i] = { parent: 0, children: [0, 0], which_child: 0 };
  }
  return t;
})();

function initTree() {
  tree[0].parent = 0;
  tree[0].children[0] = 0;
  tree[0].children[1] = 0;
  tree[0].which_child = 0;
  for (let i = 1; i < tree.length; i++) {
    tree[i].parent = UNUSED;
    tree[i].children[0] = UNUSED;
    tree[i].children[1] = UNUSED;
    tree[i].which_child = UNUSED;
  }
}

function copyNode(src, tgt) {
  tree[tgt].parent = tree[src].parent;
  tree[tgt].children[0] = tree[src].children[0];
  tree[tgt].children[1] = tree[src].children[1];
  tree[tgt].which_child = tree[src].which_child;
}

function replaceParents(node) {
  tree[tree[node + 1].children[Child.Smaller] + 1].parent = node;
  tree[tree[node + 1].children[Child.Larger] + 1].parent = node;
}

function replace_node(old_node, new_node) {
  copyNode(old_node + 1, new_node + 1);

  replaceParents(new_node);

  tree[tree[old_node + 1].parent + 1].children[tree[old_node + 1].which_child] =
    new_node;
}

function updateParent(node, parent, which_child) {
  tree[node + 1].parent = parent;
  tree[node + 1].which_child = which_child;
}

function findNextNode(node) {
  let next = tree[node + 1].children[Child.Smaller];

  if (tree[next + 1].children[Child.Larger] === UNUSED)
    tree[node + 1].children[Child.Smaller] =
      tree[next + 1].children[Child.Smaller];
  else {
    while (tree[next + 1].children[Child.Larger] !== UNUSED)
      next = tree[next + 1].children[Child.Larger];
    tree[tree[next + 1].parent + 1].children[Child.Larger] =
      tree[next + 1].children[Child.Smaller];
  }

  return next;
}

function updateChild(src_tree, which_child) {
  if (tree[src_tree + 1].children[which_child] !== UNUSED)
    updateParent(
      tree[src_tree + 1].children[which_child],
      tree[src_tree + 1].parent,
      tree[src_tree + 1].which_child
    );

  tree[tree[src_tree + 1].parent + 1].children[tree[src_tree + 1].which_child] =
    tree[src_tree + 1].children[which_child];
}

// Adapted from:
// https://github.com/OBattler/lbatools-c/blob/master/compress/lzmit.c
export function compressLZSS_LBA_type_2(data: <fim_suffix>) {
  let val = 0;
  let src_off = 0;
  let out_len = 1;
  let offset_off = 0;
  let flag_bit = 0;
  let best_match = 1;
  let best_node = 0;

  const length = data.byteLength;

  if (length <= RAW_LOOK_AHEAD_SIZE) {
    return data;
  }

  const input = new Uint8Array(data);
  const output = new Uint8Array(length);

  initTree();

  while (best_match + src_off - 1 < length) {
    let i = best_match;
    while (i > 0) {
      const src_tree = src_off % MAX_OFFSET;

      if (tree[src_tree + 1].parent !== UNUSED) {
        if (
          tree[src_tree + 1].children[Child.Smaller] !== UNUSED &&
          tree[src_tree + 1].children[Child.Larger] !== UNUSED
        ) {
          const replacement = findNextNode(src_tree);
          updateParent(
            tree[replacement + 1].children[Child.Smaller],
            tree[replacement + 1].parent,
            tree[replacement + 1].which_child
          );
          replace_node(src_tree, replacement);
        } else {
          updateChild(
            src_tree,
            tree[src_tree + 1].children[Child.Smaller] === UNUSED
              ? Child.Larger
              : Child.Smaller
          );
        }
      }

      tree[src_tree + 1].children[Child.Larger] = UNUSED;
      tree[src_tree + 1].children[Child.Smaller] = UNUSED;

      let cur_node = tree[TREE_ROOT + 1].children[Child.Smaller];

      if (cur_node < 0) {
        best_match = 0;
        best_node = 0;

        updateParent(src_tree, TREE_ROOT, 0);
        tree[TREE_ROOT + 1].children[Child.Smaller] = src_tree;
      } else {
        best_match = 2;

        // eslint-disable-next-line no-constant-condition
        while (true) {
          let cur_string = src_off;
          let cmp_string =
            cur_string - ((src_tree - cur_node + MAX_OFFSET) % MAX_OFFSET);
          const node = cur_node;
          let j = RAW_LOOK_AHEAD_SIZE + 2;
          cur_node = j - 1;

          let diff: number;
          do diff = input[cur_string++] - input[cmp_string++];
          while (--j !== 0 && diff === 0);

          if (j !== 0 || diff !== 0) {
            cur_node -= j;
            if (cur_node > best_match) {
              best_match = cur_node;
              best_node = node;
            }

            j = diff >= 0 ? 1 : 0;
            cur_node = tree[node + 1].children[j];

            if (cur_node < 0) {
              updateParent(src_tree, node, j);
              tree[node + 1].children[j] = src_tree;
              break;
            }
          } else {
            replace_node(node, src_tree);
            tree[node + 1].parent = UNUSED;
            best_match = RAW_LOOK_AHEAD_SIZE + 2;
            best_node = node;
            break;
          }
        }
      }

      if (--i > 0) src_off++;
    }

    if (out_len >= length - RAW_LOOK_AHEAD_SIZE - 1) {
      return data;
    }

    val >>= 1;

    if (best_match > 2 && src_off + best_match <= length) {
      const temp =
        (best_match - 3) |
        ((src_off - best_node - 1 + MAX_OFFSET) % MAX_OFFSET <<
          LENGTH_BIT_COUNT);
      output[out_len] = temp & 0xff;
      output[out_len + 1] = temp >> 8;
      out_len += 2;
    } else {
      output[out_len++] = input[src_off];
      val |= 0x80;
      best_match = 1;
    }

    flag_bit++;
    if (flag_bit >= 8) {
      flag_bit = 0;
      output[offset_off] = val & 0xff;
      offset_off = out_len;
      out_len++;
    }

    src_off++;
  }

  if (flag_bit === 0) out_len--;
  else if (flag_bit < 8) output[offset_off] = val >> (8 - flag_bit);

  return output.buffer.slice(0, out_len);
}
<fim_middle>",incorrect,3713
6,6,6,6,6,6,6,6,Uint8Array,ArrayBuffer,8942b9bffbeae8bdf02b8ff01a9a7a9bca89f53c,"<fim_prefix>const INDEX_BIT_COUNT = 12;
const LENGTH_BIT_COUNT = 4;
const WINDOW_SIZE = 1 << INDEX_BIT_COUNT;
const RAW_LOOK_AHEAD_SIZE = 1 << LENGTH_BIT_COUNT;
const BREAK_EVEN = Math.floor((1 + INDEX_BIT_COUNT + LENGTH_BIT_COUNT) / 9);
const LOOK_AHEAD_SIZE = RAW_LOOK_AHEAD_SIZE + BREAK_EVEN;
const TREE_ROOT = WINDOW_SIZE;
const UNUSED = -1;
const MOD_WINDOW = (a) => a & (WINDOW_SIZE - 1);

enum Child {
  Smaller = 0,
  Larger = 1,
}

interface DefTree {
  parent: number;
  children: [number, number];
}

let current_pos: number;
let match_pos: number;
const win = new Uint8Array(WINDOW_SIZE * 5);
const tree: DefTree[] = (() => {
  const t = new Array<DefTree>(WINDOW_SIZE + 2);
  for (let i = 0; i < t.length; i++) {
    t[i] = { parent: 0, children: [0, 0] };
  }
  return t;
})();

function initTree(r) {
  for (let i = 0; i <= WINDOW_SIZE; i++) {
    const node = tree[i];
    node.parent = UNUSED;
    node.children[Child.Smaller] = UNUSED;
    node.children[Child.Larger] = UNUSED;
  }
  tree[TREE_ROOT].children[Child.Larger] = r;
  tree[r].parent = TREE_ROOT;
  tree[-1] = tree[WINDOW_SIZE + 1];
}

function contractNode(old_node, new_node) {
  tree[new_node].parent = tree[old_node].parent;
  if (tree[tree[old_node].parent].children[Child.Larger] === old_node)
    tree[tree[old_node].parent].children[Child.Larger] = new_node;
  else tree[tree[old_node].parent].children[Child.Smaller] = new_node;
  tree[old_node].parent = UNUSED;
}

function copyNode(new_node, old_node) {
  tree[new_node].parent = tree[old_node].parent;
  tree[new_node].children[Child.Smaller] =
    tree[old_node].children[Child.Smaller];
  tree[new_node].children[Child.Larger] = tree[old_node].children[Child.Larger];
}

function replaceNode(old_node, new_node) {
  const parent = tree[old_node].parent;
  if (tree[parent].children[Child.Smaller] === old_node)
    tree[parent].children[Child.Smaller] = new_node;
  else tree[parent].children[Child.Larger] = new_node;
  copyNode(new_node, old_node);
  if (tree[new_node].children[Child.Smaller] !== UNUSED)
    tree[tree[new_node].children[Child.Smaller]].parent = new_node;
  if (tree[new_node].children[Child.Larger] !== UNUSED)
    tree[tree[new_node].children[Child.Larger]].parent = new_node;
  tree[old_node].parent = UNUSED;
}

function findNextNode(node) {
  let next = tree[node].children[Child.Smaller];
  while (tree[next].children[Child.Larger] !== UNUSED)
    next = tree[next].children[Child.Larger];
  return next;
}

function deleteString(p) {
  if (tree[p].parent === UNUSED) return;
  if (tree[p].children[Child.Larger] === UNUSED)
    contractNode(p, tree[p].children[Child.Smaller]);
  else if (tree[p].children[Child.Smaller] === UNUSED)
    contractNode(p, tree[p].children[Child.Larger]);
  else {
    const replacement = findNextNode(p);
    deleteString(replacement);
    replaceNode(p, replacement);
  }
}

function addString() {
  let i = 0;
  let delta = 0;
  let test_node = tree[TREE_ROOT].children[Child.Larger];
  let match_length = 0;
  for (;;) {
    for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
      delta = win[MOD_WINDOW(current_pos + i)] - win[MOD_WINDOW(test_node + i)];
      if (delta !== 0) break;
    }
    if (i >= match_length) {
      match_length = i;
      match_pos = test_node;
      if (match_length >= LOOK_AHEAD_SIZE) {
        replaceNode(test_node, current_pos);
        return match_length;
      }
    }
    const child_node = tree[test_node];
    const child_prop = delta >= 0 ? Child.Larger : Child.Smaller;
    if (child_node.children[child_prop] === UNUSED) {
      child_node.children[child_prop] = current_pos;
      tree[current_pos].parent = test_node;
      tree[current_pos].children[Child.Larger] = UNUSED;
      tree[current_pos].children[Child.Smaller] = UNUSED;
      return match_length;
    }
    test_node = child_node.children[child_prop];
  }
}

// Adapted from:
// https://github.com/2point21/lba2-classic/blob/main/SOURCES/LZSS.CPP
export function compressLZSS_LBA_type_1(data): <fim_suffix> {
  let i: number;
  let read = 0;
  let write = 0;
  let info: number;
  let look_ahead_bytes: number;
  let replace_count: number;
  let match_length: number;
  let count_bits = 0;
  let mask = 1;
  let len = 0;
  let length = data.byteLength;

  const input = new Uint8Array(data);
  const output = new Uint8Array(length);

  const save_length = length;
  current_pos = 0;

  for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
    if (length === 0) break;
    win[current_pos + i] = input[read++];
    length--;
  }

  look_ahead_bytes = i;
  initTree(current_pos);
  match_length = 0;
  match_pos = 0;
  info = write++;

  if (++len >= save_length) return data;

  output[info] = 0;

  while (look_ahead_bytes > 0) {
    if (match_length > look_ahead_bytes) match_length = look_ahead_bytes;

    if (match_length <= BREAK_EVEN) {
      replace_count = 1;
      output[info] |= mask;
      output[write++] = win[current_pos];
      if (++len >= save_length) return data;
    } else {
      if ((len = len + 2) >= save_length) return data;

      const value =
        (MOD_WINDOW(current_pos - match_pos - 1) << LENGTH_BIT_COUNT) |
        (match_length - BREAK_EVEN - 1);
      const low = (value & 0xff00) >> 8;
      const high = value & 0xff;
      output[write] = high;
      output[write + 1] = low;

      write += 2;
      replace_count = match_length;
    }

    if (++count_bits === 8) {
      if (++len >= save_length) return data;
      info = write++;
      output[info] = 0;
      count_bits = 0;
      mask = 1;
    } else {
      mask = (mask << 1) & 0xff;
    }

    for (i = 0; i < replace_count; i++) {
      deleteString(MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE));
      if (length === 0) look_ahead_bytes--;
      else {
        win[MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE)] = input[read++];
        length--;
      }

      current_pos = MOD_WINDOW(current_pos + 1);
      if (look_ahead_bytes) match_length = addString();
    }
  }

  if (count_bits === 0) len--;
  return output.buffer.slice(0, len);
}
<fim_middle>",incorrect,4257
7,7,7,7,7,7,7,7,void,Board,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board): <fim_suffix> {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",incorrect,804
8,8,8,8,8,8,8,8,Cursor,Board,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction): <fim_suffix> {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",incorrect,812
9,9,9,9,9,9,9,9,"string[]) => {
    for (let i = 0; i < gues",Board,15b8db192fc5ac36ac290289da3f8a7f39a0fb7b,"<fim_prefix>export type Board = string[][]
export const numberOfLetters = 5
export const numberOfRows = 6
export const word = 'לחמים'
export const empty = '-'

export const endOfWordToRegularLetters = {
    ם: 'מ',
    ן: 'נ',
    ץ: 'צ',
    ף: 'פ',
    ך: 'כ',
}

export const regularToEndOfWordLetters = {
    מ: 'ם',
    נ: 'ן',
    צ: 'ץ',
    פ: 'ף',
    כ: 'ך',
}

// The enum ordering is used in order to always push a better result into the dict
export enum LetterType {
    Unevaluated,
    Miss,
    Present,
    Correct,
}

export const letterTypeToBgColor = {
    [LetterType.Unevaluated]: 'hg-unevaluated',
    [LetterType.Miss]: 'bg-zinc-400',
    [LetterType.Present]: 'bg-orange-400',
    [LetterType.Correct]: 'bg-green-400',
}

export const letterTypeToEmoji = {
    [LetterType.Miss]: '⬛',
    [LetterType.Present]: '🟨',
    [LetterType.Correct]: '🟩',
}

export const keyboardLettersFromGuesses = (word, guesses) => {
    let letters = {
        א: LetterType.Unevaluated,
        ב: LetterType.Unevaluated,
        ג: LetterType.Unevaluated,
        ד: LetterType.Unevaluated,
        ה: LetterType.Unevaluated,
        ו: LetterType.Unevaluated,
        ז: LetterType.Unevaluated,
        ח: LetterType.Unevaluated,
        ט: LetterType.Unevaluated,
        י: LetterType.Unevaluated,
        כ: LetterType.Unevaluated,
        ל: LetterType.Unevaluated,
        מ: LetterType.Unevaluated,
        נ: LetterType.Unevaluated,
        ס: LetterType.Unevaluated,
        ע: LetterType.Unevaluated,
        פ: LetterType.Unevaluated,
        צ: LetterType.Unevaluated,
        ק: LetterType.Unevaluated,
        ר: LetterType.Unevaluated,
        ש: LetterType.Unevaluated,
        ת: LetterType.Unevaluated,
        ם: LetterType.Unevaluated,
        ן: LetterType.Unevaluated,
        ץ: LetterType.Unevaluated,
        ף: LetterType.Unevaluated,
        ך: LetterType.Unevaluated,
    }
    for (const i in guesses) {
        let line = guesses[i]
        let r = getCorrectAndPresent(word, line)
        for (const t in r) {
            // Using the enum ordering in order to always push a better result into the dict
            if (r[t] > letters[line[t]]) letters[line[t]] = r[t]
        }
    }
    return letters
}

export const emojiFromGuesses = (
    word,
    guesses,
    rtl = false
) => {
    let content = []
    for (let i = 0; i < guesses.length; i++) {
        if (rtl) {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .reverse()
                    .join('')
            )
        } else {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .join('')
            )
        }
    }
    return content.join('\n')
}

export const wordInGuesses = (word, guesses: <fim_suffix>) => {
    for (let i = 0; i < guesses.length; i++) {
        if (word === guesses[i].join('')) return true
    }
    return false
}

export const sanitizeString = (str) => {
    let r = []
    for (let i = 0; i < str.length; i++) {
        if (str[i] in endOfWordToRegularLetters) {
            r.push(endOfWordToRegularLetters[str[i]])
        } else {
            r.push(str[i])
        }
    }
    return r.join('')
}

export const getCorrectAndPresent = (
    word,
    guess
) => {
    const cleanWord = sanitizeString(word)
    const cleanGuess = guess
        .map((e) => (e === '' && empty) || e)
        .map(sanitizeString)
        .join('')

    let correctAndPresent = {
        cleanWord: Array(cleanWord.length).fill(LetterType.Unevaluated),
        cleanGuess: Array(cleanGuess.length).fill(LetterType.Unevaluated),
    }

    // For each letter of guess, check if it's correct
    for (let i = 0; i < cleanWord.length; i++) {
        if (cleanWord[i] === cleanGuess[i])
            correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[i] =
                LetterType.Correct
    }

    // Now the tricky part is to find the present
    // A letter is present iff it appears in the word somewhere that is not already present or correct
    for (let i = 0; i < cleanGuess.length; i++) {
        for (let j = 0; j < cleanWord.length; j++) {
            if (
                cleanGuess[i] === cleanWord[j] &&
                correctAndPresent.cleanGuess[i] !== LetterType.Correct &&
                correctAndPresent.cleanWord[j] !== LetterType.Correct &&
                correctAndPresent.cleanGuess[i] !== LetterType.Present &&
                correctAndPresent.cleanWord[j] !== LetterType.Present
            )
                correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[
                    j
                ] = LetterType.Present
        }
        if (
            correctAndPresent.cleanGuess[i] === LetterType.Unevaluated &&
            cleanGuess[i] !== empty
        ) {
            // Finally, set the character to miss
            correctAndPresent.cleanGuess[i] = LetterType.Miss
        }
    }

    return correctAndPresent.cleanGuess
}
<fim_middle>",incorrect,3820
10,10,10,10,10,10,10,10,string[][],Board,15b8db192fc5ac36ac290289da3f8a7f39a0fb7b,"<fim_prefix>export type Board = string[][]
export const numberOfLetters = 5
export const numberOfRows = 6
export const word = 'לחמים'
export const empty = '-'

export const endOfWordToRegularLetters = {
    ם: 'מ',
    ן: 'נ',
    ץ: 'צ',
    ף: 'פ',
    ך: 'כ',
}

export const regularToEndOfWordLetters = {
    מ: 'ם',
    נ: 'ן',
    צ: 'ץ',
    פ: 'ף',
    כ: 'ך',
}

// The enum ordering is used in order to always push a better result into the dict
export enum LetterType {
    Unevaluated,
    Miss,
    Present,
    Correct,
}

export const letterTypeToBgColor = {
    [LetterType.Unevaluated]: 'hg-unevaluated',
    [LetterType.Miss]: 'bg-zinc-400',
    [LetterType.Present]: 'bg-orange-400',
    [LetterType.Correct]: 'bg-green-400',
}

export const letterTypeToEmoji = {
    [LetterType.Miss]: '⬛',
    [LetterType.Present]: '🟨',
    [LetterType.Correct]: '🟩',
}

export const keyboardLettersFromGuesses = (word, guesses) => {
    let letters = {
        א: LetterType.Unevaluated,
        ב: LetterType.Unevaluated,
        ג: LetterType.Unevaluated,
        ד: LetterType.Unevaluated,
        ה: LetterType.Unevaluated,
        ו: LetterType.Unevaluated,
        ז: LetterType.Unevaluated,
        ח: LetterType.Unevaluated,
        ט: LetterType.Unevaluated,
        י: LetterType.Unevaluated,
        כ: LetterType.Unevaluated,
        ל: LetterType.Unevaluated,
        מ: LetterType.Unevaluated,
        נ: LetterType.Unevaluated,
        ס: LetterType.Unevaluated,
        ע: LetterType.Unevaluated,
        פ: LetterType.Unevaluated,
        צ: LetterType.Unevaluated,
        ק: LetterType.Unevaluated,
        ר: LetterType.Unevaluated,
        ש: LetterType.Unevaluated,
        ת: LetterType.Unevaluated,
        ם: LetterType.Unevaluated,
        ן: LetterType.Unevaluated,
        ץ: LetterType.Unevaluated,
        ף: LetterType.Unevaluated,
        ך: LetterType.Unevaluated,
    }
    for (const i in guesses) {
        let line = guesses[i]
        let r = getCorrectAndPresent(word, line)
        for (const t in r) {
            // Using the enum ordering in order to always push a better result into the dict
            if (r[t] > letters[line[t]]) letters[line[t]] = r[t]
        }
    }
    return letters
}

export const emojiFromGuesses = (
    word,
    guesses: <fim_suffix>,
    rtl = false
) => {
    let content = []
    for (let i = 0; i < guesses.length; i++) {
        if (rtl) {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .reverse()
                    .join('')
            )
        } else {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .join('')
            )
        }
    }
    return content.join('\n')
}

export const wordInGuesses = (word, guesses) => {
    for (let i = 0; i < guesses.length; i++) {
        if (word === guesses[i].join('')) return true
    }
    return false
}

export const sanitizeString = (str) => {
    let r = []
    for (let i = 0; i < str.length; i++) {
        if (str[i] in endOfWordToRegularLetters) {
            r.push(endOfWordToRegularLetters[str[i]])
        } else {
            r.push(str[i])
        }
    }
    return r.join('')
}

export const getCorrectAndPresent = (
    word,
    guess
) => {
    const cleanWord = sanitizeString(word)
    const cleanGuess = guess
        .map((e) => (e === '' && empty) || e)
        .map(sanitizeString)
        .join('')

    let correctAndPresent = {
        cleanWord: Array(cleanWord.length).fill(LetterType.Unevaluated),
        cleanGuess: Array(cleanGuess.length).fill(LetterType.Unevaluated),
    }

    // For each letter of guess, check if it's correct
    for (let i = 0; i < cleanWord.length; i++) {
        if (cleanWord[i] === cleanGuess[i])
            correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[i] =
                LetterType.Correct
    }

    // Now the tricky part is to find the present
    // A letter is present iff it appears in the word somewhere that is not already present or correct
    for (let i = 0; i < cleanGuess.length; i++) {
        for (let j = 0; j < cleanWord.length; j++) {
            if (
                cleanGuess[i] === cleanWord[j] &&
                correctAndPresent.cleanGuess[i] !== LetterType.Correct &&
                correctAndPresent.cleanWord[j] !== LetterType.Correct &&
                correctAndPresent.cleanGuess[i] !== LetterType.Present &&
                correctAndPresent.cleanWord[j] !== LetterType.Present
            )
                correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[
                    j
                ] = LetterType.Present
        }
        if (
            correctAndPresent.cleanGuess[i] === LetterType.Unevaluated &&
            cleanGuess[i] !== empty
        ) {
            // Finally, set the character to miss
            correctAndPresent.cleanGuess[i] = LetterType.Miss
        }
    }

    return correctAndPresent.cleanGuess
}
<fim_middle>",incorrect,3823
11,11,11,11,11,11,11,11,string[],Board,15b8db192fc5ac36ac290289da3f8a7f39a0fb7b,"<fim_prefix>export type Board = string[][]
export const numberOfLetters = 5
export const numberOfRows = 6
export const word = 'לחמים'
export const empty = '-'

export const endOfWordToRegularLetters = {
    ם: 'מ',
    ן: 'נ',
    ץ: 'צ',
    ף: 'פ',
    ך: 'כ',
}

export const regularToEndOfWordLetters = {
    מ: 'ם',
    נ: 'ן',
    צ: 'ץ',
    פ: 'ף',
    כ: 'ך',
}

// The enum ordering is used in order to always push a better result into the dict
export enum LetterType {
    Unevaluated,
    Miss,
    Present,
    Correct,
}

export const letterTypeToBgColor = {
    [LetterType.Unevaluated]: 'hg-unevaluated',
    [LetterType.Miss]: 'bg-zinc-400',
    [LetterType.Present]: 'bg-orange-400',
    [LetterType.Correct]: 'bg-green-400',
}

export const letterTypeToEmoji = {
    [LetterType.Miss]: '⬛',
    [LetterType.Present]: '🟨',
    [LetterType.Correct]: '🟩',
}

export const keyboardLettersFromGuesses = (word, guesses: <fim_suffix>) => {
    let letters = {
        א: LetterType.Unevaluated,
        ב: LetterType.Unevaluated,
        ג: LetterType.Unevaluated,
        ד: LetterType.Unevaluated,
        ה: LetterType.Unevaluated,
        ו: LetterType.Unevaluated,
        ז: LetterType.Unevaluated,
        ח: LetterType.Unevaluated,
        ט: LetterType.Unevaluated,
        י: LetterType.Unevaluated,
        כ: LetterType.Unevaluated,
        ל: LetterType.Unevaluated,
        מ: LetterType.Unevaluated,
        נ: LetterType.Unevaluated,
        ס: LetterType.Unevaluated,
        ע: LetterType.Unevaluated,
        פ: LetterType.Unevaluated,
        צ: LetterType.Unevaluated,
        ק: LetterType.Unevaluated,
        ר: LetterType.Unevaluated,
        ש: LetterType.Unevaluated,
        ת: LetterType.Unevaluated,
        ם: LetterType.Unevaluated,
        ן: LetterType.Unevaluated,
        ץ: LetterType.Unevaluated,
        ף: LetterType.Unevaluated,
        ך: LetterType.Unevaluated,
    }
    for (const i in guesses) {
        let line = guesses[i]
        let r = getCorrectAndPresent(word, line)
        for (const t in r) {
            // Using the enum ordering in order to always push a better result into the dict
            if (r[t] > letters[line[t]]) letters[line[t]] = r[t]
        }
    }
    return letters
}

export const emojiFromGuesses = (
    word,
    guesses,
    rtl = false
) => {
    let content = []
    for (let i = 0; i < guesses.length; i++) {
        if (rtl) {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .reverse()
                    .join('')
            )
        } else {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .join('')
            )
        }
    }
    return content.join('\n')
}

export const wordInGuesses = (word, guesses) => {
    for (let i = 0; i < guesses.length; i++) {
        if (word === guesses[i].join('')) return true
    }
    return false
}

export const sanitizeString = (str) => {
    let r = []
    for (let i = 0; i < str.length; i++) {
        if (str[i] in endOfWordToRegularLetters) {
            r.push(endOfWordToRegularLetters[str[i]])
        } else {
            r.push(str[i])
        }
    }
    return r.join('')
}

export const getCorrectAndPresent = (
    word,
    guess
) => {
    const cleanWord = sanitizeString(word)
    const cleanGuess = guess
        .map((e) => (e === '' && empty) || e)
        .map(sanitizeString)
        .join('')

    let correctAndPresent = {
        cleanWord: Array(cleanWord.length).fill(LetterType.Unevaluated),
        cleanGuess: Array(cleanGuess.length).fill(LetterType.Unevaluated),
    }

    // For each letter of guess, check if it's correct
    for (let i = 0; i < cleanWord.length; i++) {
        if (cleanWord[i] === cleanGuess[i])
            correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[i] =
                LetterType.Correct
    }

    // Now the tricky part is to find the present
    // A letter is present iff it appears in the word somewhere that is not already present or correct
    for (let i = 0; i < cleanGuess.length; i++) {
        for (let j = 0; j < cleanWord.length; j++) {
            if (
                cleanGuess[i] === cleanWord[j] &&
                correctAndPresent.cleanGuess[i] !== LetterType.Correct &&
                correctAndPresent.cleanWord[j] !== LetterType.Correct &&
                correctAndPresent.cleanGuess[i] !== LetterType.Present &&
                correctAndPresent.cleanWord[j] !== LetterType.Present
            )
                correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[
                    j
                ] = LetterType.Present
        }
        if (
            correctAndPresent.cleanGuess[i] === LetterType.Unevaluated &&
            cleanGuess[i] !== empty
        ) {
            // Finally, set the character to miss
            correctAndPresent.cleanGuess[i] = LetterType.Miss
        }
    }

    return correctAndPresent.cleanGuess
}
<fim_middle>",incorrect,3825
12,12,12,12,12,12,12,12,void,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace): <fim_suffix>;
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",incorrect,3974
13,13,13,13,13,13,13,13,,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace): <fim_suffix>;
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",incorrect,3978
14,14,14,14,14,14,14,14,computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight): <fim_suffix>;
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",incorrect,4002
15,15,15,15,15,15,15,15,"'EUR') {
  // ✔️ parameter validation, and default value
  assert",Currency,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest() {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency: <fim_suffix> = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions) {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",incorrect,2975
16,16,16,16,16,16,16,16,"string) {
        return parseDate(this._utc, date)
    }",Date,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date) {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date: <fim_suffix>) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",incorrect,690
17,17,17,17,17,17,17,17,"string) {
	const { year, month, day, hour, minute",Date,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date: <fim_suffix>) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date) {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",incorrect,701
18,18,18,18,18,18,18,18,string,Date,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date: <fim_suffix>) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date) {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",incorrect,704
19,19,19,19,19,19,19,19,"GregorianDate): JalaaliDate;
export function toJalaali",Date,55ca1837cce770e7e7f0bda123564f098fe3a486,"<fim_prefix>export type JalaaliDate = { jy: number; jm: number; jd: number };
export type GregorianDate = { gy: number; gm: number; gd: number };

/**
 * Converts a Gregorian date to Jalaali.
 */
export function toJalaali(date: <fim_suffix>);
export function toJalaali(gy, gm, gd);
export function toJalaali(
  gy,
  gm?,
  gd?,
) {
  if (gy instanceof Date) {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }
  return d2j(g2d(gy, gm!, gd!));
}

/**
 * Converts a Jalaali date to Gregorian.
 */
export function toGregorian(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd));
}

/**
 * Checks whether a Jalaali date is valid or not.
 */
export function isValidJalaaliDate(
  jy,
  jm,
  jd,
) {
  return (
    jy >= minJalaaliYear &&
    jy <= maxJalaaliYear &&
    jm >= 1 &&
    jm <= 12 &&
    jd >= 1 &&
    jd <= jalaaliMonthLength(jy, jm)
  );
}

/**
 * Is this a leap year or not?
 */
export function isLeapJalaaliYear(jy) {
  return jalCalLeap(jy) === 0;
}

/**
 * The number of days in a given month in a Jalaali year.
 */
export function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) {
    return 31;
  }
  if (jm <= 11) {
    return 30;
  }
  if (isLeapJalaaliYear(jy)) {
    return 30;
  }
  return 29;
}

/**
 * This function determines if the Jalaali (Persian) year is
 * leap (366-day long) or is the common year (365 days), and
 * finds the day in March (Gregorian calendar) of the first
 * day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @param withoutLeap when don't need leap (true or false) default is false
 * @returns
 *   leap: number of years since the last leap year (0 to 4)
 *   gy: Gregorian year of the beginning of Jalaali year
 *   march: the March day of Farvardin the 1st (1st day of jy)
 * @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
 * @see: http://www.fourmilab.ch/documents/calendar/
 */
export function jalCal(jy, withoutLeap = false) {
  validateJalaaliYear(jy);

  let jump = 0;
  let leapJ = -14;
  let jp = minJalaaliYear;
  // Find the limiting years for the Jalaali year jy.
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
      leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
    }
  }
  let n = jy - jp;

  // Find the number of leap years from AD 621 to the beginning
  // of the current Jalaali year in the Persian calendar.
  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
  if (mod(jump, 33) === 4 && jump - n === 4) {
    leapJ += 1;
  }

  const gy = jy + 621;

  // And the same in the Gregorian calendar (until the year gy).
  const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

  // Determine the Gregorian date of Farvardin the 1st.
  const march = 20 + leapJ - leapG;

  // return with gy and march when we don't need leap
  if (withoutLeap) {
    return {
      gy,
      march,
    };
  }

  // Find how many years have passed since the last leap year.
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }
  let leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }

  return {
    leap,
    gy,
    march,
  };
}

/**
 * Converts a date of the Jalaali calendar to the Julian Day number.
 *
 * @param jy Jalaali year (1 to 3100)
 * @param jm Jalaali month (1 to 12)
 * @param jd Jalaali day (1 to 29/31)
 * @returns Julian Day number
 */
export function j2d(jy, jm, jd) {
  const { gy, march } = jalCal(jy, true);
  return g2d(gy, 3, march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
}

/**
 * Converts the Julian Day number to a date in the Jalaali calendar.
 *
 * @param jdn Julian Day number
 * @returns
 *   jy: Jalaali year (1 to 3100)
 *   jm: Jalaali month (1 to 12)
 *   jd: Jalaali day (1 to 29/31)
 */
export function d2j(jdn) {
  const gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
  let jy = gy - 621;
  const r = jalCal(jy, false);
  const jdn1f = g2d(gy, 3, r.march);
  let jd;
  let jm;
  let k;

  // Find number of days that passed since 1 Farvardin.
  k = jdn - jdn1f;
  if (k >= 0) {
    if (k <= 185) {
      // The first 6 months.
      jm = 1 + div(k, 31);
      jd = mod(k, 31) + 1;
      return { jy: jy, jm: jm, jd: jd };
    } else {
      // The remaining months.
      k -= 186;
    }
  } else {
    // Previous Jalaali year.
    jy -= 1;
    k += 179;
    if (r.leap === 1) k += 1;
  }
  jm = 7 + div(k, 30);
  jd = mod(k, 30) + 1;
  return { jy: jy, jm: jm, jd: jd };
}

/**
 * Calculates the Julian Day number from Gregorian or Julian
 * calendar dates. This integer number corresponds to the noon of
 * the date (i.e. 12 hours of Universal Time).
 * The procedure was tested to be good since 1 March, -100100 (of both
 * calendars) up to a few million years into the future.
 *
 * @param gy Calendar year (years BC numbered 0, -1, -2, ...)
 * @param gm Calendar month (1 to 12)
 * @param gd Calendar day of the month (1 to 28/29/30/31)
 * @returns Julian Day number
 */
export function g2d(gy, gm, gd) {
  let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) +
    div(153 * mod(gm + 9, 12) + 2, 5) +
    gd -
    34840408;
  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
  return d;
}

/**
 * Calculates Gregorian and Julian calendar dates from the Julian Day number
 * (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
 * calendars) to some millions of years ahead of the present.
 *
 * @param jdn Julian Day number
 * @returns
 *   gy: Calendar year (years BC numbered 0, -1, -2, ...)
 *   gm: Calendar month (1 to 12)
 *   gd: Calendar day of the month M (1 to 28/29/30/31)
 */
export function d2g(jdn) {
  let j = 4 * jdn + 139361631;
  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  const i = div(mod(j, 1461), 4) * 5 + 308;
  const gd = div(mod(i, 153), 5) + 1;
  const gm = mod(div(i, 153), 12) + 1;
  const gy = div(j, 1461) - 100100 + div(8 - gm, 6);
  return { gy, gm, gd };
}

/**
 * Returns Saturday and Friday day of the current week
 * (week starts on Saturday)
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @returns Saturday and Friday of the current week
 */
export function jalaaliWeek(jy, jm, jd) {
  const dayOfWeek = jalaaliToDateObject(jy, jm, jd).getDay();

  const startDayDifference = dayOfWeek == 6 ? 0 : -(dayOfWeek + 1);
  const endDayDifference = 6 + startDayDifference;

  return {
    saturday: d2j(j2d(jy, jm, jd + startDayDifference)),
    friday: d2j(j2d(jy, jm, jd + endDayDifference)),
  };
}

/**
 * Convert Jalaali calendar dates to javascript Date object
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @param [h] hours
 * @param [m] minutes
 * @param [s] seconds
 * @param [ms] milliseconds
 * @returns Date object of the jalaali calendar dates
 */
export function jalaaliToDateObject(
  jy,
  jm,
  jd,
  h = 0,
  m = 0,
  s = 0,
  ms = 0,
) {
  const { gy, gm, gd } = toGregorian(jy, jm, jd);

  return new Date(gy, gm - 1, gd, h, m, s, ms);
}

/**
 * Checks wether the jalaali year is between min and max
 */
function validateJalaaliYear(jy) {
  if (jy < minJalaaliYear || jy > maxJalaaliYear) {
    throw new Error(`Invalid Jalaali year ${jy}`);
  }
}

/**
 * This function determines if the Jalaali (Persian) year is a leap
 * (366-day long) or is the common year (365 days), and finds the day in March
 * (Gregorian calendar) of the first day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @returns number of years since the last leap year (0 to 4)
 */
function jalCalLeap(jy) {
  validateJalaaliYear(jy);

  let jump = 0;
  let jp = minJalaaliYear;
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
    }
  }

  let n = jy - jp;
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }

  const leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    return 4;
  }
  return leap;
}

/**
 * Utility helper functions.
 */
function div(a, b) {
  return ~~(a / b);
}
function mod(a, b) {
  return a - ~~(a / b) * b;
}

/**
 * Jalaali years starting the 33-year rule.
 */
const breaks: number[] = [
  -61,
  9,
  38,
  199,
  426,
  686,
  756,
  818,
  1111,
  1181,
  1210,
  1635,
  2060,
  2097,
  2192,
  2262,
  2324,
  2394,
  2456,
  3178,
];

const minJalaaliYear = breaks[0];
const maxJalaaliYear = breaks[breaks.length - 1] - 1;
<fim_middle>",incorrect,2239
20,20,20,20,20,20,20,20,any,Error,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error: <fim_suffix>) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",incorrect,1144
21,21,21,21,21,21,21,21,any,Error,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error: <fim_suffix>) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",incorrect,1146
22,22,22,22,22,22,22,22,any,Error,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error: <fim_suffix>) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",incorrect,1148
23,23,23,23,23,23,23,23,any,Error,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error: <fim_suffix>) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",incorrect,1150
24,24,24,24,24,24,24,24,"IErrorOptions);
  constructor(message: string",Error,e70a5228b92ce6501abeaac18e383c237a14e734,"<fim_prefix>interface IErrorOptions {
  cause?: Error;
}

export interface ISerializedError {
  message: string;
  stack?: string;
  code?: string | number;
  [key: PropertyKey]: any;
}

/**
 * An error that serializes!
 * It is a copy of the normal definition of an error but allows 
 * to serialize the value via the toJSON() function and restore previous values 
 * with the `new()` function.
 */
export class SerializableError {
  message: string;
  code?: number | string;
  private stackValue?: string;
  get stack() {
    return this.stackValue;
  }

  get name() {
    return 'SerializableError';
  }

  constructor();
  constructor(error: <fim_suffix>);
  constructor(message);
  constructor(message, options);
  constructor(message, code?);

  constructor(message?, options = {}) {
    if (typeof message === 'string') {
      this.message = message;
    } else if (message) {
      this.message = message.message;
      this.stackValue = message.stack;
    } else {
      this.message = '';
    }
    if (typeof options === 'string' || typeof options === 'number') {
      this.code = options;
    } else if (options.cause && options.cause.stack) {
      this.stackValue = options.cause.stack;
    }
  }

  new(values) {
    if (values.message) {
      this.message = values.message;
    }
    if (values.stack) {
      this.stackValue = values.stack;
    }
    if (values.code || values.code === 0) {
      this.code = values.code;
    }
  }

  toJSON() {
    const { message, stackValue: stack, code } = this;
    const result: ISerializedError = {
      message,
    };
    if (stack) {
      result.stack = stack;
    }
    if (code || code === 0) {
      result.code = code;
    }
    return result;
  }

  toString() {
    return this.message;
  }
}
<fim_middle>",incorrect,1686
25,25,25,25,25,25,25,25,(...args: any[]) => any,Function,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn: <fim_suffix>) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",incorrect,830
26,26,26,26,26,26,26,26,"(...args: any[]) => any, desType: DesType",Function,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn: <fim_suffix>, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",incorrect,835
27,27,27,27,27,27,27,27,any,Function,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj: <fim_suffix>) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",incorrect,839
28,28,28,28,28,28,28,28,"()=>{}, cover = false)=>{
        let ev:busEv = this.",Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn: <fim_suffix>, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",incorrect,2317
29,29,29,29,29,29,29,29,"(name: string, packet: any, next: ()=>{})",Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn: <fim_suffix>)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",incorrect,2327
30,30,30,30,30,30,30,30,() => HTMLCanvasElement,Function,bf991cf13e41beda6a1e948184ea7f39b759886d,"<fim_prefix>interface offsets {
  vertical: number
  horizontal: number
}
export function measureOffsets (
  text,
  fontFamily,
  fontSize,
  createCanvas: <fim_suffix>
) {
  const canvas = createCanvas()
  const ctx = canvas.getContext('2d')
  ctx.font = `${fontSize}px ${fontFamily}`

  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize
  ctx.font = `${fontSize}px ${fontFamily}`
  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize

  ctx.font = `${fontSize}px ${fontFamily}`
  ctx.textBaseline = 'alphabetic'
  ctx.textAlign = 'center'
  ctx.fillStyle = 'white'
  ctx.fillText(text, canvas.width / 2, canvas.height / 2)

  const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data

  let textTop = 0
  let textBottom = 0
  for (let y = 0; y <= canvas.height; y++) {
    for (let x = 0; x <= canvas.width; x++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]
      if (rValue === 255) {
        if (textTop === 0) {
          textTop = y
        }
        textBottom = y
        break
      }
    }
  }
  const canvasHorizontalCenterLine = canvas.height / 2
  const textHorizontalCenterLine = (textBottom - textTop) / 2 + textTop

  let textLeft = 0
  let textRight = 0
  for (let x = 0; x <= canvas.width; x++) {
    for (let y = 0; y <= canvas.height; y++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]

      if (rValue === 255) {
        if (textLeft === 0) {
          textLeft = x
        }
        textRight = x
        break
      }
    }
  }

  const canvasVerticalCenterLine = canvas.width / 2
  const textVerticalCenterLine = (textRight - textLeft) / 2 + textLeft

  return {
    vertical: canvasHorizontalCenterLine - textHorizontalCenterLine,
    horizontal: canvasVerticalCenterLine - textVerticalCenterLine
  }
}
<fim_middle>",incorrect,4434
31,31,31,31,31,31,31,31,string,Id,32fad88cf989fe13e31b63cb2ea82544e40b70b9,"<fim_prefix>type Id = string | number;
type Owner = { Id: string }

export enum NFTAction {
  SEND='SEND',
  CONSUME='CONSUME',
  FREEZE='FREEZE',
  DELEGATE='DELEGATE',
  THAW='THAW',
  REVOKE='REVOKE',
  NONE='',
}

export const actionResolver: Record<NFTAction, [string, string]> = {
  SEND: ['uniques','transfer'],
  CONSUME: ['uniques','burn'],
  DELEGATE: ['uniques','approveTransfer'],
  FREEZE: ['uniques','freeze'],
  THAW: ['uniques','thaw'],
  REVOKE: ['uniques','cancelApproval'],
  '': ['',''],
}

export const basicUpdateFunction = (name, index) => `${name} #${index + 1}`

class NFTUtils {
  static createCollection(id, admin) {
    return [String(id), { Id: admin }]
  }


  static createNFT(classId: <fim_suffix>, id, owner) {
    return [String(classId), String(id), { Id: owner }]
  }

  static getActionParams(selectedAction, classId, id, meta) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.CONSUME:
    case NFTAction.DELEGATE:
    case NFTAction.REVOKE:
      return [classId, id, meta]
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return [classId, id]
    default:
      throw new Error('Action not found')
    }
  }

  static apiCall(selectedAction) {
    return actionResolver[selectedAction] || new Error('Action not found')

  }

  static correctMeta(selectedAction, meta, currentOwner, delegate) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.DELEGATE:
      return meta
    case NFTAction.CONSUME:
      return currentOwner
    case NFTAction.REVOKE:
      return delegate
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return ''
    default:
      throw new Error('Action not found')
    }
  }
}



export default NFTUtils
<fim_middle>",incorrect,2630
32,32,32,32,32,32,32,32,"string | number) {
    return this.get(key).exception === undefined",JsonKey,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key: <fim_suffix>, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",incorrect,520
33,33,33,33,33,33,33,33,"Record<string, unknown>,
  postMessageType: string",Metadata,8dd4eba467cc4f8c283713bdfc23d3b71e87f31d,"<fim_prefix>export type BasePostMessageCallbackProps<T> = {
  onMessage?: (message) => void
  onInvalidMessageError?: (message, error) => void
}

// This is an internal error. Thrown when we are decoding a post message's
// metadata and we encourntered a missing field or an invalid value. This
// likely means there has been a change to the definition of a post message
// that we do not know about.
export class PostMessageFieldDecodeError extends Error {
  public messageType: string
  public field: string
  public expectedType: TypeDef
  public gotValue: unknown

  constructor(messageType, field, expectedType, gotValue) {
    super(`Unable to decode '${field}' from '${messageType}'`)

    this.messageType = messageType
    this.field = field
    this.expectedType = expectedType
    this.gotValue = gotValue

    Object.setPrototypeOf(this, PostMessageFieldDecodeError.prototype)
  }
}

// This is an internal error. Thrown when we get a post message we don't konw
// about. This likely means there is a new post message that this package needs
// to define.
export class PostMessageUnknownTypeError extends Error {
  public postMessageType: string

  constructor(postMessageType) {
    super(`Unknown post message: ${postMessageType}`)

    this.postMessageType = postMessageType

    Object.setPrototypeOf(this, PostMessageUnknownTypeError.prototype)
  }
}

export type MessageEventData = {
  mx?: boolean
  metadata?: Metadata
  type?: string
}

export type Value = string | number
export type NestedValue = Record<string, Value>
export type TypeDef = string | Array<string> | Record<string, string>
export type Metadata = Record<string, Value | NestedValue>

export function assertMessageProp(
  container: <fim_suffix>,
  postMessageType,
  field,
  expectedType,
) {
  const value = container[field]

  const valueIsDefined = typeof value !== ""undefined""
  const valueIsString = typeof value === ""string""
  const valueIsNumber = typeof value === ""number""
  const valueIsObject = typeof value === ""object"" && !Array.isArray(value)

  const typeIsString = expectedType === ""string""
  const typeIsNumber = expectedType === ""number""
  const typeIsArray = expectedType instanceof Array
  const typeIsObject = typeof expectedType === ""object"" && !Array.isArray(expectedType)

  if (!valueIsDefined) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsString && !valueIsString) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsNumber && !valueIsNumber) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsArray && !(valueIsString && expectedType.includes(value))) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && !valueIsObject) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && valueIsObject) {
    Object.keys(expectedType).forEach((field) => {
      assertMessageProp(value, postMessageType, field, expectedType[field])
    })
  }
}
<fim_middle>",incorrect,2988
34,34,34,34,34,34,34,34,any,Object,4fa4cc3b188c443e4bf9fce3c1d94ca87897d5c9,"<fim_prefix>interface Listener {
    callback: Function;
    once: boolean;
}

interface Listeners {
    [key: string]: Listener[];
}

interface ListenersRegex {
    [key: string]: RegExp;
}

interface EventObject {
    event: string;
    stack?: {
        typeName: string,
        methodName: string,
        function: Function,
        functionName: string,
        fileName: string,
        lineNumber: number,
    }[]
}

interface EventEmitterOptions {
    mode?: 'wildcard' | 'regex' | 'simple';
    includeStack?: boolean;
    delimiter?: string;
}

export default class EventEmitter {
    private _listeners: Listeners = {};
    private _wildcardsRegex: ListenersRegex = {};
    private _listenerRegex: ListenersRegex = {};

    mode = ""wildcard"";
    includeStack = false;
    delimiter = ""."";

    constructor({mode = ""wildcard"", includeStack = false, delimiter = "".""} = {}) {
        if (mode) {
            this.mode = mode;
        }
        if (includeStack !== undefined) {
            this.includeStack = includeStack;
        }
        if (delimiter) {
            this.delimiter = delimiter;
        }
    }

    addListener = (event, cb, options = {}) => {
        if (Array.isArray(event)) {
            event.forEach((e) => this._addListener(e, cb, options))
        } else {
            this._addListener(event, cb, options)
        }
        return this;
    }

    private _addListener = (event, cb, options = {}) => {
        if (!hasOwnProperty(this._listeners, event)) {
            defineProperty(this._listeners, event, []);
        }
        this.emit(""newListener"", event, cb);

        if (!hasOwnProperty(this._wildcardsRegex, event)) {
            const parts = event.split(this.delimiter).map((p) => (p === ""*"" ? ""\\w*"" : p.replace(/[.*+?^${}()|[\]\\]/g, ""\\$&"")));
            const regex = new RegExp(`^${parts.join(""\\"" + this.delimiter)}$`);
            defineProperty(this._wildcardsRegex, event, regex);
        }

        if (!hasOwnProperty(this._listenerRegex, event)) {
            defineProperty(this._listenerRegex, event, new RegExp(event));
        }

        this._listeners[event].push({callback: cb, once: !!options?.once});
    };

    on = this.addListener;

    once = (event, cb, options = {}) => {
        return this.addListener(event, cb, {...options, once: true});
    };

    private _removeListener = (event, listener) => {
        if (this.listenerCount(event)) {
            let listenerIndex = this._listeners[event].findIndex((l) => l?.callback === listener);
            if (listenerIndex > -1) {
                this._listeners[event].splice(listenerIndex, 1);
                return true;
            }
        }
        return false;
    };

    removeListener = (event, listener) => {
        if (this._removeListener(event, listener)) {
            this.emit(""removeListener"", event, listener);
        }
        return this;
    };

    off = this.removeListener;

    removeAllListeners = (event) => {
        if (event && this.listeners(event).length) {
            const callbacks = this.listeners(event);
            delete this._listeners[event];

            for (const callback of callbacks) {
                this.emit(""removeListener"", event, callback);
            }
        }
        return this;
    };

    eventNames = () => Object.keys(this._listeners);

    listenerCount = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].length;
        }
        return 0;
    };

    listeners = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].map(l => l.callback);
        }
        return [];
    };

    private _getStack = () => {
        // @ts-ignore
        const prepareStackTraceOrg = Error.prepareStackTrace;
        const err = new Error();
        // @ts-ignore
        Error.prepareStackTrace = (_, stack) => stack;
        const stacks = err.stack;
        // @ts-ignore
        Error.prepareStackTrace = prepareStackTraceOrg;
        return stacks?.slice(2) || [];
    };

    private _callListeners = (e, eventObject, params) => {
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                callback?.callback?.(eventObject, ...params);
            }
        }
    };

    private _callAsyncListeners = (e, eventObject, params) => {
        const promises: Promise<any>[] = [];
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                promises.push(callback?.callback?.(eventObject, ...params));
            }
        }
        return promises;
    };

    emit = (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let listenerFound = false;
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            this._callListeners(event, eventObject, params);
            listenerFound = true;
        }
        return listenerFound;
    };

    emitAsync = async (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let promises: Promise<any>[] = [];
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            promises = this._callAsyncListeners(event, eventObject, params);
        }

        if (promises?.length) {
            await Promise.allSettled(promises);
            return true;
        }
        return false;
    };
}

function defineProperty(source, key, value) {
    return Object.defineProperty(source, key, {value, configurable: true, writable: true, enumerable: true});
}

function hasOwnProperty(obj: <fim_suffix>, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
<fim_middle>",incorrect,5160
35,35,35,35,35,35,35,35,"any, key: string",Object,4fa4cc3b188c443e4bf9fce3c1d94ca87897d5c9,"<fim_prefix>interface Listener {
    callback: Function;
    once: boolean;
}

interface Listeners {
    [key: string]: Listener[];
}

interface ListenersRegex {
    [key: string]: RegExp;
}

interface EventObject {
    event: string;
    stack?: {
        typeName: string,
        methodName: string,
        function: Function,
        functionName: string,
        fileName: string,
        lineNumber: number,
    }[]
}

interface EventEmitterOptions {
    mode?: 'wildcard' | 'regex' | 'simple';
    includeStack?: boolean;
    delimiter?: string;
}

export default class EventEmitter {
    private _listeners: Listeners = {};
    private _wildcardsRegex: ListenersRegex = {};
    private _listenerRegex: ListenersRegex = {};

    mode = ""wildcard"";
    includeStack = false;
    delimiter = ""."";

    constructor({mode = ""wildcard"", includeStack = false, delimiter = "".""} = {}) {
        if (mode) {
            this.mode = mode;
        }
        if (includeStack !== undefined) {
            this.includeStack = includeStack;
        }
        if (delimiter) {
            this.delimiter = delimiter;
        }
    }

    addListener = (event, cb, options = {}) => {
        if (Array.isArray(event)) {
            event.forEach((e) => this._addListener(e, cb, options))
        } else {
            this._addListener(event, cb, options)
        }
        return this;
    }

    private _addListener = (event, cb, options = {}) => {
        if (!hasOwnProperty(this._listeners, event)) {
            defineProperty(this._listeners, event, []);
        }
        this.emit(""newListener"", event, cb);

        if (!hasOwnProperty(this._wildcardsRegex, event)) {
            const parts = event.split(this.delimiter).map((p) => (p === ""*"" ? ""\\w*"" : p.replace(/[.*+?^${}()|[\]\\]/g, ""\\$&"")));
            const regex = new RegExp(`^${parts.join(""\\"" + this.delimiter)}$`);
            defineProperty(this._wildcardsRegex, event, regex);
        }

        if (!hasOwnProperty(this._listenerRegex, event)) {
            defineProperty(this._listenerRegex, event, new RegExp(event));
        }

        this._listeners[event].push({callback: cb, once: !!options?.once});
    };

    on = this.addListener;

    once = (event, cb, options = {}) => {
        return this.addListener(event, cb, {...options, once: true});
    };

    private _removeListener = (event, listener) => {
        if (this.listenerCount(event)) {
            let listenerIndex = this._listeners[event].findIndex((l) => l?.callback === listener);
            if (listenerIndex > -1) {
                this._listeners[event].splice(listenerIndex, 1);
                return true;
            }
        }
        return false;
    };

    removeListener = (event, listener) => {
        if (this._removeListener(event, listener)) {
            this.emit(""removeListener"", event, listener);
        }
        return this;
    };

    off = this.removeListener;

    removeAllListeners = (event) => {
        if (event && this.listeners(event).length) {
            const callbacks = this.listeners(event);
            delete this._listeners[event];

            for (const callback of callbacks) {
                this.emit(""removeListener"", event, callback);
            }
        }
        return this;
    };

    eventNames = () => Object.keys(this._listeners);

    listenerCount = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].length;
        }
        return 0;
    };

    listeners = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].map(l => l.callback);
        }
        return [];
    };

    private _getStack = () => {
        // @ts-ignore
        const prepareStackTraceOrg = Error.prepareStackTrace;
        const err = new Error();
        // @ts-ignore
        Error.prepareStackTrace = (_, stack) => stack;
        const stacks = err.stack;
        // @ts-ignore
        Error.prepareStackTrace = prepareStackTraceOrg;
        return stacks?.slice(2) || [];
    };

    private _callListeners = (e, eventObject, params) => {
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                callback?.callback?.(eventObject, ...params);
            }
        }
    };

    private _callAsyncListeners = (e, eventObject, params) => {
        const promises: Promise<any>[] = [];
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                promises.push(callback?.callback?.(eventObject, ...params));
            }
        }
        return promises;
    };

    emit = (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let listenerFound = false;
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            this._callListeners(event, eventObject, params);
            listenerFound = true;
        }
        return listenerFound;
    };

    emitAsync = async (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let promises: Promise<any>[] = [];
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            promises = this._callAsyncListeners(event, eventObject, params);
        }

        if (promises?.length) {
            await Promise.allSettled(promises);
            return true;
        }
        return false;
    };
}

function defineProperty(source: <fim_suffix>, key, value) {
    return Object.defineProperty(source, key, {value, configurable: true, writable: true, enumerable: true});
}

function hasOwnProperty(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
<fim_middle>",incorrect,5163
36,36,36,36,36,36,36,36,any,Options,e8163c19af6d0400d21846442a54c5e20ba9eac3,"<fim_prefix>export enum LongOption {
  NUMBER = 'number',
  LONG = 'long',
  STRING = 'string',
}

export enum DateOption {
  DATE = 'date',
  STRING = 'string',
  TIMESTAMP = 'timestamp',
}

export enum EnvOption {
  NODE = 'node',
  BROWSER = 'browser',
  BOTH = 'both',
}

export enum OneofOption {
  PROPERTIES = 'properties',
  UNIONS = 'unions',
}

export enum ServiceOption {
  GRPC = 'grpc-js',
  GENERIC = 'generic-definitions',
  DEFAULT = 'default',
  NONE = 'none',
}

export type Options = {
  context: boolean;
  snakeToCamel: Array<'json' | 'keys'>;
  forceLong: LongOption;
  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated
  useDate: DateOption;
  oneof: OneofOption;
  esModuleInterop: boolean;
  fileSuffix: string;
  outputEncodeMethods: boolean;
  outputJsonMethods: boolean;
  outputPartialMethods: boolean;
  outputTypeRegistry: boolean;
  stringEnums: boolean;
  constEnums: boolean;
  enumsAsLiterals: boolean;
  outputClientImpl: boolean | 'grpc-web';
  outputServices: ServiceOption;
  addGrpcMetadata: boolean;
  addNestjsRestParameter: boolean;
  returnObservable: boolean;
  lowerCaseServiceMethods: boolean;
  nestJs: boolean;
  env: EnvOption;
  unrecognizedEnum: boolean;
  exportCommonSymbols: boolean;
  outputSchema: boolean;
  // An alias of !output
  onlyTypes: boolean;
  emitImportedFiles: boolean;
  useExactTypes: boolean;
  delimitedMethods: boolean;
};

export function defaultOptions() {
  return {
    context: false,
    snakeToCamel: ['json', 'keys'],
    forceLong: LongOption.NUMBER,
    useOptionals: 'none',
    useDate: DateOption.DATE,
    oneof: OneofOption.PROPERTIES,
    esModuleInterop: false,
    fileSuffix: '',
    lowerCaseServiceMethods: false,
    outputEncodeMethods: true,
    outputJsonMethods: true,
    outputPartialMethods: true,
    outputTypeRegistry: false,
    stringEnums: false,
    constEnums: false,
    enumsAsLiterals: false,
    outputClientImpl: true,
    outputServices: ServiceOption.DEFAULT,
    returnObservable: false,
    addGrpcMetadata: false,
    addNestjsRestParameter: false,
    nestJs: false,
    env: EnvOption.BOTH,
    unrecognizedEnum: true,
    exportCommonSymbols: true,
    outputSchema: false,
    onlyTypes: false,
    emitImportedFiles: true,
    useExactTypes: true,
    delimitedMethods: false,
  };
}

const nestJsOptions: Partial<Options> = {
  lowerCaseServiceMethods: true,
  outputEncodeMethods: false,
  outputJsonMethods: false,
  outputPartialMethods: false,
  outputClientImpl: false,
  useDate: DateOption.TIMESTAMP,
};

export function optionsFromParameter(parameter) {
  const options = defaultOptions();
  if (parameter) {
    const parsed = parseParameter(parameter);
    if (parsed.nestJs) {
      Object.assign(options, nestJsOptions);
    }
    Object.assign(options, parsed);
  }
  // We should promote onlyTypes to its own documented flag, but just an alias for now
  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {
    options.onlyTypes = true;
  }

  // Treat forceLong=true as LONG
  if ((options.forceLong as any) === true) {
    options.forceLong = LongOption.LONG;
  }

  // Treat outputServices=false as NONE
  if ((options.outputServices as any) === false) {
    options.outputServices = ServiceOption.NONE;
  }

  if ((options.useDate as any) === true) {
    // Treat useDate=true as DATE
    options.useDate = DateOption.DATE;
  } else if ((options.useDate as any) === false) {
    // Treat useDate=false as TIMESTAMP
    options.useDate = DateOption.TIMESTAMP;
  }

  if ((options.snakeToCamel as any) === false) {
    options.snakeToCamel = [];
  } else if ((options.snakeToCamel as any) === true) {
    options.snakeToCamel = ['keys', 'json'];
  }

  return options;
}

// A very naive parse function, eventually could/should use iots/runtypes
function parseParameter(parameter): <fim_suffix> {
  const options = {} as any;
  const pairs = parameter.split(',').map((s) => s.split('='));
  pairs.forEach(([key, value]) => {
    options[key] = value === 'true' ? true : value === 'false' ? false : value;
  });
  return options;
}

export function getTsPoetOpts(options) {
  if (options.esModuleInterop) {
    return { forceDefaultImport: ['protobufjs/minimal'] };
  } else {
    return {};
  }
}
<fim_middle>",incorrect,3849
37,37,37,37,37,37,37,37,Partial<Options>,Options,e8163c19af6d0400d21846442a54c5e20ba9eac3,"<fim_prefix>export enum LongOption {
  NUMBER = 'number',
  LONG = 'long',
  STRING = 'string',
}

export enum DateOption {
  DATE = 'date',
  STRING = 'string',
  TIMESTAMP = 'timestamp',
}

export enum EnvOption {
  NODE = 'node',
  BROWSER = 'browser',
  BOTH = 'both',
}

export enum OneofOption {
  PROPERTIES = 'properties',
  UNIONS = 'unions',
}

export enum ServiceOption {
  GRPC = 'grpc-js',
  GENERIC = 'generic-definitions',
  DEFAULT = 'default',
  NONE = 'none',
}

export type Options = {
  context: boolean;
  snakeToCamel: Array<'json' | 'keys'>;
  forceLong: LongOption;
  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated
  useDate: DateOption;
  oneof: OneofOption;
  esModuleInterop: boolean;
  fileSuffix: string;
  outputEncodeMethods: boolean;
  outputJsonMethods: boolean;
  outputPartialMethods: boolean;
  outputTypeRegistry: boolean;
  stringEnums: boolean;
  constEnums: boolean;
  enumsAsLiterals: boolean;
  outputClientImpl: boolean | 'grpc-web';
  outputServices: ServiceOption;
  addGrpcMetadata: boolean;
  addNestjsRestParameter: boolean;
  returnObservable: boolean;
  lowerCaseServiceMethods: boolean;
  nestJs: boolean;
  env: EnvOption;
  unrecognizedEnum: boolean;
  exportCommonSymbols: boolean;
  outputSchema: boolean;
  // An alias of !output
  onlyTypes: boolean;
  emitImportedFiles: boolean;
  useExactTypes: boolean;
  delimitedMethods: boolean;
};

export function defaultOptions(): <fim_suffix> {
  return {
    context: false,
    snakeToCamel: ['json', 'keys'],
    forceLong: LongOption.NUMBER,
    useOptionals: 'none',
    useDate: DateOption.DATE,
    oneof: OneofOption.PROPERTIES,
    esModuleInterop: false,
    fileSuffix: '',
    lowerCaseServiceMethods: false,
    outputEncodeMethods: true,
    outputJsonMethods: true,
    outputPartialMethods: true,
    outputTypeRegistry: false,
    stringEnums: false,
    constEnums: false,
    enumsAsLiterals: false,
    outputClientImpl: true,
    outputServices: ServiceOption.DEFAULT,
    returnObservable: false,
    addGrpcMetadata: false,
    addNestjsRestParameter: false,
    nestJs: false,
    env: EnvOption.BOTH,
    unrecognizedEnum: true,
    exportCommonSymbols: true,
    outputSchema: false,
    onlyTypes: false,
    emitImportedFiles: true,
    useExactTypes: true,
    delimitedMethods: false,
  };
}

const nestJsOptions: Partial<Options> = {
  lowerCaseServiceMethods: true,
  outputEncodeMethods: false,
  outputJsonMethods: false,
  outputPartialMethods: false,
  outputClientImpl: false,
  useDate: DateOption.TIMESTAMP,
};

export function optionsFromParameter(parameter) {
  const options = defaultOptions();
  if (parameter) {
    const parsed = parseParameter(parameter);
    if (parsed.nestJs) {
      Object.assign(options, nestJsOptions);
    }
    Object.assign(options, parsed);
  }
  // We should promote onlyTypes to its own documented flag, but just an alias for now
  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {
    options.onlyTypes = true;
  }

  // Treat forceLong=true as LONG
  if ((options.forceLong as any) === true) {
    options.forceLong = LongOption.LONG;
  }

  // Treat outputServices=false as NONE
  if ((options.outputServices as any) === false) {
    options.outputServices = ServiceOption.NONE;
  }

  if ((options.useDate as any) === true) {
    // Treat useDate=true as DATE
    options.useDate = DateOption.DATE;
  } else if ((options.useDate as any) === false) {
    // Treat useDate=false as TIMESTAMP
    options.useDate = DateOption.TIMESTAMP;
  }

  if ((options.snakeToCamel as any) === false) {
    options.snakeToCamel = [];
  } else if ((options.snakeToCamel as any) === true) {
    options.snakeToCamel = ['keys', 'json'];
  }

  return options;
}

// A very naive parse function, eventually could/should use iots/runtypes
function parseParameter(parameter) {
  const options = {} as any;
  const pairs = parameter.split(',').map((s) => s.split('='));
  pairs.forEach(([key, value]) => {
    options[key] = value === 'true' ? true : value === 'false' ? false : value;
  });
  return options;
}

export function getTsPoetOpts(options) {
  if (options.esModuleInterop) {
    return { forceDefaultImport: ['protobufjs/minimal'] };
  } else {
    return {};
  }
}
<fim_middle>",incorrect,3853
38,38,38,38,38,38,38,38,number,Pitch,4e77d6fefc465d02bbfde5576d003dda41ab6508,"<fim_prefix>export type Pitch = number;

export const C = 0 as Pitch;
export const CIS = 1 as Pitch;
export const D = 2 as Pitch;
export const DIS = 3 as Pitch;
export const E = 4 as Pitch;
export const F = 5 as Pitch;
export const FIS = 6 as Pitch;
export const G = 7 as Pitch;
export const GIS = 8 as Pitch;
export const A = 9 as Pitch;
export const AIS = 10 as Pitch;
export const B = 11 as Pitch;

export const NUM_PITCHES = 12;
export const PITCHES = Array.from(Array(NUM_PITCHES).keys()) as Pitch[];

export function getPitchWithOctave(index: <fim_suffix>, octave) {
    const pitch = getPitch(index);
    const octaveFixed = octave + (index / NUM_PITCHES);
    return pitch + octaveFixed;
}

export function getPitch(index) {
    switch (index % NUM_PITCHES) {
        case C:
            return ""C"";
        case CIS:
            return ""C#"";
        case D:
            return ""D"";
        case DIS:
            return ""D#"";
        case E:
            return ""E"";
        case F:
            return ""F"";
        case FIS:
            return ""F#"";
        case G:
            return ""G"";
        case GIS:
            return ""G#"";
        case A:
            return ""A"";
        case AIS:
            return ""A#"";
        case B:
            return ""B"";
        default:
            throw new Error(""Invalid pitch"");
    }
}

export function isBlack(index) {
    return [CIS, DIS, FIS, GIS, AIS].includes(index % NUM_PITCHES);
}

<fim_middle>",incorrect,3785
39,39,39,39,39,39,39,39,"(state: Position, instruction: Instruction) => Position,
        initialState: Position",Position,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState: <fim_suffix>)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",incorrect,295
40,40,40,40,40,40,40,40,StrictQuery<Resolved>,Resolved,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use(): <fim_suffix> {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query) {
  return new StrictQuery(query)
}
<fim_middle>",incorrect,540
41,41,41,41,41,41,41,41,"Answer) {
  return validOperators(row.operator).includes(row.",Row,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty) => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row: <fim_suffix>) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",incorrect,4706
42,42,42,42,42,42,42,42,"""black"" | ""white""",Side,035143ca918f5ec39ef8a6d403d38090c1efd46d,"<fim_prefix>/**
 * Collection of 0x88-based methods to represent chessboard state.
 *
 * https://www.chessprogramming.org/0x88
 */

export const SQUARE_COLORS = [""light"", ""dark""] as const;
export const SIDE_COLORS = [""white"", ""black""] as const;
export const PIECE_TYPES = [
  ""queen"",
  ""king"",
  ""knight"",
  ""bishop"",
  ""rook"",
  ""pawn"",
] as const;

export type SquareColor = typeof SQUARE_COLORS[number];
export type Side = typeof SIDE_COLORS[number];
export type PieceType = typeof PIECE_TYPES[number];
export type Position = Partial<Record<Square, Piece>>;

export interface Piece {
  pieceType: PieceType;
  color: Side;
}

// prettier-ignore
const SQUARES_MAP = {
  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
}
const SQUARES = Object.keys(SQUARES_MAP) as Square[];
export type Square = keyof typeof SQUARES_MAP;

// prettier-ignore
const SQUARE_DISTANCE_TABLE = [
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  7 , 6 , 5 , 4 , 3 , 2, 1, 0, 1, 2, 3 , 4 , 5 , 6 , 7 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
]

const REVERSE_SQUARES_MAP = SQUARES.reduce((acc, key) => {
  acc[SQUARES_MAP[key]] = key;
  return acc;
}, {} as Record<number, Square>);

const FEN_PIECE_TYPE_MAP: { [key: string]: PieceType } = {
  p: ""pawn"",
  n: ""knight"",
  b: ""bishop"",
  r: ""rook"",
  q: ""queen"",
  k: ""king"",
};
const REVERSE_FEN_PIECE_TYPE_MAP: Record<PieceType, string> = Object.keys(
  FEN_PIECE_TYPE_MAP
).reduce((acc, key) => {
  acc[FEN_PIECE_TYPE_MAP[key]] = key;
  return acc;
}, {} as Record<PieceType, string>);

export type PositionDiff = {
  added: Array<{ piece: Piece; square: Square }>;
  removed: Array<{ piece: Piece; square: Square }>;
  moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }>;
};

/**
 * Parse a FEN string and return an object that maps squares to pieces.
 *
 * Also accepts the special string ""initial"" or ""start"" to represent
 * standard game starting position.
 *
 * Note that only the first part of the FEN string (piece placement) is
 * parsed; any additional components are ignored.
 *
 * @param fen the FEN string
 * @returns an object where key is of type Square (string) and value is
 *          of type Piece
 */
export function getPosition(fen) {
  if (fen === ""initial"" || fen === ""start"") {
    fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"";
  }

  const parts = fen.split("" "");
  const ranks = parts[0].split(""/"");
  if (ranks.length !== 8) {
    return undefined;
  }

  const position: Position = {};
  for (let i = 0; i < 8; i++) {
    const rank = 8 - i;
    let fileOffset = 0;
    for (let j = 0; j < ranks[i].length; j++) {
      const pieceLetter = ranks[i][j].toLowerCase();
      if (pieceLetter in FEN_PIECE_TYPE_MAP) {
        const square = (String.fromCharCode(97 + fileOffset) + rank) as Square;
        position[square] = {
          pieceType: FEN_PIECE_TYPE_MAP[pieceLetter],
          color: pieceLetter === ranks[i][j] ? ""black"" : ""white"",
        };
        fileOffset += 1;
      } else {
        const emptySpaces = parseInt(ranks[i][j]);
        if (isNaN(emptySpaces) || emptySpaces === 0 || emptySpaces > 8) {
          return undefined;
        } else {
          fileOffset += emptySpaces;
        }
      }
    }
    if (fileOffset !== 8) {
      return undefined;
    }
  }
  return position;
}

/**
 * Get FEN string corresponding to Position object. Note that this only returns
 * the first (piece placement) component of the FEN string.
 */
export function getFen(position) {
  const rankSpecs = [];
  for (let i = 0; i < 8; i++) {
    let rankSpec = """";
    let gap = 0;
    for (let j = 0; j < 8; j++) {
      const square = REVERSE_SQUARES_MAP[16 * i + j];
      const piece = position[square];
      if (piece !== undefined) {
        const pieceStr = REVERSE_FEN_PIECE_TYPE_MAP[piece.pieceType];
        if (gap > 0) {
          rankSpec += gap;
        }
        rankSpec += piece.color === ""white"" ? pieceStr.toUpperCase() : pieceStr;
        gap = 0;
      } else {
        gap += 1;
      }
    }
    if (gap > 0) {
      rankSpec += gap;
    }
    rankSpecs.push(rankSpec);
  }
  return rankSpecs.join(""/"");
}

/**
 * Return square identifier for visual index in a grid, depending on
 * orientation. If `orientation` is ""white"", then a8 is on the top
 * left (0) and h8 is on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 */
export function getSquare(visualIndex, orientation) {
  const idx = visualIndex + (visualIndex & ~0x7);
  return REVERSE_SQUARES_MAP[orientation === ""black"" ? 0x77 - idx : idx];
}

/**
 * Get the ""visual"" index for `square` depending on `orientation`.
 * If `orientation` is ""white"", then a8 is on the top left (0) and h8 is
 * on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 *
 * @param square square to convert to visual index.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns a visual index for the square in question.
 */
export function getVisualIndex(square, orientation) {
  const idx = SQUARES_MAP[square];
  const orientedIdx = orientation === ""black"" ? 0x77 - idx : idx;
  return (orientedIdx + (orientedIdx & 0x7)) >> 1;
}

/**
 * Like `getVisualIndex`, but returns a row and column combination.
 *
 * @param square square to convert to visual row and column.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns an array containing [row, column] for the square in question.
 */
export function getVisualRowColumn(
  square,
  orientation: <fim_suffix>
) {
  const idx = getVisualIndex(square, orientation);
  return [idx >> 3, idx & 0x7];
}

/**
 * https://www.chessprogramming.org/Color_of_a_Square#By_Anti-Diagonal_Index
 */
export function getSquareColor(square) {
  const idx0x88 = SQUARES_MAP[square];
  const idx = (idx0x88 + (idx0x88 & 0x7)) >> 1;
  return ((idx * 9) & 8) === 0 ? ""light"" : ""dark"";
}

/**
 * Type guard to check if `key` (string) is a valid chess square.
 */
export function keyIsSquare(key): key is Square {
  return key !== undefined && key in SQUARES_MAP;
}

/**
 * Deep equality check for two Piece objects.
 */
export function pieceEqual(a, b) {
  return (
    (a === undefined && b === undefined) ||
    (a !== undefined &&
      b !== undefined &&
      a.color === b.color &&
      a.pieceType === b.pieceType)
  );
}

/**
 * Type guard for string values that need to conform to a `Side` definition.
 */
export function isSide(s): s is Side {
  return SIDE_COLORS.includes(s as Side);
}

/**
 * Deep equality check for Position objects.
 */
export function positionsEqual(a, b) {
  return SQUARES.every((square) => pieceEqual(a[square], b[square]));
}

export function calcPositionDiff(
  oldPosition,
  newPosition
) {
  // Limit old and new positions only to squares that are different
  const oldPositionLimited = { ...oldPosition };
  const newPositionLimited = { ...newPosition };
  Object.keys(newPosition).forEach((k) => {
    const square = k as Square;
    if (pieceEqual(newPosition[square], oldPosition[square])) {
      delete oldPositionLimited[square];
      delete newPositionLimited[square];
    }
  });

  const added: Array<{ piece: Piece; square: Square }> = [];
  const removed: Array<{ piece: Piece; square: Square }> = [];
  const moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }> =
    [];

  Object.entries(newPositionLimited).forEach(([k, newPiece]) => {
    const newSquare = k as Square;
    let minDistance = 15;
    let closestSquare: Square | undefined;
    Object.entries(oldPositionLimited).forEach(([l, oldPiece]) => {
      const oldSquare = l as Square;
      if (pieceEqual(newPiece, oldPiece)) {
        const distance = squareDistance(newSquare, oldSquare);
        if (distance < minDistance) {
          minDistance = distance;
          closestSquare = oldSquare;
        }
      }
    });
    if (closestSquare !== undefined) {
      moved.push({ piece: newPiece, oldSquare: closestSquare, newSquare });
      delete oldPositionLimited[closestSquare];
      delete newPositionLimited[newSquare];
    }
  });

  Object.entries(newPositionLimited).forEach(([k, piece]) => {
    added.push({ piece, square: k as Square });
  });

  Object.entries(oldPositionLimited).forEach(([k, piece]) => {
    removed.push({ piece, square: k as Square });
  });

  return { added, removed, moved };
}

export function squareDistance(a, b) {
  return SQUARE_DISTANCE_TABLE[SQUARES_MAP[a] - SQUARES_MAP[b] + 0x77];
}
<fim_middle>",incorrect,2258
43,43,43,43,43,43,43,43,"""white"" | ""black"") {
  const idx = SQUARES_",Side,035143ca918f5ec39ef8a6d403d38090c1efd46d,"<fim_prefix>/**
 * Collection of 0x88-based methods to represent chessboard state.
 *
 * https://www.chessprogramming.org/0x88
 */

export const SQUARE_COLORS = [""light"", ""dark""] as const;
export const SIDE_COLORS = [""white"", ""black""] as const;
export const PIECE_TYPES = [
  ""queen"",
  ""king"",
  ""knight"",
  ""bishop"",
  ""rook"",
  ""pawn"",
] as const;

export type SquareColor = typeof SQUARE_COLORS[number];
export type Side = typeof SIDE_COLORS[number];
export type PieceType = typeof PIECE_TYPES[number];
export type Position = Partial<Record<Square, Piece>>;

export interface Piece {
  pieceType: PieceType;
  color: Side;
}

// prettier-ignore
const SQUARES_MAP = {
  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
}
const SQUARES = Object.keys(SQUARES_MAP) as Square[];
export type Square = keyof typeof SQUARES_MAP;

// prettier-ignore
const SQUARE_DISTANCE_TABLE = [
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  7 , 6 , 5 , 4 , 3 , 2, 1, 0, 1, 2, 3 , 4 , 5 , 6 , 7 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
]

const REVERSE_SQUARES_MAP = SQUARES.reduce((acc, key) => {
  acc[SQUARES_MAP[key]] = key;
  return acc;
}, {} as Record<number, Square>);

const FEN_PIECE_TYPE_MAP: { [key: string]: PieceType } = {
  p: ""pawn"",
  n: ""knight"",
  b: ""bishop"",
  r: ""rook"",
  q: ""queen"",
  k: ""king"",
};
const REVERSE_FEN_PIECE_TYPE_MAP: Record<PieceType, string> = Object.keys(
  FEN_PIECE_TYPE_MAP
).reduce((acc, key) => {
  acc[FEN_PIECE_TYPE_MAP[key]] = key;
  return acc;
}, {} as Record<PieceType, string>);

export type PositionDiff = {
  added: Array<{ piece: Piece; square: Square }>;
  removed: Array<{ piece: Piece; square: Square }>;
  moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }>;
};

/**
 * Parse a FEN string and return an object that maps squares to pieces.
 *
 * Also accepts the special string ""initial"" or ""start"" to represent
 * standard game starting position.
 *
 * Note that only the first part of the FEN string (piece placement) is
 * parsed; any additional components are ignored.
 *
 * @param fen the FEN string
 * @returns an object where key is of type Square (string) and value is
 *          of type Piece
 */
export function getPosition(fen) {
  if (fen === ""initial"" || fen === ""start"") {
    fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"";
  }

  const parts = fen.split("" "");
  const ranks = parts[0].split(""/"");
  if (ranks.length !== 8) {
    return undefined;
  }

  const position: Position = {};
  for (let i = 0; i < 8; i++) {
    const rank = 8 - i;
    let fileOffset = 0;
    for (let j = 0; j < ranks[i].length; j++) {
      const pieceLetter = ranks[i][j].toLowerCase();
      if (pieceLetter in FEN_PIECE_TYPE_MAP) {
        const square = (String.fromCharCode(97 + fileOffset) + rank) as Square;
        position[square] = {
          pieceType: FEN_PIECE_TYPE_MAP[pieceLetter],
          color: pieceLetter === ranks[i][j] ? ""black"" : ""white"",
        };
        fileOffset += 1;
      } else {
        const emptySpaces = parseInt(ranks[i][j]);
        if (isNaN(emptySpaces) || emptySpaces === 0 || emptySpaces > 8) {
          return undefined;
        } else {
          fileOffset += emptySpaces;
        }
      }
    }
    if (fileOffset !== 8) {
      return undefined;
    }
  }
  return position;
}

/**
 * Get FEN string corresponding to Position object. Note that this only returns
 * the first (piece placement) component of the FEN string.
 */
export function getFen(position) {
  const rankSpecs = [];
  for (let i = 0; i < 8; i++) {
    let rankSpec = """";
    let gap = 0;
    for (let j = 0; j < 8; j++) {
      const square = REVERSE_SQUARES_MAP[16 * i + j];
      const piece = position[square];
      if (piece !== undefined) {
        const pieceStr = REVERSE_FEN_PIECE_TYPE_MAP[piece.pieceType];
        if (gap > 0) {
          rankSpec += gap;
        }
        rankSpec += piece.color === ""white"" ? pieceStr.toUpperCase() : pieceStr;
        gap = 0;
      } else {
        gap += 1;
      }
    }
    if (gap > 0) {
      rankSpec += gap;
    }
    rankSpecs.push(rankSpec);
  }
  return rankSpecs.join(""/"");
}

/**
 * Return square identifier for visual index in a grid, depending on
 * orientation. If `orientation` is ""white"", then a8 is on the top
 * left (0) and h8 is on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 */
export function getSquare(visualIndex, orientation) {
  const idx = visualIndex + (visualIndex & ~0x7);
  return REVERSE_SQUARES_MAP[orientation === ""black"" ? 0x77 - idx : idx];
}

/**
 * Get the ""visual"" index for `square` depending on `orientation`.
 * If `orientation` is ""white"", then a8 is on the top left (0) and h8 is
 * on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 *
 * @param square square to convert to visual index.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns a visual index for the square in question.
 */
export function getVisualIndex(square, orientation: <fim_suffix>) {
  const idx = SQUARES_MAP[square];
  const orientedIdx = orientation === ""black"" ? 0x77 - idx : idx;
  return (orientedIdx + (orientedIdx & 0x7)) >> 1;
}

/**
 * Like `getVisualIndex`, but returns a row and column combination.
 *
 * @param square square to convert to visual row and column.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns an array containing [row, column] for the square in question.
 */
export function getVisualRowColumn(
  square,
  orientation
) {
  const idx = getVisualIndex(square, orientation);
  return [idx >> 3, idx & 0x7];
}

/**
 * https://www.chessprogramming.org/Color_of_a_Square#By_Anti-Diagonal_Index
 */
export function getSquareColor(square) {
  const idx0x88 = SQUARES_MAP[square];
  const idx = (idx0x88 + (idx0x88 & 0x7)) >> 1;
  return ((idx * 9) & 8) === 0 ? ""light"" : ""dark"";
}

/**
 * Type guard to check if `key` (string) is a valid chess square.
 */
export function keyIsSquare(key): key is Square {
  return key !== undefined && key in SQUARES_MAP;
}

/**
 * Deep equality check for two Piece objects.
 */
export function pieceEqual(a, b) {
  return (
    (a === undefined && b === undefined) ||
    (a !== undefined &&
      b !== undefined &&
      a.color === b.color &&
      a.pieceType === b.pieceType)
  );
}

/**
 * Type guard for string values that need to conform to a `Side` definition.
 */
export function isSide(s): s is Side {
  return SIDE_COLORS.includes(s as Side);
}

/**
 * Deep equality check for Position objects.
 */
export function positionsEqual(a, b) {
  return SQUARES.every((square) => pieceEqual(a[square], b[square]));
}

export function calcPositionDiff(
  oldPosition,
  newPosition
) {
  // Limit old and new positions only to squares that are different
  const oldPositionLimited = { ...oldPosition };
  const newPositionLimited = { ...newPosition };
  Object.keys(newPosition).forEach((k) => {
    const square = k as Square;
    if (pieceEqual(newPosition[square], oldPosition[square])) {
      delete oldPositionLimited[square];
      delete newPositionLimited[square];
    }
  });

  const added: Array<{ piece: Piece; square: Square }> = [];
  const removed: Array<{ piece: Piece; square: Square }> = [];
  const moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }> =
    [];

  Object.entries(newPositionLimited).forEach(([k, newPiece]) => {
    const newSquare = k as Square;
    let minDistance = 15;
    let closestSquare: Square | undefined;
    Object.entries(oldPositionLimited).forEach(([l, oldPiece]) => {
      const oldSquare = l as Square;
      if (pieceEqual(newPiece, oldPiece)) {
        const distance = squareDistance(newSquare, oldSquare);
        if (distance < minDistance) {
          minDistance = distance;
          closestSquare = oldSquare;
        }
      }
    });
    if (closestSquare !== undefined) {
      moved.push({ piece: newPiece, oldSquare: closestSquare, newSquare });
      delete oldPositionLimited[closestSquare];
      delete newPositionLimited[newSquare];
    }
  });

  Object.entries(newPositionLimited).forEach(([k, piece]) => {
    added.push({ piece, square: k as Square });
  });

  Object.entries(oldPositionLimited).forEach(([k, piece]) => {
    removed.push({ piece, square: k as Square });
  });

  return { added, removed, moved };
}

export function squareDistance(a, b) {
  return SQUARE_DISTANCE_TABLE[SQUARES_MAP[a] - SQUARES_MAP[b] + 0x77];
}
<fim_middle>",incorrect,2260
44,44,44,44,44,44,44,44,"""white"" | ""black""",Side,035143ca918f5ec39ef8a6d403d38090c1efd46d,"<fim_prefix>/**
 * Collection of 0x88-based methods to represent chessboard state.
 *
 * https://www.chessprogramming.org/0x88
 */

export const SQUARE_COLORS = [""light"", ""dark""] as const;
export const SIDE_COLORS = [""white"", ""black""] as const;
export const PIECE_TYPES = [
  ""queen"",
  ""king"",
  ""knight"",
  ""bishop"",
  ""rook"",
  ""pawn"",
] as const;

export type SquareColor = typeof SQUARE_COLORS[number];
export type Side = typeof SIDE_COLORS[number];
export type PieceType = typeof PIECE_TYPES[number];
export type Position = Partial<Record<Square, Piece>>;

export interface Piece {
  pieceType: PieceType;
  color: Side;
}

// prettier-ignore
const SQUARES_MAP = {
  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
}
const SQUARES = Object.keys(SQUARES_MAP) as Square[];
export type Square = keyof typeof SQUARES_MAP;

// prettier-ignore
const SQUARE_DISTANCE_TABLE = [
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  7 , 6 , 5 , 4 , 3 , 2, 1, 0, 1, 2, 3 , 4 , 5 , 6 , 7 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
]

const REVERSE_SQUARES_MAP = SQUARES.reduce((acc, key) => {
  acc[SQUARES_MAP[key]] = key;
  return acc;
}, {} as Record<number, Square>);

const FEN_PIECE_TYPE_MAP: { [key: string]: PieceType } = {
  p: ""pawn"",
  n: ""knight"",
  b: ""bishop"",
  r: ""rook"",
  q: ""queen"",
  k: ""king"",
};
const REVERSE_FEN_PIECE_TYPE_MAP: Record<PieceType, string> = Object.keys(
  FEN_PIECE_TYPE_MAP
).reduce((acc, key) => {
  acc[FEN_PIECE_TYPE_MAP[key]] = key;
  return acc;
}, {} as Record<PieceType, string>);

export type PositionDiff = {
  added: Array<{ piece: Piece; square: Square }>;
  removed: Array<{ piece: Piece; square: Square }>;
  moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }>;
};

/**
 * Parse a FEN string and return an object that maps squares to pieces.
 *
 * Also accepts the special string ""initial"" or ""start"" to represent
 * standard game starting position.
 *
 * Note that only the first part of the FEN string (piece placement) is
 * parsed; any additional components are ignored.
 *
 * @param fen the FEN string
 * @returns an object where key is of type Square (string) and value is
 *          of type Piece
 */
export function getPosition(fen) {
  if (fen === ""initial"" || fen === ""start"") {
    fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"";
  }

  const parts = fen.split("" "");
  const ranks = parts[0].split(""/"");
  if (ranks.length !== 8) {
    return undefined;
  }

  const position: Position = {};
  for (let i = 0; i < 8; i++) {
    const rank = 8 - i;
    let fileOffset = 0;
    for (let j = 0; j < ranks[i].length; j++) {
      const pieceLetter = ranks[i][j].toLowerCase();
      if (pieceLetter in FEN_PIECE_TYPE_MAP) {
        const square = (String.fromCharCode(97 + fileOffset) + rank) as Square;
        position[square] = {
          pieceType: FEN_PIECE_TYPE_MAP[pieceLetter],
          color: pieceLetter === ranks[i][j] ? ""black"" : ""white"",
        };
        fileOffset += 1;
      } else {
        const emptySpaces = parseInt(ranks[i][j]);
        if (isNaN(emptySpaces) || emptySpaces === 0 || emptySpaces > 8) {
          return undefined;
        } else {
          fileOffset += emptySpaces;
        }
      }
    }
    if (fileOffset !== 8) {
      return undefined;
    }
  }
  return position;
}

/**
 * Get FEN string corresponding to Position object. Note that this only returns
 * the first (piece placement) component of the FEN string.
 */
export function getFen(position) {
  const rankSpecs = [];
  for (let i = 0; i < 8; i++) {
    let rankSpec = """";
    let gap = 0;
    for (let j = 0; j < 8; j++) {
      const square = REVERSE_SQUARES_MAP[16 * i + j];
      const piece = position[square];
      if (piece !== undefined) {
        const pieceStr = REVERSE_FEN_PIECE_TYPE_MAP[piece.pieceType];
        if (gap > 0) {
          rankSpec += gap;
        }
        rankSpec += piece.color === ""white"" ? pieceStr.toUpperCase() : pieceStr;
        gap = 0;
      } else {
        gap += 1;
      }
    }
    if (gap > 0) {
      rankSpec += gap;
    }
    rankSpecs.push(rankSpec);
  }
  return rankSpecs.join(""/"");
}

/**
 * Return square identifier for visual index in a grid, depending on
 * orientation. If `orientation` is ""white"", then a8 is on the top
 * left (0) and h8 is on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 */
export function getSquare(visualIndex, orientation: <fim_suffix>) {
  const idx = visualIndex + (visualIndex & ~0x7);
  return REVERSE_SQUARES_MAP[orientation === ""black"" ? 0x77 - idx : idx];
}

/**
 * Get the ""visual"" index for `square` depending on `orientation`.
 * If `orientation` is ""white"", then a8 is on the top left (0) and h8 is
 * on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 *
 * @param square square to convert to visual index.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns a visual index for the square in question.
 */
export function getVisualIndex(square, orientation) {
  const idx = SQUARES_MAP[square];
  const orientedIdx = orientation === ""black"" ? 0x77 - idx : idx;
  return (orientedIdx + (orientedIdx & 0x7)) >> 1;
}

/**
 * Like `getVisualIndex`, but returns a row and column combination.
 *
 * @param square square to convert to visual row and column.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns an array containing [row, column] for the square in question.
 */
export function getVisualRowColumn(
  square,
  orientation
) {
  const idx = getVisualIndex(square, orientation);
  return [idx >> 3, idx & 0x7];
}

/**
 * https://www.chessprogramming.org/Color_of_a_Square#By_Anti-Diagonal_Index
 */
export function getSquareColor(square) {
  const idx0x88 = SQUARES_MAP[square];
  const idx = (idx0x88 + (idx0x88 & 0x7)) >> 1;
  return ((idx * 9) & 8) === 0 ? ""light"" : ""dark"";
}

/**
 * Type guard to check if `key` (string) is a valid chess square.
 */
export function keyIsSquare(key): key is Square {
  return key !== undefined && key in SQUARES_MAP;
}

/**
 * Deep equality check for two Piece objects.
 */
export function pieceEqual(a, b) {
  return (
    (a === undefined && b === undefined) ||
    (a !== undefined &&
      b !== undefined &&
      a.color === b.color &&
      a.pieceType === b.pieceType)
  );
}

/**
 * Type guard for string values that need to conform to a `Side` definition.
 */
export function isSide(s): s is Side {
  return SIDE_COLORS.includes(s as Side);
}

/**
 * Deep equality check for Position objects.
 */
export function positionsEqual(a, b) {
  return SQUARES.every((square) => pieceEqual(a[square], b[square]));
}

export function calcPositionDiff(
  oldPosition,
  newPosition
) {
  // Limit old and new positions only to squares that are different
  const oldPositionLimited = { ...oldPosition };
  const newPositionLimited = { ...newPosition };
  Object.keys(newPosition).forEach((k) => {
    const square = k as Square;
    if (pieceEqual(newPosition[square], oldPosition[square])) {
      delete oldPositionLimited[square];
      delete newPositionLimited[square];
    }
  });

  const added: Array<{ piece: Piece; square: Square }> = [];
  const removed: Array<{ piece: Piece; square: Square }> = [];
  const moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }> =
    [];

  Object.entries(newPositionLimited).forEach(([k, newPiece]) => {
    const newSquare = k as Square;
    let minDistance = 15;
    let closestSquare: Square | undefined;
    Object.entries(oldPositionLimited).forEach(([l, oldPiece]) => {
      const oldSquare = l as Square;
      if (pieceEqual(newPiece, oldPiece)) {
        const distance = squareDistance(newSquare, oldSquare);
        if (distance < minDistance) {
          minDistance = distance;
          closestSquare = oldSquare;
        }
      }
    });
    if (closestSquare !== undefined) {
      moved.push({ piece: newPiece, oldSquare: closestSquare, newSquare });
      delete oldPositionLimited[closestSquare];
      delete newPositionLimited[newSquare];
    }
  });

  Object.entries(newPositionLimited).forEach(([k, piece]) => {
    added.push({ piece, square: k as Square });
  });

  Object.entries(oldPositionLimited).forEach(([k, piece]) => {
    removed.push({ piece, square: k as Square });
  });

  return { added, removed, moved };
}

export function squareDistance(a, b) {
  return SQUARE_DISTANCE_TABLE[SQUARES_MAP[a] - SQUARES_MAP[b] + 0x77];
}
<fim_middle>",incorrect,2262
45,45,45,45,45,45,45,45,any,State,9eb078d7d68852e0860617c539c62b7d3a9f0a9a,"<fim_prefix>/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key) => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current,
    index,
    path,
    value,
    destroyArrays,
): <fim_suffix> => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state, key, value) => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
<fim_middle>",incorrect,2056
46,46,46,46,46,46,46,46,string,Symbol,0545d587e8e888d3350df282e773e2290f9fb999,"<fim_prefix>export const WS = String.fromCharCode(29);
export const RS = ' ';
export const NL = '\n';
export const INDENT = String.fromCharCode(16);
export const UNINDENT = String.fromCharCode(17);

export interface SrcBuilderOptions {
  isPretty: boolean;
  isTypeScript: boolean;
  isModule: boolean;
  isJSX: boolean;
}

export class File {
  filename: string;
  imports = new Imports();
  options: SrcBuilderOptions;
  src: SrcBuilder;
  qwikModule: string;
  qrlPrefix: string;
  exports: Map<string, string> = new Map();

  get module() {
    return this.filename.substr(0, this.filename.lastIndexOf('.'));
  }
  get path() {
    return this.filename;
  }
  get contents() {
    return this.toString();
  }

  constructor(
    filename,
    options,
    qwikModule,
    qrlPrefix,
  ) {
    this.filename = filename;
    this.options = options;
    this.src = new SrcBuilder(this.options);
    this.qwikModule = qwikModule;
    this.qrlPrefix = qrlPrefix;
  }

  import(module, symbol): <fim_suffix> {
    return this.imports.get(module, symbol);
  }

  toQrl(symbol) {
    return string(this.qrlPrefix + this.module + '#' + symbol);
  }

  exportConst(name, value?) {
    this.exports.set(name, this.src.isModule ? name : 'exports.' + name);
    this.src.const(name, value, true);
  }

  toString() {
    const srcImports = new SrcBuilder(this.options);
    const imports = this.imports.imports;
    const modules = Array.from(imports.keys()).sort();
    modules.forEach((module) => {
      const symbolMap = imports.get(module)!;
      const symbols = Array.from(symbolMap.keys()).sort();
      if (removeExt(module) !== removeExt(this.qrlPrefix + this.filename)) {
        srcImports.import(module, symbols);
      }
    });
    srcImports.emit(NL);
    return srcImports.toString() + this.src.toString();
  }
}

function removeExt(filename) {
  const indx = filename.lastIndexOf('.');
  return indx == -1 ? filename : filename.substr(0, indx);
}

const spaces: string[] = [''];

export class SrcBuilder {
  isPretty: boolean;
  isTypeScript: boolean;
  isModule: boolean;
  isJSX: boolean;

  buf: string[] = [];
  wasLastNL = false;
  nestingDepth: number = 0;
  offset: number = 0;

  constructor(options) {
    this.isPretty = options.isPretty;
    this.isTypeScript = options.isTypeScript;
    this.isModule = options.isModule;
    this.isJSX = options.isJSX;
  }

  import(module, symbols) {
    if (this.isModule) {
      this.emit(
        'import',
        WS,
        '{',
        WS,
        symbols,
        WS,
        '}',
        WS,
        'from',
        WS,
        string(module),
        ';',
        NL,
      );
    } else {
      symbols.forEach((symbol) => {
        this.const(symbol, function(this) {
          this.emit(invoke('require', [string(module)]), '.', symbol);
        });
      });
    }
    this.emit(NL);
    return this;
  }

  emit(...values) {
    for (let i = 0; i < values.length; i++) {
      const value = values[i];
      if (typeof value == 'function') {
        value.call(this);
      } else if (value === null) {
        this.push('null');
      } else if (value === undefined) {
        this.push('undefined');
      } else if (typeof value == 'string') {
        this.push(value);
      } else if (typeof value == 'number') {
        this.push(String(value));
      } else if (typeof value == 'boolean') {
        this.push(String(value));
      } else if (Array.isArray(value)) {
        this.emitList(value);
      } else if (typeof value == 'object') {
        this.emit('{', NL, INDENT);
        let separator = false;
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            if (separator) {
              this.emit(',', NL);
            }
            this.emit(possiblyQuotePropertyName(key)).emit(':', WS, value[key]);
            separator = true;
          }
        }
        this.emit(NL, UNINDENT, '}');
      } else {
        throw new Error('Unexpected value: ' + value);
      }
    }
    return this;
  }

  private push(value) {
    if (value == UNINDENT) {
      this.nestingDepth--;
    } else if (value == INDENT) {
      this.nestingDepth++;
    } else {
      if (value == ')' || value == ':' || value == ']' || value == '}') {
        // clear last ',';
        let index = this.buf.length - 1;
        let ch: string = '';
        while (index > 1 && isWhitespace((ch = this.buf[index]))) {
          index--;
        }
        if (ch == ',') {
          this.buf[index] = '';
        }
      }
      if (this.isPretty && this.wasLastNL) {
        while (spaces.length <= this.nestingDepth) {
          spaces.push(spaces[spaces.length - 1] + '  ');
        }
        this.buf.push(spaces[this.nestingDepth]);
      }
      this.wasLastNL = value === NL;
      if (this.isPretty || (value !== WS && value !== NL)) {
        this.buf.push(value == WS ? ' ' : value);
      }
    }
  }

  emitList(values, sep = ',') {
    let separator = false;
    for (const value of values) {
      if (separator) {
        this.emit(sep, sep == ';' ? NL : WS);
      }
      this.emit(value);
      separator = true;
    }
    return this;
  }

  const(name, value?, exprt = false) {
    if (exprt) {
      this.emit(this.isModule ? 'export const ' : 'exports.');
    } else {
      this.emit('const ');
    }
    this.emit(name);
    if (value !== undefined) {
      this.emit(WS, '=', WS, value);
    }
    this.emit(';', NL);
    return this;
  }

  type(def) {
    if (this.isTypeScript) {
      this.emit(':', def);
    }
    return this;
  }

  typeParameters(typeParameters) {
    if (this.isTypeScript && typeParameters && typeParameters.length) {
      this.emit('<', typeParameters, '>');
    }
  }

  jsxBegin(
    symbol,
    props,
    bindings,
  ) {
    if (this.isJSX) {
      this.emit('<' + symbol);
    } else {
      this.emit(
        'h',
        '(',
        INDENT,
        NL,
        literalTagName(symbol),
        ',',
        NL,
        '{',
        NL,
        INDENT,
      );
    }
    let first = true;
    for (const key in props) {
      if (Object.prototype.hasOwnProperty.call(props, key) && !ignoreKey(key)) {
        if (first) {
          first = false;
          this.isJSX && this.emit(RS, INDENT, INDENT);
        } else {
          this.isJSX ? this.emit(NL) : this.emit(',', NL);
        }
        this.isJSX ? this.emit(key) : this.emit(possiblyQuotePropertyName(key));
        this.isJSX ? this.emit('=') : this.emit(':', WS);
        this.emit(string(props[key]));
      }
    }
    for (const key in bindings) {
      if (
        Object.prototype.hasOwnProperty.call(bindings, key) &&
        !ignoreKey(key)
      ) {
        if (first) {
          first = false;
          this.isJSX && this.emit(RS, INDENT, INDENT);
        } else {
          this.isJSX ? this.emit(NL) : this.emit(',', NL);
        }
        this.isJSX ? this.emit(key) : this.emit(possiblyQuotePropertyName(key));
        this.isJSX ? this.emit('={') : this.emit(':', WS);
        this.emit(bindings[key]);
        this.isJSX ? this.emit('}') : this.emit();
      }
    }
    if (!first) {
      this.isJSX && this.emit(UNINDENT, UNINDENT);
    }
    if (this.isJSX) {
      this.emit('>', INDENT, NL);
    } else {
      this.emit(NL, UNINDENT, '}', ',', NL);
    }
  }

  jsxEnd(symbol) {
    if (this.isJSX) {
      this.emit(UNINDENT, '</', symbol, '>', NL);
    } else {
      this.emit(UNINDENT, ')', ',', NL);
    }
  }

  jsxBeginFragment(symbol) {
    if (this.isJSX) {
      this.emit('<>', INDENT, NL);
    } else {
      this.emit('h', '(', symbol.name, ',', WS, 'null', ',', INDENT, NL);
    }
  }
  jsxEndFragment() {
    if (this.isJSX) {
      this.emit(UNINDENT, NL, '</>');
    } else {
      this.emit(UNINDENT, ')', NL);
    }
  }

  jsxTextBinding(exp) {
    if (this.isJSX) {
      this.emit('{', exp, '}', NL);
    } else {
      this.emit(exp, NL);
    }
  }

  toString() {
    return this.buf.join('');
  }
}

export class Symbol {
  name: string;
  constructor(name) {
    this.name = name;
  }
}

export class Imports {
  imports: Map<string, Map<string, Symbol>> = new Map();

  get(moduleName, symbolName) {
    let importSymbols = this.imports.get(moduleName);
    if (!importSymbols) {
      importSymbols = new Map();
      this.imports.set(moduleName, importSymbols);
    }
    let symbol = importSymbols.get(symbolName);
    if (!symbol) {
      symbol = new Symbol(symbolName);
      importSymbols.set(symbolName, symbol);
    }
    return symbol;
  }
}

function ignoreKey(key) {
  return (
    key.startsWith('$') ||
    key.startsWith('_') ||
    key == 'code' ||
    key == '' ||
    key == 'builder-id'
  );
}

export class Block {
  imports: Imports;
  constructor(imports) {
    this.imports = imports;
  }
}

function possiblyQuotePropertyName(key) {
  return /^\w[\w\d]*$/.test(key) ? key : JSON.stringify(key);
}

export function string(text) {
  return JSON.stringify(text);
}

export function invoke(
  symbol,
  args,
  typeParameters?,
) {
  return function(this) {
    this.emit(typeof symbol == 'string' ? symbol : symbol.name);
    this.typeParameters(typeParameters);
    this.emit('(', args, ')');
  };
}

export function arrowFnBlock(args, statements) {
  return function(this) {
    this.emit('(', args, ')', WS, '=>', WS);
    this.emit('{', INDENT, NL)
      .emitList(statements, ';')
      .emit(UNINDENT, NL, '}');
  };
}

export function arrowFnValue(args, expression) {
  return function(this) {
    this.emit('(', args, ')', WS, '=>', WS, expression);
  };
}

const LOWER_CASE = 'a'.charCodeAt(0) - 1;

function literalTagName(symbol) {
  if (
    typeof symbol == 'string' &&
    symbol.charCodeAt(0) > LOWER_CASE &&
    symbol.indexOf('.') === -1
  ) {
    return string(symbol);
  }
  return symbol;
}
function isWhitespace(ch) {
  return ch == '' || ch == RS || ch == NL;
}
<fim_middle>",incorrect,3489
47,47,47,47,47,47,47,47,"Constructor, args) {
    this.add(className, args);
    this",T,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className: <fim_suffix>, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",incorrect,996
48,48,48,48,48,48,48,48,any,T,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type,
    ...args
);

export function inject<T>(a, b, ...args): <fim_suffix> {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",incorrect,1701
49,49,49,49,49,49,49,49,"?);

    replaced(value);

    replacedByValue<TId>(field",T,b0280f038563e54e983ad28728ead564ef36b563,"<fim_prefix>/*
 * Notifo.io
 *
 * @license
 * Copyright (c) Sebastian Stehle. All rights reserved.
 */

/* eslint-disable */

interface ReadonlyArray<T> {
    replacedBy(field, value);

    removedBy(field, value);

    removed(value?);

    sorted();

    sortedByString(selector);

    toMap(selector);
}

interface Array<T> {
    replacedBy(field, value);

    replaceBy(field, value);

    removedBy(field, value);

    removeBy(field, value);

    removeByValue<TId>(field, oldId);

    removed(value);

    remove(value: <fim_suffix>);

    sorted();

    sortedByString(selector);

    sortByString(selector);

    set<TId>(field, value);

    setOrPush<TId>(field, value);

    setOrUnshift<TId>(field, value);

    toMap(selector);
}

Array.prototype.replaceBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            self[i] = value;
            break;
        }
    }

    return self;
};

Array.prototype.replacedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            copy[i] = value;
            break;
        }
    }

    return copy;
};

Array.prototype.removeBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    self.splice(self.findIndex(x => x[field] === value[field]), 1);

    return self;
};

Array.prototype.removeByValue = function<T, TId>(field, oldId) {
    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === oldId) {
            this.splice(i, 1);
            return true;
        }
    }

    return false;
};

Array.prototype.removed = function<T>(value?) {
    const self: ReadonlyArray<T> = this;

    if (!value) {
        return this;
    }

    return self.filter((v) => v !== value);
};

Array.prototype.remove = function<T>(value?) {
    const self: T[] = this;

    if (!value) {
        return this;
    }

    const index = self.indexOf(value);

    self.splice(index, 1);

    return self;
};

Array.prototype.removedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    return self.filter((v) => v[field] !== value[field]);
};

Array.prototype.sorted = function() {
    const self: any[] = this;

    const copy: any[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort();

    return copy;
};

Array.prototype.sortedByString = function<T>(selector) {
    const self: ReadonlyArray<any> = this;

    if (!selector) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return copy;
};

Array.prototype.sortByString = function<T>(selector) {
    const self: any[] = this;

    if (!selector) {
        return self;
    }

    self.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return self;
};

Array.prototype.toMap = function<T>(selector) {
    const result: { [key: string]: T } = {};

    for (const item of this) {
        result[selector(item)] = item;
    }

    return result;
};

Array.prototype.set = function<T, TId>(field, newValue) {
    if (!newValue) {
        return false;
    }

    const newId = field(newValue);

    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === newId) {
            this[i] = newValue;
            return true;
        }
    }

    return false;
};

Array.prototype.setOrPush = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.push(newValue);
    }
};

Array.prototype.setOrUnshift = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.unshift(newValue);
    }
};<fim_middle>",incorrect,2723
50,50,50,50,50,50,50,50,"any);

    replaceBy(field, value: any",T,b0280f038563e54e983ad28728ead564ef36b563,"<fim_prefix>/*
 * Notifo.io
 *
 * @license
 * Copyright (c) Sebastian Stehle. All rights reserved.
 */

/* eslint-disable */

interface ReadonlyArray<T> {
    replacedBy(field, value);

    removedBy(field, value);

    removed(value?);

    sorted();

    sortedByString(selector);

    toMap(selector);
}

interface Array<T> {
    replacedBy(field, value);

    replaceBy(field, value);

    removedBy(field, value: <fim_suffix>);

    removeBy(field, value);

    removeByValue<TId>(field, oldId);

    removed(value);

    remove(value);

    sorted();

    sortedByString(selector);

    sortByString(selector);

    set<TId>(field, value);

    setOrPush<TId>(field, value);

    setOrUnshift<TId>(field, value);

    toMap(selector);
}

Array.prototype.replaceBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            self[i] = value;
            break;
        }
    }

    return self;
};

Array.prototype.replacedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            copy[i] = value;
            break;
        }
    }

    return copy;
};

Array.prototype.removeBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    self.splice(self.findIndex(x => x[field] === value[field]), 1);

    return self;
};

Array.prototype.removeByValue = function<T, TId>(field, oldId) {
    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === oldId) {
            this.splice(i, 1);
            return true;
        }
    }

    return false;
};

Array.prototype.removed = function<T>(value?) {
    const self: ReadonlyArray<T> = this;

    if (!value) {
        return this;
    }

    return self.filter((v) => v !== value);
};

Array.prototype.remove = function<T>(value?) {
    const self: T[] = this;

    if (!value) {
        return this;
    }

    const index = self.indexOf(value);

    self.splice(index, 1);

    return self;
};

Array.prototype.removedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    return self.filter((v) => v[field] !== value[field]);
};

Array.prototype.sorted = function() {
    const self: any[] = this;

    const copy: any[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort();

    return copy;
};

Array.prototype.sortedByString = function<T>(selector) {
    const self: ReadonlyArray<any> = this;

    if (!selector) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return copy;
};

Array.prototype.sortByString = function<T>(selector) {
    const self: any[] = this;

    if (!selector) {
        return self;
    }

    self.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return self;
};

Array.prototype.toMap = function<T>(selector) {
    const result: { [key: string]: T } = {};

    for (const item of this) {
        result[selector(item)] = item;
    }

    return result;
};

Array.prototype.set = function<T, TId>(field, newValue) {
    if (!newValue) {
        return false;
    }

    const newId = field(newValue);

    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === newId) {
            this[i] = newValue;
            return true;
        }
    }

    return false;
};

Array.prototype.setOrPush = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.push(newValue);
    }
};

Array.prototype.setOrUnshift = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.unshift(newValue);
    }
};<fim_middle>",incorrect,2733
51,51,51,51,51,51,51,51,"b) => number;

export type RankingFunction<T> =",T,595681bb13aee410a4c20056b48f731d78418652,"<fim_prefix>type Comparator<T> = (a:: <fim_suffix> b) => number;

export const RankingFunctionComparator =
    <T>(rank) =>
    (a, b) =>
        rank(b) - rank(a);

export const NumericComparator = RankingFunctionComparator<number>((x) => x);

/**
 * Min heap implementation.
 * Comparator function is expected to return a positive number, zero or a negative number if a > b, a === b or a < b.
 */
const MinHeap = <T>(comparator) => {
    // heap-ordered complete binary tree in heap[1..n] with heap[0] unused
    const heap: T[] = [];
    const compare = comparator;
    let n = 0;

    // comparator function
    const greater = (i, j) => compare(heap[i], heap[j]) < 0;

    // swap two elements
    const swap = (i, j) => {
        const temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    };

    // bubble k-th element up
    const swim = (k) => {
        let k2 = k >> 1;
        while (k > 1 && greater(k2, k)) {
            swap(k2, k);
            k = k2;
            k2 = k >> 1;
        }
    };

    // bubble k-th element down
    const sink = (k) => {
        let j = k << 1;
        while (j <= n) {
            if (j < n && greater(j, j + 1)) j++;
            if (!greater(k, j)) break;
            swap(k, j);
            k = j;
            j = k << 1;
        }
    };

    return {
        /** add element to the heap */
        push: (element) => {
            n += 1;
            heap[n] = element;
            swim(n);
        },

        /** remove the first element from the heap */
        pop: () => {
            if (n === 0) return undefined;
            swap(1, n);
            n -= 1;
            const max = heap.pop();
            sink(1);
            return max;
        },

        /** heap size */
        size: () => n,
    };
};

export default MinHeap;
<fim_middle>",incorrect,2801
52,52,52,52,52,52,52,52,"string) => void
  onInvalidMessage?: (message: string",T,8dd4eba467cc4f8c283713bdfc23d3b71e87f31d,"<fim_prefix>export type BasePostMessageCallbackProps<T> = {
  onMessage?: (message) => void
  onInvalidMessageError?: (message: <fim_suffix>, error) => void
}

// This is an internal error. Thrown when we are decoding a post message's
// metadata and we encourntered a missing field or an invalid value. This
// likely means there has been a change to the definition of a post message
// that we do not know about.
export class PostMessageFieldDecodeError extends Error {
  public messageType: string
  public field: string
  public expectedType: TypeDef
  public gotValue: unknown

  constructor(messageType, field, expectedType, gotValue) {
    super(`Unable to decode '${field}' from '${messageType}'`)

    this.messageType = messageType
    this.field = field
    this.expectedType = expectedType
    this.gotValue = gotValue

    Object.setPrototypeOf(this, PostMessageFieldDecodeError.prototype)
  }
}

// This is an internal error. Thrown when we get a post message we don't konw
// about. This likely means there is a new post message that this package needs
// to define.
export class PostMessageUnknownTypeError extends Error {
  public postMessageType: string

  constructor(postMessageType) {
    super(`Unknown post message: ${postMessageType}`)

    this.postMessageType = postMessageType

    Object.setPrototypeOf(this, PostMessageUnknownTypeError.prototype)
  }
}

export type MessageEventData = {
  mx?: boolean
  metadata?: Metadata
  type?: string
}

export type Value = string | number
export type NestedValue = Record<string, Value>
export type TypeDef = string | Array<string> | Record<string, string>
export type Metadata = Record<string, Value | NestedValue>

export function assertMessageProp(
  container,
  postMessageType,
  field,
  expectedType,
) {
  const value = container[field]

  const valueIsDefined = typeof value !== ""undefined""
  const valueIsString = typeof value === ""string""
  const valueIsNumber = typeof value === ""number""
  const valueIsObject = typeof value === ""object"" && !Array.isArray(value)

  const typeIsString = expectedType === ""string""
  const typeIsNumber = expectedType === ""number""
  const typeIsArray = expectedType instanceof Array
  const typeIsObject = typeof expectedType === ""object"" && !Array.isArray(expectedType)

  if (!valueIsDefined) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsString && !valueIsString) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsNumber && !valueIsNumber) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsArray && !(valueIsString && expectedType.includes(value))) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && !valueIsObject) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && valueIsObject) {
    Object.keys(expectedType).forEach((field) => {
      assertMessageProp(value, postMessageType, field, expectedType[field])
    })
  }
}
<fim_middle>",incorrect,2995
53,53,53,53,53,53,53,53,type,TKey,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type: <fim_suffix>, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",incorrect,1718
54,54,54,54,54,54,54,54,type,TKey,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type: <fim_suffix>, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",incorrect,1721
55,55,55,55,55,55,55,55,number,Token,4e0101374b9ed16a03bd794fbb67ac927c7f589a,"<fim_prefix>function buildParenthesizedExpression(token) {
    if (!Array.isArray(token)) {
        throw Error(""accident token type"");
    }
    const inner_expression = buildExpression(token);
    if (!inner_expression) {
        throw Error(""empty expression"");
    }
    const current_expression: Expression = {
        type: ""ParenthesizedExpression"",
        expression: inner_expression,
    };
    return current_expression;
}
function buildNumericLiteralExpression(token: <fim_suffix>) {
    if (typeof token !== ""number"") {
        throw Error(""accident token type"");
    }
    const current_expression: Expression = {
        type: ""NumericLiteral"",
        value: token,
    };
    return current_expression;
}
export default function calculate(s) {
    const tokens = tokenize(s);

    const ast = buildExpression(tokens);

    return evaluate(ast);
}
export function evaluate(ast) {
    if (ast.type === ""NumericLiteral"") {
        return ast.value;
    }
    if (ast.type === ""UnaryExpression"") {
        if (ast.operator === ""-"") {
            return -1 * evaluate(ast.argument);
        }
    }
    if (ast.type === ""BinaryExpression"") {
        if (ast.operator === ""-"") {
            return evaluate(ast.left) - evaluate(ast.right);
        }
        if (ast.operator === ""*"") {
            return evaluate(ast.left) * evaluate(ast.right);
        }
        if (ast.operator === ""+"") {
            return evaluate(ast.left) + evaluate(ast.right);
        }

        if (ast.operator === ""/"") {
            const num1 = evaluate(ast.left);
            const num2 = evaluate(ast.right);
            const sign = Math.sign(num2) * Math.sign(num1);
            return sign * Math.floor(Math.abs(num1) / Math.abs(num2));
            //整数除法
        }
    }
    if (ast.type === ""ParenthesizedExpression"") {
        return evaluate(ast.expression);
    }
    throw Error(""not support expression"");
}
type Token = Tokens extends (infer P)[] ? P : never;

type Tokens = Array<string | number | Tokens>;
function getTokenType(token) {
    const tokentype: TokenType = typeof token === ""number""
        ? TokenType[""number""]
        : typeof token === ""string""
        ? TokenType[""operator""]
        : Array.isArray(token)
        ? TokenType[""parentheses""]
        : TokenType[""unknown""];
    return tokentype;
}
export function tokenize(s) {
    const tokens: Tokens = [];
    const stack: Tokens[] = [tokens];
    for (let i = 0; i < s.length; i++) {
        const value = s[i];
        if (/\d/.test(value)) {
            //只处理整数
            const digits: string[] = [value];

            while (/\d/.test(s[i + 1])) {
                digits.push(s[i + 1]);
                i++;
            }

            const num = Number(digits.join(""""));
            stack[stack.length - 1].push(num);
        }
        if ([""+"", ""-"", ""/"", ""*""].includes(value)) {
            stack[stack.length - 1].push(value);
        }
        if (value === ""("") {
            stack.push([]);
        }
        if (value === "")"") {
            if (stack.length <= 0) throw Error(""parentheses mismatch"");
            const last = stack[stack.length - 1];
            stack.pop();
            stack[stack.length - 1].push(last);
        }
    }
    if (stack.length !== 1) throw Error(""parentheses mismatch"");
    return tokens;
}
export function buildExpression(tokens) {
    if (tokens.length === 0) {
        throw Error(""empty expression"");
    }
    let state = State.initial;
    const pendingtype: ExpressionType[] = [];
    const pendingoperator: ExpressionOperator[] = [];

    const pendingleft: Expression[] = [];
    for (const token of tokens) {
        const tokentype: TokenType = getTokenType(token);
        if (tokentype === TokenType.unknown) throw Error(""unknown token"");
        state = transform[state][tokentype] ?? State.unknown;
        if (state === State.unknown) throw Error(""unknown state"");
        if (state === State.unary) {
            pendingtype.push(""UnaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
        if ([State.parentheses, State.number].includes(state)) {
            const current_expression: Expression = State.number === state
                ? buildNumericLiteralExpression(token)
                : buildParenthesizedExpression(token);
            if (pendingtype.length === 0 && pendingoperator.length === 0) {
                pendingleft.push(current_expression);
            } else {
                const type = pendingtype[pendingtype.length - 1];
                pendingtype.pop();
                const operator = pendingoperator[pendingoperator.length - 1];
                pendingoperator.pop();
                if (type === ""BinaryExpression"") {
                    //优先级更高

                    const left = pendingleft[pendingleft.length - 1];

                    if (
                        left.type === ""BinaryExpression"" &&
                        [""*"", ""/""].includes(operator) &&
                        [""+"", ""-""].includes(left.operator)
                    ) {
                        left.right = {
                            type: ""BinaryExpression"",
                            operator: operator as BinaryExpression[""operator""],
                            left: left.right,
                            right: current_expression,
                        };
                    } else {
                        pendingleft.pop();
                        pendingleft.push({
                            operator: operator as BinaryExpression[""operator""],
                            type: ""BinaryExpression"",
                            left,
                            right: current_expression,
                        });
                    }
                }
                if (type === ""UnaryExpression"") {
                    pendingleft.push({
                        operator: operator as UnaryExpression[""operator""],
                        type: ""UnaryExpression"",
                        argument: current_expression,
                    });
                }
            }
        }

        if (state === State.binary) {
            pendingtype.push(""BinaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
    }
    if (valid_end_states.includes(state) && pendingleft.length) {
        return pendingleft[0];
    } else {
        throw new Error(""unexpected end state or empty expression"");
    }
}
const enum State {
    ""initial"",
    ""unary"",
    ""parentheses"",
    ""number"",
    ""binary"",
    ""unknown"",
}
const valid_end_states = [State[""parentheses""], State[""number""]];
const enum TokenType {
    ""number"",
    ""operator"",
    ""parentheses"",
    ""unknown"",
}
const transform: Record<State, Record<TokenType, State>> = {
    [State.initial]: {
        [TokenType.operator]: State.unary,
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.unary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.binary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.parentheses]: {
        [TokenType.operator]: State.binary,
    },
    [State.number]: {
        [TokenType.operator]: State.binary,
    },
} as Record<State, Record<TokenType, State>>;
type ExpressionType = Expression[""type""];

type ExpressionOperator =
    | UnaryExpression[""operator""]
    | BinaryExpression[""operator""];
type Expression =
    | BinaryExpression
    | NumericLiteral
    | UnaryExpression
    | ParenthesizedExpression;
interface ParenthesizedExpression {
    type: ""ParenthesizedExpression"";
    expression: Expression;
}
interface NumericLiteral {
    type: ""NumericLiteral"";
    value: number;
}
interface UnaryExpression {
    type: ""UnaryExpression"";
    operator: ""void"" | ""throw"" | ""delete"" | ""!"" | ""+"" | ""-"" | ""~"" | ""typeof"";
    argument: Expression;
}
interface BinaryExpression {
    type: ""BinaryExpression"";
    operator:
        | ""+""
        | ""-""
        | ""/""
        | ""%""
        | ""*""
        | ""**""
        | ""&""
        | ""|""
        | "">>""
        | "">>>""
        | ""<<""
        | ""^""
        | ""==""
        | ""===""
        | ""!=""
        | ""!==""
        | ""in""
        | ""instanceof""
        | "">""
        | ""<""
        | "">=""
        | ""<=""
        | ""|>"";
    left: Expression;
    right: Expression;
}
<fim_middle>",incorrect,3751
56,56,56,56,56,56,56,56,"string) {
    if (token === ""("") {
        return {
            type",Token,4e0101374b9ed16a03bd794fbb67ac927c7f589a,"<fim_prefix>function buildParenthesizedExpression(token:: <fim_suffix> {
    if (!Array.isArray(token)) {
        throw Error(""accident token type"");
    }
    const inner_expression = buildExpression(token);
    if (!inner_expression) {
        throw Error(""empty expression"");
    }
    const current_expression: Expression = {
        type: ""ParenthesizedExpression"",
        expression: inner_expression,
    };
    return current_expression;
}
function buildNumericLiteralExpression(token) {
    if (typeof token !== ""number"") {
        throw Error(""accident token type"");
    }
    const current_expression: Expression = {
        type: ""NumericLiteral"",
        value: token,
    };
    return current_expression;
}
export default function calculate(s) {
    const tokens = tokenize(s);

    const ast = buildExpression(tokens);

    return evaluate(ast);
}
export function evaluate(ast) {
    if (ast.type === ""NumericLiteral"") {
        return ast.value;
    }
    if (ast.type === ""UnaryExpression"") {
        if (ast.operator === ""-"") {
            return -1 * evaluate(ast.argument);
        }
    }
    if (ast.type === ""BinaryExpression"") {
        if (ast.operator === ""-"") {
            return evaluate(ast.left) - evaluate(ast.right);
        }
        if (ast.operator === ""*"") {
            return evaluate(ast.left) * evaluate(ast.right);
        }
        if (ast.operator === ""+"") {
            return evaluate(ast.left) + evaluate(ast.right);
        }

        if (ast.operator === ""/"") {
            const num1 = evaluate(ast.left);
            const num2 = evaluate(ast.right);
            const sign = Math.sign(num2) * Math.sign(num1);
            return sign * Math.floor(Math.abs(num1) / Math.abs(num2));
            //整数除法
        }
    }
    if (ast.type === ""ParenthesizedExpression"") {
        return evaluate(ast.expression);
    }
    throw Error(""not support expression"");
}
type Token = Tokens extends (infer P)[] ? P : never;

type Tokens = Array<string | number | Tokens>;
function getTokenType(token) {
    const tokentype: TokenType = typeof token === ""number""
        ? TokenType[""number""]
        : typeof token === ""string""
        ? TokenType[""operator""]
        : Array.isArray(token)
        ? TokenType[""parentheses""]
        : TokenType[""unknown""];
    return tokentype;
}
export function tokenize(s) {
    const tokens: Tokens = [];
    const stack: Tokens[] = [tokens];
    for (let i = 0; i < s.length; i++) {
        const value = s[i];
        if (/\d/.test(value)) {
            //只处理整数
            const digits: string[] = [value];

            while (/\d/.test(s[i + 1])) {
                digits.push(s[i + 1]);
                i++;
            }

            const num = Number(digits.join(""""));
            stack[stack.length - 1].push(num);
        }
        if ([""+"", ""-"", ""/"", ""*""].includes(value)) {
            stack[stack.length - 1].push(value);
        }
        if (value === ""("") {
            stack.push([]);
        }
        if (value === "")"") {
            if (stack.length <= 0) throw Error(""parentheses mismatch"");
            const last = stack[stack.length - 1];
            stack.pop();
            stack[stack.length - 1].push(last);
        }
    }
    if (stack.length !== 1) throw Error(""parentheses mismatch"");
    return tokens;
}
export function buildExpression(tokens) {
    if (tokens.length === 0) {
        throw Error(""empty expression"");
    }
    let state = State.initial;
    const pendingtype: ExpressionType[] = [];
    const pendingoperator: ExpressionOperator[] = [];

    const pendingleft: Expression[] = [];
    for (const token of tokens) {
        const tokentype: TokenType = getTokenType(token);
        if (tokentype === TokenType.unknown) throw Error(""unknown token"");
        state = transform[state][tokentype] ?? State.unknown;
        if (state === State.unknown) throw Error(""unknown state"");
        if (state === State.unary) {
            pendingtype.push(""UnaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
        if ([State.parentheses, State.number].includes(state)) {
            const current_expression: Expression = State.number === state
                ? buildNumericLiteralExpression(token)
                : buildParenthesizedExpression(token);
            if (pendingtype.length === 0 && pendingoperator.length === 0) {
                pendingleft.push(current_expression);
            } else {
                const type = pendingtype[pendingtype.length - 1];
                pendingtype.pop();
                const operator = pendingoperator[pendingoperator.length - 1];
                pendingoperator.pop();
                if (type === ""BinaryExpression"") {
                    //优先级更高

                    const left = pendingleft[pendingleft.length - 1];

                    if (
                        left.type === ""BinaryExpression"" &&
                        [""*"", ""/""].includes(operator) &&
                        [""+"", ""-""].includes(left.operator)
                    ) {
                        left.right = {
                            type: ""BinaryExpression"",
                            operator: operator as BinaryExpression[""operator""],
                            left: left.right,
                            right: current_expression,
                        };
                    } else {
                        pendingleft.pop();
                        pendingleft.push({
                            operator: operator as BinaryExpression[""operator""],
                            type: ""BinaryExpression"",
                            left,
                            right: current_expression,
                        });
                    }
                }
                if (type === ""UnaryExpression"") {
                    pendingleft.push({
                        operator: operator as UnaryExpression[""operator""],
                        type: ""UnaryExpression"",
                        argument: current_expression,
                    });
                }
            }
        }

        if (state === State.binary) {
            pendingtype.push(""BinaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
    }
    if (valid_end_states.includes(state) && pendingleft.length) {
        return pendingleft[0];
    } else {
        throw new Error(""unexpected end state or empty expression"");
    }
}
const enum State {
    ""initial"",
    ""unary"",
    ""parentheses"",
    ""number"",
    ""binary"",
    ""unknown"",
}
const valid_end_states = [State[""parentheses""], State[""number""]];
const enum TokenType {
    ""number"",
    ""operator"",
    ""parentheses"",
    ""unknown"",
}
const transform: Record<State, Record<TokenType, State>> = {
    [State.initial]: {
        [TokenType.operator]: State.unary,
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.unary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.binary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.parentheses]: {
        [TokenType.operator]: State.binary,
    },
    [State.number]: {
        [TokenType.operator]: State.binary,
    },
} as Record<State, Record<TokenType, State>>;
type ExpressionType = Expression[""type""];

type ExpressionOperator =
    | UnaryExpression[""operator""]
    | BinaryExpression[""operator""];
type Expression =
    | BinaryExpression
    | NumericLiteral
    | UnaryExpression
    | ParenthesizedExpression;
interface ParenthesizedExpression {
    type: ""ParenthesizedExpression"";
    expression: Expression;
}
interface NumericLiteral {
    type: ""NumericLiteral"";
    value: number;
}
interface UnaryExpression {
    type: ""UnaryExpression"";
    operator: ""void"" | ""throw"" | ""delete"" | ""!"" | ""+"" | ""-"" | ""~"" | ""typeof"";
    argument: Expression;
}
interface BinaryExpression {
    type: ""BinaryExpression"";
    operator:
        | ""+""
        | ""-""
        | ""/""
        | ""%""
        | ""*""
        | ""**""
        | ""&""
        | ""|""
        | "">>""
        | "">>>""
        | ""<<""
        | ""^""
        | ""==""
        | ""===""
        | ""!=""
        | ""!==""
        | ""in""
        | ""instanceof""
        | "">""
        | ""<""
        | "">=""
        | ""<=""
        | ""|>"";
    left: Expression;
    right: Expression;
}
<fim_middle>",incorrect,3752
57,57,57,57,57,57,57,57,"'millisecond',
  maxUnit: 'year'
) => ({",Units,5f5d91c414bbb516a535e1d2016984f7aa4955b0,"<fim_prefix>export type Units =
  | 'millisecond'
  | 'second'
  | 'minute'
  | 'hour'
  | 'day'
  | 'month'
  | 'year';

export type InputDate = string;
export type ParsedDate = Date;

type InputDuration = {
  [U in Units]?: number;
};

interface Step {
  date: ParsedDate;
  unit: Units;
  scale: number;
}

interface ZoomLevel {
  unit: Units;
  duration: number;
  isMajorLevel: (mainLevel) => boolean;
  getSteps: (startDate, endDate) => Step[];
}

const SECOND_IN_MILLISECONDS = 1000;
const MINUTE_IN_MILLISECONDS = 60 * SECOND_IN_MILLISECONDS;
const HOUR_IN_MILLISECONDS = 60 * MINUTE_IN_MILLISECONDS;
const DAY_IN_MILLISECONDS = 24 * HOUR_IN_MILLISECONDS;
const MONTH_IN_MILLISECONDS = 30 * DAY_IN_MILLISECONDS;
const YEAR_IN_MILLISECONDS = 12 * MONTH_IN_MILLISECONDS;

const units = [
  'millisecond',
  'second',
  'minute',
  'hour',
  'day',
  'month',
  'year',
];

function parse(minUnit) {
  return date => startOf(new Date(date), minUnit);
}

function unparse(date) {
  return date.toISOString();
}

function parseDuration(duration) {
  let milliseconds = 0;

  milliseconds += duration.millisecond ? duration.millisecond : 0;
  milliseconds += duration.second
    ? duration.second * SECOND_IN_MILLISECONDS
    : 0;
  milliseconds += duration.minute
    ? duration.minute * MINUTE_IN_MILLISECONDS
    : 0;
  milliseconds += duration.hour ? duration.hour * HOUR_IN_MILLISECONDS : 0;
  milliseconds += duration.day ? duration.day * DAY_IN_MILLISECONDS : 0;
  milliseconds += duration.month ? duration.month * MONTH_IN_MILLISECONDS : 0;
  milliseconds += duration.year ? duration.year * YEAR_IN_MILLISECONDS : 0;

  return milliseconds;
}

function getMinimumDuration(minUnit) {
  return () => {
    switch (minUnit) {
      case 'second':
        return SECOND_IN_MILLISECONDS;
      case 'minute':
        return MINUTE_IN_MILLISECONDS;
      case 'hour':
        return HOUR_IN_MILLISECONDS;
      case 'day':
        return DAY_IN_MILLISECONDS;
      case 'month':
        return MONTH_IN_MILLISECONDS;
      case 'year':
        return YEAR_IN_MILLISECONDS;
      default:
        return 1;
    }
  };
}

function isBefore(dateA, dateB) {
  return dateA.getTime() < dateB.getTime();
}

function diff(dateA, dateB) {
  return dateA.getTime() - dateB.getTime();
}

function add(
  date,
  amount,
  unit = 'millisecond'
) {
  let newDate = new Date(date.getTime());

  switch (unit) {
    case 'millisecond':
      return new Date(date.getTime() + amount);
    case 'second':
      return add(date, amount * SECOND_IN_MILLISECONDS, 'millisecond');
    case 'minute':
      return add(date, amount * MINUTE_IN_MILLISECONDS, 'millisecond');
    case 'hour':
      return add(date, amount * HOUR_IN_MILLISECONDS, 'millisecond');
    case 'day':
      newDate.setDate(date.getDate() + amount);
      return newDate;
    case 'month':
      const desiredMonth = date.getMonth() + amount;
      const lastDayOfMonth = new Date(date.getFullYear(), desiredMonth + 1, 0);

      newDate.setMonth(
        desiredMonth,
        Math.min(lastDayOfMonth.getDate(), date.getDate())
      );
      return newDate;
    case 'year':
      return add(date, amount * 12, 'month');
    default:
      return date;
  }
}

function subtract(
  date,
  amount,
  unit = 'millisecond'
) {
  return add(date, -amount, unit);
}

function startOf(date, unit) {
  let newDate = new Date(date.getTime());

  switch (unit) {
    case 'second':
      newDate.setMilliseconds(0);
      return newDate;
    case 'minute':
      newDate.setSeconds(0, 0);
      return newDate;
    case 'hour':
      newDate.setMinutes(0, 0, 0);
      return newDate;
    case 'day':
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    case 'month':
      newDate.setDate(1);
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    case 'year':
      newDate.setFullYear(date.getFullYear(), 0, 1);
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    default:
      return newDate;
  }
}

function get(date, unit) {
  switch (unit) {
    case 'millisecond':
      return date.getMilliseconds();
    case 'second':
      return date.getSeconds();
    case 'minute':
      return date.getMinutes();
    case 'hour':
      return date.getHours();
    case 'day':
      return date.getDate();
    case 'month':
      return date.getMonth();
    case 'year':
      return date.getFullYear();
  }
}

function format(locale, minUnit, maxUnit) {
  function internFormat(
    date,
    unit?,
    onlyUnit = false
  ) {
    const monthLabels: { [locale: string]: string[] } = {
      en: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec',
      ],
      fr: [
        'janv.',
        'févr.',
        'mars',
        'avr.',
        'mai',
        'juin',
        'juil.',
        'août',
        'sept.',
        'oct.',
        'nov.',
        'déc.',
      ],
    };

    const padded = (u) => (u < 10 ? `0${u}` : `${u}`);
    const paddedMs = (u) =>
      u < 10 ? `00${u}` : u < 100 ? `0${u}` : `${u}`;

    switch (unit) {
      case 'millisecond':
        return onlyUnit
          ? `${date.getMilliseconds()}ms`
          : `${internFormat(date, 'second')}.${paddedMs(
              date.getMilliseconds()
            )}`;
      case 'second':
        return onlyUnit
          ? `${padded(date.getSeconds())}s`
          : `${internFormat(date, 'minute')}:${padded(date.getSeconds())}`;
      case 'minute':
        return `${padded(date.getHours())}:${padded(date.getMinutes())}`;
      case 'hour':
        return onlyUnit
          ? `${padded(date.getHours())}:00`
          : `${padded(date.getHours())}h`;
      case 'day':
        return onlyUnit
          ? `${padded(date.getDate())}`
          : `${padded(date.getDate())} ${internFormat(date, 'month')}`;
      case 'month':
        const formattedMonth = monthLabels[locale][date.getMonth()];
        return onlyUnit
          ? `${formattedMonth}`
          : `${formattedMonth} ${internFormat(date, 'year')}`;
      case 'year':
        return `${date.getFullYear()}`;
      default:
        const part1 =
          units.indexOf(minUnit) > units.indexOf('day')
            ? `${internFormat(date, minUnit)}`
            : `${internFormat(date, 'day')}`;
        const part2 =
          units.indexOf(minUnit) < units.indexOf('day')
            ? ` - ${internFormat(date, minUnit)}`
            : '';

        return `${part1}${part2}`;
    }
  }

  return internFormat;
}

function getSteps(unit, n) {
  return (startDate, endDate) => {
    const list = [];

    let offsetUnits = get(startDate, unit);

    if (unit === 'day') {
      const correctedStartDate = subtract(
        startDate,
        n > 1 && get(startDate, unit) >= 30 ? n : 0,
        unit
      ); // Fix to hide days 30 and 31
      const moduloDay = get(correctedStartDate, unit) < n ? 1 : 0; // Fix to round to 1st day of month
      offsetUnits = get(correctedStartDate, unit) - moduloDay;
    }

    let date = subtract(startOf(startDate, unit), offsetUnits % n, unit);
    let stop = false;

    while (!stop) {
      if (!isBefore(date, endDate)) {
        stop = true; // We need to go an extra step after the end date to compute the last step size
      }

      list.push({ date, unit, scale: n });

      let durationToAdd = n;
      const previousMonth = unit === 'day' ? get(date, 'month') : null;

      if (unit === 'day' && n > 1 && get(date, unit) === 1) {
        durationToAdd = n - 1; // Fix due to the round of 1st day of month
      }

      date = add(date, durationToAdd, unit);

      if (unit === 'day') {
        date = add(date, n > 1 && get(date, unit) >= 30 ? 1 : 0, 'month'); // Fix to hide days 30 and 31

        if (get(date, 'month') !== previousMonth) {
          date = startOf(date, 'month');
        }
      }
    }

    return list;
  };
}

function isImportantStep(step) {
  if (step.unit === 'year') {
    return get(step.date, 'year') % (10 * step.scale) === 0;
  }

  return false;
}

function getZoomLevels(minUnit, maxUnit) {
  const zoomLevels: ZoomLevel[] = [];

  if (
    units.indexOf(minUnit) <= units.indexOf('millisecond') &&
    units.indexOf(maxUnit) >= units.indexOf('millisecond')
  ) {
    zoomLevels.push(
      {
        unit: 'millisecond',
        duration: 1,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 1),
      },
      {
        unit: 'millisecond',
        duration: 100,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 100),
      },
      {
        unit: 'millisecond',
        duration: 500,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 500),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('second') &&
    units.indexOf(maxUnit) >= units.indexOf('second')
  ) {
    zoomLevels.push(
      {
        unit: 'second',
        duration: 1 * SECOND_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'millisecond',
        getSteps: getSteps('second', 1),
      },
      {
        unit: 'second',
        duration: 5 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 5),
      },
      {
        unit: 'second',
        duration: 10 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 10),
      },
      {
        unit: 'second',
        duration: 30 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 30),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('minute') &&
    units.indexOf(maxUnit) >= units.indexOf('minute')
  ) {
    zoomLevels.push(
      {
        unit: 'minute',
        duration: 1 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'second',
        getSteps: getSteps('minute', 1),
      },
      {
        unit: 'minute',
        duration: 5 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 5),
      },
      {
        unit: 'minute',
        duration: 10 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 10),
      },
      {
        unit: 'minute',
        duration: 30 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 30),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('hour') &&
    units.indexOf(maxUnit) >= units.indexOf('hour')
  ) {
    zoomLevels.push(
      {
        unit: 'hour',
        duration: 1 * HOUR_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'minute',
        getSteps: getSteps('hour', 1),
      },
      {
        unit: 'hour',
        duration: 3 * HOUR_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('hour', 3),
      },
      {
        unit: 'hour',
        duration: 6 * HOUR_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('hour', 6),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('day') &&
    units.indexOf(maxUnit) >= units.indexOf('day')
  ) {
    zoomLevels.push(
      {
        unit: 'day',
        duration: 1 * DAY_IN_MILLISECONDS,
        isMajorLevel: mainLevel =>
          ['hour', 'minute', 'second', 'millisecond'].includes(mainLevel.unit),
        getSteps: getSteps('day', 1),
      },
      {
        unit: 'day',
        duration: 5 * DAY_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('day', 5),
      },
      {
        unit: 'day',
        duration: 10 * DAY_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('day', 10),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('month') &&
    units.indexOf(maxUnit) >= units.indexOf('month')
  ) {
    for (const i of [1, 2, 4, 6]) {
      zoomLevels.push({
        unit: 'month',
        duration: i * MONTH_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'day' && i === 1,
        getSteps: getSteps('month', i),
      });
    }
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('year') &&
    units.indexOf(maxUnit) >= units.indexOf('year')
  ) {
    for (const i of [1, 10, 100, 1000]) {
      zoomLevels.push(
        {
          unit: 'year',
          duration: i * YEAR_IN_MILLISECONDS,
          isMajorLevel: mainLevel => mainLevel.unit === 'month' && i === 1,
          getSteps: getSteps('year', i),
        },
        {
          unit: 'year',
          duration: 2 * i * YEAR_IN_MILLISECONDS,
          isMajorLevel: () => false,
          getSteps: getSteps('year', 2 * i),
        },
        {
          unit: 'year',
          duration: 5 * i * YEAR_IN_MILLISECONDS,
          isMajorLevel: () => false,
          getSteps: getSteps('year', 5 * i),
        }
      );
    }
  }

  return zoomLevels;
}

export default (
  locale = 'en',
  minUnit: <fim_suffix> = 'millisecond',
  maxUnit = 'year'
) => ({
  parse: parse(minUnit),
  unparse,
  parseDuration,
  getMinimumDuration: getMinimumDuration(minUnit),
  isBefore,
  diff,
  add,
  subtract,
  format: format(locale, minUnit, maxUnit),
  isImportantStep,
  zoomLevels: getZoomLevels(minUnit, maxUnit),
});
<fim_middle>",incorrect,4944
58,58,58,58,58,58,58,58,"'millisecond'
) {
  let newDate = new Date(date",Units,5f5d91c414bbb516a535e1d2016984f7aa4955b0,"<fim_prefix>export type Units =
  | 'millisecond'
  | 'second'
  | 'minute'
  | 'hour'
  | 'day'
  | 'month'
  | 'year';

export type InputDate = string;
export type ParsedDate = Date;

type InputDuration = {
  [U in Units]?: number;
};

interface Step {
  date: ParsedDate;
  unit: Units;
  scale: number;
}

interface ZoomLevel {
  unit: Units;
  duration: number;
  isMajorLevel: (mainLevel) => boolean;
  getSteps: (startDate, endDate) => Step[];
}

const SECOND_IN_MILLISECONDS = 1000;
const MINUTE_IN_MILLISECONDS = 60 * SECOND_IN_MILLISECONDS;
const HOUR_IN_MILLISECONDS = 60 * MINUTE_IN_MILLISECONDS;
const DAY_IN_MILLISECONDS = 24 * HOUR_IN_MILLISECONDS;
const MONTH_IN_MILLISECONDS = 30 * DAY_IN_MILLISECONDS;
const YEAR_IN_MILLISECONDS = 12 * MONTH_IN_MILLISECONDS;

const units = [
  'millisecond',
  'second',
  'minute',
  'hour',
  'day',
  'month',
  'year',
];

function parse(minUnit) {
  return date => startOf(new Date(date), minUnit);
}

function unparse(date) {
  return date.toISOString();
}

function parseDuration(duration) {
  let milliseconds = 0;

  milliseconds += duration.millisecond ? duration.millisecond : 0;
  milliseconds += duration.second
    ? duration.second * SECOND_IN_MILLISECONDS
    : 0;
  milliseconds += duration.minute
    ? duration.minute * MINUTE_IN_MILLISECONDS
    : 0;
  milliseconds += duration.hour ? duration.hour * HOUR_IN_MILLISECONDS : 0;
  milliseconds += duration.day ? duration.day * DAY_IN_MILLISECONDS : 0;
  milliseconds += duration.month ? duration.month * MONTH_IN_MILLISECONDS : 0;
  milliseconds += duration.year ? duration.year * YEAR_IN_MILLISECONDS : 0;

  return milliseconds;
}

function getMinimumDuration(minUnit) {
  return () => {
    switch (minUnit) {
      case 'second':
        return SECOND_IN_MILLISECONDS;
      case 'minute':
        return MINUTE_IN_MILLISECONDS;
      case 'hour':
        return HOUR_IN_MILLISECONDS;
      case 'day':
        return DAY_IN_MILLISECONDS;
      case 'month':
        return MONTH_IN_MILLISECONDS;
      case 'year':
        return YEAR_IN_MILLISECONDS;
      default:
        return 1;
    }
  };
}

function isBefore(dateA, dateB) {
  return dateA.getTime() < dateB.getTime();
}

function diff(dateA, dateB) {
  return dateA.getTime() - dateB.getTime();
}

function add(
  date,
  amount,
  unit = 'millisecond'
) {
  let newDate = new Date(date.getTime());

  switch (unit) {
    case 'millisecond':
      return new Date(date.getTime() + amount);
    case 'second':
      return add(date, amount * SECOND_IN_MILLISECONDS, 'millisecond');
    case 'minute':
      return add(date, amount * MINUTE_IN_MILLISECONDS, 'millisecond');
    case 'hour':
      return add(date, amount * HOUR_IN_MILLISECONDS, 'millisecond');
    case 'day':
      newDate.setDate(date.getDate() + amount);
      return newDate;
    case 'month':
      const desiredMonth = date.getMonth() + amount;
      const lastDayOfMonth = new Date(date.getFullYear(), desiredMonth + 1, 0);

      newDate.setMonth(
        desiredMonth,
        Math.min(lastDayOfMonth.getDate(), date.getDate())
      );
      return newDate;
    case 'year':
      return add(date, amount * 12, 'month');
    default:
      return date;
  }
}

function subtract(
  date,
  amount,
  unit: <fim_suffix> = 'millisecond'
) {
  return add(date, -amount, unit);
}

function startOf(date, unit) {
  let newDate = new Date(date.getTime());

  switch (unit) {
    case 'second':
      newDate.setMilliseconds(0);
      return newDate;
    case 'minute':
      newDate.setSeconds(0, 0);
      return newDate;
    case 'hour':
      newDate.setMinutes(0, 0, 0);
      return newDate;
    case 'day':
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    case 'month':
      newDate.setDate(1);
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    case 'year':
      newDate.setFullYear(date.getFullYear(), 0, 1);
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    default:
      return newDate;
  }
}

function get(date, unit) {
  switch (unit) {
    case 'millisecond':
      return date.getMilliseconds();
    case 'second':
      return date.getSeconds();
    case 'minute':
      return date.getMinutes();
    case 'hour':
      return date.getHours();
    case 'day':
      return date.getDate();
    case 'month':
      return date.getMonth();
    case 'year':
      return date.getFullYear();
  }
}

function format(locale, minUnit, maxUnit) {
  function internFormat(
    date,
    unit?,
    onlyUnit = false
  ) {
    const monthLabels: { [locale: string]: string[] } = {
      en: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec',
      ],
      fr: [
        'janv.',
        'févr.',
        'mars',
        'avr.',
        'mai',
        'juin',
        'juil.',
        'août',
        'sept.',
        'oct.',
        'nov.',
        'déc.',
      ],
    };

    const padded = (u) => (u < 10 ? `0${u}` : `${u}`);
    const paddedMs = (u) =>
      u < 10 ? `00${u}` : u < 100 ? `0${u}` : `${u}`;

    switch (unit) {
      case 'millisecond':
        return onlyUnit
          ? `${date.getMilliseconds()}ms`
          : `${internFormat(date, 'second')}.${paddedMs(
              date.getMilliseconds()
            )}`;
      case 'second':
        return onlyUnit
          ? `${padded(date.getSeconds())}s`
          : `${internFormat(date, 'minute')}:${padded(date.getSeconds())}`;
      case 'minute':
        return `${padded(date.getHours())}:${padded(date.getMinutes())}`;
      case 'hour':
        return onlyUnit
          ? `${padded(date.getHours())}:00`
          : `${padded(date.getHours())}h`;
      case 'day':
        return onlyUnit
          ? `${padded(date.getDate())}`
          : `${padded(date.getDate())} ${internFormat(date, 'month')}`;
      case 'month':
        const formattedMonth = monthLabels[locale][date.getMonth()];
        return onlyUnit
          ? `${formattedMonth}`
          : `${formattedMonth} ${internFormat(date, 'year')}`;
      case 'year':
        return `${date.getFullYear()}`;
      default:
        const part1 =
          units.indexOf(minUnit) > units.indexOf('day')
            ? `${internFormat(date, minUnit)}`
            : `${internFormat(date, 'day')}`;
        const part2 =
          units.indexOf(minUnit) < units.indexOf('day')
            ? ` - ${internFormat(date, minUnit)}`
            : '';

        return `${part1}${part2}`;
    }
  }

  return internFormat;
}

function getSteps(unit, n) {
  return (startDate, endDate) => {
    const list = [];

    let offsetUnits = get(startDate, unit);

    if (unit === 'day') {
      const correctedStartDate = subtract(
        startDate,
        n > 1 && get(startDate, unit) >= 30 ? n : 0,
        unit
      ); // Fix to hide days 30 and 31
      const moduloDay = get(correctedStartDate, unit) < n ? 1 : 0; // Fix to round to 1st day of month
      offsetUnits = get(correctedStartDate, unit) - moduloDay;
    }

    let date = subtract(startOf(startDate, unit), offsetUnits % n, unit);
    let stop = false;

    while (!stop) {
      if (!isBefore(date, endDate)) {
        stop = true; // We need to go an extra step after the end date to compute the last step size
      }

      list.push({ date, unit, scale: n });

      let durationToAdd = n;
      const previousMonth = unit === 'day' ? get(date, 'month') : null;

      if (unit === 'day' && n > 1 && get(date, unit) === 1) {
        durationToAdd = n - 1; // Fix due to the round of 1st day of month
      }

      date = add(date, durationToAdd, unit);

      if (unit === 'day') {
        date = add(date, n > 1 && get(date, unit) >= 30 ? 1 : 0, 'month'); // Fix to hide days 30 and 31

        if (get(date, 'month') !== previousMonth) {
          date = startOf(date, 'month');
        }
      }
    }

    return list;
  };
}

function isImportantStep(step) {
  if (step.unit === 'year') {
    return get(step.date, 'year') % (10 * step.scale) === 0;
  }

  return false;
}

function getZoomLevels(minUnit, maxUnit) {
  const zoomLevels: ZoomLevel[] = [];

  if (
    units.indexOf(minUnit) <= units.indexOf('millisecond') &&
    units.indexOf(maxUnit) >= units.indexOf('millisecond')
  ) {
    zoomLevels.push(
      {
        unit: 'millisecond',
        duration: 1,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 1),
      },
      {
        unit: 'millisecond',
        duration: 100,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 100),
      },
      {
        unit: 'millisecond',
        duration: 500,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 500),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('second') &&
    units.indexOf(maxUnit) >= units.indexOf('second')
  ) {
    zoomLevels.push(
      {
        unit: 'second',
        duration: 1 * SECOND_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'millisecond',
        getSteps: getSteps('second', 1),
      },
      {
        unit: 'second',
        duration: 5 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 5),
      },
      {
        unit: 'second',
        duration: 10 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 10),
      },
      {
        unit: 'second',
        duration: 30 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 30),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('minute') &&
    units.indexOf(maxUnit) >= units.indexOf('minute')
  ) {
    zoomLevels.push(
      {
        unit: 'minute',
        duration: 1 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'second',
        getSteps: getSteps('minute', 1),
      },
      {
        unit: 'minute',
        duration: 5 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 5),
      },
      {
        unit: 'minute',
        duration: 10 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 10),
      },
      {
        unit: 'minute',
        duration: 30 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 30),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('hour') &&
    units.indexOf(maxUnit) >= units.indexOf('hour')
  ) {
    zoomLevels.push(
      {
        unit: 'hour',
        duration: 1 * HOUR_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'minute',
        getSteps: getSteps('hour', 1),
      },
      {
        unit: 'hour',
        duration: 3 * HOUR_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('hour', 3),
      },
      {
        unit: 'hour',
        duration: 6 * HOUR_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('hour', 6),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('day') &&
    units.indexOf(maxUnit) >= units.indexOf('day')
  ) {
    zoomLevels.push(
      {
        unit: 'day',
        duration: 1 * DAY_IN_MILLISECONDS,
        isMajorLevel: mainLevel =>
          ['hour', 'minute', 'second', 'millisecond'].includes(mainLevel.unit),
        getSteps: getSteps('day', 1),
      },
      {
        unit: 'day',
        duration: 5 * DAY_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('day', 5),
      },
      {
        unit: 'day',
        duration: 10 * DAY_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('day', 10),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('month') &&
    units.indexOf(maxUnit) >= units.indexOf('month')
  ) {
    for (const i of [1, 2, 4, 6]) {
      zoomLevels.push({
        unit: 'month',
        duration: i * MONTH_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'day' && i === 1,
        getSteps: getSteps('month', i),
      });
    }
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('year') &&
    units.indexOf(maxUnit) >= units.indexOf('year')
  ) {
    for (const i of [1, 10, 100, 1000]) {
      zoomLevels.push(
        {
          unit: 'year',
          duration: i * YEAR_IN_MILLISECONDS,
          isMajorLevel: mainLevel => mainLevel.unit === 'month' && i === 1,
          getSteps: getSteps('year', i),
        },
        {
          unit: 'year',
          duration: 2 * i * YEAR_IN_MILLISECONDS,
          isMajorLevel: () => false,
          getSteps: getSteps('year', 2 * i),
        },
        {
          unit: 'year',
          duration: 5 * i * YEAR_IN_MILLISECONDS,
          isMajorLevel: () => false,
          getSteps: getSteps('year', 5 * i),
        }
      );
    }
  }

  return zoomLevels;
}

export default (
  locale = 'en',
  minUnit = 'millisecond',
  maxUnit = 'year'
) => ({
  parse: parse(minUnit),
  unparse,
  parseDuration,
  getMinimumDuration: getMinimumDuration(minUnit),
  isBefore,
  diff,
  add,
  subtract,
  format: format(locale, minUnit, maxUnit),
  isImportantStep,
  zoomLevels: getZoomLevels(minUnit, maxUnit),
});
<fim_middle>",incorrect,4969
59,59,59,59,59,59,59,59,"'millisecond'
) {
  let newDate = new Date(date",Units,5f5d91c414bbb516a535e1d2016984f7aa4955b0,"<fim_prefix>export type Units =
  | 'millisecond'
  | 'second'
  | 'minute'
  | 'hour'
  | 'day'
  | 'month'
  | 'year';

export type InputDate = string;
export type ParsedDate = Date;

type InputDuration = {
  [U in Units]?: number;
};

interface Step {
  date: ParsedDate;
  unit: Units;
  scale: number;
}

interface ZoomLevel {
  unit: Units;
  duration: number;
  isMajorLevel: (mainLevel) => boolean;
  getSteps: (startDate, endDate) => Step[];
}

const SECOND_IN_MILLISECONDS = 1000;
const MINUTE_IN_MILLISECONDS = 60 * SECOND_IN_MILLISECONDS;
const HOUR_IN_MILLISECONDS = 60 * MINUTE_IN_MILLISECONDS;
const DAY_IN_MILLISECONDS = 24 * HOUR_IN_MILLISECONDS;
const MONTH_IN_MILLISECONDS = 30 * DAY_IN_MILLISECONDS;
const YEAR_IN_MILLISECONDS = 12 * MONTH_IN_MILLISECONDS;

const units = [
  'millisecond',
  'second',
  'minute',
  'hour',
  'day',
  'month',
  'year',
];

function parse(minUnit) {
  return date => startOf(new Date(date), minUnit);
}

function unparse(date) {
  return date.toISOString();
}

function parseDuration(duration) {
  let milliseconds = 0;

  milliseconds += duration.millisecond ? duration.millisecond : 0;
  milliseconds += duration.second
    ? duration.second * SECOND_IN_MILLISECONDS
    : 0;
  milliseconds += duration.minute
    ? duration.minute * MINUTE_IN_MILLISECONDS
    : 0;
  milliseconds += duration.hour ? duration.hour * HOUR_IN_MILLISECONDS : 0;
  milliseconds += duration.day ? duration.day * DAY_IN_MILLISECONDS : 0;
  milliseconds += duration.month ? duration.month * MONTH_IN_MILLISECONDS : 0;
  milliseconds += duration.year ? duration.year * YEAR_IN_MILLISECONDS : 0;

  return milliseconds;
}

function getMinimumDuration(minUnit) {
  return () => {
    switch (minUnit) {
      case 'second':
        return SECOND_IN_MILLISECONDS;
      case 'minute':
        return MINUTE_IN_MILLISECONDS;
      case 'hour':
        return HOUR_IN_MILLISECONDS;
      case 'day':
        return DAY_IN_MILLISECONDS;
      case 'month':
        return MONTH_IN_MILLISECONDS;
      case 'year':
        return YEAR_IN_MILLISECONDS;
      default:
        return 1;
    }
  };
}

function isBefore(dateA, dateB) {
  return dateA.getTime() < dateB.getTime();
}

function diff(dateA, dateB) {
  return dateA.getTime() - dateB.getTime();
}

function add(
  date,
  amount,
  unit: <fim_suffix> = 'millisecond'
) {
  let newDate = new Date(date.getTime());

  switch (unit) {
    case 'millisecond':
      return new Date(date.getTime() + amount);
    case 'second':
      return add(date, amount * SECOND_IN_MILLISECONDS, 'millisecond');
    case 'minute':
      return add(date, amount * MINUTE_IN_MILLISECONDS, 'millisecond');
    case 'hour':
      return add(date, amount * HOUR_IN_MILLISECONDS, 'millisecond');
    case 'day':
      newDate.setDate(date.getDate() + amount);
      return newDate;
    case 'month':
      const desiredMonth = date.getMonth() + amount;
      const lastDayOfMonth = new Date(date.getFullYear(), desiredMonth + 1, 0);

      newDate.setMonth(
        desiredMonth,
        Math.min(lastDayOfMonth.getDate(), date.getDate())
      );
      return newDate;
    case 'year':
      return add(date, amount * 12, 'month');
    default:
      return date;
  }
}

function subtract(
  date,
  amount,
  unit = 'millisecond'
) {
  return add(date, -amount, unit);
}

function startOf(date, unit) {
  let newDate = new Date(date.getTime());

  switch (unit) {
    case 'second':
      newDate.setMilliseconds(0);
      return newDate;
    case 'minute':
      newDate.setSeconds(0, 0);
      return newDate;
    case 'hour':
      newDate.setMinutes(0, 0, 0);
      return newDate;
    case 'day':
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    case 'month':
      newDate.setDate(1);
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    case 'year':
      newDate.setFullYear(date.getFullYear(), 0, 1);
      newDate.setHours(0, 0, 0, 0);
      return newDate;
    default:
      return newDate;
  }
}

function get(date, unit) {
  switch (unit) {
    case 'millisecond':
      return date.getMilliseconds();
    case 'second':
      return date.getSeconds();
    case 'minute':
      return date.getMinutes();
    case 'hour':
      return date.getHours();
    case 'day':
      return date.getDate();
    case 'month':
      return date.getMonth();
    case 'year':
      return date.getFullYear();
  }
}

function format(locale, minUnit, maxUnit) {
  function internFormat(
    date,
    unit?,
    onlyUnit = false
  ) {
    const monthLabels: { [locale: string]: string[] } = {
      en: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec',
      ],
      fr: [
        'janv.',
        'févr.',
        'mars',
        'avr.',
        'mai',
        'juin',
        'juil.',
        'août',
        'sept.',
        'oct.',
        'nov.',
        'déc.',
      ],
    };

    const padded = (u) => (u < 10 ? `0${u}` : `${u}`);
    const paddedMs = (u) =>
      u < 10 ? `00${u}` : u < 100 ? `0${u}` : `${u}`;

    switch (unit) {
      case 'millisecond':
        return onlyUnit
          ? `${date.getMilliseconds()}ms`
          : `${internFormat(date, 'second')}.${paddedMs(
              date.getMilliseconds()
            )}`;
      case 'second':
        return onlyUnit
          ? `${padded(date.getSeconds())}s`
          : `${internFormat(date, 'minute')}:${padded(date.getSeconds())}`;
      case 'minute':
        return `${padded(date.getHours())}:${padded(date.getMinutes())}`;
      case 'hour':
        return onlyUnit
          ? `${padded(date.getHours())}:00`
          : `${padded(date.getHours())}h`;
      case 'day':
        return onlyUnit
          ? `${padded(date.getDate())}`
          : `${padded(date.getDate())} ${internFormat(date, 'month')}`;
      case 'month':
        const formattedMonth = monthLabels[locale][date.getMonth()];
        return onlyUnit
          ? `${formattedMonth}`
          : `${formattedMonth} ${internFormat(date, 'year')}`;
      case 'year':
        return `${date.getFullYear()}`;
      default:
        const part1 =
          units.indexOf(minUnit) > units.indexOf('day')
            ? `${internFormat(date, minUnit)}`
            : `${internFormat(date, 'day')}`;
        const part2 =
          units.indexOf(minUnit) < units.indexOf('day')
            ? ` - ${internFormat(date, minUnit)}`
            : '';

        return `${part1}${part2}`;
    }
  }

  return internFormat;
}

function getSteps(unit, n) {
  return (startDate, endDate) => {
    const list = [];

    let offsetUnits = get(startDate, unit);

    if (unit === 'day') {
      const correctedStartDate = subtract(
        startDate,
        n > 1 && get(startDate, unit) >= 30 ? n : 0,
        unit
      ); // Fix to hide days 30 and 31
      const moduloDay = get(correctedStartDate, unit) < n ? 1 : 0; // Fix to round to 1st day of month
      offsetUnits = get(correctedStartDate, unit) - moduloDay;
    }

    let date = subtract(startOf(startDate, unit), offsetUnits % n, unit);
    let stop = false;

    while (!stop) {
      if (!isBefore(date, endDate)) {
        stop = true; // We need to go an extra step after the end date to compute the last step size
      }

      list.push({ date, unit, scale: n });

      let durationToAdd = n;
      const previousMonth = unit === 'day' ? get(date, 'month') : null;

      if (unit === 'day' && n > 1 && get(date, unit) === 1) {
        durationToAdd = n - 1; // Fix due to the round of 1st day of month
      }

      date = add(date, durationToAdd, unit);

      if (unit === 'day') {
        date = add(date, n > 1 && get(date, unit) >= 30 ? 1 : 0, 'month'); // Fix to hide days 30 and 31

        if (get(date, 'month') !== previousMonth) {
          date = startOf(date, 'month');
        }
      }
    }

    return list;
  };
}

function isImportantStep(step) {
  if (step.unit === 'year') {
    return get(step.date, 'year') % (10 * step.scale) === 0;
  }

  return false;
}

function getZoomLevels(minUnit, maxUnit) {
  const zoomLevels: ZoomLevel[] = [];

  if (
    units.indexOf(minUnit) <= units.indexOf('millisecond') &&
    units.indexOf(maxUnit) >= units.indexOf('millisecond')
  ) {
    zoomLevels.push(
      {
        unit: 'millisecond',
        duration: 1,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 1),
      },
      {
        unit: 'millisecond',
        duration: 100,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 100),
      },
      {
        unit: 'millisecond',
        duration: 500,
        isMajorLevel: () => false,
        getSteps: getSteps('millisecond', 500),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('second') &&
    units.indexOf(maxUnit) >= units.indexOf('second')
  ) {
    zoomLevels.push(
      {
        unit: 'second',
        duration: 1 * SECOND_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'millisecond',
        getSteps: getSteps('second', 1),
      },
      {
        unit: 'second',
        duration: 5 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 5),
      },
      {
        unit: 'second',
        duration: 10 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 10),
      },
      {
        unit: 'second',
        duration: 30 * SECOND_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('second', 30),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('minute') &&
    units.indexOf(maxUnit) >= units.indexOf('minute')
  ) {
    zoomLevels.push(
      {
        unit: 'minute',
        duration: 1 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'second',
        getSteps: getSteps('minute', 1),
      },
      {
        unit: 'minute',
        duration: 5 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 5),
      },
      {
        unit: 'minute',
        duration: 10 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 10),
      },
      {
        unit: 'minute',
        duration: 30 * MINUTE_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('minute', 30),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('hour') &&
    units.indexOf(maxUnit) >= units.indexOf('hour')
  ) {
    zoomLevels.push(
      {
        unit: 'hour',
        duration: 1 * HOUR_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'minute',
        getSteps: getSteps('hour', 1),
      },
      {
        unit: 'hour',
        duration: 3 * HOUR_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('hour', 3),
      },
      {
        unit: 'hour',
        duration: 6 * HOUR_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('hour', 6),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('day') &&
    units.indexOf(maxUnit) >= units.indexOf('day')
  ) {
    zoomLevels.push(
      {
        unit: 'day',
        duration: 1 * DAY_IN_MILLISECONDS,
        isMajorLevel: mainLevel =>
          ['hour', 'minute', 'second', 'millisecond'].includes(mainLevel.unit),
        getSteps: getSteps('day', 1),
      },
      {
        unit: 'day',
        duration: 5 * DAY_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('day', 5),
      },
      {
        unit: 'day',
        duration: 10 * DAY_IN_MILLISECONDS,
        isMajorLevel: () => false,
        getSteps: getSteps('day', 10),
      }
    );
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('month') &&
    units.indexOf(maxUnit) >= units.indexOf('month')
  ) {
    for (const i of [1, 2, 4, 6]) {
      zoomLevels.push({
        unit: 'month',
        duration: i * MONTH_IN_MILLISECONDS,
        isMajorLevel: mainLevel => mainLevel.unit === 'day' && i === 1,
        getSteps: getSteps('month', i),
      });
    }
  }

  if (
    units.indexOf(minUnit) <= units.indexOf('year') &&
    units.indexOf(maxUnit) >= units.indexOf('year')
  ) {
    for (const i of [1, 10, 100, 1000]) {
      zoomLevels.push(
        {
          unit: 'year',
          duration: i * YEAR_IN_MILLISECONDS,
          isMajorLevel: mainLevel => mainLevel.unit === 'month' && i === 1,
          getSteps: getSteps('year', i),
        },
        {
          unit: 'year',
          duration: 2 * i * YEAR_IN_MILLISECONDS,
          isMajorLevel: () => false,
          getSteps: getSteps('year', 2 * i),
        },
        {
          unit: 'year',
          duration: 5 * i * YEAR_IN_MILLISECONDS,
          isMajorLevel: () => false,
          getSteps: getSteps('year', 5 * i),
        }
      );
    }
  }

  return zoomLevels;
}

export default (
  locale = 'en',
  minUnit = 'millisecond',
  maxUnit = 'year'
) => ({
  parse: parse(minUnit),
  unparse,
  parseDuration,
  getMinimumDuration: getMinimumDuration(minUnit),
  isBefore,
  diff,
  add,
  subtract,
  format: format(locale, minUnit, maxUnit),
  isImportantStep,
  zoomLevels: getZoomLevels(minUnit, maxUnit),
});
<fim_middle>",incorrect,4973
60,60,60,60,60,60,60,60,string,ValueType,251dc8a6bd0853f15cfeabfb12becc4052d3fe54,"<fim_prefix>type ValueType = string | number;

const isE = (number) => {
  const str = String(number);

  return !Number.isNaN(Number(str)) && str.includes('e');
};

export const trimNumber = (numStr) => {
  let str = numStr.trim();

  if (str === '' || str === '0') {
    return {
      negative: false,
      negativeStr: '',
      trimStr: '',
      integerStr: '0',
      decimalStr: '',
      fullStr: str,
    };
  }

  let negative = str.startsWith('-');

  if (negative) {
    str = str.slice(1);
  }

  str = str
    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
    .replace(/(\.\d*[^0])0*$/, '$1')
    // Remove useless decimal. `1.` => `1`
    .replace(/\.0*$/, '')
    // Remove integer 0. `0001` => `1`, 000.1' => `.1`
    .replace(/^0+/, '');

  if (str.startsWith('.')) {
    str = `0${str}`;
  }

  const trimStr = str || '0';
  const splitNumber = trimStr.split('.');

  const integerStr = splitNumber[0] || '0';
  const decimalStr = splitNumber[1] || '0';

  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }

  const negativeStr = negative ? '-' : '';

  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`,
  };
};

const validateNumber = (num) => {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }

  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
};

const getNumberPrecision = (number) => {
  const numStr = String(number);

  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));

    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch?.[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }

  return numStr.includes('.') && validateNumber(numStr)
    ? numStr.length - numStr.indexOf('.') - 1
    : 0;
};

const maxPrecision = (pre, cur) =>
  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));

const add = (pre, cur) => {
  const preValue = Number(pre);
  const curValue = Number(cur);

  const totalValue = preValue + curValue;
  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {
    return bigIntDecimalAdd(pre, cur);
  }
  return totalValue.toFixed(maxPrecision(pre, cur));
};

const makeBigIntDecimal = (value) => {
  // We need convert back to Number since it require `toFixed` to handle this
  if (isE(value)) {
    value = Number(value);
  }

  value = typeof value === 'string' ? value : num2str(value);

  if (validateNumber(value)) {
    const trimRet = trimNumber(value);
    const numbers = trimRet.trimStr.split('.');
    const decimalStr = numbers[1] || '0';

    return {
      value: value,
      negative: trimRet.negative,
      integer: BigInt(numbers[0]),
      decimal: BigInt(decimalStr),
      decimalLen: decimalStr.length,
    };
  }
  return null;
};

type BigIntDecimalType = {
  value: string;
  negative: boolean;
  integer: BigInt;
  decimal: BigInt;
  decimalLen: number;
};

const bigIntDecimalAdd = (pre, cur: <fim_suffix>) => {
  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;
  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;

  if (!preValue || !curValue) return '';

  const maxDecimalLength = Math.max(
    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,
    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,
  );
  const preDecimal = BigInt(
    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal
      .toString()
      .padStart(preValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );
  const curDecimal = BigInt(
    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal
      .toString()
      .padStart(curValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );

  const valueStr = (preDecimal + curDecimal).toString();

  // We need fill string length back to `maxDecimalLength` to avoid parser failed
  const { negativeStr, trimStr } = trimNumber(valueStr);
  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;

  return trimNumber(
    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,
  ).fullStr;
};

export const num2str = (value) => {
  let numIn = value.toString();
  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;
  let sign = ''; // To remember the number sign
  if (numIn.charAt(0) === '-') {
    numIn = numIn.substring(1);
    sign = '-';
  }
  let str = numIn.split(/[eE]/g); // Split numberic string at e or E

  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back

  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)
  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one

  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator
  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point

  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else """"
  let baseLH = str[0]; // LH base part.

  if (power > 0) {
    // ------- Positive Exponents (Process the RH Base Part)
    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with ""0"" at RH
    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base
    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it
  } else {
    // ------- Negative Exponents (Process the LH Base Part)
    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's
    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with ""0"" at LH
    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert ""."" at the correct place into LH base
    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add ""0""
  }
  return sign + baseLH + baseRH; // Return the long number (with sign)
};

export default add;
<fim_middle>",incorrect,4633
61,61,61,61,61,61,61,61,"string, cur: string) => {
  const preValue = makeBigIntDecimal",ValueType,251dc8a6bd0853f15cfeabfb12becc4052d3fe54,"<fim_prefix>type ValueType = string | number;

const isE = (number) => {
  const str = String(number);

  return !Number.isNaN(Number(str)) && str.includes('e');
};

export const trimNumber = (numStr) => {
  let str = numStr.trim();

  if (str === '' || str === '0') {
    return {
      negative: false,
      negativeStr: '',
      trimStr: '',
      integerStr: '0',
      decimalStr: '',
      fullStr: str,
    };
  }

  let negative = str.startsWith('-');

  if (negative) {
    str = str.slice(1);
  }

  str = str
    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
    .replace(/(\.\d*[^0])0*$/, '$1')
    // Remove useless decimal. `1.` => `1`
    .replace(/\.0*$/, '')
    // Remove integer 0. `0001` => `1`, 000.1' => `.1`
    .replace(/^0+/, '');

  if (str.startsWith('.')) {
    str = `0${str}`;
  }

  const trimStr = str || '0';
  const splitNumber = trimStr.split('.');

  const integerStr = splitNumber[0] || '0';
  const decimalStr = splitNumber[1] || '0';

  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }

  const negativeStr = negative ? '-' : '';

  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`,
  };
};

const validateNumber = (num) => {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }

  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
};

const getNumberPrecision = (number) => {
  const numStr = String(number);

  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));

    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch?.[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }

  return numStr.includes('.') && validateNumber(numStr)
    ? numStr.length - numStr.indexOf('.') - 1
    : 0;
};

const maxPrecision = (pre, cur) =>
  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));

const add = (pre, cur) => {
  const preValue = Number(pre);
  const curValue = Number(cur);

  const totalValue = preValue + curValue;
  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {
    return bigIntDecimalAdd(pre, cur);
  }
  return totalValue.toFixed(maxPrecision(pre, cur));
};

const makeBigIntDecimal = (value) => {
  // We need convert back to Number since it require `toFixed` to handle this
  if (isE(value)) {
    value = Number(value);
  }

  value = typeof value === 'string' ? value : num2str(value);

  if (validateNumber(value)) {
    const trimRet = trimNumber(value);
    const numbers = trimRet.trimStr.split('.');
    const decimalStr = numbers[1] || '0';

    return {
      value: value,
      negative: trimRet.negative,
      integer: BigInt(numbers[0]),
      decimal: BigInt(decimalStr),
      decimalLen: decimalStr.length,
    };
  }
  return null;
};

type BigIntDecimalType = {
  value: string;
  negative: boolean;
  integer: BigInt;
  decimal: BigInt;
  decimalLen: number;
};

const bigIntDecimalAdd = (pre: <fim_suffix>, cur) => {
  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;
  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;

  if (!preValue || !curValue) return '';

  const maxDecimalLength = Math.max(
    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,
    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,
  );
  const preDecimal = BigInt(
    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal
      .toString()
      .padStart(preValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );
  const curDecimal = BigInt(
    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal
      .toString()
      .padStart(curValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );

  const valueStr = (preDecimal + curDecimal).toString();

  // We need fill string length back to `maxDecimalLength` to avoid parser failed
  const { negativeStr, trimStr } = trimNumber(valueStr);
  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;

  return trimNumber(
    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,
  ).fullStr;
};

export const num2str = (value) => {
  let numIn = value.toString();
  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;
  let sign = ''; // To remember the number sign
  if (numIn.charAt(0) === '-') {
    numIn = numIn.substring(1);
    sign = '-';
  }
  let str = numIn.split(/[eE]/g); // Split numberic string at e or E

  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back

  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)
  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one

  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator
  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point

  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else """"
  let baseLH = str[0]; // LH base part.

  if (power > 0) {
    // ------- Positive Exponents (Process the RH Base Part)
    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with ""0"" at RH
    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base
    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it
  } else {
    // ------- Negative Exponents (Process the LH Base Part)
    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's
    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with ""0"" at LH
    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert ""."" at the correct place into LH base
    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add ""0""
  }
  return sign + baseLH + baseRH; // Return the long number (with sign)
};

export default add;
<fim_middle>",incorrect,4634
62,62,62,62,62,62,62,62,string,ValueType,251dc8a6bd0853f15cfeabfb12becc4052d3fe54,"<fim_prefix>type ValueType = string | number;

const isE = (number) => {
  const str = String(number);

  return !Number.isNaN(Number(str)) && str.includes('e');
};

export const trimNumber = (numStr) => {
  let str = numStr.trim();

  if (str === '' || str === '0') {
    return {
      negative: false,
      negativeStr: '',
      trimStr: '',
      integerStr: '0',
      decimalStr: '',
      fullStr: str,
    };
  }

  let negative = str.startsWith('-');

  if (negative) {
    str = str.slice(1);
  }

  str = str
    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
    .replace(/(\.\d*[^0])0*$/, '$1')
    // Remove useless decimal. `1.` => `1`
    .replace(/\.0*$/, '')
    // Remove integer 0. `0001` => `1`, 000.1' => `.1`
    .replace(/^0+/, '');

  if (str.startsWith('.')) {
    str = `0${str}`;
  }

  const trimStr = str || '0';
  const splitNumber = trimStr.split('.');

  const integerStr = splitNumber[0] || '0';
  const decimalStr = splitNumber[1] || '0';

  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }

  const negativeStr = negative ? '-' : '';

  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`,
  };
};

const validateNumber = (num) => {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }

  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
};

const getNumberPrecision = (number) => {
  const numStr = String(number);

  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));

    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch?.[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }

  return numStr.includes('.') && validateNumber(numStr)
    ? numStr.length - numStr.indexOf('.') - 1
    : 0;
};

const maxPrecision = (pre, cur) =>
  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));

const add = (pre, cur) => {
  const preValue = Number(pre);
  const curValue = Number(cur);

  const totalValue = preValue + curValue;
  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {
    return bigIntDecimalAdd(pre, cur);
  }
  return totalValue.toFixed(maxPrecision(pre, cur));
};

const makeBigIntDecimal = (value: <fim_suffix>) => {
  // We need convert back to Number since it require `toFixed` to handle this
  if (isE(value)) {
    value = Number(value);
  }

  value = typeof value === 'string' ? value : num2str(value);

  if (validateNumber(value)) {
    const trimRet = trimNumber(value);
    const numbers = trimRet.trimStr.split('.');
    const decimalStr = numbers[1] || '0';

    return {
      value: value,
      negative: trimRet.negative,
      integer: BigInt(numbers[0]),
      decimal: BigInt(decimalStr),
      decimalLen: decimalStr.length,
    };
  }
  return null;
};

type BigIntDecimalType = {
  value: string;
  negative: boolean;
  integer: BigInt;
  decimal: BigInt;
  decimalLen: number;
};

const bigIntDecimalAdd = (pre, cur) => {
  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;
  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;

  if (!preValue || !curValue) return '';

  const maxDecimalLength = Math.max(
    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,
    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,
  );
  const preDecimal = BigInt(
    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal
      .toString()
      .padStart(preValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );
  const curDecimal = BigInt(
    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal
      .toString()
      .padStart(curValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );

  const valueStr = (preDecimal + curDecimal).toString();

  // We need fill string length back to `maxDecimalLength` to avoid parser failed
  const { negativeStr, trimStr } = trimNumber(valueStr);
  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;

  return trimNumber(
    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,
  ).fullStr;
};

export const num2str = (value) => {
  let numIn = value.toString();
  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;
  let sign = ''; // To remember the number sign
  if (numIn.charAt(0) === '-') {
    numIn = numIn.substring(1);
    sign = '-';
  }
  let str = numIn.split(/[eE]/g); // Split numberic string at e or E

  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back

  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)
  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one

  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator
  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point

  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else """"
  let baseLH = str[0]; // LH base part.

  if (power > 0) {
    // ------- Positive Exponents (Process the RH Base Part)
    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with ""0"" at RH
    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base
    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it
  } else {
    // ------- Negative Exponents (Process the LH Base Part)
    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's
    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with ""0"" at LH
    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert ""."" at the correct place into LH base
    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add ""0""
  }
  return sign + baseLH + baseRH; // Return the long number (with sign)
};

export default add;
<fim_middle>",incorrect,4635
63,63,63,63,63,63,63,63,"string, cur: string) => {
  const preValue = Number(pre",ValueType,251dc8a6bd0853f15cfeabfb12becc4052d3fe54,"<fim_prefix>type ValueType = string | number;

const isE = (number) => {
  const str = String(number);

  return !Number.isNaN(Number(str)) && str.includes('e');
};

export const trimNumber = (numStr) => {
  let str = numStr.trim();

  if (str === '' || str === '0') {
    return {
      negative: false,
      negativeStr: '',
      trimStr: '',
      integerStr: '0',
      decimalStr: '',
      fullStr: str,
    };
  }

  let negative = str.startsWith('-');

  if (negative) {
    str = str.slice(1);
  }

  str = str
    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
    .replace(/(\.\d*[^0])0*$/, '$1')
    // Remove useless decimal. `1.` => `1`
    .replace(/\.0*$/, '')
    // Remove integer 0. `0001` => `1`, 000.1' => `.1`
    .replace(/^0+/, '');

  if (str.startsWith('.')) {
    str = `0${str}`;
  }

  const trimStr = str || '0';
  const splitNumber = trimStr.split('.');

  const integerStr = splitNumber[0] || '0';
  const decimalStr = splitNumber[1] || '0';

  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }

  const negativeStr = negative ? '-' : '';

  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`,
  };
};

const validateNumber = (num) => {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }

  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
};

const getNumberPrecision = (number) => {
  const numStr = String(number);

  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));

    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch?.[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }

  return numStr.includes('.') && validateNumber(numStr)
    ? numStr.length - numStr.indexOf('.') - 1
    : 0;
};

const maxPrecision = (pre, cur) =>
  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));

const add = (pre: <fim_suffix>, cur) => {
  const preValue = Number(pre);
  const curValue = Number(cur);

  const totalValue = preValue + curValue;
  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {
    return bigIntDecimalAdd(pre, cur);
  }
  return totalValue.toFixed(maxPrecision(pre, cur));
};

const makeBigIntDecimal = (value) => {
  // We need convert back to Number since it require `toFixed` to handle this
  if (isE(value)) {
    value = Number(value);
  }

  value = typeof value === 'string' ? value : num2str(value);

  if (validateNumber(value)) {
    const trimRet = trimNumber(value);
    const numbers = trimRet.trimStr.split('.');
    const decimalStr = numbers[1] || '0';

    return {
      value: value,
      negative: trimRet.negative,
      integer: BigInt(numbers[0]),
      decimal: BigInt(decimalStr),
      decimalLen: decimalStr.length,
    };
  }
  return null;
};

type BigIntDecimalType = {
  value: string;
  negative: boolean;
  integer: BigInt;
  decimal: BigInt;
  decimalLen: number;
};

const bigIntDecimalAdd = (pre, cur) => {
  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;
  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;

  if (!preValue || !curValue) return '';

  const maxDecimalLength = Math.max(
    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,
    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,
  );
  const preDecimal = BigInt(
    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal
      .toString()
      .padStart(preValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );
  const curDecimal = BigInt(
    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal
      .toString()
      .padStart(curValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );

  const valueStr = (preDecimal + curDecimal).toString();

  // We need fill string length back to `maxDecimalLength` to avoid parser failed
  const { negativeStr, trimStr } = trimNumber(valueStr);
  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;

  return trimNumber(
    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,
  ).fullStr;
};

export const num2str = (value) => {
  let numIn = value.toString();
  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;
  let sign = ''; // To remember the number sign
  if (numIn.charAt(0) === '-') {
    numIn = numIn.substring(1);
    sign = '-';
  }
  let str = numIn.split(/[eE]/g); // Split numberic string at e or E

  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back

  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)
  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one

  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator
  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point

  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else """"
  let baseLH = str[0]; // LH base part.

  if (power > 0) {
    // ------- Positive Exponents (Process the RH Base Part)
    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with ""0"" at RH
    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base
    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it
  } else {
    // ------- Negative Exponents (Process the LH Base Part)
    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's
    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with ""0"" at LH
    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert ""."" at the correct place into LH base
    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add ""0""
  }
  return sign + baseLH + baseRH; // Return the long number (with sign)
};

export default add;
<fim_middle>",incorrect,4637
64,64,64,64,64,64,64,64,"{
  const dx = vertex2.x - vertex1.x;",Vector,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2): <fim_suffix> {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",incorrect,3406
65,65,65,65,65,65,65,65,"string,
) {
  const distances = vertices.reduce((acc, curr",Vertex,eaa92966cbe116f28e1b5c9c0f4b724a32bab041,"<fim_prefix>type Vertex = string;
type Weight = number;
type Graph = Record<string, Record<string, Weight>>;

/**
 * If a target is not provided, finds the single-source shortest path distance from the source vertex with positive or negative edge weights
 * (but with no negative weight cycles).
 * Else, it returns the shortest path as well as its distance from source vertex to target vertex.
 * In the case of negative weight cycles, if target is defined, then negative infinity and empty array path will be returned,
 * else, all distances from A will be returned with negative infinity.
 *
 * @param {Graph} graph Vertex with its fields being the neighboring vertices and value being the weight from vertex to neighboring vertices
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target Ending vertex in graph
 * @return {Record<string, number> | [number, Array<Vertex>]} An object mapping of the distance from the source vertex or an array containing the distance
 * and an array containing the path from source to target vertex
 */
function bellmanFord(
  graph,
  source,
  target?,
) {
  const vertices = Object.keys(graph);
  // if graph is empty, immediately return
  if (vertices.length === 0) {
    return target ? [0, []] : {};
  }

  if (!vertices.includes(source) || (target && !vertices.includes(target))) {
    return target ? [-Infinity, []] : {};
  }

  const distances = getDistances(vertices, source);
  const predecessor = getPredecessor(vertices);

  // requires only n - 1 iteration
  for (let i = 0; i < vertices.length - 1; i++) {
    for (let startVertex of vertices) {
      const neighbors = graph[startVertex];
      for (let endVertex in neighbors) {
        const weight = graph[startVertex][endVertex];
        // relaxation
        if (distances[startVertex] + weight < distances[endVertex]) {
          distances[endVertex] = distances[startVertex] + weight;
          predecessor[endVertex] = startVertex;
        }
      }
    }
  }

  // checks for any negative weight cycles. If true returns all distances as -Infinity as a sign negative weight cycles
  for (let startVertex of vertices) {
    const neighbors = graph[startVertex];
    for (let endVertex in neighbors) {
      const weight = graph[startVertex][endVertex];
      // if relaxation occurs here, negative weight cycles detected
      if (distances[startVertex] + weight < distances[endVertex]) {
        return target ? [-Infinity, []] : negativeWeightCycles(vertices);
      }
    }
  }

  if (!target) {
    return distances;
  }

  const shortestDistance = distances[target];
  const path = getPath(predecessor, source, target);
  return [shortestDistance, path];
}

/**
 * Returns an Object mapping of nodes to distance with values all being negative infinity to represent a negative weight cycle being present.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, number>} An object mapping of nodes with values being negative infinity
 */
function negativeWeightCycles(vertices) {
  return vertices.reduce((acc, curr) => {
    acc[curr] = -Infinity;
    return acc;
  }, {} as Record<string, number>);
}

/**
 * Initializes the distance mapping from source to rest of the vertices.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @param {Vertex} source Starting vertex in graph
 * @return {Record<string, number>} An object mapping of source to rest of vertices
 */
function getDistances(
  vertices,
  source: <fim_suffix>,
) {
  const distances = vertices.reduce((acc, curr) => {
    acc[curr] = Infinity;
    return acc;
  }, {} as Record<string, number>);
  distances[source] = 0;
  return distances;
}

/**
 * Returns an array denoting the path from start vertex to end vertex.
 *
 * @param {Object} predecessor Mapping of child vertex pointing to parent vertex
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target End vertex in graph
 * @return {Array<String>} An array containing the path from source to target vertex
 */
function getPath(
  predecessor,
  source,
  target,
) {
  const path = [target];
  while (target && target !== source) {
    const next = predecessor[target];
    target = next ?? source; // if next is undefined, it reaches source
    path.push(target);
  }
  return path.reverse();
}

/**
 * Generates a default object mapping of child vertex pointing to parent vertex which will be defaulted to undefined initially.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, Vertex | undefined>} An object mapping of child vertex pointing to parent vertex
 */
function getPredecessor(
  vertices,
) {
  const predecessor = {} as Record<string, Vertex | undefined>;
  for (let vertex of vertices) {
    predecessor[vertex] = undefined;
  }
  return predecessor;
}

export default bellmanFord;
<fim_middle>",incorrect,4130
66,66,66,66,66,66,66,66,"string,
) {
  const vertices = Object.keys(graph);",Vertex,eaa92966cbe116f28e1b5c9c0f4b724a32bab041,"<fim_prefix>type Vertex = string;
type Weight = number;
type Graph = Record<string, Record<string, Weight>>;

/**
 * If a target is not provided, finds the single-source shortest path distance from the source vertex with positive or negative edge weights
 * (but with no negative weight cycles).
 * Else, it returns the shortest path as well as its distance from source vertex to target vertex.
 * In the case of negative weight cycles, if target is defined, then negative infinity and empty array path will be returned,
 * else, all distances from A will be returned with negative infinity.
 *
 * @param {Graph} graph Vertex with its fields being the neighboring vertices and value being the weight from vertex to neighboring vertices
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target Ending vertex in graph
 * @return {Record<string, number> | [number, Array<Vertex>]} An object mapping of the distance from the source vertex or an array containing the distance
 * and an array containing the path from source to target vertex
 */
function bellmanFord(
  graph,
  source,
  target?: <fim_suffix>,
) {
  const vertices = Object.keys(graph);
  // if graph is empty, immediately return
  if (vertices.length === 0) {
    return target ? [0, []] : {};
  }

  if (!vertices.includes(source) || (target && !vertices.includes(target))) {
    return target ? [-Infinity, []] : {};
  }

  const distances = getDistances(vertices, source);
  const predecessor = getPredecessor(vertices);

  // requires only n - 1 iteration
  for (let i = 0; i < vertices.length - 1; i++) {
    for (let startVertex of vertices) {
      const neighbors = graph[startVertex];
      for (let endVertex in neighbors) {
        const weight = graph[startVertex][endVertex];
        // relaxation
        if (distances[startVertex] + weight < distances[endVertex]) {
          distances[endVertex] = distances[startVertex] + weight;
          predecessor[endVertex] = startVertex;
        }
      }
    }
  }

  // checks for any negative weight cycles. If true returns all distances as -Infinity as a sign negative weight cycles
  for (let startVertex of vertices) {
    const neighbors = graph[startVertex];
    for (let endVertex in neighbors) {
      const weight = graph[startVertex][endVertex];
      // if relaxation occurs here, negative weight cycles detected
      if (distances[startVertex] + weight < distances[endVertex]) {
        return target ? [-Infinity, []] : negativeWeightCycles(vertices);
      }
    }
  }

  if (!target) {
    return distances;
  }

  const shortestDistance = distances[target];
  const path = getPath(predecessor, source, target);
  return [shortestDistance, path];
}

/**
 * Returns an Object mapping of nodes to distance with values all being negative infinity to represent a negative weight cycle being present.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, number>} An object mapping of nodes with values being negative infinity
 */
function negativeWeightCycles(vertices) {
  return vertices.reduce((acc, curr) => {
    acc[curr] = -Infinity;
    return acc;
  }, {} as Record<string, number>);
}

/**
 * Initializes the distance mapping from source to rest of the vertices.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @param {Vertex} source Starting vertex in graph
 * @return {Record<string, number>} An object mapping of source to rest of vertices
 */
function getDistances(
  vertices,
  source,
) {
  const distances = vertices.reduce((acc, curr) => {
    acc[curr] = Infinity;
    return acc;
  }, {} as Record<string, number>);
  distances[source] = 0;
  return distances;
}

/**
 * Returns an array denoting the path from start vertex to end vertex.
 *
 * @param {Object} predecessor Mapping of child vertex pointing to parent vertex
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target End vertex in graph
 * @return {Array<String>} An array containing the path from source to target vertex
 */
function getPath(
  predecessor,
  source,
  target,
) {
  const path = [target];
  while (target && target !== source) {
    const next = predecessor[target];
    target = next ?? source; // if next is undefined, it reaches source
    path.push(target);
  }
  return path.reverse();
}

/**
 * Generates a default object mapping of child vertex pointing to parent vertex which will be defaulted to undefined initially.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, Vertex | undefined>} An object mapping of child vertex pointing to parent vertex
 */
function getPredecessor(
  vertices,
) {
  const predecessor = {} as Record<string, Vertex | undefined>;
  for (let vertex of vertices) {
    predecessor[vertex] = undefined;
  }
  return predecessor;
}

export default bellmanFord;
<fim_middle>",incorrect,4135
67,67,67,67,67,67,67,67,"string,
  target?: string,
) {
  const vertices = Object.",Vertex,eaa92966cbe116f28e1b5c9c0f4b724a32bab041,"<fim_prefix>type Vertex = string;
type Weight = number;
type Graph = Record<string, Record<string, Weight>>;

/**
 * If a target is not provided, finds the single-source shortest path distance from the source vertex with positive or negative edge weights
 * (but with no negative weight cycles).
 * Else, it returns the shortest path as well as its distance from source vertex to target vertex.
 * In the case of negative weight cycles, if target is defined, then negative infinity and empty array path will be returned,
 * else, all distances from A will be returned with negative infinity.
 *
 * @param {Graph} graph Vertex with its fields being the neighboring vertices and value being the weight from vertex to neighboring vertices
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target Ending vertex in graph
 * @return {Record<string, number> | [number, Array<Vertex>]} An object mapping of the distance from the source vertex or an array containing the distance
 * and an array containing the path from source to target vertex
 */
function bellmanFord(
  graph,
  source: <fim_suffix>,
  target?,
) {
  const vertices = Object.keys(graph);
  // if graph is empty, immediately return
  if (vertices.length === 0) {
    return target ? [0, []] : {};
  }

  if (!vertices.includes(source) || (target && !vertices.includes(target))) {
    return target ? [-Infinity, []] : {};
  }

  const distances = getDistances(vertices, source);
  const predecessor = getPredecessor(vertices);

  // requires only n - 1 iteration
  for (let i = 0; i < vertices.length - 1; i++) {
    for (let startVertex of vertices) {
      const neighbors = graph[startVertex];
      for (let endVertex in neighbors) {
        const weight = graph[startVertex][endVertex];
        // relaxation
        if (distances[startVertex] + weight < distances[endVertex]) {
          distances[endVertex] = distances[startVertex] + weight;
          predecessor[endVertex] = startVertex;
        }
      }
    }
  }

  // checks for any negative weight cycles. If true returns all distances as -Infinity as a sign negative weight cycles
  for (let startVertex of vertices) {
    const neighbors = graph[startVertex];
    for (let endVertex in neighbors) {
      const weight = graph[startVertex][endVertex];
      // if relaxation occurs here, negative weight cycles detected
      if (distances[startVertex] + weight < distances[endVertex]) {
        return target ? [-Infinity, []] : negativeWeightCycles(vertices);
      }
    }
  }

  if (!target) {
    return distances;
  }

  const shortestDistance = distances[target];
  const path = getPath(predecessor, source, target);
  return [shortestDistance, path];
}

/**
 * Returns an Object mapping of nodes to distance with values all being negative infinity to represent a negative weight cycle being present.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, number>} An object mapping of nodes with values being negative infinity
 */
function negativeWeightCycles(vertices) {
  return vertices.reduce((acc, curr) => {
    acc[curr] = -Infinity;
    return acc;
  }, {} as Record<string, number>);
}

/**
 * Initializes the distance mapping from source to rest of the vertices.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @param {Vertex} source Starting vertex in graph
 * @return {Record<string, number>} An object mapping of source to rest of vertices
 */
function getDistances(
  vertices,
  source,
) {
  const distances = vertices.reduce((acc, curr) => {
    acc[curr] = Infinity;
    return acc;
  }, {} as Record<string, number>);
  distances[source] = 0;
  return distances;
}

/**
 * Returns an array denoting the path from start vertex to end vertex.
 *
 * @param {Object} predecessor Mapping of child vertex pointing to parent vertex
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target End vertex in graph
 * @return {Array<String>} An array containing the path from source to target vertex
 */
function getPath(
  predecessor,
  source,
  target,
) {
  const path = [target];
  while (target && target !== source) {
    const next = predecessor[target];
    target = next ?? source; // if next is undefined, it reaches source
    path.push(target);
  }
  return path.reverse();
}

/**
 * Generates a default object mapping of child vertex pointing to parent vertex which will be defaulted to undefined initially.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, Vertex | undefined>} An object mapping of child vertex pointing to parent vertex
 */
function getPredecessor(
  vertices,
) {
  const predecessor = {} as Record<string, Vertex | undefined>;
  for (let vertex of vertices) {
    predecessor[vertex] = undefined;
  }
  return predecessor;
}

export default bellmanFord;
<fim_middle>",incorrect,4136
68,68,68,68,68,68,68,68,"string[] {
  const esComponentsFolder = '@element-ultra/components",any,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName): <fim_suffix> {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",incorrect,32
69,69,69,69,69,69,69,69,boolean,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional: <fim_suffix>) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",incorrect,82
70,70,70,70,70,70,70,70,"T {
  return transform(val, typ, jsToJSONProps);",any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ): <fim_suffix> {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",incorrect,86
71,71,71,71,71,71,71,71,"T) {
  return transform(val, typ, jsonToJSProps);",any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ: <fim_suffix>) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",incorrect,90
72,72,72,72,72,72,72,72,Date,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val): <fim_suffix> {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",incorrect,96
73,73,73,73,73,73,73,73,Node_,any,ed707857103d58beb481bd7cdef24308b16ff916,"<fim_prefix>type Node_Type = Node_;
export class Node_{
	public data:any;
	public children: Node_Type[];
	public parent: Node_ | null;
	constructor(data){
		this.data = data;
		this.children = [];
		this.parent = null;
	}
}
export default class tree {
	public static head: Node_ = new Node_('head');
	public static path:string[][] | string[] = [];
	public static rootNode = '';
    
	static append(parent: <fim_suffix>=undefined, data){
		const node = new Node_(data);
		if (!parent){
			this.head?.children.push(node);
			return;
		} else {
			const stack = [...this.head?.children] as Node_[];
			let prevIdx = null;
			while (stack?.length){
				const shiftItem = stack.shift();
				prevIdx = shiftItem;
				const children = shiftItem?.children;
				if (shiftItem?.data?.data === parent.data){
					node.parent = prevIdx as Node_;
					shiftItem?.children.push(node);
					return;
				} else {
					children?.forEach((node)=>{
						stack.push(node);
					});
				}
			}
		}
	}
	static getTree(){
		return this.head;
	}
	static async getPath(){
		// let rootNode = ;
		const rootNode = this.getRoot();
		const stack = [...this.head.children];
		let path_:string[] = [];
		while (stack.length){
			const shiftItem = stack.shift();
			path_.push(shiftItem?.data.data);
			const children = shiftItem?.children;
			if (shiftItem?.data.type === 'item'){
				(this.path as string[][]).push([...path_ as string[]]);
				if (shiftItem.parent){
					while (
						path_[path_.length - 1] !== rootNode?.data.data
					){
						path_.pop();
					}
				} else {
					path_ = [];
				}
			} else if (!shiftItem?.children.length){
				(this.path as string[][]).push([...path_ as string[]]);
				path_.pop();
				if (shiftItem?.parent){
					while (
						path_[path_.length - 1] !== rootNode?.data.data
					){
						path_.pop();
					}
				} else {
					path_ = [];
				}
			}
			for (let i=children?.length as number-1; i>=0; i--){
				stack.unshift(children?.[i] as Node_);
			}
		}
		return this.path;
	}
	private static getRoot(){
		const stack = [...tree.head.children];
		while (stack.length){
			const shiftItem = stack.shift();
			if (shiftItem?.data.type === 'parent'){
				return shiftItem;
			} else {
				const children = shiftItem?.children;
				for (let i=children?.length as number-1; i>=0; i--){
					stack.unshift(children?.[i] as Node_);
				}
			}
		}
		return undefined;
	}
	static clearTree(){
		this.head = new Node_('head');
		this.path = [];
		this.rootNode = '';
		return true;
	}
}

/**
 * a {
 *  b{
 *      d
 *   }
 *  c{
 *   }
 * }
 * 
 * 
 * 
 * 
 */
<fim_middle>",incorrect,168
74,74,74,74,74,74,74,74,x is string,boolean,cb14c7a279f215293358730312da69fac60347a7,"<fim_prefix>const isNull =
	(val): val is null =>
		val === null

const isString =
	(val): val is string =>
		typeof val === ""string""

const isBoolean =
	(val): val is boolean =>
		typeof val === ""boolean""

const isUndefined =
	(val): val is undefined =>
		val === undefined

const isUpperCase =
	(x): <fim_suffix> =>
		x === x.toUpperCase()

const isEmpty =
	(val) =>
		val.length === 0

const normalizeInput =
	(classNames) =>
		classNames
			.map(
				className => {
					if (isBoolean(className) || isNull(className) || isUndefined(className)) {
						return { className: """", remove: true }
					} else if (isString(className)) {
						if (isEmpty(className)) {
							return { className }
						} else if (isUpperCase(className.charAt(0))) {
							return { className, ignore: true }
						} else {
							return { className }
						}
					} else {
						return className
					}
				},
			)

const filterRemove =
	(classNames) =>
		classNames.filter(({ remove }) => !remove)

const mapBEMValues =
	(classNames, componentName) =>
		classNames.map(
			({ ignore, className }) => {
				if (ignore) {
					return className
				} else if (isEmpty(componentName)) {
					return className
				} else if (isEmpty(className)) {
					return componentName
				} else {
					return `${componentName}__${className}`
				}
			},
		)

const joinToString =
	(classNames) => (
		isEmpty(classNames) ?
			undefined :
			classNames.join("" "")
	)

export const createBEM =
	(componentName) =>
		(...classNames) =>
			joinToString(
				mapBEMValues(
					filterRemove(
						normalizeInput(classNames),
					),
					componentName,
				),
			)

export interface BEMClassType {
	remove?: boolean,
	ignore?: boolean,
	className: string,
}

export type BEMInput =
	BEMClassType | string | boolean | undefined | null<fim_middle>",incorrect,726
75,75,75,75,75,75,75,75,"number {
    const info: TreeNodeInfo = {
      node: this.root",boolean,1bdf15e64741ff92173aa49927c0b9358b078f8c,"<fim_prefix>// Copyright (c) 2022 Onur Cinar. All Rights Reserved.
// https://github.com/cinar/indicatorts

/**
 * Tree node.
 */
interface TreeNode {
  value: number;
  left: TreeNode | null;
  right: TreeNode | null;
}

/**
 * Tree result info object.
 */
interface TreeNodeInfo {
  node: TreeNode | null;
  parent: TreeNode | null;
}

/**
 * Binary search tree object.
 */
export class BinarySearchTree {
  private root: TreeNode | null = null;

  /**
   * Inserts the given value.
   * @param value numeric value.
   */
  insert(value) {
    const node: TreeNode = {
      value: value,
      left: null,
      right: null,
    };

    if (this.root === null) {
      this.root = node;
      return;
    }

    let current = this.root;
    let found = false;

    while (!found) {
      if (node.value <= current.value) {
        if (current.left === null) {
          current.left = node;
          found = true;
        } else {
          current = current.left;
        }
      } else {
        if (current.right === null) {
          current.right = node;
          found = true;
        } else {
          current = current.right;
        }
      }
    }
  }

  /**
   * Removes the given value.
   * @param value numeric value.
   * @return value removed.
   */
  remove(value): <fim_suffix> {
    const info: TreeNodeInfo = {
      node: this.root,
      parent: null,
    };

    while (info.node !== null) {
      if (value === info.node.value) {
        this.removeNode(info);
        return true;
      } else {
        info.parent = info.node;

        if (value < info.node.value) {
          info.node = info.node.left;
        } else {
          info.node = info.node.right;
        }
      }
    }

    return false;
  }

  /**
   * Min value.
   * @return min value.
   */
  min() {
    const minInfo = BinarySearchTree.minNode(this.root);
    if (minInfo.node === null) {
      throw new Error('Tree empty');
    }

    return minInfo.node.value;
  }

  /**
   * Max value.
   * @return max value.
   */
  max() {
    const maxInfo = BinarySearchTree.maxNode(this.root);
    if (maxInfo.node === null) {
      throw new Error('Tree empty');
    }

    return maxInfo.node?.value;
  }

  /**
   * Removes the node info.
   * @param info node info.
   */
  private removeNode(info) {
    if (info.node === null) {
      return;
    }

    if (info.node.left !== null && info.node.right !== null) {
      const minInfo = BinarySearchTree.minNode(info.node.right);
      if (minInfo.parent === null) {
        minInfo.parent = info.node;
      }

      this.removeNode(minInfo);
      if (minInfo.node !== null) {
        info.node.value = minInfo.node.value;
      }
    } else {
      let child: TreeNode | null = null;

      if (info.node.left !== null) {
        child = info.node.left;
      } else {
        child = info.node.right;
      }

      if (info.parent === null) {
        this.root = child;
      } else if (info.parent.left === info.node) {
        info.parent.left = child;
      } else {
        info.parent.right = child;
      }
    }
  }

  /**
   * Min node function returns the min node and its parent.
   * @param root root node.
   * @return node info.
   */
  private static minNode(root) {
    const info: TreeNodeInfo = {
      node: null,
      parent: null,
    };

    if (root !== null) {
      info.node = root;

      while (info.node.left !== null) {
        info.parent = info.node;
        info.node = info.node.left;
      }
    }

    return info;
  }

  /**
   * Max node funection returns the mac node and its parent.
   * @param root root node.
   * @return node info.
   */
  private static maxNode(root) {
    const info: TreeNodeInfo = {
      node: null,
      parent: null,
    };

    if (root !== null) {
      info.node = root;

      while (info.node.right !== null) {
        info.parent = info.node;
        info.node = info.node.right;
      }
    }

    return info;
  }
}
<fim_middle>",incorrect,1338
76,76,76,76,76,76,76,76,"T[] {
    if (!newValue) {
        return this;
    }",boolean,b0280f038563e54e983ad28728ead564ef36b563,"<fim_prefix>/*
 * Notifo.io
 *
 * @license
 * Copyright (c) Sebastian Stehle. All rights reserved.
 */

/* eslint-disable */

interface ReadonlyArray<T> {
    replacedBy(field, value);

    removedBy(field, value);

    removed(value?);

    sorted();

    sortedByString(selector);

    toMap(selector);
}

interface Array<T> {
    replacedBy(field, value);

    replaceBy(field, value);

    removedBy(field, value);

    removeBy(field, value);

    removeByValue<TId>(field, oldId);

    removed(value);

    remove(value);

    sorted();

    sortedByString(selector);

    sortByString(selector);

    set<TId>(field, value);

    setOrPush<TId>(field, value);

    setOrUnshift<TId>(field, value);

    toMap(selector);
}

Array.prototype.replaceBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            self[i] = value;
            break;
        }
    }

    return self;
};

Array.prototype.replacedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            copy[i] = value;
            break;
        }
    }

    return copy;
};

Array.prototype.removeBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    self.splice(self.findIndex(x => x[field] === value[field]), 1);

    return self;
};

Array.prototype.removeByValue = function<T, TId>(field, oldId) {
    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === oldId) {
            this.splice(i, 1);
            return true;
        }
    }

    return false;
};

Array.prototype.removed = function<T>(value?) {
    const self: ReadonlyArray<T> = this;

    if (!value) {
        return this;
    }

    return self.filter((v) => v !== value);
};

Array.prototype.remove = function<T>(value?) {
    const self: T[] = this;

    if (!value) {
        return this;
    }

    const index = self.indexOf(value);

    self.splice(index, 1);

    return self;
};

Array.prototype.removedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    return self.filter((v) => v[field] !== value[field]);
};

Array.prototype.sorted = function() {
    const self: any[] = this;

    const copy: any[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort();

    return copy;
};

Array.prototype.sortedByString = function<T>(selector) {
    const self: ReadonlyArray<any> = this;

    if (!selector) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return copy;
};

Array.prototype.sortByString = function<T>(selector) {
    const self: any[] = this;

    if (!selector) {
        return self;
    }

    self.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return self;
};

Array.prototype.toMap = function<T>(selector) {
    const result: { [key: string]: T } = {};

    for (const item of this) {
        result[selector(item)] = item;
    }

    return result;
};

Array.prototype.set = function<T, TId>(field, newValue): <fim_suffix> {
    if (!newValue) {
        return false;
    }

    const newId = field(newValue);

    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === newId) {
            this[i] = newValue;
            return true;
        }
    }

    return false;
};

Array.prototype.setOrPush = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.push(newValue);
    }
};

Array.prototype.setOrUnshift = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.unshift(newValue);
    }
};<fim_middle>",incorrect,2685
77,77,77,77,77,77,77,77,"T[] {
    const self: T[] = this;

    if (!field",boolean,b0280f038563e54e983ad28728ead564ef36b563,"<fim_prefix>/*
 * Notifo.io
 *
 * @license
 * Copyright (c) Sebastian Stehle. All rights reserved.
 */

/* eslint-disable */

interface ReadonlyArray<T> {
    replacedBy(field, value);

    removedBy(field, value);

    removed(value?);

    sorted();

    sortedByString(selector);

    toMap(selector);
}

interface Array<T> {
    replacedBy(field, value);

    replaceBy(field, value);

    removedBy(field, value);

    removeBy(field, value);

    removeByValue<TId>(field, oldId);

    removed(value);

    remove(value);

    sorted();

    sortedByString(selector);

    sortByString(selector);

    set<TId>(field, value);

    setOrPush<TId>(field, value);

    setOrUnshift<TId>(field, value);

    toMap(selector);
}

Array.prototype.replaceBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            self[i] = value;
            break;
        }
    }

    return self;
};

Array.prototype.replacedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            copy[i] = value;
            break;
        }
    }

    return copy;
};

Array.prototype.removeBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    self.splice(self.findIndex(x => x[field] === value[field]), 1);

    return self;
};

Array.prototype.removeByValue = function<T, TId>(field, oldId): <fim_suffix> {
    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === oldId) {
            this.splice(i, 1);
            return true;
        }
    }

    return false;
};

Array.prototype.removed = function<T>(value?) {
    const self: ReadonlyArray<T> = this;

    if (!value) {
        return this;
    }

    return self.filter((v) => v !== value);
};

Array.prototype.remove = function<T>(value?) {
    const self: T[] = this;

    if (!value) {
        return this;
    }

    const index = self.indexOf(value);

    self.splice(index, 1);

    return self;
};

Array.prototype.removedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    return self.filter((v) => v[field] !== value[field]);
};

Array.prototype.sorted = function() {
    const self: any[] = this;

    const copy: any[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort();

    return copy;
};

Array.prototype.sortedByString = function<T>(selector) {
    const self: ReadonlyArray<any> = this;

    if (!selector) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return copy;
};

Array.prototype.sortByString = function<T>(selector) {
    const self: any[] = this;

    if (!selector) {
        return self;
    }

    self.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return self;
};

Array.prototype.toMap = function<T>(selector) {
    const result: { [key: string]: T } = {};

    for (const item of this) {
        result[selector(item)] = item;
    }

    return result;
};

Array.prototype.set = function<T, TId>(field, newValue) {
    if (!newValue) {
        return false;
    }

    const newId = field(newValue);

    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === newId) {
            this[i] = newValue;
            return true;
        }
    }

    return false;
};

Array.prototype.setOrPush = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.push(newValue);
    }
};

Array.prototype.setOrUnshift = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.unshift(newValue);
    }
};<fim_middle>",incorrect,2697
78,78,78,78,78,78,78,78,input is IHostRule,boolean,fe48985f9ace65089aa5d0dd92573b69804e7a66,"<fim_prefix>export const Kind = 'Core#HostRule';

/**
 * API Client host rule definition.
 */
export interface IHostRule {
  kind?: typeof Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from: string;
  /**
   * replacement value
   */
  to: string;
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;
}

export class HostRule {
  kind = Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from = '';
  /**
   * replacement value
   */
  to = '';
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;

  static fromValues(from, to ) {
    const result = new HostRule({
      kind: Kind,
      from,
      to,
      enabled: true,
    });
    return result;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IHostRule;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        from: '',
        to: '',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not an API Client thing.
   */
  new(init) {
    if (!HostRule.isHostRule(init)) {
      throw new Error(`Not a HostRule.`);
    }
    const { from='', to='', enabled, comment } = init;
    this.kind = Kind;
    this.from = from;
    this.to = to;
    this.enabled = enabled;
    this.comment = comment;
  }

  /**
   * Checks whether the input is a definition of a host rule.
   */
  static isHostRule(input): <fim_suffix> {
    const typed = input as IHostRule;
    if (input && typed.kind && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IHostRule = {
      kind: Kind,
      from : this.from,
      to : this.to,
    };
    if (typeof this.enabled === 'boolean') {
      result.enabled = this.enabled;
    }
    if (this.comment) {
      result.comment = this.comment;
    }
    return result;
  }

  /**
   * Applies `hosts` rules to the URL.
   *
   * @param value An URL to apply the rules to
   * @param rules List of host rules. It is a list of objects containing `from` and `to` properties.
   * @return Evaluated URL with hosts rules.
   */
  static applyHosts(value, rules) {
    if (!rules || !rules.length) {
      return value;
    }
    for (let i = 0; i < rules.length; i++) {
      const rule = rules[i];
      const result = HostRule.evaluateRule(value, rule);
      if (result) {
        value = result;
      }
    }
    return value;
  }

  /**
   * Evaluates hosts rule and applies it to the `url`.
   * @param {string} url The URL to evaluate
   * @param {HostRule} rule The host rule definition
   * @return {string} Processed url.
   */
  static evaluateRule(url, rule) {
    if (!rule || !rule.from || !rule.to) {
      return;
    }
    const re = HostRule.createRuleRe(rule.from);
    if (!re.test(url)) {
      return;
    }
    return url.replace(re, rule.to);
  }

  /**
   * @param input Rule body
   * @return Regular expression for the rule.
   */
  static createRuleRe(input) {
    input = input.replace(/\*/g, '(.*)');
    return new RegExp(input, 'gi');
  }
}
<fim_middle>",incorrect,3418
79,79,79,79,79,79,79,79,x is SCSVUnion,boolean,155ed385f5c8e4cb526b8f77f7864d57ba5bd325,"<fim_prefix>export const enum SCSVPrimitiveName {
  ""string"",
  ""number"",
  ""boolean"",
  ""null"",
}

export type SCSVPrimitive = {
  type: SCSVPrimitiveName;
};

export type SCSVArray = {
  type: ""array"";
  elementType: SCSVType;
};

export type SCSVTuple = {
  type: ""tuple"";
  elements: SCSVType[];
};

export type SCSVObject = {
  type: ""object"";
  valueType: SCSVType;
};

export type SCSVRecord = {
  type: ""record"";
  fields: Record<string, SCSVType>;
};

export type SCSVUnion = {
  type: ""union"";
  variants: SCSVType[]; // set of types
};

export type SCSVType =
  | SCSVPrimitive
  | SCSVArray
  | SCSVTuple
  | SCSVObject
  | SCSVRecord
  | SCSVUnion;

export const scsv = {
  string: {
    type: SCSVPrimitiveName.string,
  },
  number: {
    type: SCSVPrimitiveName.number,
  },
  boolean: {
    type: SCSVPrimitiveName.boolean,
  },
  null: {
    type: SCSVPrimitiveName.null,
  },
  array(elementType) {
    return {
      type: ""array"",
      elementType,
    };
  },
  tuple(...elements) {
    return {
      type: ""tuple"",
      elements,
    };
  },
  object(valueType) {
    return {
      type: ""object"",
      valueType,
    };
  },
  record(fields) {
    return {
      type: ""record"",
      fields,
    };
  },
  union(...variants) {
    return {
      type: ""union"",
      variants,
    };
  },
  optional(type) {
    return this.union(type, this.null);
  },
  parse(x) {
    // todo(maximsmol): tuple, record support
    let idx = 0;

    const consume = (c) => {
      if (x[idx] !== c) return false;
      ++idx;
      return true;
    };

    const parsePrimitive = () => {
      if (consume(""s"")) return this.string;
      if (consume(""n"")) return this.number;
      if (consume(""b"")) return this.boolean;
      if (consume(""N"")) return this.null;
      throw new Error(`unknown primitive: ""${x[idx]}""`);
    };

    const parseParens = () => {
      if (!consume(""("")) return parsePrimitive();
      const res = parseType();
      if (!consume("")"")) throw new Error(""expected closing parenthesis"");
      return res;
    };

    const parsePostfix = () => {
      const l = parseParens();
      if (!""[{?"".includes(x[idx] ?? ""eof"")) return l;

      let res = l;
      while (true) {
        if (consume(""["")) {
          if (!consume(""]"")) throw new Error(""expected closing bracket"");
          res = this.array(res);
        } else if (consume(""{"")) {
          if (!consume(""}"")) throw new Error(""expected closing brace"");
          res = this.object(res);
        } else if (consume(""?"")) {
          res = this.optional(res);
        } else break;
      }

      return res;
    };

    const parseUnion = () => {
      const l = parsePostfix();
      if (x[idx] !== ""|"") return l;

      const res = [l];
      while (consume(""|"")) res.push(parsePostfix());

      return this.union(...res);
    };

    const parseType = () => {
      return parseUnion();
    };

    return parseType();
  },
};

export type SCSVObjectOutput = { [key: string]: SCSVOutput };
export type SCSVOutput =
  | string
  | number
  | boolean
  | null
  | SCSVOutput[]
  | SCSVObjectOutput;

// todo(maximsmol): implement this properly
// export type JSTypeFromSCSVType<T extends SCSVType> = T extends SCSVPrimitive
//   ? T[""type""] extends SCSVPrimitiveName.string
//     ? string
//     : T[""type""] extends SCSVPrimitiveName.number
//     ? number
//     : T[""type""] extends SCSVPrimitiveName.boolean
//     ? boolean
//     : T[""type""] extends SCSVPrimitiveName.null
//     ? null
//     : never
//   : T extends SCSVArray
//   ? JSTypeFromSCSVType<T[""elementType""]>[]
//   : T extends SCSVTuple
//   ? { [K in keyof T[""elements""]]: SCSVType }
//   : T extends SCSVObject
//   ? { [key: string]: JSTypeFromSCSVType<T[""valueType""]> }
//   : T extends SCSVRecord
//   ? { [K in keyof T[""fields""]]: JSTypeFromSCSVType<T[""fields""][K]> }
//   : T extends SCSVUnion
//   ? keyof { [K in keyof T[""variants""]]: SCSVType }
//   : never;

export const isOptional = (x): <fim_suffix> =>
  x.type === ""union"" &&
  x.variants.findIndex((x) => x === scsv.null || isOptional(x)) !== -1;
<fim_middle>",incorrect,3795
80,80,80,80,80,80,80,80,"0 | 1 | 2,
    limit
) {
    let list",number,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type: <fim_suffix>,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",incorrect,11
81,81,81,81,81,81,81,81,"string, second: number) {
      return first === second
    }
  ]",number,9561f88ffc8f31e9c7d0151d058ab8d7dc194fb3,"<fim_prefix>
const literalTypes = () => {
  let places: 'sea' | 'mountain';
  let numbers: 5 | 4 | 3 | 2 | 1;
  
  type Mixed = string | number
  const age1: Mixed = 25
  const age2: Mixed = '25'

  places = 'sea';
  places = 'mountain';

  // numbers = 10;
  numbers = 3
  numbers = 1
}

const restType = () => {
  const myCollections: string[] = ['1', '2', '3']

  const myNewCollections = [
    ...myCollections,
    '4',
    '5'
  ]
}

// variadic tuple
const typeTuple = () => {
  const myTup: [string, boolean] = ['John', true]
  
  const anotherTup: [string, number, (a, b) => boolean] = [
    'john',
    18,
    function (first: <fim_suffix>, second) {
      return (first + second) % 10 === 0
    }
  ]

  type RestAndBool = [...any[], boolean]
  const restAndBool: RestAndBool = [
    true,
    1,
    2,
    'as',
    true,
  ]

  type StringAndRest = [string, ...any[]]
  const stringAndRest: StringAndRest = [
    '1',
    '2',
    true,
  ]
}

const typeArrayFunction = () => {
  // @ts-ignore
  const arrFns: [() => string] = [
    () => {
      return 'valid'
    },
    (a, b) => {
      const h = a + b
      return a + b as unknown as string
    }
  ]

  const arrFns2: Array<() => string> = [
    () => {
      return 'valid'
    },
  ]

  const objFn: { () }[] = [
    () => 'still ok',
    () => {
      return 'also ok'
    },
  ]
}

const fnJSONType = () => {
  const myJson: { [key: string]: any } = {
    abc: 'foo',
    def: 'bar',
    num: 123
  }
}<fim_middle>",incorrect,404
82,82,82,82,82,82,82,82,"string) => boolean] = [
    'John',
    18,",number,9561f88ffc8f31e9c7d0151d058ab8d7dc194fb3,"<fim_prefix>
const literalTypes = () => {
  let places: 'sea' | 'mountain';
  let numbers: 5 | 4 | 3 | 2 | 1;
  
  type Mixed = string | number
  const age1: Mixed = 25
  const age2: Mixed = '25'

  places = 'sea';
  places = 'mountain';

  // numbers = 10;
  numbers = 3
  numbers = 1
}

const restType = () => {
  const myCollections: string[] = ['1', '2', '3']

  const myNewCollections = [
    ...myCollections,
    '4',
    '5'
  ]
}

// variadic tuple
const typeTuple = () => {
  const myTup: [string, boolean] = ['John', true]
  
  const anotherTup: [string, number, (a: <fim_suffix>, b) => boolean] = [
    'john',
    18,
    function (first, second) {
      return (first + second) % 10 === 0
    }
  ]

  type RestAndBool = [...any[], boolean]
  const restAndBool: RestAndBool = [
    true,
    1,
    2,
    'as',
    true,
  ]

  type StringAndRest = [string, ...any[]]
  const stringAndRest: StringAndRest = [
    '1',
    '2',
    true,
  ]
}

const typeArrayFunction = () => {
  // @ts-ignore
  const arrFns: [() => string] = [
    () => {
      return 'valid'
    },
    (a, b) => {
      const h = a + b
      return a + b as unknown as string
    }
  ]

  const arrFns2: Array<() => string> = [
    () => {
      return 'valid'
    },
  ]

  const objFn: { () }[] = [
    () => 'still ok',
    () => {
      return 'also ok'
    },
  ]
}

const fnJSONType = () => {
  const myJson: { [key: string]: any } = {
    abc: 'foo',
    def: 'bar',
    num: 123
  }
}<fim_middle>",incorrect,406
83,83,83,83,83,83,83,83,Date,number,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date): <fim_suffix> {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date) {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",incorrect,700
84,84,84,84,84,84,84,84,string,number,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l) => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l): <fim_suffix> =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",incorrect,771
85,85,85,85,85,85,85,85,"Rgb => {
	if (t < 0) t += 1",number,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t): <fim_suffix> => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l) => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",incorrect,787
86,86,86,86,86,86,86,86,"any) {
    var keys = [];
    for (var key in obj)",object,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj:: <fim_suffix> hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",incorrect,1054
87,87,87,87,87,87,87,87,"any) => {
        let eventArr:Array<any> = this.",object,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data: <fim_suffix>)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",incorrect,2313
88,88,88,88,88,88,88,88,any,object,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet: <fim_suffix>)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",incorrect,2324
89,89,89,89,89,89,89,89,"number | string;
    };
  type ObjectCoercibleNotSymbol = primitive",primitive,54795a90e2bd17f0016b0a39e21d9821b144d333,"<fim_prefix>/// <reference no-default-lib=""true""/>
/// <reference lib=""es6"" />

(function () {
  type primitiveObject = boolean | number | string;
  type primitive = primitiveObject | null | undefined;
  type ObjectCoercible = primitiveObject | {
      toString ();
    } | {
      valueOf (): <fim_suffix>;
    };
  type anyNotSymbol = ObjectCoercible | null | undefined;
  interface StandardString {
    endsWith? (this, searchString, pos?);
    endsWith? (this, searchString?, pos?);
    includes? (this, searchString, pos?);
    includes? (this, searchString?, pos?);
    startsWith? (this, searchString, pos?);
    startsWith? (this, searchString?, pos?);
  }

  const symMatch = typeof Symbol === ""function"" && typeof Symbol.match === ""symbol"" &&
                    (Symbol.match as symbol | string as ""Symbol(Symbol.match)""),
  // eslint-disable-next-line id-denylist
  StrCls = String as StringConstructor & { readonly prototype: StandardString }, TECls = TypeError,
  StrProto = StrCls.prototype,
  toStr = Object.prototype.toString;

  """".startsWith || (
  StrProto.startsWith = function startsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""startsWith""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    return a.lastIndexOf(b, c) === c;
  });

  """".endsWith || (
  StrProto.endsWith = function endsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""endsWith""));
    }
    let b = StrCls(searchString), args = arguments, u: undefined, c: number
      , p: primitive | object = args.length > 1 ? args[1] : u, l = a.length;
    c = (p === u ? l : (c = +<number | string> p) > 0 ? c | 0 : 0) - b.length;
    c > l && (c = l);
    return c >= 0 && a.indexOf(b, c) === c;
  });

  """".includes || (
  StrProto.includes = function includes(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""includes""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    // eslint-disable-next-line @typescript-eslint/prefer-includes
    return a.indexOf(b, c) >= 0;
  });

  function check(a, b) {
    /** note: should never call `valueOf` or `toString` on a / b */
    if (a == null) { return ""String.prototype.${func} called on null or undefined""; }
    if (!b) { return 0; }
    let t: 0 | 1 | 2 = typeof a === ""symbol"" ? 1 : typeof b === ""symbol"" ? 2 : 0;
    if (t) { return t; }
    interface PossibleTypeOfB {
      [key: string]: ((this, re) => boolean) | primitive;
    }
    let f: PossibleTypeOfB[string], u: undefined
      , i = symMatch && (f = (b as PossibleTypeOfB)[symMatch]) !== u ? f
          : toStr.call(b) === ""[object RegExp]"";
    return i ? ""First argument to String.prototype.${func} must not be a regular expression"" : 0;
  }
})();
<fim_middle>",incorrect,4609
90,90,90,90,90,90,90,90,string,primitive,54795a90e2bd17f0016b0a39e21d9821b144d333,"<fim_prefix>/// <reference no-default-lib=""true""/>
/// <reference lib=""es6"" />

(function () {
  type primitiveObject = boolean | number | string;
  type primitive = primitiveObject | null | undefined;
  type ObjectCoercible = primitiveObject | {
      toString (): <fim_suffix>;
    } | {
      valueOf ();
    };
  type anyNotSymbol = ObjectCoercible | null | undefined;
  interface StandardString {
    endsWith? (this, searchString, pos?);
    endsWith? (this, searchString?, pos?);
    includes? (this, searchString, pos?);
    includes? (this, searchString?, pos?);
    startsWith? (this, searchString, pos?);
    startsWith? (this, searchString?, pos?);
  }

  const symMatch = typeof Symbol === ""function"" && typeof Symbol.match === ""symbol"" &&
                    (Symbol.match as symbol | string as ""Symbol(Symbol.match)""),
  // eslint-disable-next-line id-denylist
  StrCls = String as StringConstructor & { readonly prototype: StandardString }, TECls = TypeError,
  StrProto = StrCls.prototype,
  toStr = Object.prototype.toString;

  """".startsWith || (
  StrProto.startsWith = function startsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""startsWith""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    return a.lastIndexOf(b, c) === c;
  });

  """".endsWith || (
  StrProto.endsWith = function endsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""endsWith""));
    }
    let b = StrCls(searchString), args = arguments, u: undefined, c: number
      , p: primitive | object = args.length > 1 ? args[1] : u, l = a.length;
    c = (p === u ? l : (c = +<number | string> p) > 0 ? c | 0 : 0) - b.length;
    c > l && (c = l);
    return c >= 0 && a.indexOf(b, c) === c;
  });

  """".includes || (
  StrProto.includes = function includes(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""includes""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    // eslint-disable-next-line @typescript-eslint/prefer-includes
    return a.indexOf(b, c) >= 0;
  });

  function check(a, b) {
    /** note: should never call `valueOf` or `toString` on a / b */
    if (a == null) { return ""String.prototype.${func} called on null or undefined""; }
    if (!b) { return 0; }
    let t: 0 | 1 | 2 = typeof a === ""symbol"" ? 1 : typeof b === ""symbol"" ? 2 : 0;
    if (t) { return t; }
    interface PossibleTypeOfB {
      [key: string]: ((this, re) => boolean) | primitive;
    }
    let f: PossibleTypeOfB[string], u: undefined
      , i = symMatch && (f = (b as PossibleTypeOfB)[symMatch]) !== u ? f
          : toStr.call(b) === ""[object RegExp]"";
    return i ? ""First argument to String.prototype.${func} must not be a regular expression"" : 0;
  }
})();
<fim_middle>",incorrect,4610
91,91,91,91,91,91,91,91,JSX.Element,string,5ee8da532cd90e4925e467deb8769a2f6b51a942,"<fim_prefix>type TimeCalculatorPropsType = {
  createdAt: Date
}

const TimeCalculator = ({ createdAt }): <fim_suffix> => {
  const createdDate: Date = new Date(createdAt)
  const nowDate: Date = new Date()

  const months = [
    'January',
    'February',
    'March',
    'April',
    'May',
    'June',
    'July',
    'August',
    'September',
    'October',
    'November',
    'December'
  ]

  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']

  const milisecond: number = nowDate.valueOf() - createdDate.valueOf()
  const second = milisecond / 1000
  const minute = second / 60
  const hour = minute / 60
  const day = hour / 24

  if (second < 1) {
    return 'now'
  }

  if (
    Math.floor(minute) === 0 &&
    Math.floor(hour) === 0 &&
    Math.floor(day) === 0
  ) {
    return Math.round(second) === 1
      ? `${Math.round(second)} second ago`
      : `${Math.round(second)} seconds ago`
  }

  if (Math.floor(day) === 0 && Math.floor(hour) === 0) {
    return Math.round(minute) === 1
      ? `${Math.round(minute)} minute ago`
      : `${Math.round(minute)} minutes ago`
  }

  if (Math.floor(day) === 0) {
    return Math.round(hour) === 1
      ? `${Math.round(hour)} hour ago`
      : `${Math.round(hour)} hours ago`
  }

  if (Math.round(day) < 7) {
    return Math.round(day) === 1
      ? `${Math.round(day)} day ago`
      : `${Math.round(day)} days ago`
  }

  const dayName = days[createdDate.getDay()]
  const date = createdDate.getDate()
  const monthName = months[createdDate.getMonth()]
  const createdYear =
    createdDate.getFullYear() === nowDate.getFullYear()
      ? ''
      : createdDate.getFullYear()
  const createdTime = createdDate.toLocaleTimeString([], {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false
  })

  return `${createdTime} · ${dayName}, ${date} ${monthName} ${createdYear}`
}

export default TimeCalculator
<fim_middle>",incorrect,48
92,92,92,92,92,92,92,92,number,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount: <fim_suffix>,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",incorrect,677
93,93,93,93,93,93,93,93,number,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount: <fim_suffix>,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",incorrect,681
94,94,94,94,94,94,94,94,TypeAmount,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount: <fim_suffix>,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",incorrect,686
95,95,95,95,95,95,95,95,"'0',
  dataEntry: '{}',
  nstime: '0",string,b6c4e1fb10e5beed8368e9e86826f11e965be6f5,"<fim_prefix>const DFG_VERSION = '0.18.1';

export enum QueryDetail {
  LABEL = 'LABEL',
  SKELETON = 'SKELETON',
  SUMMARY = 'SUMMARY',
  FULL = 'FULL',
}

export enum VariableType {
  POINT2 = 'RoME.Point2',
  POSE2 = 'RoME.Pose2',
}

export type Variable = {
  label: string;
  dataEntry: string;
  nstime: string;
  variableType: string;
  dataEntryType: string;
  ppeDict: string;
  solverDataDict: string;
  smallData: string;
  solvable: number;
  tags: string;
  timestamp: string;
  _version: string;
};

export function Variable(
  label,
  type,
  tags = ['VARIABLE'],
  timestamp: <fim_suffix> = new Date().toISOString(),
) {
  const solverDataDict = {
    default: {
      vecval: [
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      ],
      dimval: 3,
      vecbw: [0.0, 0.0, 0.0],
      dimbw: 3,
      BayesNetOutVertIDs: [],
      dimIDs: [0, 1, 2],
      dims: 3,
      eliminated: false,
      BayesNetVertID: '_null',
      separator: [],
      variableType: type,
      initialized: false,
      infoPerCoord: [0.0, 0.0, 0.0],
      ismargin: false,
      dontmargin: false,
      solveInProgress: 0,
      solvedCount: 0,
      solveKey: 'default',
    },
  };
  const result: Variable = {
    label,
    dataEntry: '{}',
    nstime: '0',
    variableType: type,
    dataEntryType: '{}',
    ppeDict: '{}',
    solverDataDict: JSON.stringify(solverDataDict),
    smallData: '{}',
    solvable: 1,
    tags: JSON.stringify(tags),
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",incorrect,1024
96,96,96,96,96,96,96,96,"VariableType,
  dataEntry = '{}',
  nstime = '0",string,b6c4e1fb10e5beed8368e9e86826f11e965be6f5,"<fim_prefix>const DFG_VERSION = '0.18.1';

export enum QueryDetail {
  LABEL = 'LABEL',
  SKELETON = 'SKELETON',
  SUMMARY = 'SUMMARY',
  FULL = 'FULL',
}

export enum VariableType {
  POINT2 = 'RoME.Point2',
  POSE2 = 'RoME.Pose2',
}

export type Variable = {
  label: string;
  dataEntry: string;
  nstime: string;
  variableType: string;
  dataEntryType: string;
  ppeDict: string;
  solverDataDict: string;
  smallData: string;
  solvable: number;
  tags: string;
  timestamp: string;
  _version: string;
};

export function Variable(
  label,
  type: <fim_suffix>,
  tags = ['VARIABLE'],
  timestamp = new Date().toISOString(),
) {
  const solverDataDict = {
    default: {
      vecval: [
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      ],
      dimval: 3,
      vecbw: [0.0, 0.0, 0.0],
      dimbw: 3,
      BayesNetOutVertIDs: [],
      dimIDs: [0, 1, 2],
      dims: 3,
      eliminated: false,
      BayesNetVertID: '_null',
      separator: [],
      variableType: type,
      initialized: false,
      infoPerCoord: [0.0, 0.0, 0.0],
      ismargin: false,
      dontmargin: false,
      solveInProgress: 0,
      solvedCount: 0,
      solveKey: 'default',
    },
  };
  const result: Variable = {
    label,
    dataEntry: '{}',
    nstime: '0',
    variableType: type,
    dataEntryType: '{}',
    ppeDict: '{}',
    solverDataDict: JSON.stringify(solverDataDict),
    smallData: '{}',
    solvable: 1,
    tags: JSON.stringify(tags),
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",incorrect,1026
97,97,97,97,97,97,97,97,"PropertyKey,
    type?,
    newVal?
) {
    if (!active",symbol,be6ce21d863494461463ab50a0cb4150d8233268,"<fim_prefix>export type EffectOptions = {
    scheduler?: (fn) => void;
    lazy?: boolean;
};
export type EffectFunction<T> = {
    ();
    deps: Set<Function>[];
    options?: EffectOptions;
};
export type TriggerType = ""ADD"" | ""SET"" | ""DELETE"";
export type TriggrtFunction = (
    target,
    key,
    ITERATE_KEY?,
    MAP_KEY_ITERATE_KEY?,
    type?,
    newVal?
) => void;

let activeEffect: undefined | EffectFunction<any>;
const bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();
const effectStack: EffectFunction<any>[] = [];

export function effect<T>(fn, options?) {
    const effectFn: EffectFunction<T> = () => {
        // 清除之前的effect
        cleanup(effectFn);
        activeEffect = effectFn;
        // 压入栈中
        effectStack.push(effectFn);
        const res = fn();
        effectStack.pop();
        activeEffect = effectStack[effectStack.length - 1];
        return res;
    };
    effectFn.deps = [] as Set<Function>[];
    effectFn.options = options;
    if (!options?.lazy) {
        effectFn();
    }
    return effectFn;
}

/**
 * 清除之前的绑定，用于刷新绑定effect
 * 可解决分支切换问题、比如三元
 * @param effectFn
 */
function cleanup<T>(effectFn) {
    for (let index = 0; index < effectFn.deps.length; index++) {
        const deps = effectFn.deps[index];
        deps.delete(effectFn);
    }
    effectFn.deps.length = 0;
}

export function track(target, key) {
    if (!activeEffect) return;
    // data or props
    let depsMap = bucket.get(target);
    if (!depsMap) {
        bucket.set(target, (depsMap = new Map()));
    }
    // 属性值对应的set，set里可能存在多个effect函数
    let deps: Set<EffectFunction<any>> | undefined = depsMap.get(key);
    if (!deps) {
        depsMap.set(key, (deps = new Set()));
    }
    // 属性对应的effect函数、effect可能存在多个、同个则覆盖
    deps.add(activeEffect);
    // 将当前effect添加依赖的effect
    activeEffect.deps.push(deps);
}

export function trigger(
    target,
    key,
    ITERATE_KEY?,
    MAP_KEY_ITERATE_KEY?: <fim_suffix>,
    type?,
    newVal?
) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;
    // 获取对应值的所有 effects
    const effects: Set<EffectFunction<any>> | undefined = depsMap.get(key);

    // 取得与ITERATE_KEY关联的副作用函数
    let iterateEffects: Set<EffectFunction<any>> | undefined;
    if (ITERATE_KEY) {
        iterateEffects = depsMap.get(ITERATE_KEY);
    }

    let mapKeyIterateEffects: Set<EffectFunction<any>> | undefined;
    if (MAP_KEY_ITERATE_KEY) {
        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);
    }

    // 分支--防止无限循环
    const effectsToRun = new Set<EffectFunction<any>>();

    effects &&
        effects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    // set
    if (
        target instanceof Set &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // map
    if (
        target instanceof Map &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    if (
        target instanceof Map &&
        (type === ""ADD"" || type === ""DELETE"")
    ) {
        MAP_KEY_ITERATE_KEY &&
            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&
            mapKeyIterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // array
    if (type === ""ADD"" && Array.isArray(target)) {
        const lengthEffects = depsMap.get(""length"");
        lengthEffects &&
            lengthEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }
    if (Array.isArray(target) && key === ""length"") {
        depsMap.forEach((effects, key) => {
            if ((key as number) >= (newVal as number)) {
                effects.forEach(effectFn => {
                    if (activeEffect !== effectFn) {
                        effectsToRun.add(effectFn);
                    }
                });
            }
        });
    }

    // object
    (type === ""ADD"" || type === ""DELETE"") &&
        iterateEffects &&
        iterateEffects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    effectsToRun.forEach(effectFn => {
        // 调度器执行
        if (effectFn?.options?.scheduler) {
            effectFn?.options.scheduler(effectFn);
        } else {
            effectFn();
        }
    });
}
<fim_middle>",incorrect,4804
98,98,98,98,98,98,98,98,"PropertyKey,
    MAP_KEY_ITERATE_KEY?: PropertyKey,",symbol,be6ce21d863494461463ab50a0cb4150d8233268,"<fim_prefix>export type EffectOptions = {
    scheduler?: (fn) => void;
    lazy?: boolean;
};
export type EffectFunction<T> = {
    ();
    deps: Set<Function>[];
    options?: EffectOptions;
};
export type TriggerType = ""ADD"" | ""SET"" | ""DELETE"";
export type TriggrtFunction = (
    target,
    key,
    ITERATE_KEY?,
    MAP_KEY_ITERATE_KEY?,
    type?,
    newVal?
) => void;

let activeEffect: undefined | EffectFunction<any>;
const bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();
const effectStack: EffectFunction<any>[] = [];

export function effect<T>(fn, options?) {
    const effectFn: EffectFunction<T> = () => {
        // 清除之前的effect
        cleanup(effectFn);
        activeEffect = effectFn;
        // 压入栈中
        effectStack.push(effectFn);
        const res = fn();
        effectStack.pop();
        activeEffect = effectStack[effectStack.length - 1];
        return res;
    };
    effectFn.deps = [] as Set<Function>[];
    effectFn.options = options;
    if (!options?.lazy) {
        effectFn();
    }
    return effectFn;
}

/**
 * 清除之前的绑定，用于刷新绑定effect
 * 可解决分支切换问题、比如三元
 * @param effectFn
 */
function cleanup<T>(effectFn) {
    for (let index = 0; index < effectFn.deps.length; index++) {
        const deps = effectFn.deps[index];
        deps.delete(effectFn);
    }
    effectFn.deps.length = 0;
}

export function track(target, key) {
    if (!activeEffect) return;
    // data or props
    let depsMap = bucket.get(target);
    if (!depsMap) {
        bucket.set(target, (depsMap = new Map()));
    }
    // 属性值对应的set，set里可能存在多个effect函数
    let deps: Set<EffectFunction<any>> | undefined = depsMap.get(key);
    if (!deps) {
        depsMap.set(key, (deps = new Set()));
    }
    // 属性对应的effect函数、effect可能存在多个、同个则覆盖
    deps.add(activeEffect);
    // 将当前effect添加依赖的effect
    activeEffect.deps.push(deps);
}

export function trigger(
    target,
    key,
    ITERATE_KEY?: <fim_suffix>,
    MAP_KEY_ITERATE_KEY?,
    type?,
    newVal?
) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;
    // 获取对应值的所有 effects
    const effects: Set<EffectFunction<any>> | undefined = depsMap.get(key);

    // 取得与ITERATE_KEY关联的副作用函数
    let iterateEffects: Set<EffectFunction<any>> | undefined;
    if (ITERATE_KEY) {
        iterateEffects = depsMap.get(ITERATE_KEY);
    }

    let mapKeyIterateEffects: Set<EffectFunction<any>> | undefined;
    if (MAP_KEY_ITERATE_KEY) {
        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);
    }

    // 分支--防止无限循环
    const effectsToRun = new Set<EffectFunction<any>>();

    effects &&
        effects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    // set
    if (
        target instanceof Set &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // map
    if (
        target instanceof Map &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    if (
        target instanceof Map &&
        (type === ""ADD"" || type === ""DELETE"")
    ) {
        MAP_KEY_ITERATE_KEY &&
            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&
            mapKeyIterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // array
    if (type === ""ADD"" && Array.isArray(target)) {
        const lengthEffects = depsMap.get(""length"");
        lengthEffects &&
            lengthEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }
    if (Array.isArray(target) && key === ""length"") {
        depsMap.forEach((effects, key) => {
            if ((key as number) >= (newVal as number)) {
                effects.forEach(effectFn => {
                    if (activeEffect !== effectFn) {
                        effectsToRun.add(effectFn);
                    }
                });
            }
        });
    }

    // object
    (type === ""ADD"" || type === ""DELETE"") &&
        iterateEffects &&
        iterateEffects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    effectsToRun.forEach(effectFn => {
        // 调度器执行
        if (effectFn?.options?.scheduler) {
            effectFn?.options.scheduler(effectFn);
        } else {
            effectFn();
        }
    });
}
<fim_middle>",incorrect,4805
99,99,99,99,99,99,99,99,"PropertyKey,
    type?,
    newVal?
) => void;
export",symbol,be6ce21d863494461463ab50a0cb4150d8233268,"<fim_prefix>export type EffectOptions = {
    scheduler?: (fn) => void;
    lazy?: boolean;
};
export type EffectFunction<T> = {
    ();
    deps: Set<Function>[];
    options?: EffectOptions;
};
export type TriggerType = ""ADD"" | ""SET"" | ""DELETE"";
export type TriggrtFunction = (
    target,
    key,
    ITERATE_KEY?,
    MAP_KEY_ITERATE_KEY?: <fim_suffix>,
    type?,
    newVal?
) => void;

let activeEffect: undefined | EffectFunction<any>;
const bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();
const effectStack: EffectFunction<any>[] = [];

export function effect<T>(fn, options?) {
    const effectFn: EffectFunction<T> = () => {
        // 清除之前的effect
        cleanup(effectFn);
        activeEffect = effectFn;
        // 压入栈中
        effectStack.push(effectFn);
        const res = fn();
        effectStack.pop();
        activeEffect = effectStack[effectStack.length - 1];
        return res;
    };
    effectFn.deps = [] as Set<Function>[];
    effectFn.options = options;
    if (!options?.lazy) {
        effectFn();
    }
    return effectFn;
}

/**
 * 清除之前的绑定，用于刷新绑定effect
 * 可解决分支切换问题、比如三元
 * @param effectFn
 */
function cleanup<T>(effectFn) {
    for (let index = 0; index < effectFn.deps.length; index++) {
        const deps = effectFn.deps[index];
        deps.delete(effectFn);
    }
    effectFn.deps.length = 0;
}

export function track(target, key) {
    if (!activeEffect) return;
    // data or props
    let depsMap = bucket.get(target);
    if (!depsMap) {
        bucket.set(target, (depsMap = new Map()));
    }
    // 属性值对应的set，set里可能存在多个effect函数
    let deps: Set<EffectFunction<any>> | undefined = depsMap.get(key);
    if (!deps) {
        depsMap.set(key, (deps = new Set()));
    }
    // 属性对应的effect函数、effect可能存在多个、同个则覆盖
    deps.add(activeEffect);
    // 将当前effect添加依赖的effect
    activeEffect.deps.push(deps);
}

export function trigger(
    target,
    key,
    ITERATE_KEY?,
    MAP_KEY_ITERATE_KEY?,
    type?,
    newVal?
) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;
    // 获取对应值的所有 effects
    const effects: Set<EffectFunction<any>> | undefined = depsMap.get(key);

    // 取得与ITERATE_KEY关联的副作用函数
    let iterateEffects: Set<EffectFunction<any>> | undefined;
    if (ITERATE_KEY) {
        iterateEffects = depsMap.get(ITERATE_KEY);
    }

    let mapKeyIterateEffects: Set<EffectFunction<any>> | undefined;
    if (MAP_KEY_ITERATE_KEY) {
        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);
    }

    // 分支--防止无限循环
    const effectsToRun = new Set<EffectFunction<any>>();

    effects &&
        effects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    // set
    if (
        target instanceof Set &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // map
    if (
        target instanceof Map &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    if (
        target instanceof Map &&
        (type === ""ADD"" || type === ""DELETE"")
    ) {
        MAP_KEY_ITERATE_KEY &&
            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&
            mapKeyIterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // array
    if (type === ""ADD"" && Array.isArray(target)) {
        const lengthEffects = depsMap.get(""length"");
        lengthEffects &&
            lengthEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }
    if (Array.isArray(target) && key === ""length"") {
        depsMap.forEach((effects, key) => {
            if ((key as number) >= (newVal as number)) {
                effects.forEach(effectFn => {
                    if (activeEffect !== effectFn) {
                        effectsToRun.add(effectFn);
                    }
                });
            }
        });
    }

    // object
    (type === ""ADD"" || type === ""DELETE"") &&
        iterateEffects &&
        iterateEffects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    effectsToRun.forEach(effectFn => {
        // 调度器执行
        if (effectFn?.options?.scheduler) {
            effectFn?.options.scheduler(effectFn);
        } else {
            effectFn();
        }
    });
}
<fim_middle>",incorrect,4815
100,100,100,100,100,100,100,100,PropertyKey,symbol,be6ce21d863494461463ab50a0cb4150d8233268,"<fim_prefix>export type EffectOptions = {
    scheduler?: (fn) => void;
    lazy?: boolean;
};
export type EffectFunction<T> = {
    ();
    deps: Set<Function>[];
    options?: EffectOptions;
};
export type TriggerType = ""ADD"" | ""SET"" | ""DELETE"";
export type TriggrtFunction = (
    target,
    key,
    ITERATE_KEY?: <fim_suffix>,
    MAP_KEY_ITERATE_KEY?,
    type?,
    newVal?
) => void;

let activeEffect: undefined | EffectFunction<any>;
const bucket = new WeakMap<any, Map<PropertyKey, Set<EffectFunction<any>>>>();
const effectStack: EffectFunction<any>[] = [];

export function effect<T>(fn, options?) {
    const effectFn: EffectFunction<T> = () => {
        // 清除之前的effect
        cleanup(effectFn);
        activeEffect = effectFn;
        // 压入栈中
        effectStack.push(effectFn);
        const res = fn();
        effectStack.pop();
        activeEffect = effectStack[effectStack.length - 1];
        return res;
    };
    effectFn.deps = [] as Set<Function>[];
    effectFn.options = options;
    if (!options?.lazy) {
        effectFn();
    }
    return effectFn;
}

/**
 * 清除之前的绑定，用于刷新绑定effect
 * 可解决分支切换问题、比如三元
 * @param effectFn
 */
function cleanup<T>(effectFn) {
    for (let index = 0; index < effectFn.deps.length; index++) {
        const deps = effectFn.deps[index];
        deps.delete(effectFn);
    }
    effectFn.deps.length = 0;
}

export function track(target, key) {
    if (!activeEffect) return;
    // data or props
    let depsMap = bucket.get(target);
    if (!depsMap) {
        bucket.set(target, (depsMap = new Map()));
    }
    // 属性值对应的set，set里可能存在多个effect函数
    let deps: Set<EffectFunction<any>> | undefined = depsMap.get(key);
    if (!deps) {
        depsMap.set(key, (deps = new Set()));
    }
    // 属性对应的effect函数、effect可能存在多个、同个则覆盖
    deps.add(activeEffect);
    // 将当前effect添加依赖的effect
    activeEffect.deps.push(deps);
}

export function trigger(
    target,
    key,
    ITERATE_KEY?,
    MAP_KEY_ITERATE_KEY?,
    type?,
    newVal?
) {
    const depsMap = bucket.get(target);
    if (!depsMap) return;
    // 获取对应值的所有 effects
    const effects: Set<EffectFunction<any>> | undefined = depsMap.get(key);

    // 取得与ITERATE_KEY关联的副作用函数
    let iterateEffects: Set<EffectFunction<any>> | undefined;
    if (ITERATE_KEY) {
        iterateEffects = depsMap.get(ITERATE_KEY);
    }

    let mapKeyIterateEffects: Set<EffectFunction<any>> | undefined;
    if (MAP_KEY_ITERATE_KEY) {
        mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);
    }

    // 分支--防止无限循环
    const effectsToRun = new Set<EffectFunction<any>>();

    effects &&
        effects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    // set
    if (
        target instanceof Set &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // map
    if (
        target instanceof Map &&
        (type === ""SET"" || type === ""ADD"" || type === ""DELETE"")
    ) {
        ITERATE_KEY &&
            (iterateEffects = depsMap.get(ITERATE_KEY)) &&
            iterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    if (
        target instanceof Map &&
        (type === ""ADD"" || type === ""DELETE"")
    ) {
        MAP_KEY_ITERATE_KEY &&
            (mapKeyIterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)) &&
            mapKeyIterateEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }

    // array
    if (type === ""ADD"" && Array.isArray(target)) {
        const lengthEffects = depsMap.get(""length"");
        lengthEffects &&
            lengthEffects.forEach(effectFn => {
                if (activeEffect !== effectFn) {
                    effectsToRun.add(effectFn);
                }
            });
    }
    if (Array.isArray(target) && key === ""length"") {
        depsMap.forEach((effects, key) => {
            if ((key as number) >= (newVal as number)) {
                effects.forEach(effectFn => {
                    if (activeEffect !== effectFn) {
                        effectsToRun.add(effectFn);
                    }
                });
            }
        });
    }

    // object
    (type === ""ADD"" || type === ""DELETE"") &&
        iterateEffects &&
        iterateEffects.forEach(effectFn => {
            if (activeEffect !== effectFn) {
                effectsToRun.add(effectFn);
            }
        });

    effectsToRun.forEach(effectFn => {
        // 调度器执行
        if (effectFn?.options?.scheduler) {
            effectFn?.options.scheduler(effectFn);
        } else {
            effectFn();
        }
    });
}
<fim_middle>",incorrect,4816
101,101,101,101,101,101,101,101,void,undefined,26077dd04ed537e87974d0ea6dd3e9721b850057,"<fim_prefix>//https://dev.to/shinshin86/a-mock-of-localstorage-written-in-typescript-2680
type Store = any;

export class LocalStorageMock {
    store: Store;
    length: number;

    constructor() {
        this.store = {};
        this.length = 0;
    }

    key(n) {
        if (typeof n === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""key"" on ""Storage"": 1 argument required, but only 0 present.',
            );
        }

        if (n >= Object.keys(this.store).length) {
            return null;
        }

        return Object.keys(this.store)[n];
    }

    getItem(key) {
        if (!Object.keys(this.store).includes(key)) {
            return null;
        }

        return this.store[key];
    }

    setItem(key, value) {
        if (typeof key === 'undefined' && typeof value === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""setItem"" on ""Storage"": 2 arguments required, but only 0 present.',
            );
        }

        if (typeof value === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""setItem"" on ""Storage"": 2 arguments required, but only 1 present.',
            );
        }

        if (!key) return undefined;

        this.store[key] = value.toString() || '';
        this.length = Object.keys(this.store).length;

        return undefined;
    }

    removeItem(key) {
        if (typeof key === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""removeItem"" on ""Storage"": 1 argument required, but only 0 present.',
            );
        }

        delete this.store[key];
        this.length = Object.keys(this.store).length;
        return undefined;
    }

    clear(): <fim_suffix> {
        this.store = {};
        this.length = 0;

        return undefined;
    }
}

export const getLocalStorageMock = () => {
    return new LocalStorageMock();
};
<fim_middle>",incorrect,4733
102,102,102,102,102,102,102,102,any,undefined,26077dd04ed537e87974d0ea6dd3e9721b850057,"<fim_prefix>//https://dev.to/shinshin86/a-mock-of-localstorage-written-in-typescript-2680
type Store = any;

export class LocalStorageMock {
    store: Store;
    length: number;

    constructor() {
        this.store = {};
        this.length = 0;
    }

    key(n) {
        if (typeof n === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""key"" on ""Storage"": 1 argument required, but only 0 present.',
            );
        }

        if (n >= Object.keys(this.store).length) {
            return null;
        }

        return Object.keys(this.store)[n];
    }

    getItem(key) {
        if (!Object.keys(this.store).includes(key)) {
            return null;
        }

        return this.store[key];
    }

    setItem(key, value) {
        if (typeof key === 'undefined' && typeof value === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""setItem"" on ""Storage"": 2 arguments required, but only 0 present.',
            );
        }

        if (typeof value === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""setItem"" on ""Storage"": 2 arguments required, but only 1 present.',
            );
        }

        if (!key) return undefined;

        this.store[key] = value.toString() || '';
        this.length = Object.keys(this.store).length;

        return undefined;
    }

    removeItem(key): <fim_suffix> {
        if (typeof key === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""removeItem"" on ""Storage"": 1 argument required, but only 0 present.',
            );
        }

        delete this.store[key];
        this.length = Object.keys(this.store).length;
        return undefined;
    }

    clear() {
        this.store = {};
        this.length = 0;

        return undefined;
    }
}

export const getLocalStorageMock = () => {
    return new LocalStorageMock();
};
<fim_middle>",incorrect,4734
103,103,103,103,103,103,103,103,any,undefined,26077dd04ed537e87974d0ea6dd3e9721b850057,"<fim_prefix>//https://dev.to/shinshin86/a-mock-of-localstorage-written-in-typescript-2680
type Store = any;

export class LocalStorageMock {
    store: Store;
    length: number;

    constructor() {
        this.store = {};
        this.length = 0;
    }

    key(n) {
        if (typeof n === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""key"" on ""Storage"": 1 argument required, but only 0 present.',
            );
        }

        if (n >= Object.keys(this.store).length) {
            return null;
        }

        return Object.keys(this.store)[n];
    }

    getItem(key) {
        if (!Object.keys(this.store).includes(key)) {
            return null;
        }

        return this.store[key];
    }

    setItem(key, value): <fim_suffix> {
        if (typeof key === 'undefined' && typeof value === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""setItem"" on ""Storage"": 2 arguments required, but only 0 present.',
            );
        }

        if (typeof value === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""setItem"" on ""Storage"": 2 arguments required, but only 1 present.',
            );
        }

        if (!key) return undefined;

        this.store[key] = value.toString() || '';
        this.length = Object.keys(this.store).length;

        return undefined;
    }

    removeItem(key) {
        if (typeof key === 'undefined') {
            throw new Error(
                'Uncaught TypeError: Failed to execute ""removeItem"" on ""Storage"": 1 argument required, but only 0 present.',
            );
        }

        delete this.store[key];
        this.length = Object.keys(this.store).length;
        return undefined;
    }

    clear() {
        this.store = {};
        this.length = 0;

        return undefined;
    }
}

export const getLocalStorageMock = () => {
    return new LocalStorageMock();
};
<fim_middle>",incorrect,4736
104,104,104,104,104,104,104,104,IResponseAuthorization,unknown,1d39ec473347edb072e37f629ad2a9736fad5a7a,"<fim_prefix>export const Kind = 'Core#ResponseAuthorization';

export interface IResponseAuthorization {
  kind: typeof Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method: string;
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;
}

export class ResponseAuthorization {
  kind = Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method = 'unknown';
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;

  /**
   * @param input The response authorization definition used to restore the state.
   */
  constructor(input?) {
    let init: IResponseAuthorization;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        method: 'unknown',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new response authorization clearing anything that is so far defined.
   * 
   * Note, this throws an error when the object is not a response authorization.
   */
  new(init) {
    if (!ResponseAuthorization.isResponseAuthorization(init)) {
      throw new Error(`Not a response authorization.`);
    }
    const { method, state, headers, challengeHeader } = init;
    this.kind = Kind;
    this.method = method;
    this.state = state;
    this.headers = headers;
    this.challengeHeader = challengeHeader;
  }

  /**
   * Checks whether the input is a definition of a response authorization.
   */
  static isResponseAuthorization(input: <fim_suffix>) {
    const typed = input as IResponseAuthorization;
    if (!input || !typed.method) {
      return false;
    }
    return true;
  }

  toJSON() {
    const result: IResponseAuthorization = {
      kind: Kind,
      method: this.method,
    };
    if (typeof this.state === 'number') {
      result.state = this.state;
    }
    if (this.headers) {
      result.headers = this.headers;
    }
    if (this.challengeHeader) {
      result.challengeHeader = this.challengeHeader;
    }
    return result;
  }
}
<fim_middle>",incorrect,76
105,105,105,105,105,105,105,105,any,unknown,cb14c7a279f215293358730312da69fac60347a7,"<fim_prefix>const isNull =
	(val): val is null =>
		val === null

const isString =
	(val): val is string =>
		typeof val === ""string""

const isBoolean =
	(val): val is boolean =>
		typeof val === ""boolean""

const isUndefined =
	(val: <fim_suffix>): val is undefined =>
		val === undefined

const isUpperCase =
	(x) =>
		x === x.toUpperCase()

const isEmpty =
	(val) =>
		val.length === 0

const normalizeInput =
	(classNames) =>
		classNames
			.map(
				className => {
					if (isBoolean(className) || isNull(className) || isUndefined(className)) {
						return { className: """", remove: true }
					} else if (isString(className)) {
						if (isEmpty(className)) {
							return { className }
						} else if (isUpperCase(className.charAt(0))) {
							return { className, ignore: true }
						} else {
							return { className }
						}
					} else {
						return className
					}
				},
			)

const filterRemove =
	(classNames) =>
		classNames.filter(({ remove }) => !remove)

const mapBEMValues =
	(classNames, componentName) =>
		classNames.map(
			({ ignore, className }) => {
				if (ignore) {
					return className
				} else if (isEmpty(componentName)) {
					return className
				} else if (isEmpty(className)) {
					return componentName
				} else {
					return `${componentName}__${className}`
				}
			},
		)

const joinToString =
	(classNames) => (
		isEmpty(classNames) ?
			undefined :
			classNames.join("" "")
	)

export const createBEM =
	(componentName) =>
		(...classNames) =>
			joinToString(
				mapBEMValues(
					filterRemove(
						normalizeInput(classNames),
					),
					componentName,
				),
			)

export interface BEMClassType {
	remove?: boolean,
	ignore?: boolean,
	className: string,
}

export type BEMInput =
	BEMClassType | string | boolean | undefined | null<fim_middle>",incorrect,728
106,106,106,106,106,106,106,106,,unknown,cb14c7a279f215293358730312da69fac60347a7,"<fim_prefix>const isNull =
	(val): val is null =>
		val === null

const isString =
	(val): val is string =>
		typeof val === ""string""

const isBoolean =
	(val: <fim_suffix>): val is boolean =>
		typeof val === ""boolean""

const isUndefined =
	(val): val is undefined =>
		val === undefined

const isUpperCase =
	(x) =>
		x === x.toUpperCase()

const isEmpty =
	(val) =>
		val.length === 0

const normalizeInput =
	(classNames) =>
		classNames
			.map(
				className => {
					if (isBoolean(className) || isNull(className) || isUndefined(className)) {
						return { className: """", remove: true }
					} else if (isString(className)) {
						if (isEmpty(className)) {
							return { className }
						} else if (isUpperCase(className.charAt(0))) {
							return { className, ignore: true }
						} else {
							return { className }
						}
					} else {
						return className
					}
				},
			)

const filterRemove =
	(classNames) =>
		classNames.filter(({ remove }) => !remove)

const mapBEMValues =
	(classNames, componentName) =>
		classNames.map(
			({ ignore, className }) => {
				if (ignore) {
					return className
				} else if (isEmpty(componentName)) {
					return className
				} else if (isEmpty(className)) {
					return componentName
				} else {
					return `${componentName}__${className}`
				}
			},
		)

const joinToString =
	(classNames) => (
		isEmpty(classNames) ?
			undefined :
			classNames.join("" "")
	)

export const createBEM =
	(componentName) =>
		(...classNames) =>
			joinToString(
				mapBEMValues(
					filterRemove(
						normalizeInput(classNames),
					),
					componentName,
				),
			)

export interface BEMClassType {
	remove?: boolean,
	ignore?: boolean,
	className: string,
}

export type BEMInput =
	BEMClassType | string | boolean | undefined | null<fim_middle>",incorrect,729
107,107,107,107,107,107,107,107,any,unknown,cb14c7a279f215293358730312da69fac60347a7,"<fim_prefix>const isNull =
	(val): val is null =>
		val === null

const isString =
	(val: <fim_suffix>): val is string =>
		typeof val === ""string""

const isBoolean =
	(val): val is boolean =>
		typeof val === ""boolean""

const isUndefined =
	(val): val is undefined =>
		val === undefined

const isUpperCase =
	(x) =>
		x === x.toUpperCase()

const isEmpty =
	(val) =>
		val.length === 0

const normalizeInput =
	(classNames) =>
		classNames
			.map(
				className => {
					if (isBoolean(className) || isNull(className) || isUndefined(className)) {
						return { className: """", remove: true }
					} else if (isString(className)) {
						if (isEmpty(className)) {
							return { className }
						} else if (isUpperCase(className.charAt(0))) {
							return { className, ignore: true }
						} else {
							return { className }
						}
					} else {
						return className
					}
				},
			)

const filterRemove =
	(classNames) =>
		classNames.filter(({ remove }) => !remove)

const mapBEMValues =
	(classNames, componentName) =>
		classNames.map(
			({ ignore, className }) => {
				if (ignore) {
					return className
				} else if (isEmpty(componentName)) {
					return className
				} else if (isEmpty(className)) {
					return componentName
				} else {
					return `${componentName}__${className}`
				}
			},
		)

const joinToString =
	(classNames) => (
		isEmpty(classNames) ?
			undefined :
			classNames.join("" "")
	)

export const createBEM =
	(componentName) =>
		(...classNames) =>
			joinToString(
				mapBEMValues(
					filterRemove(
						normalizeInput(classNames),
					),
					componentName,
				),
			)

export interface BEMClassType {
	remove?: boolean,
	ignore?: boolean,
	className: string,
}

export type BEMInput =
	BEMClassType | string | boolean | undefined | null<fim_middle>",incorrect,730
108,108,108,108,108,108,108,108,"any,
    isStrictCheck = false,
    options?: {
        customTest",unknown,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b: <fim_suffix>,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",incorrect,1031
109,109,109,109,109,109,109,109,"any,
    b: any,
    isStrictCheck?: boolean,
    options",unknown,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a: <fim_suffix>,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",incorrect,1032
110,110,110,110,110,110,110,110,Promise<any>,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",incorrect,59
111,111,111,111,111,111,111,111,Promise<Transaction[]>,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",incorrect,60
112,112,112,112,112,112,112,112,any,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",incorrect,62
113,113,113,113,113,113,113,113,any,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",incorrect,63
114,114,114,114,114,114,114,114,"T) => void

  protected generator!: AsyncGenerator<T>

  protected generator",void,b6bfc45eb561308bc0f3960f3a75e7c4a2d28a90,"<fim_prefix>/**
 * Options for Chan.
 */
export type ChanOpts = {
  /**
   * Yield reject to iterator if the value is rejected in receiver(generator).
   */
  rejectInReceiver?: boolean
}

/**
 * Class reperesenting a channel.
 * @template T - Type of the value that will be send via Channel.
 */
export class Chan<T> {
  protected opts: ChanOpts = { rejectInReceiver: false }
  protected bufSize = 0
  protected buf!: T[]
  protected sendFunc!: (p) => Promise<void>

  protected bufPromise!: Promise<void>
  protected bufResolve!: (value) => void

  protected valuePromise!: Promise<void>
  protected valueResolve!: (value: <fim_suffix>) => void

  protected generatorClosed: boolean = false
  protected closed: boolean = false

  /**
   * Make a channel.
   * @param bufSize - size of buffer in channel.
   * @param opts - options.
   */
  constructor(bufSize = 0, opts = {}) {
    if (opts.rejectInReceiver !== undefined) {
      this.opts.rejectInReceiver = opts.rejectInReceiver
    }
    this.bufSize = bufSize === 0 ? 1 : bufSize // バッファーサイズ 0 のときも内部的にはバッファーは必要.
    this.sendFunc = bufSize === 0 ? this._sendWithoutBuf : this._sendWithBuf
    this.buf = []
    this.bufReset()
    this.valueReset()
  }
  protected bufReset() {
    this.bufPromise = new Promise((resolve) => {
      this.bufResolve = resolve
    })
  }
  protected bufRelease() {
    this.bufResolve()
  }
  protected valueReset() {
    this.valuePromise = new Promise((resolve, reject) => {
      this.valueResolve = resolve
    })
  }
  protected valueRelease() {
    this.valueResolve()
  }
  protected async _sendWithoutBuf(p) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        await this.valuePromise
        return
      }
      await this.valuePromise
    }
  }
  protected async _sendWithBuf(p) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        return
      }
      await this.valuePromise
    }
  }
  /**
   * Send the value to receiver via channel.
   * This method required to call with `await`.
   * It will be blocking durring buffer is filled.
   * ```
   * await ch.send(value)
   * ```
   * @param value - the value
   * @returns
   */
  readonly send = async (value) => {
    if (this.closed) {
      throw new Error('panic: send on closed channel')
    }
    // TOOD: generatorClosed でループを抜けたかのステータスを返すか検討.
    // rejectInReceiver が有効だとバッファーに乗っているものでもドロップするので、
    // (yeield で reject を for await...of などに渡すと finally が実行されるので)
    // ここのステータスだけわかってもあまり意味はないか.
    return this.sendFunc(value)
  }
  private async gate() {
    // バッファーが埋まっていない場合は、send されるまで待つ.
    // close されていれば素通し.
    while (this.buf.length === 0 && !this.closed) {
      await this.bufPromise
      this.bufReset()
    }
    // バッファーを消費していたら終了.
    // 通常は消費しない、close されていれば何度か呼びだされるうちに消費される.
    if (this.buf.length > 0) {
      return { done: false }
    }
    return { done: true }
  }
  /**
   * Get async generator to receive the value was sended.
   * @returns - Async Generator.
   */
  async *receiver() {
    try {
      while (true) {
        try {
          const i = await this.gate()
          if (i.done) {
            return
          }
          const v = await this.buf[0]
          // バッファーを空ける(yeild の後でやると次回の next() まで実行されないので注意).
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          yield v
        } catch (e) {
          // rejct された場合もバッファーを空ける.
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          if (this.opts.rejectInReceiver) {
            // value が Promise だった場合、receiver 側の for await...of などに reject を伝播させる.
            yield Promise.reject(e)
          }
        }
      }
    } finally {
      this.generatorClosed = true
      this.clean()
    }
  }
  protected clean() {
    this.bufRelease()
    this.valueRelease()
  }
  /**
   * Close channel.
   */
  close() {
    this.closed = true
    this.clean()
  }
}

/**
 * Type of send method Chan class.
 */
export type ChanSend<T> = Chan<T>['send']
/**
 * Type of async generator that is returned from receiver method of Chan class.
 */
export type ChanRecv<T> = ReturnType<Chan<T>['receiver']>
<fim_middle>",incorrect,1020
115,115,115,115,115,115,115,115,"T) => void
  protected bufReject!: (reason",void,b6bfc45eb561308bc0f3960f3a75e7c4a2d28a90,"<fim_prefix>/**
 * Options for Chan.
 */
export type ChanOpts = {
  /**
   * Yield reject to iterator if the value is rejected in receiver(generator).
   */
  rejectInReceiver?: boolean
}

/**
 * Class reperesenting a channel.
 * @template T - Type of the value that will be send via Channel.
 */
export class Chan<T> {
  protected opts: ChanOpts = { rejectInReceiver: false }
  protected bufSize = 0
  protected buf!: T[]
  protected sendFunc!: (p) => Promise<void>

  protected bufPromise!: Promise<void>
  protected bufResolve!: (value: <fim_suffix>) => void

  protected valuePromise!: Promise<void>
  protected valueResolve!: (value) => void

  protected generatorClosed: boolean = false
  protected closed: boolean = false

  /**
   * Make a channel.
   * @param bufSize - size of buffer in channel.
   * @param opts - options.
   */
  constructor(bufSize = 0, opts = {}) {
    if (opts.rejectInReceiver !== undefined) {
      this.opts.rejectInReceiver = opts.rejectInReceiver
    }
    this.bufSize = bufSize === 0 ? 1 : bufSize // バッファーサイズ 0 のときも内部的にはバッファーは必要.
    this.sendFunc = bufSize === 0 ? this._sendWithoutBuf : this._sendWithBuf
    this.buf = []
    this.bufReset()
    this.valueReset()
  }
  protected bufReset() {
    this.bufPromise = new Promise((resolve) => {
      this.bufResolve = resolve
    })
  }
  protected bufRelease() {
    this.bufResolve()
  }
  protected valueReset() {
    this.valuePromise = new Promise((resolve, reject) => {
      this.valueResolve = resolve
    })
  }
  protected valueRelease() {
    this.valueResolve()
  }
  protected async _sendWithoutBuf(p) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        await this.valuePromise
        return
      }
      await this.valuePromise
    }
  }
  protected async _sendWithBuf(p) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        return
      }
      await this.valuePromise
    }
  }
  /**
   * Send the value to receiver via channel.
   * This method required to call with `await`.
   * It will be blocking durring buffer is filled.
   * ```
   * await ch.send(value)
   * ```
   * @param value - the value
   * @returns
   */
  readonly send = async (value) => {
    if (this.closed) {
      throw new Error('panic: send on closed channel')
    }
    // TOOD: generatorClosed でループを抜けたかのステータスを返すか検討.
    // rejectInReceiver が有効だとバッファーに乗っているものでもドロップするので、
    // (yeield で reject を for await...of などに渡すと finally が実行されるので)
    // ここのステータスだけわかってもあまり意味はないか.
    return this.sendFunc(value)
  }
  private async gate() {
    // バッファーが埋まっていない場合は、send されるまで待つ.
    // close されていれば素通し.
    while (this.buf.length === 0 && !this.closed) {
      await this.bufPromise
      this.bufReset()
    }
    // バッファーを消費していたら終了.
    // 通常は消費しない、close されていれば何度か呼びだされるうちに消費される.
    if (this.buf.length > 0) {
      return { done: false }
    }
    return { done: true }
  }
  /**
   * Get async generator to receive the value was sended.
   * @returns - Async Generator.
   */
  async *receiver() {
    try {
      while (true) {
        try {
          const i = await this.gate()
          if (i.done) {
            return
          }
          const v = await this.buf[0]
          // バッファーを空ける(yeild の後でやると次回の next() まで実行されないので注意).
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          yield v
        } catch (e) {
          // rejct された場合もバッファーを空ける.
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          if (this.opts.rejectInReceiver) {
            // value が Promise だった場合、receiver 側の for await...of などに reject を伝播させる.
            yield Promise.reject(e)
          }
        }
      }
    } finally {
      this.generatorClosed = true
      this.clean()
    }
  }
  protected clean() {
    this.bufRelease()
    this.valueRelease()
  }
  /**
   * Close channel.
   */
  close() {
    this.closed = true
    this.clean()
  }
}

/**
 * Type of send method Chan class.
 */
export type ChanSend<T> = Chan<T>['send']
/**
 * Type of async generator that is returned from receiver method of Chan class.
 */
export type ChanRecv<T> = ReturnType<Chan<T>['receiver']>
<fim_middle>",incorrect,1021
