,Unnamed: 0.2,Unnamed: 0.1,Unnamed: 0,generated,solution,hexsha,prompt,correctness,id
0,0,0,0,A,A,f3813017e9bb14bf831177d63f99b8ab50b44ad4,"<fim_prefix>export type Empty = {
    readonly _tag: 'Empty';
};
export type BeregnButton = {
    readonly _tag: 'BeregnButton';
};
export type BeregnButtonAndErrorSummary<E> = {
    readonly _tag: 'BeregnButtonAndErrorSummary';
    readonly errors: E;
};
export type NoValidChildrenOrange = {
    readonly _tag: 'NoValidChildrenOrange';
};
export type ResultBox<A> = {
    readonly _tag: 'ResultBox';
    readonly result: A;
};

export type ResultView<E, A> =
    | Empty
    | BeregnButton
    | BeregnButtonAndErrorSummary<E>
    | NoValidChildrenOrange
    | ResultBox<A>;

// constructors
export const empty: ResultView<never, never> = {
    _tag: 'Empty',
};
export const beregnButton: ResultView<never, never> = {
    _tag: 'BeregnButton',
};
export const beregnButtonAndErrorSummary = <E>(errors) => ({
    _tag: 'BeregnButtonAndErrorSummary',
    errors,
});
export const noValidChildrenOrange: ResultView<never, never> = {
    _tag: 'NoValidChildrenOrange',
};
export const resultBox = <A>(result: <fim_suffix>) => ({
    _tag: 'ResultBox',
    result,
});
// filters
export const isEmpty = (data): data is Empty => data._tag === 'Empty';
export const isBeregnButton = (data): data is BeregnButton =>
    data._tag === 'BeregnButton';
export const isBeregnButtonAndErrorSummary = <E>(
    data
): data is BeregnButtonAndErrorSummary<E> => data._tag === 'BeregnButtonAndErrorSummary';
export const isNoValidChildrenOrange = (data): data is NoValidChildrenOrange =>
    data._tag === 'NoValidChildrenOrange';
export const isResultBox = <A>(data): data is ResultBox<A> => data._tag === 'ResultBox';

// fold
export const caseResultViewOf =
    <E, A, B>(
        empty,
        beregnButton,
        beregnButtonAndErrorSummary,
        noValidChildrenOrange,
        resultBox
    ) =>
    (resultView) => {
        switch (resultView._tag) {
            case 'Empty': {
                return empty();
            }
            case 'BeregnButton': {
                return beregnButton();
            }
            case 'BeregnButtonAndErrorSummary': {
                return beregnButtonAndErrorSummary(resultView.errors);
            }
            case 'NoValidChildrenOrange': {
                return noValidChildrenOrange();
            }
            case 'ResultBox': {
                return resultBox(resultView.result);
            }
        }
    };
<fim_middle>",correct,3887
1,1,1,1,Action,Action,566e0bf1c5e4eafebc876c82fc048623ab53ab35,"<fim_prefix>type Action =
  | { type: 'closeTag', tag: string }
  | { type: 'showInput' }
  | { type: 'confirmInput', tag?: string }
  | { type: 'reset' }
  | { type: 'addIngredient' }
  | { type: 'removeIngredient', id: number }
  | { type: 'addDirection' }
  | { type: 'removeDirection', id: number }

interface State {
  tags: string[]
  inputVisible: boolean
  ingredients: number[]
  directions: number[]
}


let ingredientId = 0
let directionId = 0
export const initialState = {
  tags: [],
  inputVisible: false,
  ingredients: [ingredientId],
  directions: [directionId],
}


const reducer = (state, action: <fim_suffix>) => {
  switch (action.type) {
    case 'closeTag':
      return { ...state, tags: state.tags.filter(tag => tag !== action.tag) }

    case 'reset':
      return initialState

    case 'showInput':
      return { ...state, inputVisible: true }
    case 'confirmInput':
      let tag = action.tag
      if (!tag) return { ...state, inputVisible: false }
      tag = tag.trim()

      const { tags } = state
      let newTags = tags

      if (tag && tags.indexOf(tag) === -1) newTags = [...tags, tag]

      return { ...state, inputVisible: false, tags: newTags }

    case 'addIngredient':
      ingredientId += 1
      return {
        ...state,
        ingredients: [...state.ingredients, ingredientId],
      }
    case 'removeIngredient':
      return {
        ...state,
        ingredients: state.ingredients.filter(index => index !== action.id),
      }

    case 'addDirection':
      directionId += 1
      return {
        ...state,
        directions: [...state.directions, directionId],
      }
    case 'removeDirection':
      return {
        ...state,
        directions: state.directions.filter(index => index !== action.id),
      }

    default:
      throw new Error('Unexpected action.')
  }
}


export default reducer
<fim_middle>",correct,20
2,2,2,2,Action,Action,9c7b185eb474643e7ed1d3b11566888a9164266a,"<fim_prefix>type Action =
  | { type: 'setTags', tags: string[] }
  | { type: 'closeTag', tag: string }
  | { type: 'showInput' }
  | { type: 'confirmInput', tag?: string }
  | { type: 'reset' }
  | { type: 'setIngredients', length: number }
  | { type: 'addIngredient' }
  | { type: 'removeIngredient', id: number }
  | { type: 'addDirection' }
  | { type: 'setDirections', length: number }
  | { type: 'removeDirection', id: number }

interface State {
  tags: string[]
  inputVisible: boolean
  ingredients: number[]
  directions: number[]
}


let ingredientId = 0
let directionId = 0
export const initialState = {
  tags: [],
  inputVisible: false,
  ingredients: [ingredientId],
  directions: [directionId],
}


const reducer = (state, action: <fim_suffix>) => {
  switch (action.type) {
    case 'setTags':
      return { ...state, tags: action.tags }
    case 'closeTag':
      return { ...state, tags: state.tags.filter(tag => tag !== action.tag) }

    case 'reset':
      return initialState

    case 'showInput':
      return { ...state, inputVisible: true }
    case 'confirmInput':
      let tag = action.tag
      if (!tag) return { ...state, inputVisible: false }
      tag = tag.trim()

      const { tags } = state
      let newTags = tags

      if (tag && tags.indexOf(tag) === -1) newTags = [...tags, tag]

      return { ...state, inputVisible: false, tags: newTags }

    case 'setIngredients':
      const ingredients = [] as number[]
      new Array(action.length).fill(null).forEach(() => {
        ingredientId += 1
        ingredients.push(ingredientId)
      })
      return { ...state, ingredients }
    case 'addIngredient':
      ingredientId += 1
      return {
        ...state,
        ingredients: [...state.ingredients, ingredientId],
      }
    case 'removeIngredient':
      return {
        ...state,
        ingredients: state.ingredients.filter(index => index !== action.id),
      }

    case 'setDirections':
      const directions = [] as number[]
      new Array(action.length).fill(null).forEach(() => {
        directionId += 1
        directions.push(ingredientId)
      })
      return { ...state, directions }
    case 'addDirection':
      directionId += 1
      return {
        ...state,
        directions: [...state.directions, directionId],
      }
    case 'removeDirection':
      return {
        ...state,
        directions: state.directions.filter(index => index !== action.id),
      }

    default:
      throw new Error('Unexpected action.')
  }
}


export default reducer
<fim_middle>",correct,1673
3,3,3,3,Action,Action,da0ef1973818334ec9af63eb9d4d8f9b49d3597e,"<fim_prefix>export type State = {
	username: string,
	profile_src: string,
	createdAt: string,
	client_id: string
	message: string,
	message_id: string,
	reply?: {
		reply_username: string,
		reply_picture: string,
		reply_message: string,
		reply_message_owner_id: string
	}
}

type Action = {
	type: ""SET_USER"" | ""MESSAGE_INPUT"" | ""CLEAR_MESSAGE_FIELD"" | ""SET_MESSAGE_ID"" | ""SET_REPLY_MESSAGE"" | ""CLEAR_REPLY"",
	payload: {
		username: string,
		profile_src: string,
		createdAt: string,
		client_id: string,
		message: string,
		message_id: string,
		reply_username?: string,
		reply_picture?: string,
		reply_message?: string,
		reply_message_id?: string
	}
}

const clientState: State = {
	username: '',
	profile_src: '',
	createdAt: '',
	client_id: '',
	message: '',
	message_id: ''
}

export const clientReducer = (state = clientState, action: <fim_suffix>) => {
	
	switch(action.type){
		case ""SET_USER"": {
			const {username, message_id, profile_src, createdAt, client_id} = action.payload
			return {
				...state,
				username: username,
				profile_src: profile_src,
				createdAt: createdAt,
				client_id: client_id,
				message_id: message_id
			}
		}case ""MESSAGE_INPUT"": {
			const {message} = action.payload
			return {
				...state,
				message: message
			}
		}
		case ""CLEAR_MESSAGE_FIELD"": {
			return {
				...state,
				message: """"
			}
		}
		case ""SET_MESSAGE_ID"": {
			return {
				...state,
				message_id: action.payload.message_id
			}
		}
		case ""SET_REPLY_MESSAGE"": {
			const {reply_username, reply_picture, reply_message, reply_message_id} = action.payload

			return {
				...state,
				reply: {
					reply_username: reply_username as string,
					reply_picture: reply_picture as string,
					reply_message: reply_message as string,
					reply_message_owner_id: reply_message_id as string
				}
			}
		}
		case ""CLEAR_REPLY"": {
			return {
				...state,
				reply: undefined
			}
		}
		default: return state
	}
}<fim_middle>",correct,3546
4,4,4,4,Actions,Actions,ebfbabd6e86ee48c24c3828f4ee1b92f6ff39f68,"<fim_prefix>export interface AppSetting {
  shouldSplitMemoWord: boolean;
  shouldHideImageUrl: boolean;
  shouldUseMarkdownParser: boolean;
  useTinyUndoHistoryCache: boolean;
}

export interface State extends AppSetting {
  markMemoId: string;
  editMemoId: string;
  commentMemoId: string;
  isMobileView: boolean;
  showSiderbarInMobileView: boolean;
  changedByMemos: boolean;
}

interface SetMarkMemoIdAction {
  type: 'SET_MARK_MEMO_ID';
  payload: {
    markMemoId: string;
  };
}

interface SetEditMemoIdAction {
  type: 'SET_EDIT_MEMO_ID';
  payload: {
    editMemoId: string;
  };
}

interface SetCommentMemoIdAction {
  type: 'SET_COMMENT_MEMO_ID';
  payload: {
    commentMemoId: string;
  };
}

interface SetMobileViewAction {
  type: 'SET_MOBILE_VIEW';
  payload: {
    isMobileView: boolean;
  };
}

interface SetChangedByMemosAction {
  type: 'SET_CHANGED_BY_MEMOS';
  payload: {
    changedByMemos: boolean;
  };
}

interface SetShowSidebarAction {
  type: 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW';
  payload: {
    showSiderbarInMobileView: boolean;
  };
}

interface SetAppSettingAction {
  type: 'SET_APP_SETTING';
  payload: Partial<AppSetting>;
}

export type Actions =
  | SetMobileViewAction
  | SetShowSidebarAction
  | SetEditMemoIdAction
  | SetCommentMemoIdAction
  | SetMarkMemoIdAction
  | SetChangedByMemosAction
  | SetAppSettingAction;

export function reducer(state, action: <fim_suffix>) {
  switch (action.type) {
    case 'SET_MARK_MEMO_ID': {
      if (action.payload.markMemoId === state.markMemoId) {
        return state;
      }

      return {
        ...state,
        markMemoId: action.payload.markMemoId,
      };
    }
    case 'SET_EDIT_MEMO_ID': {
      if (action.payload.editMemoId === state.editMemoId) {
        return state;
      }

      return {
        ...state,
        editMemoId: action.payload.editMemoId,
      };
    }
    case 'SET_COMMENT_MEMO_ID': {
      if (action.payload.commentMemoId === state.commentMemoId) {
        return state;
      }

      return {
        ...state,
        commentMemoId: action.payload.commentMemoId,
      };
    }
    case 'SET_MOBILE_VIEW': {
      if (action.payload.isMobileView === state.isMobileView) {
        return state;
      }

      return {
        ...state,
        isMobileView: action.payload.isMobileView,
      };
    }
    case 'SET_CHANGED_BY_MEMOS': {
      if (action.payload.changedByMemos === state.changedByMemos) {
        return state;
      }

      return {
        ...state,
        changedByMemos: action.payload.changedByMemos,
      };
    }
    case 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW': {
      if (action.payload.showSiderbarInMobileView === state.showSiderbarInMobileView) {
        return state;
      }

      return {
        ...state,
        showSiderbarInMobileView: action.payload.showSiderbarInMobileView,
      };
    }
    case 'SET_APP_SETTING': {
      return {
        ...state,
        ...action.payload,
      };
    }
    default: {
      return state;
    }
  }
}

export const defaultState: State = {
  markMemoId: '',
  editMemoId: '',
  commentMemoId: '',
  shouldSplitMemoWord: true,
  shouldHideImageUrl: true,
  shouldUseMarkdownParser: true,
  useTinyUndoHistoryCache: false,
  isMobileView: false,
  showSiderbarInMobileView: false,
  changedByMemos: false,
};
<fim_middle>",correct,236
5,5,5,5,Application,Application,cae47631c7a90006a8af948c94a65fc0aa8379c0,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IApplication {
    client_type?: string;
    description?: string;
    grant_type?: string;
    id?: string;
    image?: string;
    name?: string;
    redirect_uri?: string;
    response_type?: string;
    url?: string;
}

export default class Application {
    readonly _client_type: string | undefined;

    get clientType() {
        return this._client_type;
    }

    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _grant_type: string | undefined;

    get grantType() {
        return this._grant_type;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _image: string | undefined;

    get image() {
        return this._image;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _redirect_uri: string | undefined;

    get redirectUri() {
        return this._redirect_uri;
    }

    readonly _response_type: string | undefined;

    get responseType() {
        return this._response_type;
    }

    readonly _url: string | undefined;

    get url() {
        return this._url;
    }

    constructor(props) {
        if (typeof props.client_type === 'string') {
            this._client_type = props.client_type.trim();
        }
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.grant_type === 'string') {
            this._grant_type = props.grant_type.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.image === 'string') {
            this._image = props.image.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.redirect_uri === 'string') {
            this._redirect_uri = props.redirect_uri.trim();
        }
        if (typeof props.response_type === 'string') {
            this._response_type = props.response_type.trim();
        }
        if (typeof props.url === 'string') {
            this._url = props.url.trim();
        }
    }

    serialize() {
        const data: IApplication = {};
        if (typeof this._client_type !== 'undefined') {
            data.client_type = this._client_type;
        }
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._grant_type !== 'undefined') {
            data.grant_type = this._grant_type;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._image !== 'undefined') {
            data.image = this._image;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._redirect_uri !== 'undefined') {
            data.redirect_uri = this._redirect_uri;
        }
        if (typeof this._response_type !== 'undefined') {
            data.response_type = this._response_type;
        }
        if (typeof this._url !== 'undefined') {
            data.url = this._url;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            image: !this._image
                ? true
                : typeof this._image === 'string' && !this._image
                ? true
                : this._image,
            url: !this._url
                ? true
                : typeof this._url === 'string' && !this._url
                ? true
                : this._url,
            redirect_uri: !this._redirect_uri
                ? true
                : typeof this._redirect_uri === 'string' && !this._redirect_uri
                ? true
                : this._redirect_uri,
            grant_type: !this._grant_type
                ? true
                : typeof this._grant_type === 'string' && !this._grant_type
                ? true
                : this._grant_type,
            response_type: !this._response_type
                ? true
                : typeof this._response_type === 'string' &&
                  !this._response_type
                ? true
                : this._response_type,
            client_type: !this._client_type
                ? true
                : typeof this._client_type === 'string' && !this._client_type
                ? true
                : this._client_type,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Application({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,2034
6,6,6,6,Argument,Argument,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x: <fim_suffix>) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3358
7,7,7,7,Argument,Argument,7f5712ec06dabff06003ba15417bd3dcb2d15f53,"<fim_prefix>export type Settings = {
  parserName: string;
  typeHints: boolean;
  mainContents: string;
  mainName: string;
  cliName: string;
  argsName: string;
};

export const defaultSettings = () => {
  return {
    parserName: 'parser',
    typeHints: true,
    mainContents: '# Contents of main',
    mainName: 'main',
    cliName: 'cli',
    argsName: 'args',
  };
};

export type Argument = {
  name: string;
  type: string;
  variableName: string;
  default: string;
  required: boolean;
};

export const newArgument = (
  name,
  type,
  variableName = '',
  defaultValue = '',
  required = false,
): <fim_suffix> => {
  if (variableName === '') {
    variableName = name.replace(/-/g, '');
  }
  return { name, type, variableName, default: defaultValue, required };
};

function argumentToText(argument, parserName) {
  switch (argument.type) {
    case 'bool':
      return `${parserName}.add_argument(""${argument.name}"", action=""store_${argument.default}"")`;
    default:
      let defaultDisplay;

      if (argument.type === 'str') {
        defaultDisplay = `""${argument.default}""`;
      } else {
        defaultDisplay = argument.default;
      }

      if (argument.default === '') {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type})`;
      } else {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type}, default=${defaultDisplay})`;
      }
  }
}

const argumentToMainParams = (argument, typeHints) => {
  if (typeHints) {
    return `${argument.variableName}: ${argument.type}`;
  } else {
    return `${argument.variableName}`;
  }
};

export const argparseCode = (args, settings = defaultSettings()) => {
  const parserName: string = settings.parserName;
  const argsName: string = settings.argsName;
  const mainParameters: string[] = args.map((arg) => argumentToMainParams(arg, settings.typeHints));
  const argumentsText: string[] = args.map((arg) => argumentToText(arg, parserName));
  const returnText: string[] = args.map((x) => {
    if (x.type === 'str') {
      return `""${x.variableName}"": ${argsName}.${x.variableName},`;
    } else {
      return `""${x.variableName}"": ${x.type}(${argsName}.${x.variableName}),`;
    }
  });

  const mainReturnType = settings.typeHints ? ' -> None' : '';
  const cliReturnType = settings.typeHints ? ' -> Dict[str, Any]' : '';
  const typeImports = settings.typeHints ? '\nfrom typing import Dict, Any' : '';

  const output = `import argparse${typeImports}


def ${settings.mainName}(${mainParameters.join(', ')})${mainReturnType}:
    ${settings.mainContents}
    return


def ${settings.cliName}()${cliReturnType}:
    formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ${parserName} = argparse.ArgumentParser(formatter_class=formatter_class)

    ${argumentsText.join('\n    ')}

    ${argsName} = ${parserName}.parse_args()

    return {${returnText.join('\n            ').slice(0, -1)}}


if __name__ == '__main__':
    ${argsName} = ${settings.cliName}()
    ${settings.mainName}(${args.map((x) => `${x.variableName}=${argsName}[""${x.variableName}""]`).join(',\n         ')})
`;
  return output;
};
<fim_middle>",correct,4835
8,8,8,8,ArrayBuffer,ArrayBuffer,8942b9bffbeae8bdf02b8ff01a9a7a9bca89f53c,"<fim_prefix>const INDEX_BIT_COUNT = 12;
const LENGTH_BIT_COUNT = 4;
const WINDOW_SIZE = 1 << INDEX_BIT_COUNT;
const RAW_LOOK_AHEAD_SIZE = 1 << LENGTH_BIT_COUNT;
const BREAK_EVEN = Math.floor((1 + INDEX_BIT_COUNT + LENGTH_BIT_COUNT) / 9);
const LOOK_AHEAD_SIZE = RAW_LOOK_AHEAD_SIZE + BREAK_EVEN;
const TREE_ROOT = WINDOW_SIZE;
const UNUSED = -1;
const MOD_WINDOW = (a) => a & (WINDOW_SIZE - 1);

enum Child {
  Smaller = 0,
  Larger = 1,
}

interface DefTree {
  parent: number;
  children: [number, number];
}

let current_pos: number;
let match_pos: number;
const win = new Uint8Array(WINDOW_SIZE * 5);
const tree: DefTree[] = (() => {
  const t = new Array<DefTree>(WINDOW_SIZE + 2);
  for (let i = 0; i < t.length; i++) {
    t[i] = { parent: 0, children: [0, 0] };
  }
  return t;
})();

function initTree(r) {
  for (let i = 0; i <= WINDOW_SIZE; i++) {
    const node = tree[i];
    node.parent = UNUSED;
    node.children[Child.Smaller] = UNUSED;
    node.children[Child.Larger] = UNUSED;
  }
  tree[TREE_ROOT].children[Child.Larger] = r;
  tree[r].parent = TREE_ROOT;
  tree[-1] = tree[WINDOW_SIZE + 1];
}

function contractNode(old_node, new_node) {
  tree[new_node].parent = tree[old_node].parent;
  if (tree[tree[old_node].parent].children[Child.Larger] === old_node)
    tree[tree[old_node].parent].children[Child.Larger] = new_node;
  else tree[tree[old_node].parent].children[Child.Smaller] = new_node;
  tree[old_node].parent = UNUSED;
}

function copyNode(new_node, old_node) {
  tree[new_node].parent = tree[old_node].parent;
  tree[new_node].children[Child.Smaller] =
    tree[old_node].children[Child.Smaller];
  tree[new_node].children[Child.Larger] = tree[old_node].children[Child.Larger];
}

function replaceNode(old_node, new_node) {
  const parent = tree[old_node].parent;
  if (tree[parent].children[Child.Smaller] === old_node)
    tree[parent].children[Child.Smaller] = new_node;
  else tree[parent].children[Child.Larger] = new_node;
  copyNode(new_node, old_node);
  if (tree[new_node].children[Child.Smaller] !== UNUSED)
    tree[tree[new_node].children[Child.Smaller]].parent = new_node;
  if (tree[new_node].children[Child.Larger] !== UNUSED)
    tree[tree[new_node].children[Child.Larger]].parent = new_node;
  tree[old_node].parent = UNUSED;
}

function findNextNode(node) {
  let next = tree[node].children[Child.Smaller];
  while (tree[next].children[Child.Larger] !== UNUSED)
    next = tree[next].children[Child.Larger];
  return next;
}

function deleteString(p) {
  if (tree[p].parent === UNUSED) return;
  if (tree[p].children[Child.Larger] === UNUSED)
    contractNode(p, tree[p].children[Child.Smaller]);
  else if (tree[p].children[Child.Smaller] === UNUSED)
    contractNode(p, tree[p].children[Child.Larger]);
  else {
    const replacement = findNextNode(p);
    deleteString(replacement);
    replaceNode(p, replacement);
  }
}

function addString() {
  let i = 0;
  let delta = 0;
  let test_node = tree[TREE_ROOT].children[Child.Larger];
  let match_length = 0;
  for (;;) {
    for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
      delta = win[MOD_WINDOW(current_pos + i)] - win[MOD_WINDOW(test_node + i)];
      if (delta !== 0) break;
    }
    if (i >= match_length) {
      match_length = i;
      match_pos = test_node;
      if (match_length >= LOOK_AHEAD_SIZE) {
        replaceNode(test_node, current_pos);
        return match_length;
      }
    }
    const child_node = tree[test_node];
    const child_prop = delta >= 0 ? Child.Larger : Child.Smaller;
    if (child_node.children[child_prop] === UNUSED) {
      child_node.children[child_prop] = current_pos;
      tree[current_pos].parent = test_node;
      tree[current_pos].children[Child.Larger] = UNUSED;
      tree[current_pos].children[Child.Smaller] = UNUSED;
      return match_length;
    }
    test_node = child_node.children[child_prop];
  }
}

// Adapted from:
// https://github.com/2point21/lba2-classic/blob/main/SOURCES/LZSS.CPP
export function compressLZSS_LBA_type_1(data: <fim_suffix>) {
  let i: number;
  let read = 0;
  let write = 0;
  let info: number;
  let look_ahead_bytes: number;
  let replace_count: number;
  let match_length: number;
  let count_bits = 0;
  let mask = 1;
  let len = 0;
  let length = data.byteLength;

  const input = new Uint8Array(data);
  const output = new Uint8Array(length);

  const save_length = length;
  current_pos = 0;

  for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
    if (length === 0) break;
    win[current_pos + i] = input[read++];
    length--;
  }

  look_ahead_bytes = i;
  initTree(current_pos);
  match_length = 0;
  match_pos = 0;
  info = write++;

  if (++len >= save_length) return data;

  output[info] = 0;

  while (look_ahead_bytes > 0) {
    if (match_length > look_ahead_bytes) match_length = look_ahead_bytes;

    if (match_length <= BREAK_EVEN) {
      replace_count = 1;
      output[info] |= mask;
      output[write++] = win[current_pos];
      if (++len >= save_length) return data;
    } else {
      if ((len = len + 2) >= save_length) return data;

      const value =
        (MOD_WINDOW(current_pos - match_pos - 1) << LENGTH_BIT_COUNT) |
        (match_length - BREAK_EVEN - 1);
      const low = (value & 0xff00) >> 8;
      const high = value & 0xff;
      output[write] = high;
      output[write + 1] = low;

      write += 2;
      replace_count = match_length;
    }

    if (++count_bits === 8) {
      if (++len >= save_length) return data;
      info = write++;
      output[info] = 0;
      count_bits = 0;
      mask = 1;
    } else {
      mask = (mask << 1) & 0xff;
    }

    for (i = 0; i < replace_count; i++) {
      deleteString(MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE));
      if (length === 0) look_ahead_bytes--;
      else {
        win[MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE)] = input[read++];
        length--;
      }

      current_pos = MOD_WINDOW(current_pos + 1);
      if (look_ahead_bytes) match_length = addString();
    }
  }

  if (count_bits === 0) len--;
  return output.buffer.slice(0, len);
}
<fim_middle>",correct,4258
9,9,9,9,B,B,f3813017e9bb14bf831177d63f99b8ab50b44ad4,"<fim_prefix>export type Empty = {
    readonly _tag: 'Empty';
};
export type BeregnButton = {
    readonly _tag: 'BeregnButton';
};
export type BeregnButtonAndErrorSummary<E> = {
    readonly _tag: 'BeregnButtonAndErrorSummary';
    readonly errors: E;
};
export type NoValidChildrenOrange = {
    readonly _tag: 'NoValidChildrenOrange';
};
export type ResultBox<A> = {
    readonly _tag: 'ResultBox';
    readonly result: A;
};

export type ResultView<E, A> =
    | Empty
    | BeregnButton
    | BeregnButtonAndErrorSummary<E>
    | NoValidChildrenOrange
    | ResultBox<A>;

// constructors
export const empty: ResultView<never, never> = {
    _tag: 'Empty',
};
export const beregnButton: ResultView<never, never> = {
    _tag: 'BeregnButton',
};
export const beregnButtonAndErrorSummary = <E>(errors) => ({
    _tag: 'BeregnButtonAndErrorSummary',
    errors,
});
export const noValidChildrenOrange: ResultView<never, never> = {
    _tag: 'NoValidChildrenOrange',
};
export const resultBox = <A>(result) => ({
    _tag: 'ResultBox',
    result,
});
// filters
export const isEmpty = (data): data is Empty => data._tag === 'Empty';
export const isBeregnButton = (data): data is BeregnButton =>
    data._tag === 'BeregnButton';
export const isBeregnButtonAndErrorSummary = <E>(
    data
): data is BeregnButtonAndErrorSummary<E> => data._tag === 'BeregnButtonAndErrorSummary';
export const isNoValidChildrenOrange = (data): data is NoValidChildrenOrange =>
    data._tag === 'NoValidChildrenOrange';
export const isResultBox = <A>(data): data is ResultBox<A> => data._tag === 'ResultBox';

// fold
export const caseResultViewOf =
    <E, A, B>(
        empty,
        beregnButton,
        beregnButtonAndErrorSummary,
        noValidChildrenOrange,
        resultBox
    ) =>
    (resultView): <fim_suffix> => {
        switch (resultView._tag) {
            case 'Empty': {
                return empty();
            }
            case 'BeregnButton': {
                return beregnButton();
            }
            case 'BeregnButtonAndErrorSummary': {
                return beregnButtonAndErrorSummary(resultView.errors);
            }
            case 'NoValidChildrenOrange': {
                return noValidChildrenOrange();
            }
            case 'ResultBox': {
                return resultBox(resultView.result);
            }
        }
    };
<fim_middle>",correct,3874
10,10,10,10,Binding,Binding,4b26b14a08d5cdfff6183540cb79049b3ed5038a,"<fim_prefix>/* eslint-disable no-constant-condition */

const EOF = '~EOF~'

class Parser {
  private pos = 0

  constructor(private input) {}

  next() {
    if (this.pos >= this.input.length) {
      return EOF
    }
    return this.input[this.pos++]
  }

  backup() {
    this.pos--
  }

  parseTemplate(): <fim_suffix> {
    if (this.next() != '/') {
      throw new Error('binding URL should start with a slash')
    }
    
    return {
      segments: this.parseSegments(),
      verb: this.parseVerb(),
    }
  }

  private parseSegments() {
    let segments: Segment[] = []
    segments.push(this.parseSegment())

    while (true) {
      let r = this.next()
      switch (r) {
        case '/':
          segments.push(this.parseSegment())
          continue

        case ':':
        case '}':
          this.backup()
          return segments

        case EOF:
          return segments

        default:
          throw new Error(`unexpected ${r} in segments`)
      }
    }
  }

  private parseSegment() {
    let content = ''
    while (true) {
      let r = this.next()
      switch (r) {
        case EOF:
          if (!content.length) {
            throw new Error(`unexpected EOF in segment`)
          }
          return { content }

        case '{':
          return { content, variable: this.parseVariable() }

        case ':':
        case '/':
        case '}':
          this.backup()
          if (!content.length) {
            throw new Error(`unexpected ${r} in segment`)
          }
          return { content }

        default:
          content += r
      }
    }
  }

  private parseVariable() {
    let v: Variable = {
      name: '',
    }
    while (true) {
      let r = this.next()
      switch (r) {
        case '}':
          if (!v.name.length) {
            throw new Error(`empty variable name`)
          }
          return v

        case '=':
          v.parts = this.parseSegments().map(segment => {
            if (!segment.content.length) {
              throw new Error(`unexpected empty segment`)
            }
            return segment.content
          })
          break

        case EOF:
          throw new Error(`unexpected EOF in variable ${v.name}`)

        default:
          v.name += r
      }
    }
  }

  private parseVerb() {
    let r = this.next()
    switch (r) {
      case ':':
        break

      case EOF:
        return ''

      default:
        throw new Error(`unexpected ${r} in verb`)
    }

    let verb = ''
    while (true) {
      let r = this.next()
      if (r === EOF) {
        if (!verb.length) {
          throw new Error(`empty verb`)
        }
        return verb
      }
      verb += r
    }
  }
}

interface Binding {
  segments: Segment[]
  verb: string
}

interface Segment {
  content: string
  variable?: Variable
}

interface Variable {
  name: string
  parts?: string[]
}

export function buildURL(template, params) {
  let parser = new Parser(template)
  let binding = parser.parseTemplate()

  let parts = binding.segments.map(segment => {
    if (segment.variable) {
      if (!params[segment.variable.name]) {
        throw new Error(`input parameter ${segment.variable.name} is required`)
      }

      return params[segment.variable.name]
    }
    return segment.content
  })
  let verb = binding.verb ? `:${binding.verb}` : ''
  return '/' + parts.join('/') + verb
}
<fim_middle>",correct,928
11,11,11,11,BooleanField,BooleanField,5f2d2febe1a2a566772fc84aa89c133d84d3093b,"<fim_prefix>/**
 * Number
 */
type NumberField = {
  type: 'number';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const number = (options) => {
  return {
    type: 'number',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * BigInt
 */
type BigIntField = {
  type: 'bigint';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const bigInt = (options) => {
  return {
    type: 'bigint',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * String
 */
type StringField = {
  type: 'string';
  maxLength: number;
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const string = (options) => {
  return {
    type: 'string',
    maxLength: options.maxLength,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Boolean
 */
type BooleanField = {
  type: 'boolean';
  canBeNull: boolean;
  default: boolean | null;
  primaryKey: boolean;
};

export const boolean = (options): <fim_suffix> => {
  return {
    type: 'boolean',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Enumerated
 */
type EnumeratedField = {
  type: 'enumerated';
  values: string[];
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const enumerated = (options) => {
  return {
    type: 'enumerated',
    values: options.values,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * DateTime
 */
type DateTimeField = {
  type: 'datetime';
  canBeNull: boolean;
  default: Date | null;
  primaryKey: boolean;
};

export const dateTime = (options) => {
  return {
    type: 'datetime',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Any Field
 */
export type AnyField =
  | NumberField
  | BigIntField
  | StringField
  | BooleanField
  | EnumeratedField
  | DateTimeField;

export type Fields = {
  [key: string]: AnyField;
};
<fim_middle>",correct,4935
12,12,12,12,ClassType,ClassType,b898174dc9208306ba4726075f110ac026c56fe6,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// This file contains generic TypeScript types, and predicate methods
type VoidReturn = void | undefined;

export type VoidCallback<Args extends unknown[] = []> = Args extends []
	? ((arg?) => VoidReturn)
	: ((...args) => VoidReturn);

export type DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};

export type AsyncVoidCallback<Args extends unknown[] = []> = AsyncCallback<
	VoidReturn,
	Args
>;

export type AsyncCallback<Return, Args extends unknown[] = []> = Args extends []
	? (() => Return | Promise<Return>)
	: ((...args) => Return | Promise<Return>);

export type ErrorCallback<Err extends Error = Error> = (err) => void;

export type MapKey<T> = T extends Map<infer K, unknown> ? K : never;

export type MapValue<T> = T extends Map<unknown, infer V> ? V : never;

export type SetValue<T> = T extends Set<infer V> ? V : never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export type UnionToIntersection<U> = (U extends any ? (k) => void : never) extends ((
	k,
) => void)
	? I
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
type ClassConstructorParams<T> = T extends {
	new (
		...args
	): any;
}
	? R
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export interface Class<T, Args extends any[] = ClassConstructorParams<T>> {
	new (
		...args
	): T;
	prototype: T;
}

export type Dict<T> = Record<string, T>;

export type RequiredProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]-?: NonNullable<Obj[Key]>
};

export type OptionalProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]?: Obj[Key]
};

export type TaggedTemplateFunction<Ret, Sub> = (
	strs,
	...substitutions
) => Ret;

// Turn a type that contains interfaces into regular objects
export type InterfaceToObject<T> = T extends {}
	? {[K in keyof T]: InterfaceToObject<T[K]>}
	: T;

export type UnknownObject = Dict<unknown>;

export type UnknownFunction = (...args) => unknown;

export function isObject(obj): obj is UnknownObject {
	return typeof obj === ""object"" && obj !== null && !Array.isArray(obj);
}

export function isPlainObject(obj): obj is UnknownObject {
	// Weird duck typing for cross-realm objects
	return (
		isObject(obj) &&
		obj.constructor !== undefined &&
		obj.constructor.name === ""Object""
	);
}

export function isIterable(obj): obj is Iterable<unknown> {
	if (typeof obj === ""object"" && obj != null) {
		// @ts-ignore
		return typeof obj[Symbol.iterator] === ""function"";
	} else {
		return false;
	}
}

// TypeScript has awful behaviour where it treats optional properties and undefined values as the same
// eg. https://www.typescriptlang.org/play/index.html?ssl=3&ssc=1&pln=1&pc=1#code/C4TwDgpgBAChBOBnA9gOygXigbwFBQKgDMBLJYAOQEMBbCALikWHhNQHMBufQgGyubU6jZqw7cAvt1wBjNMyhgq8YCSq84SNIzyEo-QbQgB+ESzbsANLgmYcPAgcpHGAV1QATCKVQQP1qVxZeWBFBBRURk0Iu11CUnIhBigAIgBlCAAjAVUqVBTrPSckxhSKdxAqAocoADp6pRU1DXC0AOkAeg79HKSoEkQody8fPyhM11CAFTSoD2QIRFQAclCEeGR4XEgtVFrio0wMLGHvNj9OIA
// https://github.com/microsoft/TypeScript/issues/13195
// This means that places where we expect to receive a value when object spreading in a partial object
// can actually have undefined values!
export function mergeObjects<A extends object>(
	a,
	b,
) {
	if (b === undefined) {
		return a;
	}

	const newObj: A = {
		...a,
		...b,
	};

	// If b contains undefined properties then use the value from A
	for (const key in b) {
		if (b[key] === undefined) {
			// @ts-ignore
			newObj[key] = a[key];
		}
	}

	return newObj;
}

export function equalArray<A extends unknown[], B extends unknown[]>(
	a,
	b,
): a is B {
	if (a.length !== b.length) {
		return false;
	}

	if (a === b) {
		return true;
	}

	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

// Check if a value is instance of a class, disallowing inheritance
// rome-ignore lint/ts/noExplicitAny: Necessary
export function isSafeInstanceof<ClassType extends new (
	...args
) => any>(inst, Class: <fim_suffix>): inst is InstanceType<ClassType> {
	return inst instanceof Class && inst.constructor === Class;
}
<fim_middle>",correct,3213
13,13,13,13,Color,Color,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random(): <fim_suffix> {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,383
14,14,14,14,Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?
) => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2,
  color3?: <fim_suffix>
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1987
15,15,15,15,Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?
) => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2: <fim_suffix>,
  color3?
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1988
16,16,16,16,Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?
): <fim_suffix> => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2,
  color3?
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1992
17,17,17,17,Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?: <fim_suffix>
) => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2,
  color3?
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1993
18,18,18,18,Command,Command,c5055e95b1cf23c00d4f8174c39f7e7831a25a28,"<fim_prefix>/*--------------------------------------------------------------------------

MIT License

Copyright (c) smoke-pack 2019 Haydn Paterson (sinclair) <haydn.developer@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---------------------------------------------------------------------------*/


export interface InfoCommand   { kind: 'info',   message: string }

export interface ListCommand   { kind: 'list' }
export interface CreateCommand { kind: 'create', name: string, type: string }
export interface AddCommand    { kind: 'add',    name: string, type: string }
export interface RemoveCommand { kind: 'remove', name: string }
export interface LinkCommand   { kind: 'link',   name: string, dependency: string }
export interface UnlinkCommand { kind: 'unlink', name: string, dependency: string }

export interface CleanCommand  { kind: 'clean',  name:  string }
export interface BuildCommand  { kind: 'build',  name:  string }
export interface WatchCommand  { kind: 'watch',  names: string[] }
export interface StartCommand  { kind: 'start',  name:  string }
export interface TestCommand   { kind: 'test',   name:  string }
export interface PackCommand   { kind: 'pack',   name:  string }
export interface RunCommand    { kind: 'run',    name:  string, script: string }

export type Command =
// general
| InfoCommand 

// provision
| ListCommand
| CreateCommand 
| AddCommand 
| RemoveCommand 
| LinkCommand 
| UnlinkCommand

// automation 
| CleanCommand
| BuildCommand
| WatchCommand
| StartCommand 
| TestCommand 
| PackCommand
| RunCommand


/** Parses the given command line arguments. */
export function parse(args): <fim_suffix> {
  const forward = [args.shift()!, args.shift()!]

  if(args.length === 0) {
    const kind = 'info'
    const message = ''
    return { kind, message }
  }
  const commandKind   = args.shift()!
  switch(commandKind) {
    // ---------------------
    // provision
    // ---------------------
    case 'list': {
      const kind = 'list'
      return { kind }
    }
    // ---------------------
    // provision
    // ---------------------
    case 'create': {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <type> arguments.'
        return { kind, message }
      }
      const kind = 'create'
      const name = args.shift()!
      const type = args.shift()!
      return { kind, name, type }
    }
    case 'add': {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <type> arguments.'
        return { kind, message }
      }
      const kind = 'add'
      const name = args.shift()!
      const type = args.shift()!
      return { kind, name, type }
    }
    case 'remove': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'remove'
      const name = args.shift()!
      return { kind, name }
    }
    case ""link"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <dependency> arguments.'
        return { kind, message }
      }
      const kind       = 'link'
      const name       = args.shift()!
      const dependency = args.shift()!
      return { kind, name, dependency }
    }
    case ""unlink"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <dependency> arguments.'
        return { kind, message }
      }
      const kind       = 'unlink'
      const name       = args.shift()!
      const dependency = args.shift()!
      return { kind, name, dependency }
    }
    // ---------------------
    // automation
    // ---------------------
    case 'clean': {
      const kind = 'clean'
      if(args.length !== 1) {
        const name = '*'
        return { kind, name }
      }
      const name = args.shift()!
      return { kind, name }
    }
    case 'build': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'build'
      const name = args.shift()!
      return { kind, name }
    }
    case 'watch': {
      if(args.length < 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind  = 'watch'
      const names = [...args]
      return { kind, names }
    }
    case 'start': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'start'
      const name = args.shift()!
      return { kind, name }
    }
    case 'test': {
      if(args.length !== 1) {
        const kind = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'test'
      const name = args.shift()!
      return { kind, name }
    }
    case 'pack': {
      if(args.length !== 1) {
        const kind = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'pack'
      const name = args.shift()!
      return { kind, name }
    }
    case ""run"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <script> arguments.'
        return { kind, message }
      }
      const kind   = 'run'
      const name   = args.shift()!
      const script = args.shift()!
      return { kind, name, script }
    }
    default: {
      const kind    = 'info'
      const message = `Invalid command '${commandKind}'`
      return { kind, message }
    }
  }  
}
<fim_middle>",correct,2104
19,19,19,19,Command,Command,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x): <fim_suffix> {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3357
20,20,20,20,Command,Command,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x): <fim_suffix> {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3359
21,21,21,21,Command,Command,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command: <fim_suffix>) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3366
22,22,22,22,Config,Config,3916af040035d5fc03d4a8992d5ecdd8e2401645,"<fim_prefix>export interface Config {
    speedMultMalus: number;
    weaponSpeedMultOneHanderMalus: number;
    weaponSpeedMultTwoHanderMalus: number;
    weaponSpeedMultRangedMalus: number;
    staminaRateMultMalus: number;
    magickaRateMultMalus: number;
    powerAttackStaminaMultMalus: number;
    spellCostMalus: number;

    lightCuirassBase: number; 
    lightGauntletsBase: number; 
    lightBootsBase: number; 
    lightHelmetBase: number; 
    heavyCuirassBase: number; 
    heavyGauntletsBase: number; 
    heavyBootsBase: number; 
    heavyHelmetBase: number; 
    shieldBase: number; 

    enableSkillBonuses: boolean,
    speedMultLightArmorSkillBonus: number;
    speedMultHeavyArmorSkillBonus: number;
    weaponSpeedMultOneHandedSkillBonus: number;
    weaponSpeedMultTwoHandedSkillBonus: number;
    weaponSpeedMultMarksmanSkillBonus: number;
    staminaRateMultLightArmorSkillBonus: number;
    staminaRateMultHeavyArmorSkillBonus: number;
    magickaRateMultMagicSkillBonus: number;
    powerAttackStaminaOneHandedSkillBonus: number;
    powerAttackStaminaTwoHandedSkillBonus: number;
    spellCostSkillBonus: number;

    racialOffsets: Record<string, MalusOffset[]>;
    spellCostArgonianLightArmorRestorationPctOffset: number;
    spellCostArgonianLightArmorAlterationPctOffset: number;
    spellCostDunmerLightArmorFireDamagePctOffset: number;
    spellCostImperialHeavyArmorRestorationPctOffset: number;

    factionalOffsets: Record<string, MalusOffset[]>;
    spellCostThalmorLightArmorPctOffset: number;

    lightArmorPerkFormId: string;
    lightArmorPerkOffsetPct: number;
    heavyArmorPerkFormId: string;
    heavyArmorPerkOffsetPct: number;

    debug: boolean;
    useCloak: boolean;
}

type Types = ""string"" | ""number"" | ""boolean"" | ""object"";
export function asConfig(data): <fim_suffix> {
    const keyValidators: Record<keyof Config, Types> = {
        speedMultMalus: ""number"",
        weaponSpeedMultOneHanderMalus: ""number"",
        weaponSpeedMultTwoHanderMalus: ""number"",
        weaponSpeedMultRangedMalus: ""number"",
        staminaRateMultMalus: ""number"",
        magickaRateMultMalus: ""number"",
        powerAttackStaminaMultMalus: ""number"",
        spellCostMalus: ""number"",

        lightCuirassBase: ""number"", 
        lightGauntletsBase: ""number"", 
        lightBootsBase: ""number"", 
        lightHelmetBase: ""number"", 
        heavyCuirassBase: ""number"", 
        heavyGauntletsBase: ""number"", 
        heavyBootsBase: ""number"", 
        heavyHelmetBase: ""number"", 
        shieldBase: ""number"", 

        enableSkillBonuses: ""boolean"",
        speedMultLightArmorSkillBonus: ""number"",
        speedMultHeavyArmorSkillBonus: ""number"",
        weaponSpeedMultOneHandedSkillBonus: ""number"",
        weaponSpeedMultTwoHandedSkillBonus: ""number"",
        weaponSpeedMultMarksmanSkillBonus: ""number"",
        staminaRateMultLightArmorSkillBonus: ""number"",
        staminaRateMultHeavyArmorSkillBonus: ""number"",
        magickaRateMultMagicSkillBonus: ""number"",
        powerAttackStaminaOneHandedSkillBonus: ""number"",
        powerAttackStaminaTwoHandedSkillBonus: ""number"",
        spellCostSkillBonus: ""number"",

        racialOffsets: ""object"",
        spellCostArgonianLightArmorRestorationPctOffset: ""number"",
        spellCostArgonianLightArmorAlterationPctOffset: ""number"",
        spellCostDunmerLightArmorFireDamagePctOffset: ""number"",
        spellCostImperialHeavyArmorRestorationPctOffset: ""number"",

        factionalOffsets: ""object"",
        spellCostThalmorLightArmorPctOffset: ""number"",
    
        lightArmorPerkFormId: ""string"",
        lightArmorPerkOffsetPct: ""number"",
        heavyArmorPerkFormId: ""string"",
        heavyArmorPerkOffsetPct: ""number"",
    
        debug: ""boolean"",
        useCloak: ""boolean"",
    }

    if (typeof data === 'object' && data !== null) {
        let maybeConfig = data as Config
        for (const key of Object.keys(keyValidators) as Array<keyof Config>) {
            if (typeof maybeConfig[key] !== keyValidators[key]) {
                throw new Error(`data is not a Config: ${key} has type ${typeof maybeConfig[key]}`);
            }
            if (key === ""racialOffsets"") {
                const maybeOffsets = maybeConfig[key];
                Object.keys(maybeOffsets).map(key => maybeOffsets[key].map(maybeOffset => asMalusOffset(maybeOffset)));
            }
        }
        return maybeConfig;
    }

    throw new Error('data is not a Config');
}

type Malus = ""SpeedMult"" | ""WeaponSpeedMult"" | ""StaminaRateMult"" | ""MagickaRateMult"";
type ArmorKeyword = ""ArmorLight"" | ""ArmorHeavy"" | ""Any"";
type WeaponKeyword = ""WeapTypeSword"" | ""WeapTypeDagger"" | ""WeapTypeWarAxe"" | ""WeapTypeMace"" | ""WeapTypeGreatsword"" | ""WeapTypeBattleaxe"" | ""WeapTypeWarhammer"" | ""WeapTypeBow"" | ""WeapTypeCrossbow""  | ""Any"";
export interface MalusOffset {
    malus: Malus;
    armorKeyword: ArmorKeyword;
    weaponKeyword: WeaponKeyword;
    requiresShield: boolean;
    pctOffset: number;
}

export function asMalusOffset(data) {
    const keyValidators: Record<keyof MalusOffset, Types> = {
        malus: ""string"",
        armorKeyword: ""string"",
        weaponKeyword: ""string"",
        requiresShield: ""boolean"",
        pctOffset: ""number"",
    }

    if (typeof data === 'object' && data !== null) {
        let maybeMalusOffset = data as MalusOffset
        for (const key of Object.keys(keyValidators) as Array<keyof MalusOffset>) {
            if (typeof maybeMalusOffset[key] !== keyValidators[key]) {
                throw new Error(`data is not a MalusOffset: ${key} has type ${typeof maybeMalusOffset[key]}`);
            }
        }
        return maybeMalusOffset;
    }

    throw new Error('data is not a MalusOffset');
}
<fim_middle>",correct,1619
23,23,23,23,Config,Config,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text): <fim_suffix> {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value) {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text) {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line) {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value) {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4212
24,24,24,24,Config,Config,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text): <fim_suffix> {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value) {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text) {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line) {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value) {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4214
25,25,25,25,Config,Config,30d2bb4fdee631da49c7d9cbb94237a68567e65c,"<fim_prefix>//! Copyright (c) 2022 Victorien Elvinger
//! Licensed under Apache License 2.0 (https://apache.org/licenses/LICENSE-2.0)

export class ConfigError extends Error {
    declare readonly name: ""ConfigError""

    constructor(message) {
        super(message)
        this.name = ""ConfigError""
    }
}

export interface Config {
    readonly generator: ""bare"" | ""dts"" | ""js"" | ""ts""
    readonly importConfig: boolean
    readonly importFactory: boolean
    readonly legacy: boolean
    readonly out: string | number
    readonly pedantic: boolean
    readonly schema: string | number
    readonly useClass: boolean
    readonly useFlatUnion: boolean
    readonly useGenericArray: boolean
    readonly useIntEnum: boolean
    readonly useLaxOptional: boolean
    readonly useMutable: boolean
    readonly useQuotedProperty: boolean
    readonly useSafeInt: boolean
    readonly useUndefined: boolean
}

/**
 * @param {Partial<Config>} part
 * @returns {Config} completed config
 * @throws {ConfigError} when the code generator cannot be determinate or
 *  when the schema format is not a supported.
 */
export function Config({
    generator,
    importConfig = false,
    importFactory = false,
    legacy = false,
    out = """",
    pedantic = false,
    schema = """",
    useClass = false,
    useFlatUnion = false,
    useGenericArray = false,
    useIntEnum = false,
    useLaxOptional = false,
    useMutable = false,
    useQuotedProperty = false,
    useSafeInt = false,
    useUndefined = false,
}): <fim_suffix> {
    if (
        typeof schema === ""string"" &&
        schema !== """" &&
        !schema.endsWith("".bare"")
    ) {
        throw new ConfigError(
            ""a file containing a BARE schema must end with extension '.bare'."",
        )
    }
    const inferredGenerator =
        typeof out === ""string"" && out.endsWith("".bare"")
            ? ""bare""
            : typeof out === ""string"" && out.endsWith("".d.ts"")
            ? ""dts""
            : typeof out === ""string"" && out.endsWith("".ts"")
            ? ""ts""
            : typeof out === ""string"" && out.endsWith("".js"")
            ? ""js""
            : (typeof out === ""number"" || out === """") && generator === undefined
            ? ""ts""
            : generator
    if (generator !== undefined && inferredGenerator !== generator) {
        throw new ConfigError(
            `the inferred generator '${inferredGenerator}' from out '${out}' does not match the chosen generator '${generator}'.`,
        )
    }
    if (inferredGenerator === undefined) {
        throw new ConfigError(
            ""the code generator to use cannot be determinate. Please set the option 'generator'."",
        )
    }
    return {
        generator: inferredGenerator,
        importConfig,
        importFactory,
        legacy,
        out,
        pedantic,
        schema,
        useClass,
        useFlatUnion,
        useGenericArray,
        useIntEnum,
        useLaxOptional,
        useMutable,
        useQuotedProperty,
        useSafeInt,
        useUndefined,
    }
}
<fim_middle>",correct,4691
26,26,26,26,Config,Config,52d6fc301866fccc3a2004222d9a88498840f05e,"<fim_prefix>

interface Config {
    rc: any
    redirect?: string
    rootFile?: string
    /** 过滤文件 */
    filter?: (file) => boolean
    /** 定义组件返回 */
    component: (file) => any
}
/**
 * https://github.com/MrHzq/vue-router-auto
 * rc：require.context 传入的文件
 * redirect：需要将根路由(/)重定向到的路由
 * rootFile：页面级别的.vue存放的文件名称
 * filter：过滤文件
 * component：定义组件返回
 */
export function createRouters(config: <fim_suffix>) {
    // 所生成的所有路由数组
    const Routers: any = []
    const defaultConfig: Config = {
        rc: null,
        redirect: '',
        rootFile: 'pages',
        filter: () => true,
        component: () => ({})
    }
    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign(
        {},
        defaultConfig,
        config
    )
    if (rc === null) return Routers

    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面
    const allRouters: any = {
        len1: []
    }
    // 通过循环RC(传入的文件)
    const routerFileAndLen = rc
        .keys()
        .filter(filter)
        .map((fileName) => {
            // 因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名
            const realFileName = fileName
                .replace(/^\.\//, '')
                .replace(/\.\w+$/, '')
            return {
                file: fileName,
                fileName: realFileName,
                // routerName(路由名称)：将 / 转为 - 并去掉 _
                routerName: realFileName.replace(/\//g, '-').replace(/_/g, '').replace(/-index/g, ''),
                // routerComponent(路由异步component的文件路径)：将 ./baseButton.vue 从 . 之后截取
                routerComponent: fileName.substr(1),
                // fileLen(文件的层级深度)：通过 / 的数量来判断当前文件的深度
                fileLen: fileName.match(/\//g).length
            }
        })
        .sort((i, j) => i.fileLen - j.fileLen) // 通过文件深度 升序排序

    // 传入文件中最大深度
    let maxLen = 0
    routerFileAndLen.map((r) => {
        const name = r.routerName
        // 生成一块路由对象，包含：name、fileName(用于后续处理真正path的依据)、path、needDelectName(用于后续处理，判断是否删除name的依据)、component
        const obj = {
            name,
            exact: true,
            fileName: r.fileName,
            // path：只是以name命名的path，还不是真正的路由path
            path: '/' + (name === 'index' ? '' : name),
            // needDelectName: name === 'index',
            needDelectName: false,
            component: component(rc(r.file))//() => import(`~/${rootFile}${r.routerComponent}`)
        }
        maxLen = r.fileLen
        // allRouters的key：以 'len'加当前的文件深度 作为key
        const key = 'len' + maxLen
        if (Array.isArray(allRouters[key])) allRouters[key].push(obj)
        else allRouters[key] = [obj]
    })

    // 将根目录层的路由放入Routers中
    // @ts-ignore
    Routers.push(...allRouters.len1)

    // 截取名称方法：从开始到最后一个'-'之间的字符串
    const substrName = (name) => name.substr(0, name.lastIndexOf('-'))

    /**
     * 正式生成路由：1、将相应的路由放在对应的路由下，形成子路由；2、生成同级路由
     * index：当前文件深度，为maxlen的倒序循环
     * nofindnum：未找到路由的次数
     * newcurr：当前新的深度下的路由数据
     */
    const ceateRouter = (index, nofindnum = 0, newcurr = null) => {
        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据
        const curr = newcurr || allRouters['len' + index]
        // 当前深度上一层的路由数据
        const pre = allRouters['len' + (index - 1)]
        // 若 没有上一层的数据了
        if (!pre) {
            // 则表明是属于顶层的路由
            curr.map((c) => {
                let path = '/' + c.fileName.replace('/index', '')
                // if (path.match('_')) path = path.replace('/_', '/:')
                // 将真正的路由path赋值给当前路由
                c.path = path
                // 将当前路由放到Routers里面
                Routers.push(c)
            })
            return
        }

        // 在上一层中 未找到的 当前深度路由数据
        let noFind: any = []

        // 循环当前深度路由数据
        curr?.map((c) => {
            // 在 上一层深度 的路由数据里面查找
            const fobj = pre.find((p) => {
                // 生成 当前深度 当前项 路由的name
                let name = substrName(c.name)
                // 循环nofindnum，当nofindnum>0，则表示已经出现：在上一层中未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成
                for (let i = 0; i < nofindnum; i++) {
                    name = substrName(name)
                }

                return name === p.name
            })
            // 如果 找到了 对应的 父路由数据(fobj)
            if (fobj) {
                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；

                let path = c.fileName
                    .replace(fobj.fileName, '')
                    .substr(1)
                    .replace('_', ':')
                if (path.match('/') && !path.match('/:')) {
                    path = path.replace('/index', '')
                }
                if (path === undefined) {
                    throw new Error(
                        `找到了对应的父路由，但是生成子路由的path为【undefined】了`
                    )
                }

                // 将真正的路由path赋值给当前路由
                c.path = path

                // 若：当前路由为 index
                if (path === 'index') {
                    // 1、转为 '' path，''：表明是默认子路由，那父路由就不能存在name属性
                    c.path = ''
                    // 2、将父路由的needDelectName标记为true，表明需要删除它的name
                    fobj.needDelectName = fobj.needDelectName || true
                }
                // 将当前路由放到父路由的children里面
                if (Array.isArray(fobj.children)) fobj.children.push(c)
                else fobj.children = [c]
            } else noFind.push(c) // 表明未找到父路由，则先将当前路由的数据放入noFind中存储起来
        })

        // 若存在：未找到的路由数据，则再次向上一个层级寻找
        if (noFind.length) ceateRouter(index - 1, ++nofindnum, noFind)
    }
    // 倒序循环 最大深度，然后调用生成路由方法
    for (let i = maxLen; i > 1; i--) ceateRouter(i)

    // 路由生成完毕了，应该删除 有默认子路由的父路由的name属性
    const deleteNameFun = (arr) => {
        arr.map((r) => {
            // 删除多余的fileName属性
            delete r.fileName
            // 判断是否需要删除name属性
            if (r.needDelectName) delete r.name
            // 判断完毕了，则要删除needDelectName属性
            delete r.needDelectName
            // 若 存在子路由 则继续调用deleteNameFun，删除name
            if (Array.isArray(r.children)) deleteNameFun(r.children)
        })
    }
    // 调用deleteNameFun，先删除Routers的一级路由的name
    deleteNameFun(Routers)

    // 若存在重定向的路由，则加入重定向
    if (redirect) Routers.unshift({ path: '/', redirect })
    // 返回正儿八经的的路由数据
    return Routers
}<fim_middle>",correct,5015
27,27,27,27,Container,Container,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args): <fim_suffix> {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,994
28,28,28,28,Container,Container,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args): <fim_suffix> {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,997
29,29,29,29,Context,Context,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name
) => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?: <fim_suffix>) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,204
30,30,30,30,Converter,Converter,447872004859a7953a492bb7f23a814bdf0b3451,"<fim_prefix>const BitLookup = [ 1, 2, 4, 8, 16, 32, 64, 128 ];

export interface Converter
{
  atob?: (s) => string;
  btoa?: (s) => string;
}

// In NodeJS:

// {
//  btoa: (s: string) => { return Buffer.from(s, 'binary').toString('base64') },
//  atob: (s: string) => { return Buffer.from(s, 'base64').toString('binary') },
// }

// In Browser:

// {
//  btoa: window.btoa,
//  atob: window.atob,
// }

export class ListToBitset
{
  list: string[];
  index: { [s: string]: number };
  size: number;
  converter: Converter;

  constructor(list, converter?: <fim_suffix>)
  {
    this.list = list;
    this.converter = converter;
  }

  toBits(l)
  {
    if (! this.index)
    {
      this.size = Math.floor((this.list.length+7)/8);
      this.index = {};
      this.list.forEach((s, i) => { this.index[s] = i });
    }
    let ab = new ArrayBuffer(this.size);
    let u8 = new Uint8Array(ab);
    if (l) l.forEach(s => {
        let n = this.index[s];
        let i = Math.floor(n/8);
        u8[i] |= BitLookup[n % 8];
      });
    return u8;
  }

  toList(u8)
  {
    let list: string[] = [];
    for (let i = 0; i < u8.length; i++)
    {
      let u = u8[i];
      if (u)
      {
        if (u & 1) list.push(this.list[i*8+0]);
        if (u & 2) list.push(this.list[i*8+1]);
        if (u & 4) list.push(this.list[i*8+2]);
        if (u & 8) list.push(this.list[i*8+3]);
        if (u & 16) list.push(this.list[i*8+4]);
        if (u & 32) list.push(this.list[i*8+5]);
        if (u & 64) list.push(this.list[i*8+6]);
        if (u & 128) list.push(this.list[i*8+7]);
      }
    }
    return list;
  }

  base64tou8(base64)
  {
    let raw = this.converter.atob(base64);
    let rawLength = raw.length;
    let u8 = new Uint8Array(new ArrayBuffer(rawLength));
    for (let i = 0; i < rawLength; i++)
      u8[i] = raw.charCodeAt(i);
    return u8;
  }

  u8ToBase64(u8)
  {
    let binary: string[] = [];
    let len = u8.byteLength;
    for (let i = 0; i < len; i++) {
        binary.push(String.fromCharCode(u8[i]));
    }
    return this.converter.btoa(binary.join(''));
}

  fromBitString(base64)
  {
    return this.toList(this.base64tou8(base64));
  }

  toBitString(l)
  {
    // Note: On server, Buffer.from(this.toBits(l)).toString('base64') probably faster
    return this.u8ToBase64(this.toBits(l));
  }
}
<fim_middle>",correct,5135
31,31,31,31,Currency,Currency,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest() {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency: <fim_suffix> = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions) {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",correct,2971
32,32,32,32,Cx,Cx,6b2e48994d25dfb77d9f951487af828409217c22,"<fim_prefix>/* Types */

type Tx<T> = () => Promise<T>;
type Cx = () => Promise<unknown>;

export class ReadOnly<T> {
  constructor(public tx) {}
}

export class Mutating<T> {
  constructor(public tx, public cx) {}
}

export class Pivot<T> {
  constructor(public tx) {}
}

type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;

export type Workflow = Generator<Step<any>, void, any>;

/* Constructors */

export const readOnly = <T>(tx) => new ReadOnly<T>(tx);

export const mutating = <T>(tx, cx: <fim_suffix>) =>
  new Mutating<T>(tx, cx);

export const pivot = <T>(tx) => new Pivot<T>(tx);

/* Workflow executor */

export async function run(workflow) {
  // a list of compensating functions
  let cxs: Cx[] = [];
  // a number of pivot operations happened during the workflow
  let nPivots: number = 0;
  // should the workflow be unrolled
  let unrollReason: unknown;

  let next: IteratorResult<Step<unknown>>;
  let res: unknown;

  try {
    next = workflow.next();
  } catch (e) {
    unrollReason = e;
  }

  while (!unrollReason && !next!.done) {
    const flow = next!.value;

    try {
      // execute async operation
      res = await flow.tx();
    } catch (e1) {
      // async exception caught
      try {
        // try rethrowing into workflow -- this acquires a next workflow step;
        // compensating operation is not added, because the atomic forward
        // operation didn't succeed, so nothing to compensate
        next = workflow.throw(e1);
        continue;
      } catch (e2) {
        // rethrowing didn't succeed, unroll
        unrollReason = e2;
        break;
      }
    }

    // async operation succeeds, register its aftereffects
    if (flow instanceof Mutating) {
      cxs.push(flow.cx);
    } else if (flow instanceof Pivot) {
      nPivots++;
    }

    // try acquiring next workflow step
    try {
      next = workflow.next(res);
      continue;
    } catch (e) {
      // caught a sync exception that is not caught inside workflow, unroll
      unrollReason = e;
      break;
    }
  }

  // unroll if error happened
  if (unrollReason) {
    // workflow is not revertible if there were completed pivot operations
    if (nPivots) {
      throw unrollReason;
    }

    for (const cx of cxs.reverse()) {
      // compensating function error means the state is unknown
      // this can only be handled by a caller, so no try-catch
      await cx();
    }
    throw unrollReason;
  }
}
<fim_middle>",correct,3734
33,33,33,33,Cx,Cx,6b2e48994d25dfb77d9f951487af828409217c22,"<fim_prefix>/* Types */

type Tx<T> = () => Promise<T>;
type Cx = () => Promise<unknown>;

export class ReadOnly<T> {
  constructor(public tx) {}
}

export class Mutating<T> {
  constructor(public tx, public cx: <fim_suffix>) {}
}

export class Pivot<T> {
  constructor(public tx) {}
}

type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;

export type Workflow = Generator<Step<any>, void, any>;

/* Constructors */

export const readOnly = <T>(tx) => new ReadOnly<T>(tx);

export const mutating = <T>(tx, cx) =>
  new Mutating<T>(tx, cx);

export const pivot = <T>(tx) => new Pivot<T>(tx);

/* Workflow executor */

export async function run(workflow) {
  // a list of compensating functions
  let cxs: Cx[] = [];
  // a number of pivot operations happened during the workflow
  let nPivots: number = 0;
  // should the workflow be unrolled
  let unrollReason: unknown;

  let next: IteratorResult<Step<unknown>>;
  let res: unknown;

  try {
    next = workflow.next();
  } catch (e) {
    unrollReason = e;
  }

  while (!unrollReason && !next!.done) {
    const flow = next!.value;

    try {
      // execute async operation
      res = await flow.tx();
    } catch (e1) {
      // async exception caught
      try {
        // try rethrowing into workflow -- this acquires a next workflow step;
        // compensating operation is not added, because the atomic forward
        // operation didn't succeed, so nothing to compensate
        next = workflow.throw(e1);
        continue;
      } catch (e2) {
        // rethrowing didn't succeed, unroll
        unrollReason = e2;
        break;
      }
    }

    // async operation succeeds, register its aftereffects
    if (flow instanceof Mutating) {
      cxs.push(flow.cx);
    } else if (flow instanceof Pivot) {
      nPivots++;
    }

    // try acquiring next workflow step
    try {
      next = workflow.next(res);
      continue;
    } catch (e) {
      // caught a sync exception that is not caught inside workflow, unroll
      unrollReason = e;
      break;
    }
  }

  // unroll if error happened
  if (unrollReason) {
    // workflow is not revertible if there were completed pivot operations
    if (nPivots) {
      throw unrollReason;
    }

    for (const cx of cxs.reverse()) {
      // compensating function error means the state is unknown
      // this can only be handled by a caller, so no try-catch
      await cx();
    }
    throw unrollReason;
  }
}
<fim_middle>",correct,3739
34,34,34,34,Date,Date,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date): <fim_suffix> {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",correct,693
35,35,35,35,Date,Date,1cff957f4d2e357142c20a3575489611cf52b52e,"<fim_prefix>export const emailRegex =
  /^(([^<>()\[\]\\.,;:\s@""]+(\.[^<>()\[\]\\.,;:\s@""]+)*)|("".+""))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/

//https://www.twilio.com/docs/glossary/what-e164
const phoneRegex = /^\+[1-9]\d{1,14}$/

export const validateEmpty = (
  value?,
  message?
) => {
  let errorMessage = ''
  if (!value) {
    errorMessage = message || 'Required'
  }
  return errorMessage
}

export const validateMinLength = (
  value,
  minLength,
  fieldName = 'Field'
) =>
  value.length < minLength
    ? `${fieldName} requires at least ${minLength} characters`
    : ''

export const validateEmail = (email, equalTo?) => {
  let validation = ''
  if (equalTo) {
    validation = email === equalTo ? '' : 'Emails must match'
  }
  if (validation) {
    return validation
  }
  return !emailRegex.test(email) ? 'Please enter a valid email address' : ''
}

export const validatePasswords = (password, equalTo) => {
  let validation = ''
  if (equalTo) {
    validation = password === equalTo ? '' : 'Passwords must match'
  }
  if (validation) {
    return validation
  }
  validation = validateEmpty(password)
  if (validation) {
    return validation
  }

  return validateMinLength(password, 6, 'Password')
}

export const validateAge = (
  dateOfBirth: <fim_suffix>,
  minimumAge = 18
) => {
  const today = new Date()
  const age = today.getFullYear() - dateOfBirth.getFullYear()
  return age < minimumAge ? `You must be at least ${minimumAge} years old` : ''
}

interface IValidatePhoneNumber {
  phoneNumber?: string
  customError?: string
}
export const validatePhoneNumber = ({
  phoneNumber,
  customError,
}) => {
  if (!phoneNumber) {
    return customError || 'Please enter a phone number'
  }

  return !phoneRegex.test(`${phoneNumber}`)
    ? customError || 'Please enter a valid phone number'
    : ''
}
<fim_middle>",correct,969
36,36,36,36,Date,Date,22df358673565dcee46071280b05b031077329af,"<fim_prefix>export type MonthAndYearType = {
  string: string
  date: Date
}

const monthStrings = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'Novemeber',
  'Decemeber',
]

export const getMonthAndYearOptions = () => {
  const date = new Date()
  const year = date.getFullYear()
  const startMonth = date.getMonth()
  const months: MonthAndYearType[] = []

  for (let i = 0; i < 12; i++) {
    if (startMonth + i > 11) {
      months.push({
        string: `${monthStrings[startMonth + i - 12]} ${year + 1}`,
        date: new Date(year + 1, startMonth + i - 12, 1),
      })
    } else {
      months.push({
        string: `${monthStrings[startMonth + i]} ${year}`,
        date: new Date(year, startMonth + i, 1),
      })
    }
  }

  return months
}

export const sameMonthAndYear = (dateA, dateB) => {
  return (
    dateA.getMonth() === dateB.getMonth() &&
    dateA.getFullYear() === dateB.getFullYear()
  )
}

export const getNextMonth = (date) => {
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 11) {
    return new Date(year + 1, 0, 1)
  }

  return new Date(year, month + 1, 1)
}

export const getPreviousMonth = (date) => {
  const today = new Date()
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 0) {
    if (today.getFullYear() === year - 1 && today.getMonth() === 11) {
      return new Date(year - 1, 11, today.getDate())
    }
    return new Date(year - 1, 11, 1)
  }

  if (today.getFullYear() === year && today.getMonth() === month - 1) {
    return new Date(year, month - 1, today.getDate())
  }
  return new Date(year, month - 1, 1)
}

const getDateString = (year, month, day) => {
  return new Date(year, month, day).toDateString()
}

const isLeapYear = (date) => {
  const year = date.getFullYear()

  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
}

const getDaysInMonth = (date) => {
  const leapYear = isLeapYear(date)
  const month = date.getMonth()

  // getMonth() returns zero indexed month, so each month is the normal month number - 1
  // I.E. January is 0, February is 1, March is 2, etc.
  switch (month) {
    case 1:
      if (leapYear) {
        return 29
      }
      return 28
    case 3:
    case 5:
    case 8:
    case 10:
      return 30
    default:
      return 31
  }
}

export const generateDays = (date: <fim_suffix>) => {
  const year = date.getFullYear()
  const month = date.getMonth()
  const daysInMonth = getDaysInMonth(date)
  const today = new Date()
  const days = []

  for (let i = 1; i < daysInMonth + 1; i++) {
    if (
      i < today.getDate() &&
      month <= today.getMonth() &&
      year <= today.getFullYear()
    ) {
      days.push({
        date: i,
        disabled: true,
        dateString: getDateString(year, month, i),
      })
    } else {
      days.push({
        date: i,
        disabled: false,
        dateString: getDateString(year, month, i),
      })
    }
  }

  return days
}

// Generates an array of ""skip days"" to place the first day of the month
// on the right day of the week
export const getSkipDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  const firstDay = new Date(year, month, 1).getDay()
  const skipppedDays = []
  for (let i = 0; i < firstDay; i++) {
    skipppedDays.push(i)
  }

  return skipppedDays
}

export const getMonthAndYearString = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  return `${monthStrings[month]} ${year}`
}
<fim_middle>",correct,3178
37,37,37,37,Date,Date,22df358673565dcee46071280b05b031077329af,"<fim_prefix>export type MonthAndYearType = {
  string: string
  date: Date
}

const monthStrings = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'Novemeber',
  'Decemeber',
]

export const getMonthAndYearOptions = () => {
  const date = new Date()
  const year = date.getFullYear()
  const startMonth = date.getMonth()
  const months: MonthAndYearType[] = []

  for (let i = 0; i < 12; i++) {
    if (startMonth + i > 11) {
      months.push({
        string: `${monthStrings[startMonth + i - 12]} ${year + 1}`,
        date: new Date(year + 1, startMonth + i - 12, 1),
      })
    } else {
      months.push({
        string: `${monthStrings[startMonth + i]} ${year}`,
        date: new Date(year, startMonth + i, 1),
      })
    }
  }

  return months
}

export const sameMonthAndYear = (dateA, dateB) => {
  return (
    dateA.getMonth() === dateB.getMonth() &&
    dateA.getFullYear() === dateB.getFullYear()
  )
}

export const getNextMonth = (date: <fim_suffix>) => {
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 11) {
    return new Date(year + 1, 0, 1)
  }

  return new Date(year, month + 1, 1)
}

export const getPreviousMonth = (date) => {
  const today = new Date()
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 0) {
    if (today.getFullYear() === year - 1 && today.getMonth() === 11) {
      return new Date(year - 1, 11, today.getDate())
    }
    return new Date(year - 1, 11, 1)
  }

  if (today.getFullYear() === year && today.getMonth() === month - 1) {
    return new Date(year, month - 1, today.getDate())
  }
  return new Date(year, month - 1, 1)
}

const getDateString = (year, month, day) => {
  return new Date(year, month, day).toDateString()
}

const isLeapYear = (date) => {
  const year = date.getFullYear()

  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
}

const getDaysInMonth = (date) => {
  const leapYear = isLeapYear(date)
  const month = date.getMonth()

  // getMonth() returns zero indexed month, so each month is the normal month number - 1
  // I.E. January is 0, February is 1, March is 2, etc.
  switch (month) {
    case 1:
      if (leapYear) {
        return 29
      }
      return 28
    case 3:
    case 5:
    case 8:
    case 10:
      return 30
    default:
      return 31
  }
}

export const generateDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()
  const daysInMonth = getDaysInMonth(date)
  const today = new Date()
  const days = []

  for (let i = 1; i < daysInMonth + 1; i++) {
    if (
      i < today.getDate() &&
      month <= today.getMonth() &&
      year <= today.getFullYear()
    ) {
      days.push({
        date: i,
        disabled: true,
        dateString: getDateString(year, month, i),
      })
    } else {
      days.push({
        date: i,
        disabled: false,
        dateString: getDateString(year, month, i),
      })
    }
  }

  return days
}

// Generates an array of ""skip days"" to place the first day of the month
// on the right day of the week
export const getSkipDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  const firstDay = new Date(year, month, 1).getDay()
  const skipppedDays = []
  for (let i = 0; i < firstDay; i++) {
    skipppedDays.push(i)
  }

  return skipppedDays
}

export const getMonthAndYearString = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  return `${monthStrings[month]} ${year}`
}
<fim_middle>",correct,3185
38,38,38,38,Date,Date,22df358673565dcee46071280b05b031077329af,"<fim_prefix>export type MonthAndYearType = {
  string: string
  date: Date
}

const monthStrings = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'Novemeber',
  'Decemeber',
]

export const getMonthAndYearOptions = () => {
  const date = new Date()
  const year = date.getFullYear()
  const startMonth = date.getMonth()
  const months: MonthAndYearType[] = []

  for (let i = 0; i < 12; i++) {
    if (startMonth + i > 11) {
      months.push({
        string: `${monthStrings[startMonth + i - 12]} ${year + 1}`,
        date: new Date(year + 1, startMonth + i - 12, 1),
      })
    } else {
      months.push({
        string: `${monthStrings[startMonth + i]} ${year}`,
        date: new Date(year, startMonth + i, 1),
      })
    }
  }

  return months
}

export const sameMonthAndYear = (dateA, dateB: <fim_suffix>) => {
  return (
    dateA.getMonth() === dateB.getMonth() &&
    dateA.getFullYear() === dateB.getFullYear()
  )
}

export const getNextMonth = (date) => {
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 11) {
    return new Date(year + 1, 0, 1)
  }

  return new Date(year, month + 1, 1)
}

export const getPreviousMonth = (date) => {
  const today = new Date()
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 0) {
    if (today.getFullYear() === year - 1 && today.getMonth() === 11) {
      return new Date(year - 1, 11, today.getDate())
    }
    return new Date(year - 1, 11, 1)
  }

  if (today.getFullYear() === year && today.getMonth() === month - 1) {
    return new Date(year, month - 1, today.getDate())
  }
  return new Date(year, month - 1, 1)
}

const getDateString = (year, month, day) => {
  return new Date(year, month, day).toDateString()
}

const isLeapYear = (date) => {
  const year = date.getFullYear()

  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
}

const getDaysInMonth = (date) => {
  const leapYear = isLeapYear(date)
  const month = date.getMonth()

  // getMonth() returns zero indexed month, so each month is the normal month number - 1
  // I.E. January is 0, February is 1, March is 2, etc.
  switch (month) {
    case 1:
      if (leapYear) {
        return 29
      }
      return 28
    case 3:
    case 5:
    case 8:
    case 10:
      return 30
    default:
      return 31
  }
}

export const generateDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()
  const daysInMonth = getDaysInMonth(date)
  const today = new Date()
  const days = []

  for (let i = 1; i < daysInMonth + 1; i++) {
    if (
      i < today.getDate() &&
      month <= today.getMonth() &&
      year <= today.getFullYear()
    ) {
      days.push({
        date: i,
        disabled: true,
        dateString: getDateString(year, month, i),
      })
    } else {
      days.push({
        date: i,
        disabled: false,
        dateString: getDateString(year, month, i),
      })
    }
  }

  return days
}

// Generates an array of ""skip days"" to place the first day of the month
// on the right day of the week
export const getSkipDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  const firstDay = new Date(year, month, 1).getDay()
  const skipppedDays = []
  for (let i = 0; i < firstDay; i++) {
    skipppedDays.push(i)
  }

  return skipppedDays
}

export const getMonthAndYearString = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  return `${monthStrings[month]} ${year}`
}
<fim_middle>",correct,3186
39,39,39,39,Date,Date,88616d2acf8d66a97538d1bb1d1d2e0761bd2463,"<fim_prefix>export interface TimeDelta {
  sign: '' | '+',
  years: number,
  months: number,
  days: number,
  hours: number,
  minutes: number,
  seconds: number,
}

export interface AgeOptions {
  /**
   * Comparison date
   */
  now?: Date;

  /**
   * Precision
   */
  levels?: number;
}

/**
 * Get the ymdhms differences between two dates
 *
 * @param left  + date value
 * @param right - date value
 * @returns     difference between the two dates
 */
export function getTimeDelta(
  left,
  right,
) {
  const {
    secondsPerSecond: secondsPerSecond,
    secondsPerMinute: secondsPerMinute,
    secondsPerHour: secondsPerHour,
    secondsPerDay: secondsPerDay,
    secondsPerMonth: secondsPerMonth,
    secondsPerYear: secondsPerYear,
  } = getAge.defaults;

  const leftMs = left.valueOf();
  const rightMs = right.valueOf();
  let delta = Math.abs(leftMs - rightMs) / 1000;

  const years = Math.floor(delta / secondsPerYear);
  delta -= years * secondsPerYear;

  const months = Math.floor(delta / secondsPerMonth);
  delta -= months * secondsPerMonth;

  const days = Math.floor(delta / secondsPerDay);
  delta -= days * secondsPerDay;

  const hours = Math.floor(delta / secondsPerHour);
  delta -= hours * secondsPerHour;

  const minutes = Math.floor(delta / secondsPerMinute);
  delta -= minutes * secondsPerMinute;

  const seconds = Math.floor(delta / secondsPerSecond);
  delta -= seconds * secondsPerSecond;

  const timeDelta: TimeDelta = {
    sign: leftMs < rightMs ? '+' : '',
    years,
    months,
    days,
    hours,
    minutes,
    seconds,
  };

  return timeDelta;
}


/**
 * Get the approximate age of the given date from now
 *
 * @param birth     date to find the age of
 * @param options
 * @returns         approximate age of the date
 *
 * @example
 * ```ts
 * '2y3m4d'
 * '2y4d1h'
 * '3y2m1s'
 * '17s'
 * ```
 */
export function getAge(
  birth: <fim_suffix>,
  options?
) {
  const now = options?.now ?? getAge.defaults.NOW();
  const levels = options?.levels ?? getAge.defaults.LEVELS;
  const delta = getTimeDelta(now, birth);
  let str = delta.sign;
  let cnt = 0;

  if (levels < 0) {
    throw new TypeError(`getAge(): ""levels"" must be >= 0. Given: ${levels}.`);
  }

  // years

  if (delta.years) {
    str += `${delta.years}y`;
    cnt += 1;
  }

  // months

  if (cnt >= levels) return str;

  if (delta.months) {
    str += `${delta.months}m`;
    cnt += 1;
  }

  // days

  if (cnt >= levels) return str;

  if (delta.days) {
    str += `${delta.days}d`;
    cnt += 1;
  }

  // hours

  if (cnt >= levels) return str;

  if (delta.hours) {
    str += `${delta.hours}h`;
    cnt += 1;
  }

  // minutes

  if (cnt >= levels) return str;

  if (delta.minutes) {
    str += `${delta.minutes}m`;
    cnt += 1;
  }

  // seconds

  if (cnt >= levels) return str;

  if (delta.seconds) {
    str += `${delta.seconds}s`;
    cnt += 1;
  }

  // if there is no difference, show zero seconds...

  if (cnt === 0) {
    str += '0s';
  }

  return str;
}

/**
 * defaults for usage with `@nkp/age` functions
 */
getAge.defaults = {
  secondsPerSecond: 1,
  secondsPerMinute: 1 * 60,
  secondsPerHour  : 1 * 60 * 60,
  secondsPerDay   : 1 * 60 * 60 * 24,
  // on average 30.437 days in a month
  secondsPerMonth : 1 * 60 * 60 * 24 * 30.437,
  // SECONDS_PER_MONTH : 1 * 60 * 60 * 24 * 30,
  // on average 365.24 days in a year
  secondsPerYear  : 1 * 60 * 60 * 24 * 365.24,
  // SECONDS_PER_YEAR  : 1 * 60 * 60 * 24 * 365,

  NOW: () => new Date(),
  LEVELS: 3,
};
<fim_middle>",correct,3429
40,40,40,40,DateTimeField,DateTimeField,5f2d2febe1a2a566772fc84aa89c133d84d3093b,"<fim_prefix>/**
 * Number
 */
type NumberField = {
  type: 'number';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const number = (options) => {
  return {
    type: 'number',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * BigInt
 */
type BigIntField = {
  type: 'bigint';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const bigInt = (options) => {
  return {
    type: 'bigint',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * String
 */
type StringField = {
  type: 'string';
  maxLength: number;
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const string = (options) => {
  return {
    type: 'string',
    maxLength: options.maxLength,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Boolean
 */
type BooleanField = {
  type: 'boolean';
  canBeNull: boolean;
  default: boolean | null;
  primaryKey: boolean;
};

export const boolean = (options) => {
  return {
    type: 'boolean',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Enumerated
 */
type EnumeratedField = {
  type: 'enumerated';
  values: string[];
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const enumerated = (options) => {
  return {
    type: 'enumerated',
    values: options.values,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * DateTime
 */
type DateTimeField = {
  type: 'datetime';
  canBeNull: boolean;
  default: Date | null;
  primaryKey: boolean;
};

export const dateTime = (options): <fim_suffix> => {
  return {
    type: 'datetime',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Any Field
 */
export type AnyField =
  | NumberField
  | BigIntField
  | StringField
  | BooleanField
  | EnumeratedField
  | DateTimeField;

export type Fields = {
  [key: string]: AnyField;
};
<fim_middle>",correct,4931
41,41,41,41,Deps,Deps,4ecebdfe2a83e32ca2665144d05b64c53181178a,"<fim_prefix>/**
 *
 *
 * Copied direcly from: https://github.com/pmndrs/jotai/blob/main/src/utils/weakCache.ts
 *
 * Eventually just import it from Jotai if it's exported.
 *
 *
 *
 */
export type WeakCache<T> = WeakMap<object, [WeakCache<T>] | [WeakCache<T>, T]>;

const getWeakCacheItem = <T>(
  cache,
  deps
) => {
  while (true) {
    const [dep, ...rest] = deps;
    const entry = cache.get(dep as object);
    if (!entry) {
      return;
    }
    if (!rest.length) {
      return entry[1];
    }
    cache = entry[0];
    deps = rest;
  }
};

const setWeakCacheItem = <T>(
  cache,
  deps,
  item
) => {
  while (true) {
    const [dep, ...rest] = deps;
    let entry = cache.get(dep as object);
    if (!entry) {
      entry = [new WeakMap()];
      cache.set(dep as object, entry);
    }
    if (!rest.length) {
      entry[1] = item;
      return;
    }
    cache = entry[0];
    deps = rest;
  }
};

export const createMemoizeAtom = () => {
  const cache: WeakCache<{}> = new WeakMap();
  const memoizeAtom = <T extends {}, Deps extends readonly object[]>(
    createAtom,
    deps: <fim_suffix>
  ) => {
    const cachedAtom = getWeakCacheItem(cache, deps);
    if (cachedAtom) {
      return cachedAtom as T;
    }
    const createdAtom = createAtom();
    setWeakCacheItem(cache, deps, createdAtom);
    return createdAtom;
  };
  return memoizeAtom;
};
<fim_middle>",correct,3786
42,42,42,42,Difficulty,Difficulty,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty: <fim_suffix>) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty) => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",correct,4729
43,43,43,43,Dim,Dim,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by: <fim_suffix>)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1215
44,44,44,44,Dim,Dim,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over: <fim_suffix>, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1224
45,45,45,45,E,E,f3813017e9bb14bf831177d63f99b8ab50b44ad4,"<fim_prefix>export type Empty = {
    readonly _tag: 'Empty';
};
export type BeregnButton = {
    readonly _tag: 'BeregnButton';
};
export type BeregnButtonAndErrorSummary<E> = {
    readonly _tag: 'BeregnButtonAndErrorSummary';
    readonly errors: E;
};
export type NoValidChildrenOrange = {
    readonly _tag: 'NoValidChildrenOrange';
};
export type ResultBox<A> = {
    readonly _tag: 'ResultBox';
    readonly result: A;
};

export type ResultView<E, A> =
    | Empty
    | BeregnButton
    | BeregnButtonAndErrorSummary<E>
    | NoValidChildrenOrange
    | ResultBox<A>;

// constructors
export const empty: ResultView<never, never> = {
    _tag: 'Empty',
};
export const beregnButton: ResultView<never, never> = {
    _tag: 'BeregnButton',
};
export const beregnButtonAndErrorSummary = <E>(errors: <fim_suffix>) => ({
    _tag: 'BeregnButtonAndErrorSummary',
    errors,
});
export const noValidChildrenOrange: ResultView<never, never> = {
    _tag: 'NoValidChildrenOrange',
};
export const resultBox = <A>(result) => ({
    _tag: 'ResultBox',
    result,
});
// filters
export const isEmpty = (data): data is Empty => data._tag === 'Empty';
export const isBeregnButton = (data): data is BeregnButton =>
    data._tag === 'BeregnButton';
export const isBeregnButtonAndErrorSummary = <E>(
    data
): data is BeregnButtonAndErrorSummary<E> => data._tag === 'BeregnButtonAndErrorSummary';
export const isNoValidChildrenOrange = (data): data is NoValidChildrenOrange =>
    data._tag === 'NoValidChildrenOrange';
export const isResultBox = <A>(data): data is ResultBox<A> => data._tag === 'ResultBox';

// fold
export const caseResultViewOf =
    <E, A, B>(
        empty,
        beregnButton,
        beregnButtonAndErrorSummary,
        noValidChildrenOrange,
        resultBox
    ) =>
    (resultView) => {
        switch (resultView._tag) {
            case 'Empty': {
                return empty();
            }
            case 'BeregnButton': {
                return beregnButton();
            }
            case 'BeregnButtonAndErrorSummary': {
                return beregnButtonAndErrorSummary(resultView.errors);
            }
            case 'NoValidChildrenOrange': {
                return noValidChildrenOrange();
            }
            case 'ResultBox': {
                return resultBox(resultView.result);
            }
        }
    };
<fim_middle>",correct,3889
46,46,46,46,ElementType,ElementType,8ab616f33f5bd10a91c24a82c6b27b64f543e801,"<fim_prefix>
export interface SelectionElement {
  get selected();
  set selected(val);
  get value();

  addOnChange: (callback) => (() => void);
};

export class SelectionState<T = any, ElementType extends SelectionElement = SelectionElement> {
  elements: { el: ElementType, listener: () => void }[] = [];
  value: T | T[];
  any: boolean;
  all: boolean;
  onChange: (val, all, any) => void;
  onUpdate: (state) => void;

  constructor(
    public readonly allowMultiple,
    public readonly initialValue,
  ) {
    this.value = initialValue || (allowMultiple ? [] : undefined);
    if (this.allowMultiple && !Array.isArray(this.value)) this.value = [this.value];
  }

  private changed(sender?) {
    if (this.allowMultiple) {
      let all = true;
      let any = false;
      const res = [];
      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el.selected) {
          res.push(element.el.value);
          any = true;
        }
        else all = false;
      }
      this.value = res;
      this.all = all;
      this.any = any;
      return;
    } else {
      this.all = false;
      let firstChecked = sender;

      if (!firstChecked) {
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (element.el.selected) {
            firstChecked = element.el;
            break;
          }
        }
      }

      if (!firstChecked) {
        this.value = undefined;
        this.any = false;
        return;
      }

      if (!firstChecked.selected) firstChecked.selected = true;

      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el !== firstChecked) element.el.selected = false;
      }

      this.value = firstChecked.value;
      this.any = true;
    }
  }

  triggerChange() {
    this.onChange?.(this.value, this.all, this.any);
  }

  triggerUpdate() {
    this.onUpdate?.(this);
  }

  register(el) {
    const listener = el.addOnChange(() => {
      this.changed(el);
      this.triggerChange();
      this.triggerUpdate();
    });

    this.elements.push({ el, listener });

    if (this.allowMultiple && Array.isArray(this.value)) el.selected = this.value.includes(el.value);
    else el.selected = this.value === el.value;

    if (this.allowMultiple) {
      if (this.all && !el.selected) {
        this.all = false;
        this.triggerChange();
      }

      if (!this.any && el.selected) {
        this.any = true;
        this.triggerChange();
      }
    }

    this.triggerUpdate();
  }

  unregister(el: <fim_suffix>) {
    const ind = this.elements.findIndex(x => x.el === el);
    if (ind >= 0) {
      const item = this.elements[ind];
      this.elements.splice(ind, 1);
      if (item.listener) item.listener();
    }

    this.triggerUpdate();
  }

  setAll(checked?) {
    if (!this.allowMultiple && checked) throw new Error('Multiple values cannot be selected for radio groups');
    checked = !!checked;

    this.all = checked;
    this.any = checked;

    const values = [];
    for (let index = 0; index < this.elements.length; index++) {
      const element = this.elements[index];
      element.el.selected = checked;
    }

    this.value = this.allowMultiple ? values : undefined;
    this.all = checked;
    this.any = checked;
    this.triggerChange();
    this.triggerUpdate();
  }

  getSelectedElements() {
    const res: ElementType[] = [];
    for (let index = 0; index < this.elements.length; index++) {
      const { el } = this.elements[index];

      const isSelected = this.allowMultiple && Array.isArray(this.value) ? this.value.includes(el.value) : this.value === el.value;
      if (isSelected) res.push(el);
    }

    return res;
  }
}
<fim_middle>",correct,4457
47,47,47,47,ElementType,ElementType,8ab616f33f5bd10a91c24a82c6b27b64f543e801,"<fim_prefix>
export interface SelectionElement {
  get selected();
  set selected(val);
  get value();

  addOnChange: (callback) => (() => void);
};

export class SelectionState<T = any, ElementType extends SelectionElement = SelectionElement> {
  elements: { el: ElementType, listener: () => void }[] = [];
  value: T | T[];
  any: boolean;
  all: boolean;
  onChange: (val, all, any) => void;
  onUpdate: (state) => void;

  constructor(
    public readonly allowMultiple,
    public readonly initialValue,
  ) {
    this.value = initialValue || (allowMultiple ? [] : undefined);
    if (this.allowMultiple && !Array.isArray(this.value)) this.value = [this.value];
  }

  private changed(sender?) {
    if (this.allowMultiple) {
      let all = true;
      let any = false;
      const res = [];
      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el.selected) {
          res.push(element.el.value);
          any = true;
        }
        else all = false;
      }
      this.value = res;
      this.all = all;
      this.any = any;
      return;
    } else {
      this.all = false;
      let firstChecked = sender;

      if (!firstChecked) {
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (element.el.selected) {
            firstChecked = element.el;
            break;
          }
        }
      }

      if (!firstChecked) {
        this.value = undefined;
        this.any = false;
        return;
      }

      if (!firstChecked.selected) firstChecked.selected = true;

      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el !== firstChecked) element.el.selected = false;
      }

      this.value = firstChecked.value;
      this.any = true;
    }
  }

  triggerChange() {
    this.onChange?.(this.value, this.all, this.any);
  }

  triggerUpdate() {
    this.onUpdate?.(this);
  }

  register(el: <fim_suffix>) {
    const listener = el.addOnChange(() => {
      this.changed(el);
      this.triggerChange();
      this.triggerUpdate();
    });

    this.elements.push({ el, listener });

    if (this.allowMultiple && Array.isArray(this.value)) el.selected = this.value.includes(el.value);
    else el.selected = this.value === el.value;

    if (this.allowMultiple) {
      if (this.all && !el.selected) {
        this.all = false;
        this.triggerChange();
      }

      if (!this.any && el.selected) {
        this.any = true;
        this.triggerChange();
      }
    }

    this.triggerUpdate();
  }

  unregister(el) {
    const ind = this.elements.findIndex(x => x.el === el);
    if (ind >= 0) {
      const item = this.elements[ind];
      this.elements.splice(ind, 1);
      if (item.listener) item.listener();
    }

    this.triggerUpdate();
  }

  setAll(checked?) {
    if (!this.allowMultiple && checked) throw new Error('Multiple values cannot be selected for radio groups');
    checked = !!checked;

    this.all = checked;
    this.any = checked;

    const values = [];
    for (let index = 0; index < this.elements.length; index++) {
      const element = this.elements[index];
      element.el.selected = checked;
    }

    this.value = this.allowMultiple ? values : undefined;
    this.all = checked;
    this.any = checked;
    this.triggerChange();
    this.triggerUpdate();
  }

  getSelectedElements() {
    const res: ElementType[] = [];
    for (let index = 0; index < this.elements.length; index++) {
      const { el } = this.elements[index];

      const isSelected = this.allowMultiple && Array.isArray(this.value) ? this.value.includes(el.value) : this.value === el.value;
      if (isSelected) res.push(el);
    }

    return res;
  }
}
<fim_middle>",correct,4458
48,48,48,48,Error,Error,4626f86ebac17685496987c0b44d830041d92194,"<fim_prefix>export interface Part {
  name: string;
  group: PartGroupType;
  path: string;
  pathToSmallImage: string;
}

export interface PartsState {
  isLoading: boolean;
  error?: Error;
  backParts: Record<string, Part>;
  frontParts: Record<string, Part>;
  wordParts: Record<string, Part>;
}

export enum PartGroupType {
  BACK_NORMAL = 'BACK_NORMAL',
  BACK_SPECIAL = 'BACK_SPECIAL',
  FRONT_NORMAL = 'FRONT_NORMAL',
  FRONT_ANIMALS = 'FRONT_ANIMALS',
  FRONT_CODENAMES = 'FRONT_CODENAMES',
  FRONT_SPECIAL = 'FRONT_SPECIAL',
  WORD_NORMAL = 'WORD_NORMAL',
  WORD_PHONETIC = 'WORD_PHONETIC',
  WORD_CODENAMES = 'WORD_CODENAMES',
  WORD_NUMBER = 'WORD_NUMBER',
  WORD_LETTER = 'WORD_LETTER',
}

export const groupTypeDisplayNames = new Map([
  [PartGroupType.BACK_NORMAL, 'Normal'],
  [PartGroupType.BACK_SPECIAL, 'Special'],
  [PartGroupType.FRONT_NORMAL, 'Normal'],
  [PartGroupType.FRONT_SPECIAL, 'Special'],
  [PartGroupType.FRONT_ANIMALS, 'Animals'],
  [PartGroupType.FRONT_CODENAMES, 'Codenames'],
  [PartGroupType.WORD_NORMAL, 'Normal'],
  [PartGroupType.WORD_NUMBER, 'Numbers'],
  [PartGroupType.WORD_LETTER, 'Letter'],
  [PartGroupType.WORD_PHONETIC, 'Phonetic'],
  [PartGroupType.WORD_CODENAMES, 'Codenames'],
]);

export const backGroupTypes = new Set([
  PartGroupType.BACK_NORMAL,
  PartGroupType.BACK_SPECIAL,
]);

export const frontGroupTypes = new Set([
  PartGroupType.FRONT_NORMAL,
  PartGroupType.FRONT_ANIMALS,
  PartGroupType.FRONT_CODENAMES,
  PartGroupType.FRONT_SPECIAL,
]);

export const wordGroupTypes = new Set([
  PartGroupType.WORD_NORMAL,
  PartGroupType.WORD_PHONETIC,
  PartGroupType.WORD_CODENAMES,
  PartGroupType.WORD_NUMBER,
  PartGroupType.WORD_LETTER,
]);

export function loadingPartsState() {
  return {
    isLoading: true,
    backParts: {},
    frontParts: {},
    wordParts: {},
  };
}

export function successPartsState(json) {
  const backParts: Record<string, Part> = {};
  const frontParts: Record<string, Part> = {};
  const wordParts: Record<string, Part> = {};

  for (const id of Object.keys(json)) {
    const part = json[id];
    part.path = `/assets/images/${part.path}`;

    if (backGroupTypes.has(part.group)) {
      backParts[id] = part;
    } else if (frontGroupTypes.has(part.group)) {
      frontParts[id] = part;
    } else if (wordGroupTypes.has(part.group)) {
      wordParts[id] = part;
    }
  }

  return {
    isLoading: false,
    backParts,
    frontParts,
    wordParts,
  };
}

export function errorPartsState(error: <fim_suffix>) {
  return {
    isLoading: false,
    error,
    backParts: {},
    frontParts: {},
    wordParts: {},
  };
}
<fim_middle>",correct,1982
49,49,49,49,ErrorResponse,ErrorResponse,009999bb6cc1b9b148abc178a6579d671236e29a,"<fim_prefix>interface APIError {
	number: number
	field?: string
	message?: string
	object?: string
	value?: string
}

export type ErrorResponse =
	| { errors: APIError[] }
	| { code: string; message: string }

export default class APIClientError extends Error {
	name: string

	message: string

	code?: string

	errors?: APIError[]

	constructor(
		name,
		message,
		code?,
		errors?
	) {
		super()
		this.name = name
		this.message = message
		this.code = code
		this.errors = errors
	}
}

export const isErrorResponse = ({
	error,
	error_type: errorType,
	response,
}) => error || errorType || response.errors

export const transformErrorResponse = (errorResponse): <fim_suffix> => {
	const {
		response,
		error,
		error_description: errorDescription,
		error_type: errorType,
		message,
	} = errorResponse

	// singular error e.g., as returned by APIClient.users.me()
	if (error && errorDescription) {
		return {
			code: error,
			message: errorDescription,
		}
	}

	// not_found error
	if (errorType && message) {
		return {
			code: errorType,
			message,
		}
	}

	// general error supplied by valid endpoint
	return {
		errors: response.errors.map(
			({
				errno: number,
				field,
				message: msg,
				object,
				value,
			}) => ({
				number,
				field,
				message: msg,
				object,
				value,
			})
		),
	}
}
<fim_middle>",correct,3900
50,50,50,50,Factor,Factor,5854bf3dea0d67d8667446aaccf3a64dd1f826ee,"<fim_prefix>const DFG_VERSION = '0.18.1';
const PI = 3.14159;

export enum FactorType {
  PRIORPOSE2 = 'PriorPose2',
  POSE2POSE2 = 'Pose2Pose2',
  POSE2APRILTAG4CORNERS = 'Pose2AprilTag4Corners',
}

type FactorData = {
  eliminated: boolean;
  potentialused: boolean;
  edgeIDs: string[];
  fnc: any;
  multihypo: number[];
  certainhypo: number[];
  nullhypo: number;
  solveInProgress: number;
  inflation: number;
};

export type Factor = {
  label: string;
  nstime: string;
  fnctype: string;
  _variableOrderSymbols: string[];
  data: FactorData;
  solvable: number;
  tags: string[];
  timestamp: string;
  _version: string;
};

function InitializeFactorData() {
  return {
    eliminated: false,
    potentialused: false,
    edgeIDs: [],
    fnc: {},
    multihypo: [],
    certainhypo: [],
    nullhypo: 0.0,
    solveInProgress: 0,
    inflation: 3.0,
  };
}

export function PriorPose2Data(xythetaPrior = [0.0, 0.0, 0.0], xythetaCovars = [0.01, 0.01, 0.01]) {
  const fnc = {
    Z: {
      _type: 'IncrementalInference.PackedFullNormal',
      mu: xythetaPrior,
      cov: [xythetaCovars[0], 0.0, 0.0, 0.0, xythetaCovars[1], 0.0, 0.0, 0.0, xythetaCovars[2]],
    },
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1];
  return data;
}

export function Pose2Pose2Data(mus = [1, 0, 0.3333 * PI], sigmas = [0.01, 0.01, 0.01]) {
  const fnc = {
    Z: {
      _type: 'IncrementalInference.PackedFullNormal',
      mu: mus,
      cov: [sigmas[0], 0.0, 0.0, 0.0, sigmas[1], 0.0, 0.0, 0.0, sigmas[2]],
    },
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1, 2];
  return data;
}

export function Pose2AprilTag4CornersData(
  id,
  corners,
  homography,
  K = [300.0, 0.0, 0.0, 0.0, 300.0, 0.0, 180.0, 120.0, 1.0],
  taglength = 0.25,
) {
  const fnc = {
    _type: '/application/JuliaLang/PackedPose2AprilTag4Corners',
    corners,
    homography,
    K,
    taglength,
    id,
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1, 2];
  return data;
}

export function Factor(
  label,
  fncType,
  variableOrderSymbols,
  data,
  tags = ['FACTOR'],
  timestamp = new Date().toISOString(),
): <fim_suffix> {
  data.certainhypo = variableOrderSymbols.map((x, idx) => idx + 1);

  const result: Factor = {
    label,
    nstime: '0',
    fnctype: fncType,
    _variableOrderSymbols: variableOrderSymbols,
    data,
    solvable: 1,
    tags,
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",correct,2815
51,51,51,51,Fields,Fields,bf712f9fe76a6eeeb69b15794f6333cb9c774f5e,"<fim_prefix>/* eslint-disable @typescript-eslint/naming-convention */
export type ResponseMessage = {
    status: string;
    message: any;
};

export type ErrorResponse = {
    error: string;
    message?: string;
};

export type Fields = {
    id?: boolean;
    title?: boolean;
    main_picture?: boolean;
    alternative_titles?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    synopsis?: boolean;
    mean?: boolean;
    rank?: boolean;
    popularity?: boolean;
    num_list_users?: boolean;
    num_scoring_users?: boolean;
    nsfw?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    media_type?: boolean;
    status?: boolean;
    genres?: boolean;
    my_list_status?: boolean | Fields; // different possible fields
    num_episodes?: boolean;
    start_season?: boolean;
    broadcast?: boolean;
    source?: boolean;
    average_episode_duration?: boolean;
    rating?: boolean;
    pictures?: boolean;
    background?: boolean;
    related_anime?: boolean | Fields;
    related_manga?: boolean | Fields;
    recommendations?: boolean | Fields;
    studios?: boolean;
    statistics?: boolean;
    videos?: boolean;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function fieldsToString(fields) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    const entries = Object.entries(fields);
    let str = """";

    for (const entry of entries) {
        if (str.length > 0) {
            str += "","";
        }
        str += entry[0];
        if (entry[1] !== true && entry[1] !== false) {
            str += `{${fieldsToString(entry[1] as any)}}`;
        }
    }
    return str;
}

export function extractFields(str) {
    let subject = str;

    if (subject[0] === ""{"") {
        subject = subject.substr(1, subject.length);
    }

    let currentObject = """";
    const createdObj: any = {};

    function addObject(stri, val) {
        if (stri === """") return;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        createdObj[currentObject] = val;
        currentObject = """";
    }

    function skipSubject() {
        subject = subject.substr(1, subject.length);
    }

    while (subject.length > 0) {
        const subjZero = subject[0];

        if (subjZero === "" "") {
            skipSubject();
            if (subject.length === 0) {
                addObject(currentObject, true);
            }
            continue;
        }

        if (subjZero === ""{"") {
            const res = extractFields(subject);
            addObject(currentObject, res.fields);
            subject = res.remaining;
            continue;
        }
        if (subjZero === ""}"") {
            addObject(currentObject, true);

            skipSubject();
            if (subject[0] === "","") skipSubject();

            return {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                fields: createdObj,
                remaining: subject,
            };
        }
        if (subjZero === "","") {
            addObject(currentObject, true);
            skipSubject();
            continue;
        }

        currentObject += subjZero;
        skipSubject();

        if (subject.length === 0) {
            addObject(currentObject, true);
        }
    }

    return {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        fields: createdObj,
        remaining: """",
    };
}

export function allFields(): <fim_suffix> {
    return {
        alternative_titles: true,
        average_episode_duration: true,
        background: true,
        broadcast: true,
        created_at: true,
        end_date: true,
        genres: true,
        id: true,
        main_picture: true,
        mean: true,
        media_type: true,
        my_list_status: true,
        nsfw: true,
        num_episodes: true,
        num_list_users: true,
        num_scoring_users: true,
        pictures: true,
        popularity: true,
        rank: true,
        rating: true,
        recommendations: true,
        related_anime: true,
        related_manga: true,
        source: true,
        start_date: true,
        start_season: true,
        statistics: true,
        status: true,
        studios: true,
        synopsis: true,
        title: true,
        updated_at: true,
    };
}

type Relation = MediaNode & {
    relation_type: string;
    relation_type_formatted: string;
};

export type StatusNode = MediaNode & {
    list_status: ListStatus;
};

export type Media = {
    id: number;
    title: string;
    main_picture: Picture;
    alternative_titles?: {
        synonyms?: string[];
        en?: string;
        ja?: string;
    };
    start_date?: string;
    end_date?: string;
    synopsis?: string;
    mean?: number;
    rank?: number;
    popularity?: number;
    num_list_users?: number;
    num_scoring_users?: number;
    nsfw?: string;
    created_at?: string;
    updated_at?: string;
    media_type?: string;
    status?: string;
    genres?: Genre[];
    my_list_status?: ListStatus;
    num_episodes?: number;
    start_season?: Season;
    broadcast?: {
        day_of_the_week?: string;
        start_time?: string;
    };
    source?: string;
    average_episode_duration?: number;
    rating?: string;
    pictures?: Picture[];
    background?: string;
    related_anime?: Relation[];
    related_manga?: Relation[];
    recommendations?: (MediaNode & {
        num_recommendations?: number;
    })[];
    studios?: Studio[];
    statistics?: {
        status?: {
            watching?: string;
            completed?: string;
            on_hold?: string;
            dropped?: string;
            plan_to_watch?: string;
        };
        num_list_users?: number;
    };
};

export type tokenResponse = {
    token_type: ""Bearer"";
    expires_in: number;
    access_token: string;
    refresh_token: string;
};

export type Picture = {
    medium: string;
    large: string;
};

export type Genre = {
    id: number;
    name: string;
};

export type ListStatus = {
    status: ""watching"" | ""completed"" | ""on_hold"" | ""dropped"" | ""plan_to_watch"";
    score: number;
    num_episodes_watched: number;
    is_rewatching: boolean;
    updated_at: string;
};

export type ListPagination<T> = {
    data: T[];
    paging: {
        next: string;
        previous?: string | undefined;
    };
};

export type RequestResponse<T> = {
    response:
        | {
              response: T;
              tokens: tokenResponse;
          }
        | ErrorResponse;
};

export type MediaNode = {
    node: Media;
};

export type Season = {
    year: number;
    season: string;
};

export type Studio = {
    id: number;
    name: string;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isTokenResponse(obj): obj is tokenResponse {
    return ""tokenType"" in obj;
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isErrResp(obj): obj is ErrorResponse {
    return ""error"" in obj;
}
<fim_middle>",correct,4426
52,52,52,52,Function,Function,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn: <fim_suffix>, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",correct,838
53,53,53,53,Function,Function,27a493ada994b85fc1ed438e2a30a8ce7eab7c21,"<fim_prefix>/**
 * EventType
 */
interface EventType {
	readonly callback: Function;
	readonly once: boolean;
}

type EventsType = Record<string, EventType[]>;

const WILDCARD = '*';

/* event-emitter */
export default class EventEmitter {
	private _events: EventsType = {};

	/**
	 * 监听一个事件
	 * @param evt
	 * @param callback
	 * @param once
	 */
	on(evt, callback: <fim_suffix>, once?) {
		if (!this._events[evt]) {
			this._events[evt] = [];
		}
		this._events[evt].push({
			callback,
			once: !!once,
		});
		return this;
	}

	/**
	 * 监听一个事件一次
	 * @param evt
	 * @param callback
	 */
	once(evt, callback) {
		return this.on(evt, callback, true);
	}

	/**
	 * 触发一个事件
	 * @param evt
	 * @param args
	 */
	emit(evt, ...args) {
		const events = this._events[evt] || [];
		const wildcardEvents = this._events[WILDCARD] || [];

		// 实际的处理 emit 方法
		const doEmit = (es) => {
			let length = es.length;
			for (let i = 0; i < length; i++) {
				if (!es[i]) {
					continue;
				}
				const { callback, once } = es[i];

				if (once) {
					es.splice(i, 1);

					if (es.length === 0) {
						delete this._events[evt];
					}

					length--;
					i--;
				}

				callback.apply(this, args);
			}
		};

		doEmit(events);
		doEmit(wildcardEvents);
	}

	/**
	 * 取消监听一个事件，或者一个channel
	 * @param evt
	 * @param callback
	 */
	off(evt?, callback?) {
		if (!evt) {
			// evt 为空全部清除
			this._events = {};
		} else {
			if (!callback) {
				// evt 存在，callback 为空，清除事件所有方法
				delete this._events[evt];
			} else {
				// evt 存在，callback 存在，清除匹配的
				const events = this._events[evt] || [];

				let length = events.length;
				for (let i = 0; i < length; i++) {
					if (events[i].callback === callback) {
						events.splice(i, 1);
						length--;
						i--;
					}
				}

				if (events.length === 0) {
					delete this._events[evt];
				}
			}
		}

		return this;
	}

	/* 当前所有的事件 */
	getEvents() {
		return this._events;
	}
}
<fim_middle>",correct,2297
54,54,54,54,Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn: <fim_suffix>, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2321
55,55,55,55,Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?: <fim_suffix>)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2329
56,56,56,56,Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?: <fim_suffix>)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2332
57,57,57,57,Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?: <fim_suffix>)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2335
58,58,58,58,G,G,cc966119a9d0804aa81737f900326caade60f340,"<fim_prefix>interface ErrorOption {
  cause?: Error;
  status?: number;
}

interface Convertable {
  [key: string]: string | number;
}

type ConvertString<T extends Convertable, Group extends string> = {
  [P in keyof T]: P extends string
    ? T[P] extends number
      ? `${Uppercase<Group>}_${T[P]}`
      : never
    : never;
};

const codeGroup = new Set();

/**
 * Register error group and code, return the standard ErrorCode
 * @param errorGroup
 * @param errorCodeMapping
 */
export function registerErrorCode<T extends Convertable, G extends string>(
  errorGroup: <fim_suffix>,
  errorCodeMapping
) {
  if (codeGroup.has(errorGroup)) {
    throw new MidwayError(
      `Error group ${errorGroup} is duplicated, please check before adding.`
    );
  } else {
    codeGroup.add(errorGroup);
  }
  const newCodeEnum = {} as Convertable;
  // ERROR => GROUP_10000
  for (const errKey in errorCodeMapping) {
    newCodeEnum[errKey as string] =
      errorGroup.toUpperCase() +
      '_' +
      String(errorCodeMapping[errKey]).toUpperCase();
  }
  return newCodeEnum as ConvertString<T, G>;
}

export class MidwayError extends Error {
  code: number | string;
  cause: Error;

  constructor(message, options?);
  constructor(message, code, options?);
  constructor(message, code, options?) {
    super(message);
    if (!code || typeof code === 'object') {
      options = code;
      code = 'MIDWAY_10000';
    }
    this.name = this.constructor.name;
    this.code = code;
    this.cause = options?.cause;
  }
}

export type ResOrMessage = string | { message: string };

export class MidwayHttpError extends MidwayError {
  status: number;

  constructor(resOrMessage, status);
  constructor(
    resOrMessage,
    status,
    code,
    options?
  );
  constructor(
    resOrMessage,
    status,
    code?,
    options?
  ) {
    super(
      typeof resOrMessage === 'string' ? resOrMessage : resOrMessage.message,
      code ?? String(status),
      options
    );
    this.status = status;
  }
}
<fim_middle>",correct,2537
59,59,59,59,GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState) {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState, numberOfRounds): <fim_suffix> {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2132
60,60,60,60,GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState) {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState: <fim_suffix>, numberOfRounds) {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2134
61,61,61,61,GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState): <fim_suffix> {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState, numberOfRounds) {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2135
62,62,62,62,GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState: <fim_suffix>) {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState, numberOfRounds) {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2136
63,63,63,63,HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error): <fim_suffix> {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1145
64,64,64,64,HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error): <fim_suffix> {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1147
65,65,65,65,HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error): <fim_suffix> {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1151
66,66,66,66,HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error): <fim_suffix> {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1153
67,67,67,67,I,I,e0adc0a947e9e83b8bc03219033fde3d085cbfad,"<fim_prefix>
/**
 * The **bulk function** receives and array of atomic inputs and returns and array of outputs processed in bulk mode.
 * It is essential that this function works more effeciently with an array of items than doing the same operation individually.
 * The response of this function is an array where the items must be placed in the same position than the input items.
 * ```typescript
 * //bulk operation
 * mongodb.insertMany([obj1, obj2, obj3])
 * //atomic operation
 * Promise.all([
 *  mongodb.insertOne(obj1),
 *  mongodb.insertOne(obj2),
 *  mongodb.insertOne(obj3)
 * ])
 * ```
 * 
 * @typeParam Input The input item type.
 * @typeParam Output The output response type.
 */
export type ExecuteBulkFn<Input,Output> = (items) => Promise<Output[]>

class PromiseBulkSingle<I,O> {
    private _executionItemsPromise: Promise<O[]> = Promise.resolve([])
    private _pendingItems = []
    private _free = true


    constructor(private readonly _executeBulk) {}

    async execute(item: <fim_suffix>) {
        const newSize = this._pendingItems.push(item)
        const myIndex = newSize - 1

        if (this._free) {
            this._free = false
            const itemsToExecute = this._pendingItems
            this._pendingItems = []
            this._executionItemsPromise = this.executeBulk(itemsToExecute)
    
            const executedItems = await this._executionItemsPromise
            this._free = true
    
            return executedItems[myIndex]
    
        } else {
            await this._executionItemsPromise
    
            if (this._free) {
                this._free = false
                const itemsToExecute = this._pendingItems
                this._pendingItems = []
                this._executionItemsPromise = this.executeBulk(itemsToExecute)
    
                const executionItems = await this._executionItemsPromise
                this._free = true
                return executionItems[myIndex]
            } else {
                const executedItems = await this._executionItemsPromise
                return executedItems[myIndex]
            }
        }
    }

    executeBulk(items) {
        if (!this._executeBulk) {
            throw new Error('Execute bulk not implemented')
        }
        return this._executeBulk(items)
    }



}

/**
 * This is the main `promise-bulk` feature.
 * This class allows to instantiate bulk processes.
 * 
 * A bulk function is the only required constructor parameter.
 * 
 * @typeParam Input The type of the input items to be processed by the bulk function.
 * 
 * @typeParam Output The type of the response items of the bulk function.
 */
export class PromiseBulk<Input = unknown, Output = unknown> {
    private _index = 0
    private readonly _bulks: PromiseBulkSingle<Input,Output>[]

    /**
     * 
     * @param bulkFn Bulk function. Receives an array of imputs and returns an array of outputs.
     * @param _concurrency Limit of concurrent calls to the bulk function.
     */
    constructor(bulkFn, private readonly _concurrency = 1) {
        this._index = 0
        this._bulks = Array.from({length: _concurrency}, () => new PromiseBulkSingle(bulkFn))
    }

    /**
     * Execute
     * 
     * This function adds one item to the bulk process and waits for its response in a bulk operation.
     * @param item Atomic input that will be included in a bulk process
     * @returns The associated response to the input (will be returned from a bulk process)
     */
    async execute(item) {
        const index = this._index
        this._index = (this._index+1) % this._concurrency
        return this._bulks[index].execute(item)
    }
}<fim_middle>",correct,4342
68,68,68,68,Id,Id,32fad88cf989fe13e31b63cb2ea82544e40b70b9,"<fim_prefix>type Id = string | number;
type Owner = { Id: string }

export enum NFTAction {
  SEND='SEND',
  CONSUME='CONSUME',
  FREEZE='FREEZE',
  DELEGATE='DELEGATE',
  THAW='THAW',
  REVOKE='REVOKE',
  NONE='',
}

export const actionResolver: Record<NFTAction, [string, string]> = {
  SEND: ['uniques','transfer'],
  CONSUME: ['uniques','burn'],
  DELEGATE: ['uniques','approveTransfer'],
  FREEZE: ['uniques','freeze'],
  THAW: ['uniques','thaw'],
  REVOKE: ['uniques','cancelApproval'],
  '': ['',''],
}

export const basicUpdateFunction = (name, index) => `${name} #${index + 1}`

class NFTUtils {
  static createCollection(id, admin) {
    return [String(id), { Id: admin }]
  }


  static createNFT(classId, id, owner) {
    return [String(classId), String(id), { Id: owner }]
  }

  static getActionParams(selectedAction, classId: <fim_suffix>, id, meta) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.CONSUME:
    case NFTAction.DELEGATE:
    case NFTAction.REVOKE:
      return [classId, id, meta]
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return [classId, id]
    default:
      throw new Error('Action not found')
    }
  }

  static apiCall(selectedAction) {
    return actionResolver[selectedAction] || new Error('Action not found')

  }

  static correctMeta(selectedAction, meta, currentOwner, delegate) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.DELEGATE:
      return meta
    case NFTAction.CONSUME:
      return currentOwner
    case NFTAction.REVOKE:
      return delegate
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return ''
    default:
      throw new Error('Action not found')
    }
  }
}



export default NFTUtils
<fim_middle>",correct,2625
69,69,69,69,Index,Index,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select: <fim_suffix>)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1193
70,70,70,70,Instruction,Instruction,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input) : <fim_suffix> {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,292
71,71,71,71,Instruction,Instruction,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i: <fim_suffix>)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,299
72,72,72,72,Instruction,Instruction,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i: <fim_suffix>)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,304
73,73,73,73,Job,Job,2c31ac9149f16e030306749f32588668642a2f12,"<fim_prefix>export default function parseJob({ skills, seniorityLevels }) {
  return ({
    id,
    title,
    description,
    seniorities: seniorityIds,
    mainSkills: mainSkillIds,
    completeSkills: completeSkillIds,
    location,
    remote,
    startingDate,
  }: <fim_suffix>) => {
    const seniorities = findAll(seniorityLevels, seniorityIds) as Seniority[];
    const mainSkills = findAll(skills, mainSkillIds) as Skill[];
    const completeSkills = findAll(skills, completeSkillIds) as Skill[];
    return {
      id,
      title,
      description,
      location,
      remote,
      startingDate,
      experience: getExperienceRange(seniorities),
      salary: getSalaryRange(seniorities),
      mainSkills: getSkills(mainSkills),
      completeSkills: getSkills(completeSkills),
    };
  };
}

function find(items, id) {
  return items.find((item) => item.id === id);
}

function findAll(items, ids = []) {
  return ids.map((id) => find(items, id));
}

function getSkills(skills) {
  return skills.map((skill) => skill.name);
}

function getExperienceRange(seniorities) {
  return seniorities
    .reduce(
      (acc, seniority) => [
        Math.min(seniority.experience.min, acc[0]),
        Math.max(seniority.experience.max || seniority.experience.min, acc[1]),
      ],
      [Infinity, 0]
    )
    .join("" - "");
}

function getSalaryRange(seniorities) {
  return seniorities
    .reduce(
      (acc, seniority) => [
        Math.round(Math.min(seniority.salary.base, acc[0])),
        Math.round(Math.max(seniority.salary.base, acc[1])),
      ],
      [Infinity, 0]
    )
    .join("" - "");
}

type Skill = { id: string; name: string };

type Seniority = {
  id: string;
  experience: { max: number; min: number };
  salary: { base: number };
};

export type Job = {
  id: string;
  title: string;
  description: string;
  seniorities: string[];
  mainSkills: string[];
  completeSkills: string[];
  location: string;
  remote: boolean;
  startingDate: number;
};
<fim_middle>",correct,3117
74,74,74,74,JsonValue,JsonValue,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue: <fim_suffix>, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,525
75,75,75,75,JsonValue,JsonValue,a9791fb0765ba4c24e3bb22e28c8274b007ee1ae,"<fim_prefix>export type JsonValue =
	| null
	| string
	| number
	| boolean
	| JsonValue[]
	| { [key: string]: JsonValue };

type Dict<T> = { [key: string]: T };
const indexableObj = (i): i is Dict<JsonValue> => typeof i === 'object' && !Array.isArray(i);

/**
 * @param path - sringPath.with.dot.separators
 * @param input - A JSON Value
 */
export const getPath = (path, input) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;
	// .map(s=> {const n = Number.parseInt(s) })
	return pathSegments.reduce((p, seg) => {
		if (indexableObj(p)) {
			if (seg in p) {
				return p[seg] as JsonValue | undefined;
			} else {
				return undefined;
			}
		} else if (Array.isArray(p)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < p.length) {
				return p[n];
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}, input as JsonValue | undefined);
};

export const setPath = (
	path,
	replacerValue,
	input,
): <fim_suffix> => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;

	const seg = pathSegments[0];
	if (pathSegments.length === 1) {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	} else {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = setPath(pathSegments.slice(1), replacerValue, input[seg]);
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = setPath(pathSegments.slice(1), replacerValue, input[n]);
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	}
};

export default getPath;
<fim_middle>",correct,1665
76,76,76,76,JsonValue,JsonValue,a9791fb0765ba4c24e3bb22e28c8274b007ee1ae,"<fim_prefix>export type JsonValue =
	| null
	| string
	| number
	| boolean
	| JsonValue[]
	| { [key: string]: JsonValue };

type Dict<T> = { [key: string]: T };
const indexableObj = (i): i is Dict<JsonValue> => typeof i === 'object' && !Array.isArray(i);

/**
 * @param path - sringPath.with.dot.separators
 * @param input - A JSON Value
 */
export const getPath = (path, input) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;
	// .map(s=> {const n = Number.parseInt(s) })
	return pathSegments.reduce((p, seg) => {
		if (indexableObj(p)) {
			if (seg in p) {
				return p[seg] as JsonValue | undefined;
			} else {
				return undefined;
			}
		} else if (Array.isArray(p)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < p.length) {
				return p[n];
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}, input as JsonValue | undefined);
};

export const setPath = (
	path,
	replacerValue,
	input: <fim_suffix>,
) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;

	const seg = pathSegments[0];
	if (pathSegments.length === 1) {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	} else {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = setPath(pathSegments.slice(1), replacerValue, input[seg]);
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = setPath(pathSegments.slice(1), replacerValue, input[n]);
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	}
};

export default getPath;
<fim_middle>",correct,1666
77,77,77,77,JsonValue,JsonValue,a9791fb0765ba4c24e3bb22e28c8274b007ee1ae,"<fim_prefix>export type JsonValue =
	| null
	| string
	| number
	| boolean
	| JsonValue[]
	| { [key: string]: JsonValue };

type Dict<T> = { [key: string]: T };
const indexableObj = (i): i is Dict<JsonValue> => typeof i === 'object' && !Array.isArray(i);

/**
 * @param path - sringPath.with.dot.separators
 * @param input - A JSON Value
 */
export const getPath = (path, input: <fim_suffix>) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;
	// .map(s=> {const n = Number.parseInt(s) })
	return pathSegments.reduce((p, seg) => {
		if (indexableObj(p)) {
			if (seg in p) {
				return p[seg] as JsonValue | undefined;
			} else {
				return undefined;
			}
		} else if (Array.isArray(p)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < p.length) {
				return p[n];
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}, input as JsonValue | undefined);
};

export const setPath = (
	path,
	replacerValue,
	input,
) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;

	const seg = pathSegments[0];
	if (pathSegments.length === 1) {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	} else {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = setPath(pathSegments.slice(1), replacerValue, input[seg]);
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = setPath(pathSegments.slice(1), replacerValue, input[n]);
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	}
};

export default getPath;
<fim_middle>",correct,1670
78,78,78,78,K,K,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min(): <fim_suffix> {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1741
79,79,79,79,K,K,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key: <fim_suffix>, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1778
80,80,80,80,K,K,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key: <fim_suffix>, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1781
81,81,81,81,K,K,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key: <fim_suffix>, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1784
82,82,82,82,K,K,f77b40c49a005709dafda73e190c54efa502710e,"<fim_prefix>// Key type is always a string
type K = string;

// Internal item storage type
type Item<K, V> = [K, V, number];

// Type of a new item passed to the constructor. Level must be passed internally only.
type NewItem<K, V> = [K, V, number?];

/**
 * Immutable flat tree is the tree where position in hierarchy is defined by a delimited string key.
 */
export class ImmutableFlatTree<V> {
    private items: Item<K, V>[]; // Internally we store key, value and level
    private delimiter: K;

    /**
     * Creates the instance of ImmutableFlatTree from an array of [key, value] tuples
     * @param items Array of [key, value] tuples
     */
    constructor(items, delimiter: <fim_suffix> = ""."") {
        this.delimiter = delimiter;
        this.items = new Array<Item<K, V>>()

        const keys = new Set<K>();

        // Fill in the new items calculating level if necessary, skipping duplicates
        items.forEach(([key, value, level]) => {
            if (!keys.has(key)) {
                this.items.push([key, value, level ? level : this.levelOf(key)])
                keys.add(key)
            }
        })
    }

    private levelOf(value) {
        return value.split(this.delimiter).length
    }

    /**
     * Returns the elements of a tree that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicateeFlatTree(this.items.filter(predicate), this.delimiter)
    };

    /**
     * Returns item descendants
     * @param parent Parent key (or empty for root)
     * @param depth Depth (1 means children)
     * @returns Map of descendants
     */
    descendants(parentKey?, depth?) {
        let limit = depth

        if ((parentKey == null) && (depth == null)) {
            return this;
        }

        if (parentKey) {
            const parent = this.get(parentKey)
            if (!parent) {
                // Parent not found: return the empty tree
                return new ImmutableFlatTree<V>([]);
            }

            const [, , parentDepth] = parent
            if ((parentDepth) && (depth)) {
                limit = parentDepth + depth
            }
        }

        return this.filter(item => {
            let match: boolean
            const [key, , level] = item

            match = false

            if (parentKey) {
                match = key.startsWith(parentKey+this.delimiter) && key != parentKey
            }

            if (limit) {
                match = match && (level <= limit)
            }

            return match ? item : null
        });
    }

    /**
     * Iterates over tree elements
     * @param callbackfn Callback
     * @param thisArg Value of this
     */
    forEach(callbackfn.forEach(callbackfn);
    }

    /**
     * Gets tree item by key
     * @param key Item key
     * @returns Tree item
     */
    get(key) {
        return this.items.find((value) => value[0] == key ? value : null)
    }

    /**
     * Returns tree length
     */
    get size() {
        return this.items.length;
    }

    /**
     * Returns entries as array
     */
    get entries() {
        return this.items
    }
}
<fim_middle>",correct,2489
83,83,83,83,Key,Key,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name
): <fim_suffix> => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,206
84,84,84,84,Key,Key,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use() {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key: <fim_suffix>,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query) {
  return new StrictQuery(query)
}
<fim_middle>",correct,535
85,85,85,85,Lab,Lab,dc235984d999ebb87408d4cd3dbfcb29be357945,"<fim_prefix>const { abs, atan2, cos, exp, hypot, PI, sin, sqrt } = Math

type XYZ = [X: number, Y: number, Z: number]
type Lab = [L: number, a: number, b: number]

/**
 * Scale byte to 0...1.
 */
const unscaleByte = (x) => x / 255

/**
 * Invert sRGB gamma function.
 */
const invertGamma = (u) =>
  u <= 0.04045 ? u / 12.92 : ((u + 0.055) / 1.055) ** 2.4

const f = (w) =>
  w > 216 / 24389 ? w ** (1 / 3) : (841 / 108) * w + 4 / 29

/**
 * White point used in sRGB.
 */
const whiteD65: XYZ = [0.9505, 1, 1.089]

/**
 * Convert sRGB to Lab color.
 */
const rgbToLab = (white) => ([R, G, B]): <fim_suffix> => {
  R = invertGamma(unscaleByte(R))
  G = invertGamma(unscaleByte(G))
  B = invertGamma(unscaleByte(B))
  const X = 0.4124564 * R + 0.3575761 * G + 0.1804375 * B
  const Y = 0.2126729 * R + 0.7151522 * G + 0.072175 * B
  const Z = 0.0193339 * R + 0.119192 * G + 0.9503041 * B
  const l = f(Y / white[1])
  const L = 116 * l - 16
  const a = 500 * (f(X / white[0]) - l)
  const b = 200 * (l - f(Z / white[2]))
  return [L, a, b]
}

const degrees = (radians) => radians * (180 / PI)
const radians = (degrees) => degrees * (PI / 180)

/**
 * Returns a mod b
 */
const mod = (b) => (a) => ((a % b) + b) % b

const mod360 = mod(360)

const h = (b, a) => mod360(degrees(atan2(b, a)))

const sc7 = (c) => sqrt(c ** 7 / (c ** 7 + 25 ** 7))

const cosRad = (x) => cos(radians(x))

/**
 * Return CIEDE2000 color difference between two sRGB colors which components
 * are expected in the range 0 to 255.
 */
export const distanceRgb = (rgb1, rgb2) => {
  let [l1, a1, b1] = rgbToLab(whiteD65)(rgb1)
  let [l2, a2, b2] = rgbToLab(whiteD65)(rgb2)
  let c1 = hypot(a1, b1)
  let c2 = hypot(a2, b2)
  const fc7 = (1 - sc7((c1 + c2) / 2)) / 2
  a1 += a1 * fc7
  a2 += a2 * fc7
  const h1 = h(b1, a1)
  const h2 = h(b2, a2)
  let hd = 0
  let hs = h1 + h2
  if (c1 * c2 !== 0) {
    hd = h2 - h1
    if (hd > 180) {
      hd -= 360
    } else if (hd < -180) {
      hd += 360
    }
    const dh = abs(h1 - h2)
    if (dh <= 180) {
      hs /= 2
    } else if (dh > 180 && hs < 360) {
      hs = (hs + 360) / 2
    } else if (dh > 180 && hs >= 360) {
      hs = (hs - 360) / 2
    }
  }
  c1 = hypot(a1, b1)
  c2 = hypot(a2, b2)
  const ml = (l1 + l2) / 2
  const mc = (c1 + c2) / 2
  const t =
    1 -
    0.17 * cosRad(hs - 30) +
    0.24 * cosRad(2 * hs) +
    0.32 * cosRad(3 * hs + 6) -
    0.2 * cosRad(4 * hs - 63)
  const sl = 1 + (0.015 * (ml - 50) ** 2) / sqrt(20 + (ml - 50) ** 2)
  const sc = 1 + 0.045 * mc
  const sh = 1 + 0.015 * mc * t
  const rt = -2 * sc7(mc) * sin(radians(60 * exp(-(((hs - 275) / 25) ** 2))))
  const dl = (l2 - l1) / sl
  const dc = (c2 - c1) / sc
  const dh = (2 * sqrt(c1 * c2) * sin(radians(hd) / 2)) / sh
  return sqrt(dl ** 2 + dc ** 2 + dh ** 2 + rt * dc * dh)
}
<fim_middle>",correct,4770
86,86,86,86,Language,Language,76a884ba965e8d7964d8852a0c0f228c1ae1d7ad,"<fim_prefix>type Language = 'en' | 'zh';

type Terms = {
  selfPick: string;
  noFlowers: string;
  flowers: string;
  commonHand: string;
  fullyConcealedHand: string;
  seatWind: string;
  roundWind: string;
  dragons: string;
  mixedOrphans: string;
  winByLastCatch: string;
  robbingKong: string;
  oneCompleteSetOfFlowers: string;
  twoCompleteSetOfFlowers: string;
  winByKong: string;
  mixedOneSuit: string;
  allInTriplets: string;
  flowerHand: string;
  smallDragon: string;
  allOneSuit: string;
  smallWind: string;
  greatDragon: string;
  greatWind: string;
  allHonors: string;
  orphans: string;
  thirteenOrphans: string;
  kaanKaanHand: string;
  winByDoubleKong: string;
  eightImmortalsCrossingTheSea: string;
  allKongs: string;
  nineGates: string;
  earthlyHand: string;
  heavenlyHand: string;
};

export default class Glossary {
  private static readonly CHINESE_MAP: Terms = {
    selfPick: '自摸',
    noFlowers: '無花',
    flowers: '正花',
    commonHand: '平糊',
    fullyConcealedHand: '門前清',
    seatWind: '門風',
    roundWind: '圈風',
    dragons: '中/發/白',
    mixedOrphans: '花幺',
    winByLastCatch: '海底撈月',
    robbingKong: '搶槓',
    oneCompleteSetOfFlowers: '一台花',
    twoCompleteSetOfFlowers: '兩台花',
    winByKong: '槓上自摸',
    mixedOneSuit: '混一色',
    allInTriplets: '對對糊',
    flowerHand: '花糊',
    smallDragon: '小三元',
    allOneSuit: '清一色',
    smallWind: '小四喜',
    greatDragon: '大三元',
    greatWind: '大四喜',
    allHonors: '字一色',
    orphans: '全幺九',
    thirteenOrphans: '十三幺',
    kaanKaanHand: '坎坎糊',
    winByDoubleKong: '槓上槓自摸',
    eightImmortalsCrossingTheSea: '八仙過海',
    allKongs: '十八羅漢',
    nineGates: '九子連環',
    earthlyHand: '地糊',
    heavenlyHand: '天糊',
  };

  private static readonly ENGLISH_MAP: Terms = {
    selfPick: 'self-pick',
    noFlowers: 'no flowers',
    flowers: 'flowers matching seat position',
    commonHand: 'common hand',
    fullyConcealedHand: 'fully concealed hand',
    seatWind: 'seat wind',
    roundWind: 'round wind',
    dragons: 'dragons',
    mixedOrphans: 'mixed orphans',
    winByLastCatch: 'win by last catch',
    robbingKong: 'robbing kong',
    oneCompleteSetOfFlowers: 'one complete set of flowers',
    twoCompleteSetOfFlowers: 'two complete set of flowers',
    winByKong: 'win by Kong',
    mixedOneSuit: 'mixed one suit',
    allInTriplets: 'all in triplets',
    flowerHand: 'flower hand',
    smallDragon: 'small dragon',
    allOneSuit: 'all one suit',
    smallWind: 'small wind',
    greatDragon: 'great dragon',
    greatWind: 'great wind',
    allHonors: 'all honors',
    orphans: 'orphans',
    thirteenOrphans: 'thirteen orphans',
    kaanKaanHand: 'kaan kaan hand',
    winByDoubleKong: 'win by double Kong',
    eightImmortalsCrossingTheSea: 'eight immortals crossing the sea',
    allKongs: 'all Kongs',
    nineGates: 'nine gates',
    earthlyHand: 'earthly hand',
    heavenlyHand: 'heavenly hand',
  };

  private static language: Language = 'en';

  public static get() {
    if (this.language === 'en') {
      return this.ENGLISH_MAP;
    } else if (this.language === 'zh') {
      return this.CHINESE_MAP;
    } else {
      throw new Error('Language setting has not been configured appropriately.');
    }
  }

  public static setLanguage(languageInput: <fim_suffix>) {
    if (languageInput === 'zh' || languageInput === 'en') {
      this.language = languageInput;
    } else {
      throw new Error('Invalid input of language setting.');
    }
  }
}
<fim_middle>",correct,2148
87,87,87,87,License,License,39850647fe41aa810255752b914cdd87b3e420dc,"<fim_prefix>export const Kind = 'Core#License';

export interface ILicense {
  kind: typeof Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;
}

export class License {
  kind = Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;

  static fromUrl(url, name?) {
    return new License({
      kind: Kind,
      url,
      name,
    });
  }

  static fromContent(content, name?): <fim_suffix> {
    return new License({
      kind: Kind,
      content,
      name,
    });
  }

  /**
   * @param input The license definition used to restore the state.
   */
  constructor(input?) {
    let init: ILicense;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new license clearing anything that is so far defined.
   * 
   * Note, this throws an error when the license is not a license object.
   */
  new(init) {
    if (!License.isLicense(init)) {
      throw new Error(`Not a license.`);
    }
    const { url, content, name } = init;
    this.kind = Kind;
    this.name = name;
    this.content = content;
    this.url = url;
  }

  /**
   * Checks whether the input is a definition of a license.
   */
  static isLicense(input) {
    const typed = input as ILicense;
    if (typed && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: ILicense = {
      kind: Kind,
    };
    if (this.name) {
      result.name = this.name;
    }
    if (this.url) {
      result.url = this.url;
    }
    if (this.content) {
      result.content = this.content;
    }
    return result;
  }
}
<fim_middle>",correct,1627
88,88,88,88,License,License,39850647fe41aa810255752b914cdd87b3e420dc,"<fim_prefix>export const Kind = 'Core#License';

export interface ILicense {
  kind: typeof Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;
}

export class License {
  kind = Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;

  static fromUrl(url, name?): <fim_suffix> {
    return new License({
      kind: Kind,
      url,
      name,
    });
  }

  static fromContent(content, name?) {
    return new License({
      kind: Kind,
      content,
      name,
    });
  }

  /**
   * @param input The license definition used to restore the state.
   */
  constructor(input?) {
    let init: ILicense;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new license clearing anything that is so far defined.
   * 
   * Note, this throws an error when the license is not a license object.
   */
  new(init) {
    if (!License.isLicense(init)) {
      throw new Error(`Not a license.`);
    }
    const { url, content, name } = init;
    this.kind = Kind;
    this.name = name;
    this.content = content;
    this.url = url;
  }

  /**
   * Checks whether the input is a definition of a license.
   */
  static isLicense(input) {
    const typed = input as ILicense;
    if (typed && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: ILicense = {
      kind: Kind,
    };
    if (this.name) {
      result.name = this.name;
    }
    if (this.url) {
      result.url = this.url;
    }
    if (this.content) {
      result.content = this.content;
    }
    return result;
  }
}
<fim_middle>",correct,1630
89,89,89,89,Matrix,Matrix,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols): <fim_suffix>
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1189
90,90,90,90,MinMax,MinMax,ac730fc696dbdeb02598746fef516744d766ee52,"<fim_prefix>interface MinMax {
  min: number
  max: number
}

export class RelativeScale {
  static scale (data, tickCount, maxFactor) {
    const {
      min,
      max
    }: MinMax = RelativeScale.calculateBounds(data)

    let factor = 1

    while (true) {
      const scale = Math.pow(10, factor)

      const scaledMin = min - (min % scale)
      let scaledMax = max + (max % scale === 0 ? 0 : scale - (max % scale))

      // Prevent min/max from being equal (and generating 0 ticks)
      // This happens when all data points are products of scale value
      if (scaledMin === scaledMax) {
        scaledMax += scale
      }

      const ticks = (scaledMax - scaledMin) / scale

      if (ticks <= tickCount || (typeof maxFactor === 'number' && factor === maxFactor)) {
        return {
          scaledMin,
          scaledMax,
          scale
        }
      } else {
        // Too many steps between min/max, increase factor and try again
        factor++
      }
    }
  }

  static scaleMatrix (data, tickCount, maxFactor) {
    const nonNullData = data.flat().filter((val) => val !== null)

    // when used with the spread operator large nonNullData/data arrays can reach the max call stack size
    // use reduce calls to safely determine min/max values for any size of array
    // https://stackoverflow.com/questions/63705432/maximum-call-stack-size-exceeded-when-using-the-dots-operator/63706516#63706516
    const max = nonNullData.reduce((a, b) => {
      return Math.max(a, b)
    }, Number.NEGATIVE_INFINITY)

    return RelativeScale.scale(
      [0, RelativeScale.isFiniteOrZero(max)],
      tickCount,
      maxFactor
    )
  }

  static generateTicks (min, max, step) {
    const ticks = []
    for (let i = min; i <= max; i += step) {
      ticks.push(i)
    }
    return ticks
  }

  static calculateBounds (data): <fim_suffix> {
    if (data.length === 0) {
      return {
        min: 0,
        max: 0
      }
    } else {
      const nonNullData = data.filter((val) => val !== null)

      // when used with the spread operator large nonNullData/data arrays can reach the max call stack size
      // use reduce calls to safely determine min/max values for any size of array
      // https://stackoverflow.com/questions/63705432/maximum-call-stack-size-exceeded-when-using-the-dots-operator/63706516#63706516
      const min = nonNullData.reduce((a, b) => {
        return Math.min(a, b)
      }, Number.POSITIVE_INFINITY)
      const max = nonNullData.reduce((a, b) => {
        return Math.max(a, b)
      }, Number.NEGATIVE_INFINITY)

      return {
        min: RelativeScale.isFiniteOrZero(min),
        max: RelativeScale.isFiniteOrZero(max)
      }
    }
  }

  static isFiniteOrZero (val) {
    return Number.isFinite(val) ? val : 0
  }
}
<fim_middle>",correct,1057
91,91,91,91,Money,Money,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest() {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions): <fim_suffix> {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",correct,2966
92,92,92,92,Money,Money,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest(): <fim_suffix> {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions) {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",correct,2977
93,93,93,93,Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source: <fim_suffix>, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3864
94,94,94,94,Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v: <fim_suffix>) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3865
95,95,95,95,Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target: <fim_suffix>) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3867
96,96,96,96,Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source: <fim_suffix>, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3868
97,97,97,97,Node,Node,f6127d3ca25913df8797295ddc538560f5ecbd34,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 任务存放的数据结构
 * 类似小顶堆 将heap中最小的节点放在第一个
 * @flow strict
 */

export type Heap = Array<Node>
export type Node = {
  id: number
  sortIndex: number
}

/**
 * push一个任务
 * 先将任务放在队列末尾
 * 然后进行二分遍历，将最小的任务放在第一个
 */
export function push(heap, node) {
  const index = heap.length

  heap.push(node)
  siftUp(heap, node, index)
}

// 查看小顶堆的第一个任务
export function peek(heap) {
  return heap.length === 0 ? null : heap[0]
}

// 推出第一个任务
export function pop(heap) {
  if (heap.length === 0) {
    return null
  }

  const first = heap[0]
  const last = heap.pop() as Node

  if (last !== first) {
    heap[0] = last
    siftDown(heap, last, 0)
  }

  return first
}

/**
 * 上浮元素
 * 确保队列的第一个始终是sortIndex最小的
 *
 * 之所以不将入队的node直接和head[0]进行比较
 * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历
 */
function siftUp(heap, node, i) {
  let index = i

  while (index > 0) {
    // 获取队列中0到index的二分位置
    const parentIndex = (index - 1) >>> 1
    const parent = heap[parentIndex]

    /**
     * 如果中间位置的node和需要入队的node compare结果为正
     * 则表明需要入队的node需要继续往前移动
     * index为2或者1的时候 parentIndex会为0
     * 这样就比较了需要入队的node和head[0]
     */
    if (compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node
      heap[index] = parent
      index = parentIndex
    } else {
      // The parent is smaller. Exit.
      return
    }
  }
}

/**
 * 通过小顶堆寻找队列中最小的最小的
 * 确保队列的第一个始终是sortIndex最小的
 */
function siftDown(heap, node, i) {
  let index = i

  debugger
  const length = heap.length
  const halfLength = length >>> 1

  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1
    const left = heap[leftIndex]
    const rightIndex = leftIndex + 1
    const right = heap[rightIndex]

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) < 0) {
      // 先找到右子树中最小的
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right
        heap[rightIndex] = node
        index = rightIndex
      } else {
        // 右子树中最小的找到以后 再来比较左子树
        heap[index] = left
        heap[leftIndex] = node
        index = leftIndex
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right
      heap[rightIndex] = node
      index = rightIndex
    } else {
      // Neither child is smaller. Exit.
      return
    }
  }
}

// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id
function compare(a, b: <fim_suffix>) {
  // Compare sort index first, then task id.
  const diff = a.sortIndex - b.sortIndex

  return diff !== 0 ? diff : a.id - b.id
}
<fim_middle>",correct,4776
98,98,98,98,Node,Node,f6127d3ca25913df8797295ddc538560f5ecbd34,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 任务存放的数据结构
 * 类似小顶堆 将heap中最小的节点放在第一个
 * @flow strict
 */

export type Heap = Array<Node>
export type Node = {
  id: number
  sortIndex: number
}

/**
 * push一个任务
 * 先将任务放在队列末尾
 * 然后进行二分遍历，将最小的任务放在第一个
 */
export function push(heap, node) {
  const index = heap.length

  heap.push(node)
  siftUp(heap, node, index)
}

// 查看小顶堆的第一个任务
export function peek(heap) {
  return heap.length === 0 ? null : heap[0]
}

// 推出第一个任务
export function pop(heap) {
  if (heap.length === 0) {
    return null
  }

  const first = heap[0]
  const last = heap.pop() as Node

  if (last !== first) {
    heap[0] = last
    siftDown(heap, last, 0)
  }

  return first
}

/**
 * 上浮元素
 * 确保队列的第一个始终是sortIndex最小的
 *
 * 之所以不将入队的node直接和head[0]进行比较
 * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历
 */
function siftUp(heap, node, i) {
  let index = i

  while (index > 0) {
    // 获取队列中0到index的二分位置
    const parentIndex = (index - 1) >>> 1
    const parent = heap[parentIndex]

    /**
     * 如果中间位置的node和需要入队的node compare结果为正
     * 则表明需要入队的node需要继续往前移动
     * index为2或者1的时候 parentIndex会为0
     * 这样就比较了需要入队的node和head[0]
     */
    if (compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node
      heap[index] = parent
      index = parentIndex
    } else {
      // The parent is smaller. Exit.
      return
    }
  }
}

/**
 * 通过小顶堆寻找队列中最小的最小的
 * 确保队列的第一个始终是sortIndex最小的
 */
function siftDown(heap, node: <fim_suffix>, i) {
  let index = i

  debugger
  const length = heap.length
  const halfLength = length >>> 1

  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1
    const left = heap[leftIndex]
    const rightIndex = leftIndex + 1
    const right = heap[rightIndex]

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) < 0) {
      // 先找到右子树中最小的
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right
        heap[rightIndex] = node
        index = rightIndex
      } else {
        // 右子树中最小的找到以后 再来比较左子树
        heap[index] = left
        heap[leftIndex] = node
        index = leftIndex
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right
      heap[rightIndex] = node
      index = rightIndex
    } else {
      // Neither child is smaller. Exit.
      return
    }
  }
}

// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id
function compare(a, b) {
  // Compare sort index first, then task id.
  const diff = a.sortIndex - b.sortIndex

  return diff !== 0 ? diff : a.id - b.id
}
<fim_middle>",correct,4779
99,99,99,99,Number,Number,b1ab8c4be427c0afaf3d2a41ca821482dd787a9e,"<fim_prefix>type DotNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per dot (36)
type BamNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per bam (36)
type CrakNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per crak (36)
type WindNumber = ""East"" | ""West"" | ""South"" | ""North""; // 4 tiles per wind (16)
type DragonNumber = ""White"" | ""Green"" | ""Red""; // 4 tiles per wind (12)
type FlowerNumber = ""Rose"" | ""Lily"" | ""Tulip"" | ""Juniper""; // 2 tiles per flower (8)

export type Number = DotNumber | BamNumber | CrakNumber | WindNumber | DragonNumber | FlowerNumber;

export enum Suit {
  Dot = ""DOT"",
  Bam = ""BAM"",
  Crak = ""CRAK"",
  Wind = ""WIND"",
  Dragon = ""DRAGON"",
  Flower = ""FLOWER"",
}

export default class Tile {
  x: number;
  y: number;
  z: number;
  number: Number;
  suit: Suit;
  static dotNumbers: DotNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static bamNumbers: BamNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static crakNumbers: CrakNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static windNumbers: WindNumber[] = [""East"", ""West"", ""South"", ""North""];
  static dragonNumbers: DragonNumber[] = [""White"", ""Green"", ""Red""];
  static flowerNumbers: FlowerNumber[] = [""Rose"", ""Lily"", ""Tulip"", ""Juniper""];

  constructor(number: <fim_suffix>, suit) {
    this.number = number;
    this.suit = suit;
    this.x = -10
    this.y = -10
    this.z = -10
  }

  place({ z, x, y }) {
    this.z = z
    this.x = x
    this.y = y
  }

  get tileCells() {
    return [
      {
        z: this.z,
        x: this.x,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x,
        y: this.y + 1,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y + 1,
      },
    ];
  }

  get id() {
    return `${this.suit}_${this.number}_${this.x}_${this.y}_${this.z}`;
  }

  tileIsAdjacent(tile) {
    const t1Cells = this.tileCells;
    const t2Cells = tile.tileCells;

    let isAdjacent = false;

    t1Cells.forEach((t1) => {
      t2Cells.forEach((t2) => {
        // tile is above or below
        if ((t1.z === t2.z - 1 || t1.z === t2.z + 1) && t1.x === t2.x && t1.y === t2.y) {
          isAdjacent = true;
        }

        // tile is to the left or the right
        if (t1.z === t2.z && t1.y === t2.y && (t1.x === t2.x - 1 || t1.x === t2.x + 1)) {
          isAdjacent = true;
        }
      });
    });

    return isAdjacent;
  }
}
<fim_middle>",correct,1120
100,100,100,100,Operator,Operator,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty) => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator: <fim_suffix>, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",correct,4709
101,101,101,101,Operator,Operator,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty): <fim_suffix> => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",correct,4711
102,102,102,102,Options,Options,7c6b66273a2e2ae0cf4af96fca68877ec089846c,"<fim_prefix>type Placeholder = undefined | string | Function
interface Options {
  placeholder?: Placeholder
  freeze?: boolean
}

type Result = string | number | Function
type TextObject = Record<string, Result | object>
type TextPath = string
type Texts = TextObject[] | []
type TextFnArguments = string[] | number[]

const ALLOWED_TYPES = ['string', 'number']
const ERROR_TEXTS = Object.freeze({
  not_set: '[t-getter.js] There is no texts objects'
})

export default function GetText(
  texts,
  { placeholder = undefined, freeze = true }: <fim_suffix> = {}
) {
  if (!texts?.length) throw new Error(ERROR_TEXTS.not_set)
  texts = texts.map((o) => (freeze ? Object.freeze(o) : o))
  let placeholderOpt: any = placeholder

  function placeholderFn(options) {
    return typeof placeholderOpt == 'function'
      ? placeholderOpt(options)
      : placeholderOpt
  }

  function checkAllowedTypes(val) {
    return ALLOWED_TYPES.includes(typeof val)
  }

  function getTextValue({
    index,
    prop,
    args
  }) {
    const path = prop.split('.')
    let textObject: any = texts[index]

    let i = 0
    while (i < path.length) {
      let value: TextObject | Result = textObject[path[i]]
      if (value == null) break
      if (typeof value == 'function') value = value(...args)
      textObject = value
      i++
    }
    return textObject
  }

  function t(prop, ...args) {
    if (!texts.length) throw new Error(ERROR_TEXTS.not_set)

    let result: any = undefined
    let index = 0
    while (index < texts.length) {
      const value = getTextValue({ index, prop, args })
      if (checkAllowedTypes(value)) {
        result = value
        break
      }
      index++
    }

    if (!checkAllowedTypes(result)) return placeholderFn({ prop, args })

    return result
  }

  return t
}
<fim_middle>",correct,715
103,103,103,103,Options,Options,5a29a45f29dbe3ac69cfbfa2729fcd60bbc32789,"<fim_prefix>/*
 * @Author: wellen zhong
 * @Date: 2022-02-09 14:02:29
 * @LastEditors: wellen zhong
 * @LastEditTime: 2022-02-09 14:28:34
 * @Description: file content
 */

export interface Options {
    svgStr: string;
}
export default  (params: <fim_suffix>) =>{
    return `
    ;(function(window) {
      var svgSprite = \`${params.svgStr}\`
    var script = (function () {
      var scripts = document.getElementsByTagName(""script"");
      return scripts[scripts.length - 1];
    })();
    var shouldInjectCss = script.getAttribute(""data-injectcss"");
    var ready = function (fn) {
      if (document.addEventListener) {
        if (~[""complete"", ""loaded"", ""interactive""].indexOf(document.readyState)) {
          setTimeout(fn, 0);
        } else {
          var loadFn = function () {
            document.removeEventListener(""DOMContentLoaded"", loadFn, false);
            fn();
          };
          document.addEventListener(""DOMContentLoaded"", loadFn, false);
        }
      } else if (document.attachEvent) {
        IEContentLoaded(window, fn);
      }
      function IEContentLoaded(w, fn) {
        var d = w.document,
          done = false,
          init = function () {
            if (!done) {
              done = true;
              fn();
            }
          };
        var polling = function () {
          try {
            d.documentElement.doScroll(""left"");
          } catch (e) {
            setTimeout(polling, 50);
            return;
          }
          init();
        };
        polling();
        d.onreadystatechange = function () {
          if (d.readyState == ""complete"") {
            d.onreadystatechange = null;
            init();
          }
        };
      }
    };
    var before = function (el, target) {
      target.parentNode.insertBefore(el, target);
    };
    var prepend = function (el, target) {
      if (target.firstChild) {
        before(el, target.firstChild);
      } else {
        target.appendChild(el);
      }
    };
    function appendSvg() {
      var div, svg;
      div = document.createElement(""div"");
      div.innerHTML = svgSprite;
      svgSprite = null;
      svg = div.getElementsByTagName(""svg"")[0];
      if (svg) {
        svg.setAttribute(""aria-hidden"", ""true"");
        svg.style.position = ""absolute"";
        svg.style.width = 0;
        svg.style.height = 0;
        svg.style.overflow = ""hidden"";
        prepend(svg, document.body);
      }
    }
    if (shouldInjectCss && !window.__iconfont__svg__cssinject__) {
      window.__iconfont__svg__cssinject__ = true;
      try {
        document.write(
          ""<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>""
        );
      } catch (e) {
        console && console.log(e);
      }
    }
    ready(appendSvg);
  })(window);  
    `
}
<fim_middle>",correct,2048
104,104,104,104,Options,Options,60111e8899acd1cb31c9e942a57447f8b8c80c3b,"<fim_prefix>type Mode = ""hard"" | ""soft"";

interface Options {
    mode: Mode;
}

export class Leet {
    private mode: Mode;
    public constructor(options: <fim_suffix>) {
        this.mode = options.mode;
    }

    public translate(message) {
        if (this.mode === ""hard"") {
            return message
                .replace(/i/gi, ""1"")
                .replace(/a/gi, ""/\\"")
                .replace(/b/gi, ""I3"")
                .replace(/c/gi, ""["")
                .replace(/d/gi, ""I)"")
                .replace(/e/gi, ""€"")
                .replace(/f/gi, ""|="")
                .replace(/g/gi, ""&"")
                .replace(/h/gi, ""/-/"")
                .replace(/j/gi, ""_|"")
                .replace(/k/gi, ""|<"")
                .replace(/l/gi, ""|"")
                .replace(/m/gi, ""^^"")
                .replace(/n/gi, ""^/"")
                .replace(/o/gi, ""()"")
                .replace(/p/gi, ""|°"")
                .replace(/q/gi, ""(,)"")
                .replace(/r/gi, ""I2"")
                .replace(/s/gi, ""$"")
                .replace(/t/gi, ""+"")
                .replace(/u/gi, ""|_|"")
                .replace(/v/gi, ""|/"")
                .replace(/w/gi, ""'//"")
                .replace(/x/gi, "")("")
                .replace(/y/gi, ""`/"")
                .replace(/z/gi, ""%"");
        } else {
            return message
                .replace(/a/gi, ""4"")
                .replace(/b/gi, ""8"")
                .replace(/e/gi, ""3"")
                .replace(/i/gi, ""1"")
                .replace(/o/gi, ""0"")
                .replace(/r/gi, ""2"")
                .replace(/s/gi, ""5"")
                .replace(/t/gi, ""7"")
                .toUpperCase();
        }
    }

    public reverse(message) {
        if (this.mode === ""hard"") {
            return message
                .replace(/\/\\/g, ""a"")
                .replace(/I3/g, ""b"")
                .replace(/\[/g, ""c"")
                .replace(/I\)/g, ""d"")
                .replace(/€/g, ""e"")
                .replace(/\|=/g, ""f"")
                .replace(/&/g, ""g"")
                .replace(/\/-\//g, ""h"")
                .replace(/1/g, ""i"")
                .replace(/(?<!\|)_\|/g, ""j"")
                .replace(/\|</g, ""k"")
                .replace(/(?<!_)\|(?![=<°/_])/g, ""l"")
                .replace(/\^\^/g, ""m"")
                .replace(/\^\//g, ""n"")
                .replace(/\(\)/g, ""o"")
                .replace(/\|°/g, ""p"")
                .replace(/\(,\)/g, ""q"")
                .replace(/I2/g, ""r"")
                .replace(/\$/g, ""s"")
                .replace(/\+/g, ""t"")
                .replace(/\|_\|/g, ""u"")
                .replace(/\|\//g, ""v"")
                .replace(/'\/\//g, ""w"")
                .replace(/\)\(/g, ""x"")
                .replace(/`\//g, ""y"")
                .replace(/%/g, ""z"");
        } else {
            return message
                .replace(/4/g, ""a"")
                .replace(/8/g, ""b"")
                .replace(/3/g, ""e"")
                .replace(/1/g, ""i"")
                .replace(/0/g, ""o"")
                .replace(/2/g, ""R"")
                .replace(/5/g, ""s"")
                .replace(/7/g, ""t"")
                .toLowerCase();
        }
    }
}
<fim_middle>",correct,3027
105,105,105,105,Options,Options,e8163c19af6d0400d21846442a54c5e20ba9eac3,"<fim_prefix>export enum LongOption {
  NUMBER = 'number',
  LONG = 'long',
  STRING = 'string',
}

export enum DateOption {
  DATE = 'date',
  STRING = 'string',
  TIMESTAMP = 'timestamp',
}

export enum EnvOption {
  NODE = 'node',
  BROWSER = 'browser',
  BOTH = 'both',
}

export enum OneofOption {
  PROPERTIES = 'properties',
  UNIONS = 'unions',
}

export enum ServiceOption {
  GRPC = 'grpc-js',
  GENERIC = 'generic-definitions',
  DEFAULT = 'default',
  NONE = 'none',
}

export type Options = {
  context: boolean;
  snakeToCamel: Array<'json' | 'keys'>;
  forceLong: LongOption;
  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated
  useDate: DateOption;
  oneof: OneofOption;
  esModuleInterop: boolean;
  fileSuffix: string;
  outputEncodeMethods: boolean;
  outputJsonMethods: boolean;
  outputPartialMethods: boolean;
  outputTypeRegistry: boolean;
  stringEnums: boolean;
  constEnums: boolean;
  enumsAsLiterals: boolean;
  outputClientImpl: boolean | 'grpc-web';
  outputServices: ServiceOption;
  addGrpcMetadata: boolean;
  addNestjsRestParameter: boolean;
  returnObservable: boolean;
  lowerCaseServiceMethods: boolean;
  nestJs: boolean;
  env: EnvOption;
  unrecognizedEnum: boolean;
  exportCommonSymbols: boolean;
  outputSchema: boolean;
  // An alias of !output
  onlyTypes: boolean;
  emitImportedFiles: boolean;
  useExactTypes: boolean;
  delimitedMethods: boolean;
};

export function defaultOptions() {
  return {
    context: false,
    snakeToCamel: ['json', 'keys'],
    forceLong: LongOption.NUMBER,
    useOptionals: 'none',
    useDate: DateOption.DATE,
    oneof: OneofOption.PROPERTIES,
    esModuleInterop: false,
    fileSuffix: '',
    lowerCaseServiceMethods: false,
    outputEncodeMethods: true,
    outputJsonMethods: true,
    outputPartialMethods: true,
    outputTypeRegistry: false,
    stringEnums: false,
    constEnums: false,
    enumsAsLiterals: false,
    outputClientImpl: true,
    outputServices: ServiceOption.DEFAULT,
    returnObservable: false,
    addGrpcMetadata: false,
    addNestjsRestParameter: false,
    nestJs: false,
    env: EnvOption.BOTH,
    unrecognizedEnum: true,
    exportCommonSymbols: true,
    outputSchema: false,
    onlyTypes: false,
    emitImportedFiles: true,
    useExactTypes: true,
    delimitedMethods: false,
  };
}

const nestJsOptions: Partial<Options> = {
  lowerCaseServiceMethods: true,
  outputEncodeMethods: false,
  outputJsonMethods: false,
  outputPartialMethods: false,
  outputClientImpl: false,
  useDate: DateOption.TIMESTAMP,
};

export function optionsFromParameter(parameter): <fim_suffix> {
  const options = defaultOptions();
  if (parameter) {
    const parsed = parseParameter(parameter);
    if (parsed.nestJs) {
      Object.assign(options, nestJsOptions);
    }
    Object.assign(options, parsed);
  }
  // We should promote onlyTypes to its own documented flag, but just an alias for now
  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {
    options.onlyTypes = true;
  }

  // Treat forceLong=true as LONG
  if ((options.forceLong as any) === true) {
    options.forceLong = LongOption.LONG;
  }

  // Treat outputServices=false as NONE
  if ((options.outputServices as any) === false) {
    options.outputServices = ServiceOption.NONE;
  }

  if ((options.useDate as any) === true) {
    // Treat useDate=true as DATE
    options.useDate = DateOption.DATE;
  } else if ((options.useDate as any) === false) {
    // Treat useDate=false as TIMESTAMP
    options.useDate = DateOption.TIMESTAMP;
  }

  if ((options.snakeToCamel as any) === false) {
    options.snakeToCamel = [];
  } else if ((options.snakeToCamel as any) === true) {
    options.snakeToCamel = ['keys', 'json'];
  }

  return options;
}

// A very naive parse function, eventually could/should use iots/runtypes
function parseParameter(parameter) {
  const options = {} as any;
  const pairs = parameter.split(',').map((s) => s.split('='));
  pairs.forEach(([key, value]) => {
    options[key] = value === 'true' ? true : value === 'false' ? false : value;
  });
  return options;
}

export function getTsPoetOpts(options) {
  if (options.esModuleInterop) {
    return { forceDefaultImport: ['protobufjs/minimal'] };
  } else {
    return {};
  }
}
<fim_middle>",correct,3851
106,106,106,106,Order,Order,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order): <fim_suffix> {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,68
107,107,107,107,Organization,Organization,d85172f11ad96056d5a23d70826940b9d72011d4,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IOrganization {
    description?: string;
    id?: string;
    image?: string;
    name?: string;
    website?: string;
}

export default class Organization {
    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _image: string | undefined;

    get image() {
        return this._image;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _website: string | undefined;

    get website() {
        return this._website;
    }

    constructor(props) {
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.image === 'string') {
            this._image = props.image.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.website === 'string') {
            this._website = props.website.trim();
        }
    }

    serialize() {
        const data: IOrganization = {};
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._image !== 'undefined') {
            data.image = this._image;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._website !== 'undefined') {
            data.website = this._website;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            image: !this._image
                ? true
                : typeof this._image === 'string' && !this._image
                ? true
                : this._image,
            website: !this._website
                ? true
                : typeof this._website === 'string' && !this._website
                ? true
                : this._website,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Organization({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,3100
108,108,108,108,Params,Params,55cd248251ed1b4cc30e54f7fe9cbb0002b63241,"<fim_prefix>interface Params {
  page?: number;
  size?: number;
  message?: string;
  [key: string]: any;
}

interface Result<T> {
  code: number;
  data: {
    list: T[];
    total: number;
  };
  message?: number;
}

type FetchFun<T> = (params) => Promise<Result<T>>;

/**
 * 将分页接口转换为获取所有的接口
 * @param fetch
 */
export default function createFetchAll<T = any>(fetch) {
  return async function (params: <fim_suffix> = {}) {
    // 总数
    let allTotal = 0;
    let fetchTotal = 0;
    // 存储列表数据
    let fetchList: T[] = [];

    return new Promise(async (resolve, reject) => {
      const { page = 1, size = 1000, ...rest } = params;

      // 通过第一次分页请求
      const {
        code,
        data: { list, total },
        message
      } = await fetch({ page, size, ...rest });
      allTotal = total;
      fetchTotal += list.length;
      fetchList = fetchList.concat(list);

      // 从第二页开始
      const allPromise: Promise<Result<T>>[] = [];
      const pageSize = parseInt(total / size + 1 + '');

      for (let i = 2; i <= pageSize; ++i) {
        allPromise.push(
          fetch({
            page: i,
            size: i === pageSize ? total % size : size,
            ...rest
          })
        );
      }

      const allResult = await Promise.all(allPromise);
      for (let i = 0; i < allResult.length; ++i) {
        const {
          data: { list }
        } = allResult[i];
        fetchTotal += list.length;
        fetchList = fetchList.concat(list);
      }

      if (fetchTotal === total) {
        resolve({
          code: code,
          message: message,
          data: {
            list: fetchList,
            total: fetchTotal
          }
        });
      } else {
        reject({
          code: 500,
          message: '数据请求出错',
          data: {
            list: [],
            total: 0
          }
        });
      }
    });
  };
}
<fim_middle>",correct,2240
109,109,109,109,Permission,Permission,b9e827c9b65a470da78b1369ea3f446284d6b91c,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IPermission {
    description?: string;
    id?: string;
    is_internal?: boolean;
    name?: string;
    xml?: string;
}

export default class Permission {
    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _is_internal: boolean | undefined;

    get isInternal() {
        return this._is_internal;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _xml: string | undefined;

    get xml() {
        return this._xml;
    }

    constructor(props) {
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.is_internal === 'boolean') {
            this._is_internal = props.is_internal;
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.xml === 'string') {
            this._xml = props.xml.trim();
        }
    }

    serialize() {
        const data: IPermission = {};
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._is_internal !== 'undefined') {
            data.is_internal = this._is_internal;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._xml !== 'undefined') {
            data.xml = this._xml;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            is_internal: !this._is_internal
                ? true
                : typeof this._is_internal === 'boolean',
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            xml: !this._xml
                ? true
                : typeof this._xml === 'string' && !this._xml
                ? true
                : this._xml,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Permission({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,384
110,110,110,110,Permission,Permission,c1d22b15c50f25666b0b3e495cc4ff6d4323db74,"<fim_prefix>// Errors
export const ESuccess: number = 0;      // Generic success
export const EFail: number = 1;         // Generic failure
export const EFull: number = 2;         // Too many clients attached to this session; try later
export const ERetry: number = 3;        // Try request again
export const ENoSession: number = 4;		// No record of such session
export const EClockSeen: number = 5;
export const EClockFailure: number = 6;
export const EClockReset: number = 7;
export const ENoUser: number = 8;       // No user specified (internal error since all authorized reqs have user)
export const EBadRequest: number = 9;   // Badly formed request
export const ELoadFailed: number = 10;  // Session exists in index, but load of state failed ((temp?) internal error)
export const ENoPerm: number = 11;      // No permissions (readonly)
export const ENoAccess: number = 12;    // No access (no read)
export const EMaintenance: number = 13; // Server under maintenance
export const EClockAnomaly: number = 14;  // Typically server restart and client is ahead

// Filters
export const FilterMyMaps: number = 0;
export const FilterSharedWithMe: number = 1;
export const FilterMyPublic: number = 2;
export const FilterRecent: number = 3;
export const FilterTrash: number = 4;
export const FilterPublic: number = 5;
export const FilterOfficial: number = 6;
export const FilterCOI: number = 7;
export const FilterMyGroups: number = 8;
export const FilterCount: number = 9;
export type Filter = number;

// Permissions
export const PermNone: number = 0;      // No permissions
export const PermRead: number = 1;      // Can view
export const PermWrite: number = 2;     // Can modify
export const PermOwner: number = 4;     // Can change deleted, published, access permissions
export const PermAdmin: number = 8;     // Can administer site
export const PermEdit: number = (PermWrite|PermOwner);
export const PermAll: number = (PermRead|PermWrite|PermOwner|PermAdmin);
export type Permission = number;

// Server State
export const ServerStateRunning: number = 0;
export const ServerStateMaintenance: number = 1;
export type ServerState = number;

// Maps Access Tokens (IDs) to SessionID
export interface AccessSessionMap
{
  [key: string]: string;
}

// Maps Access ID to { list of users, permission } (stored with session)
export interface AccessMap
{
  [key: string]: Access;
}

export interface Access
{
  userIDs: string[];  // empty implies ""anyone""
  perm: Permission;
}

export interface Revision
{
  id: string;
  modifyTime: any;  // JSON date
  label?: string;   // optional label
}

export type RevisionList = Revision[];

export interface SessionUser
{
	id: string;
	name: string;
  twitterhandle: string;
}

export interface ActiveUser
{
	id: string;
	name: string;
  twitterhandle: string;
	active: number;
}

export interface SessionUserIndex
{
	[key: string]: SessionUser;
}

export interface SessionUserList
{
	[key: string]: number;
}

export interface SessionProps
{
  id: string;
  name: string;
  type: string;
  description: string;
  labels: string[];
  createdBy: string;
  lastActive: any;		// JSON date (should be string)
  createTime: any;    // JSON date (should be string)
  modifyTime: any;    // JSON date (should be string)
  clientCount: number;
  maxClients: number;
  requestCount: number;
  deleted: boolean;
  published?: string;
  official: boolean;
	loadFailed: boolean;
  accessMap: AccessMap;
  revisions: RevisionList;
  expunged?: boolean;
  expungeDate?: string;
  xprops?: { [prop: string]: string };
  groups: any;  // DT.GroupsMapIndex
  xid?: string; // external ID
}

// True to add, False to remove
export type LabelUpdate = { [name: string]: boolean|null }

export interface SessionUpdateProps
{
	id?: string;
  xid?: string;
  ids?: string[];
	deleted?: boolean;
	published?: boolean;
	official?: boolean;
  name?: string;
  description?: string;
  labelupdate?: LabelUpdate;
  access?: Access;
  accessUpdate?: AccessMap;
  restore?: string; // Revision ID
  revision?: Revision;  // If ID is empty, snap a new revision, otherwise label it.
}

export interface SessionsIndex
{
	[key: string]: SessionProps;
}

// The semantics here are:
//  if aid is provided, only look through that access token.
//  if aid is missing, look for that user in any access token (but ignore anonymous tokens).
//  in either case, return the full set of permissions a user has.
//
export function accessFindUser(a, uid)
{
  if (a === undefined) return PermNone;
  if (a.userIDs.length == 0)
    return a.perm;
  for (let i: number = 0; i < a.userIDs.length; i++)
    if (a.userIDs[i] === uid) return a.perm;
  return PermNone;
}

export function accessMapFindUser(accessMap, uid, aid?): <fim_suffix>
{
  if (aid !== undefined)
    return accessFindUser(accessMap[aid], uid);
  else
  {
    let perm: Permission = PermNone;
    for (var aid1 in accessMap) if (accessMap.hasOwnProperty(aid1))
    {
      let a = accessMap[aid1];
      for (let i: number = 0; i < a.userIDs.length; i++)
        if (a.userIDs[i] === uid)
        {
          perm |= a.perm;
          break;
        }
    }
    return perm;
  }
}

export function SessionFilterFunction(p, uid, f)
{
	if (f === FilterPublic) return p.published !== undefined;

	if (f === FilterSharedWithMe)
	{
		if (p.createdBy === uid) return false;
    return true;
	}

	// All other filters require ownership of this session
	if (p.createdBy !== uid) return false;

	if (f === FilterTrash) return p.deleted;

  if (f === FilterRecent && !p.deleted && p.modifyTime)
  {
    let d = new Date();
    let interval = d.getTime() - new Date(p.modifyTime).getTime();
    return interval < (1000 * 60 * 60 * 24 * 7);  // one week
  }

	return !p.deleted;
}
<fim_middle>",correct,1318
111,111,111,111,Permission,Permission,c1d22b15c50f25666b0b3e495cc4ff6d4323db74,"<fim_prefix>// Errors
export const ESuccess: number = 0;      // Generic success
export const EFail: number = 1;         // Generic failure
export const EFull: number = 2;         // Too many clients attached to this session; try later
export const ERetry: number = 3;        // Try request again
export const ENoSession: number = 4;		// No record of such session
export const EClockSeen: number = 5;
export const EClockFailure: number = 6;
export const EClockReset: number = 7;
export const ENoUser: number = 8;       // No user specified (internal error since all authorized reqs have user)
export const EBadRequest: number = 9;   // Badly formed request
export const ELoadFailed: number = 10;  // Session exists in index, but load of state failed ((temp?) internal error)
export const ENoPerm: number = 11;      // No permissions (readonly)
export const ENoAccess: number = 12;    // No access (no read)
export const EMaintenance: number = 13; // Server under maintenance
export const EClockAnomaly: number = 14;  // Typically server restart and client is ahead

// Filters
export const FilterMyMaps: number = 0;
export const FilterSharedWithMe: number = 1;
export const FilterMyPublic: number = 2;
export const FilterRecent: number = 3;
export const FilterTrash: number = 4;
export const FilterPublic: number = 5;
export const FilterOfficial: number = 6;
export const FilterCOI: number = 7;
export const FilterMyGroups: number = 8;
export const FilterCount: number = 9;
export type Filter = number;

// Permissions
export const PermNone: number = 0;      // No permissions
export const PermRead: number = 1;      // Can view
export const PermWrite: number = 2;     // Can modify
export const PermOwner: number = 4;     // Can change deleted, published, access permissions
export const PermAdmin: number = 8;     // Can administer site
export const PermEdit: number = (PermWrite|PermOwner);
export const PermAll: number = (PermRead|PermWrite|PermOwner|PermAdmin);
export type Permission = number;

// Server State
export const ServerStateRunning: number = 0;
export const ServerStateMaintenance: number = 1;
export type ServerState = number;

// Maps Access Tokens (IDs) to SessionID
export interface AccessSessionMap
{
  [key: string]: string;
}

// Maps Access ID to { list of users, permission } (stored with session)
export interface AccessMap
{
  [key: string]: Access;
}

export interface Access
{
  userIDs: string[];  // empty implies ""anyone""
  perm: Permission;
}

export interface Revision
{
  id: string;
  modifyTime: any;  // JSON date
  label?: string;   // optional label
}

export type RevisionList = Revision[];

export interface SessionUser
{
	id: string;
	name: string;
  twitterhandle: string;
}

export interface ActiveUser
{
	id: string;
	name: string;
  twitterhandle: string;
	active: number;
}

export interface SessionUserIndex
{
	[key: string]: SessionUser;
}

export interface SessionUserList
{
	[key: string]: number;
}

export interface SessionProps
{
  id: string;
  name: string;
  type: string;
  description: string;
  labels: string[];
  createdBy: string;
  lastActive: any;		// JSON date (should be string)
  createTime: any;    // JSON date (should be string)
  modifyTime: any;    // JSON date (should be string)
  clientCount: number;
  maxClients: number;
  requestCount: number;
  deleted: boolean;
  published?: string;
  official: boolean;
	loadFailed: boolean;
  accessMap: AccessMap;
  revisions: RevisionList;
  expunged?: boolean;
  expungeDate?: string;
  xprops?: { [prop: string]: string };
  groups: any;  // DT.GroupsMapIndex
  xid?: string; // external ID
}

// True to add, False to remove
export type LabelUpdate = { [name: string]: boolean|null }

export interface SessionUpdateProps
{
	id?: string;
  xid?: string;
  ids?: string[];
	deleted?: boolean;
	published?: boolean;
	official?: boolean;
  name?: string;
  description?: string;
  labelupdate?: LabelUpdate;
  access?: Access;
  accessUpdate?: AccessMap;
  restore?: string; // Revision ID
  revision?: Revision;  // If ID is empty, snap a new revision, otherwise label it.
}

export interface SessionsIndex
{
	[key: string]: SessionProps;
}

// The semantics here are:
//  if aid is provided, only look through that access token.
//  if aid is missing, look for that user in any access token (but ignore anonymous tokens).
//  in either case, return the full set of permissions a user has.
//
export function accessFindUser(a, uid): <fim_suffix>
{
  if (a === undefined) return PermNone;
  if (a.userIDs.length == 0)
    return a.perm;
  for (let i: number = 0; i < a.userIDs.length; i++)
    if (a.userIDs[i] === uid) return a.perm;
  return PermNone;
}

export function accessMapFindUser(accessMap, uid, aid?)
{
  if (aid !== undefined)
    return accessFindUser(accessMap[aid], uid);
  else
  {
    let perm: Permission = PermNone;
    for (var aid1 in accessMap) if (accessMap.hasOwnProperty(aid1))
    {
      let a = accessMap[aid1];
      for (let i: number = 0; i < a.userIDs.length; i++)
        if (a.userIDs[i] === uid)
        {
          perm |= a.perm;
          break;
        }
    }
    return perm;
  }
}

export function SessionFilterFunction(p, uid, f)
{
	if (f === FilterPublic) return p.published !== undefined;

	if (f === FilterSharedWithMe)
	{
		if (p.createdBy === uid) return false;
    return true;
	}

	// All other filters require ownership of this session
	if (p.createdBy !== uid) return false;

	if (f === FilterTrash) return p.deleted;

  if (f === FilterRecent && !p.deleted && p.modifyTime)
  {
    let d = new Date();
    let interval = d.getTime() - new Date(p.modifyTime).getTime();
    return interval < (1000 * 60 * 60 * 24 * 7);  // one week
  }

	return !p.deleted;
}
<fim_middle>",correct,1322
112,112,112,112,Person,Person,9e9c118238962afa94fa08ff3f99466bbd1b84bf,"<fim_prefix>/* tslint:disable */

declare var Object: any;
export interface PersonInterface {
  id?: string;
  name: string;
  realm?: string;
  username?: string;
  password: string;
  email: string;
  emailVerified?: boolean;
  verificationToken?: string;
  created_at: Date;
  updated_at: Date;
  accessTokens?: Array<any>;
}

export class Person implements PersonInterface {
  id: string;
  name: string;
  realm: string;
  username: string;
  password: string;
  email: string;
  emailVerified: boolean;
  verificationToken: string;
  created_at: Date;
  updated_at: Date;
  accessTokens: Array<any>;
  constructor(data?) {
    Object.assign(this, data);
  }
  /**
   * The name of the model represented by this $resource,
   * i.e. `Person`.
   */
  public static getModelName() {
    return ""Person"";
  }
  /**
  * @method factory
  * @author Jonathan Casarrubias
  * @license MIT
  * This method creates an instance of Person for dynamic purposes.
  **/
  public static factory(data): <fim_suffix>{
    return new Person(data);
  }  
  /**
  * @method getModelDefinition
  * @author Julien Ledun
  * @license MIT
  * This method returns an object that represents some of the model
  * definitions.
  **/
  public static getModelDefinition() {
    return {
      name: 'Person',
      plural: 'Persons',
      properties: {
        id: {
          name: 'id',
          type: 'string'
        },
        name: {
          name: 'name',
          type: 'string'
        },
        realm: {
          name: 'realm',
          type: 'string'
        },
        username: {
          name: 'username',
          type: 'string'
        },
        password: {
          name: 'password',
          type: 'string'
        },
        email: {
          name: 'email',
          type: 'string'
        },
        emailVerified: {
          name: 'emailVerified',
          type: 'boolean'
        },
        verificationToken: {
          name: 'verificationToken',
          type: 'string'
        },
        created_at: {
          name: 'created_at',
          type: 'Date'
        },
        updated_at: {
          name: 'updated_at',
          type: 'Date'
        },
      },
      relations: {
        accessTokens: {
          name: 'accessTokens',
          type: 'Array<any>',
          model: ''
        },
      }
    }
  }
}
<fim_middle>",correct,2049
113,113,113,113,Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner(): <fim_suffix> {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4540
114,114,114,114,Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer(): <fim_suffix> {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4546
115,115,115,115,Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col): <fim_suffix> {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4551
116,116,116,116,Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece: <fim_suffix>) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4557
117,117,117,117,Point,Point,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2: <fim_suffix>)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,486
118,118,118,118,Point,Point,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p: <fim_suffix>, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,488
119,119,119,119,Point,Point,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2: <fim_suffix>)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,490
120,120,120,120,Point,Point,ccee70850d7be59ff29044ffd01e8ec90a3de543,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

// to suit your point format, run search/replace for '[0]' and '[1]';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

type Point = [number, number];

// square distance between 2 points
const getSqDist = (p1, p2: <fim_suffix>) => {
  const dx = p1[0] - p2[0];
  const dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
};

// square distance from a point to a segment
const getSqSegDist = (p, p1, p2) => {
  let [x, y] = p1;
  let dx = p2[0] - x;
  let dy = p2[1] - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      [x, y] = p2;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
};
// rest of the code doesn't care about point format

// basic distance-based simplification
const simplifyRadialDist = (points, sqTolerance) => {
  if (points.length === 0) return [];

  let prevPoint = points[0];
  const newPoints = [prevPoint];
  let point: Point | null = null;

  points.forEach((d) => {
    point = d;
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  });

  if (prevPoint !== point) newPoints.push(point as unknown as Point);

  return newPoints;
};

const simplifyDPStep = (
  points,
  first,
  last,
  sqTolerance,
  simplified,
) => {
  let maxSqDist = sqTolerance;
  let index: number | null = null;

  for (let i = first + 1; i < last; i += 1) {
    const sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if ((index as number) - first > 1) {
      simplifyDPStep(points, first, (index as number), sqTolerance, simplified);
    }
    simplified.push(points[(index as number)]);
    if (last - (index as number) > 1) {
      simplifyDPStep(points, (index as number), last, sqTolerance, simplified);
    }
  }
};

// simplification using Ramer-Douglas-Peucker algorithm
const simplifyDouglasPeucker = (points, sqTolerance) => {
  const last = points.length - 1;

  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);

  return simplified;
};

// both algorithms combined for awesome performance
export default (
  points,
  tolerance,
  highestQuality,
) => {
  if (points.length <= 2) return points;

  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
  let simplified = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  simplified = simplifyDouglasPeucker(points, sqTolerance);
  return simplified;
};
<fim_middle>",correct,2577
121,121,121,121,Point,Point,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2: <fim_suffix>, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3651
122,122,122,122,Point,Point,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
): <fim_suffix> => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3653
123,123,123,123,Polygon,Polygon,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
): <fim_suffix> {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3380
124,124,124,124,Polygon,Polygon,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
): <fim_suffix> {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3384
125,125,125,125,Polygon,Polygon,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices): <fim_suffix> {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3401
126,126,126,126,Position,Position,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i) : <fim_suffix> =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,298
127,127,127,127,Position,Position,d5ff2fa2b6826801f70c82d95dcdfcf780c62790,"<fim_prefix>const OCCUPIED_SEAT = '#';
const EMPTY_SEAT = 'L';
const FLOOR = '.';

interface Position {
  x: number,
  y: number
}

interface Vector {
  x: number,
  y: number
}

type AdjacentSeatFinder = (input, position, direction) => string;

export function getAdjacentSeat(input, position: <fim_suffix>, direction) {
  const adjacentLineIndex = position.y + direction.y;
  const adjacentColumnIndex = position.x + direction.x;
  
  const newPosition = { 
    x: position.x + direction.x,
    y: position.y + direction.y
  }

  if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length){
    return FLOOR;
  }

  return input[adjacentLineIndex][adjacentColumnIndex];
}


export function getFirstSeatAtDirection(input, position, direction) {
  let seat: string = FLOOR;

  let newPosition = position;
  while(true) {
    newPosition = { 
      x: newPosition.x + direction.x,
      y: newPosition.y + direction.y
    }

    if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length) break;

    const place = input[newPosition.y][newPosition.x];

    if (place !== FLOOR) {
      seat = place;
      break;
    }
  }

  return seat;
}

export function computeRound(input, adjacentSeatFinder, maximumAdjacentOccupiedSeats) {
  return input.map((line, lineIndex) => {
    return line
      .split('')
      .map((seat, seatIndex) => {
        if (seat === FLOOR) {
          return seat;
        }

        let numberOfAdjacentOccupiedSeat = 0;
        for (let iLine = -1; iLine <= 1; iLine++) {
          for (let iColumn = -1; iColumn <= 1; iColumn ++) {
            if(iLine === 0 && iColumn === 0) continue;

            const position = { x: seatIndex, y: lineIndex};
            const direction = { x: iColumn, y: iLine }
            const adjacentSeat = adjacentSeatFinder(input, position, direction);

            if (adjacentSeat === OCCUPIED_SEAT) {
              numberOfAdjacentOccupiedSeat++;
            }
          }
        }

        if (numberOfAdjacentOccupiedSeat === 0) {
          return OCCUPIED_SEAT;
        } else if (numberOfAdjacentOccupiedSeat >= maximumAdjacentOccupiedSeats) {
          return EMPTY_SEAT;
        } else {
          return seat;
        }
      })
      .join('');
  })
}

export function countNumberOfOccupiedSeatsAfterStabilization(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getAdjacentSeat, 4);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}

export function countNumberOfOccupiedSeatsAfterStabilizationWithRayCast(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getFirstSeatAtDirection, 5);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}
<fim_middle>",correct,4862
128,128,128,128,RegExp,RegExp,d7180447147db133f246707f18b8bdb014643e7a,"<fim_prefix>// Get balanced parentheses
// Ported from: https://github.com/juliangruber/balanced-match/blob/master/index.js

export interface Output {
	/**
	 * The index of the first match of a
	 */
	start: number;
	/**
	 * The index of the matching b
	 */
	end: number;
	/**
	 * The preamble, a and b not included
	 */
	pre: string;
	/**
	 * The match, a and b not included
	 */
	body: string;
	/**
	 * The postscript, a and b not included
	 */
	post: string;
}

function maybeMatch(reg: <fim_suffix>, str) {
	const m = str.match(reg);
	return m ? m[0] : null;
}

/**
 * For the first non-nested matching pair of a and b in str, return an object with those keys:
 * start the index of the first match of
 * `end` the index of the matching b
 * `pre` the preamble, a and b not included
 * `body` the match, a and b not included
 * `post` the postscript, a and b not included
 * If there's no match, `undefined` will be returned.
 * If the `str` contains more a than b / there are unmatched pairs,
 * the first match that was closed will be used.
 * For example, `{{a}` will match `['{', 'a', '']` and `{a}}` will match `['', 'a', '}']`
 */
export function balanced(
	a,
	b,
	str,
) {
	if (a instanceof RegExp) a = maybeMatch(a, str)!;
	if (b instanceof RegExp) b = maybeMatch(b, str)!;

	const r = range(a, b, str);

	return (
		r && {
			start: r[0] ?? 0,
			end: r[1] ?? 0,
			pre: str.slice(0, r[0]),
			body: str.slice(r[0]! + (a as string).length, r[1]),
			post: str.slice(r[1]! + (b as string).length),
		}
	);
}

/**
 * For the first non-nested matching pair of `a` and `b` in `str`,
 * return an array with indexes: `[ <a index>, <b index> ]`.
 */
export function range(a, b, str) {
	let begs, beg, left, right, result;
	let ai = str.indexOf(a);
	let bi = str.indexOf(b, ai + 1);
	let i = ai;

	if (ai >= 0 && bi > 0) {
		if (a === b) {
			return [ai, bi];
		}
		begs = [];
		left = str.length;

		while (i >= 0 && !result) {
			if (i === ai) {
				begs.push(i);
				ai = str.indexOf(a, i + 1);
			} else if (begs.length === 1) {
				result = [begs.pop(), bi];
			} else {
				beg = begs.pop();
				if (beg! < left!) {
					left = beg;
					right = bi;
				}

				bi = str.indexOf(b, i + 1);
			}

			i = ai < bi && ai >= 0 ? ai : bi;
		}

		if (begs.length) {
			result = [left, right];
		}
	}

	return result;
}

// Ported from: https://github.com/mugendi/balanced-match-all/blob/master/index.js
export function balancedAll(
	pre,
	post,
	str,
	includeInside = false,
	includeOutside = true,
	level = 0,
	arr = [],
) {
	const o = balanced(pre, post, str);

	if (o) {
		arr.push(o);
		const idx = arr.length - 1;

		if (idx > 0) {
			o.start += arr[idx - 1].start + pre.length;
			o.end += arr[idx - 1].start + post.length;
		}

		// loop till all are called
		if (includeInside) {
			arr = balancedAll(
				pre,
				post,
				o.body,
				includeInside,
				includeOutside,
				level++,
				arr,
			);
		}
		if (includeOutside && arr[idx].end < (str.length - 1)) {
			arr = balancedAll(
				pre,
				post,
				str.slice(arr[idx].end - 1),
				includeInside,
				true,
				0,
				arr,
			);
		}
	}

	return arr;
}
<fim_middle>",correct,1143
129,129,129,129,RegExp,RegExp,682aeec1fecbab4978758eab943eabd8aaf76c89,"<fim_prefix>/**
 * In order so that model can process validation, Every validation function must return this type.
 *
 * valid - if true all errors for property will be cleared
 * valid - if false - if errors are array - will replace all errors for property with array. if single string, will add it, if
 * there is no error with this message, else will ignore.
 *
 * errors - either array of error messages - if valid false will replace all errors for property, if single and false will add error if not there.
 *
 */
export interface ValidationReturn {
  valid: boolean
  errors?: string[] | string
  ignore?: boolean
}

export type ValidateFunction = (value, ...rest) => ValidationReturn

/**
 * valid false is value is undefined or empty string
 */
export const validateIsRequired = (
  value,
  message = 'required'
) => {
  if (!value && (value === '' || value === undefined)) {
    return { valid: false, errors: message }
  }
  return { valid: true }
}

/**
 * valid false if value does not match pattern
 */
export const validatePattern = (
  value,
  regEx: <fim_suffix>,
  message = 'errors.isNotEmail'
) => {
  if (regEx.test(value)) {
    return { valid: true }
  }
  return { valid: false, errors: message }
}

/**
 * valid false if length lt specified
 */
export const validateMinLength = (
  value,
  minLength,
  message = 'errors.tooShort'
) => {
  if (value && value.length >= minLength) {
    return { valid: true }
  }
  return { valid: false, errors: message }
}

/**
 * valid false if length gt than specified
 */
export const validateMaxLength = (
  value,
  maxLength,
  message = 'errors.tooLong'
) => {
  if (!value) {
    return { valid: false, errors: message }
  }
  if (value.length > maxLength) {
    return { valid: false, errors: message }
  }
  return { valid: true }
}

/**
 * valid false if value not equals toMatch
 */
export const validateEquals = (
  {
    value,
    toMatchWith
  },
  message = 'errors.notEqualTo'
) => {
  if (!value && !toMatchWith) {
    return { valid: true }
  }
  if (value !== toMatchWith) {
    return { valid: false, errors: message }
  }
  return { valid: true }
}
<fim_middle>",correct,2091
130,130,130,130,RegExp,RegExp,fe48985f9ace65089aa5d0dd92573b69804e7a66,"<fim_prefix>export const Kind = 'Core#HostRule';

/**
 * API Client host rule definition.
 */
export interface IHostRule {
  kind?: typeof Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from: string;
  /**
   * replacement value
   */
  to: string;
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;
}

export class HostRule {
  kind = Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from = '';
  /**
   * replacement value
   */
  to = '';
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;

  static fromValues(from, to ) {
    const result = new HostRule({
      kind: Kind,
      from,
      to,
      enabled: true,
    });
    return result;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IHostRule;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        from: '',
        to: '',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not an API Client thing.
   */
  new(init) {
    if (!HostRule.isHostRule(init)) {
      throw new Error(`Not a HostRule.`);
    }
    const { from='', to='', enabled, comment } = init;
    this.kind = Kind;
    this.from = from;
    this.to = to;
    this.enabled = enabled;
    this.comment = comment;
  }

  /**
   * Checks whether the input is a definition of a host rule.
   */
  static isHostRule(input) {
    const typed = input as IHostRule;
    if (input && typed.kind && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IHostRule = {
      kind: Kind,
      from : this.from,
      to : this.to,
    };
    if (typeof this.enabled === 'boolean') {
      result.enabled = this.enabled;
    }
    if (this.comment) {
      result.comment = this.comment;
    }
    return result;
  }

  /**
   * Applies `hosts` rules to the URL.
   *
   * @param value An URL to apply the rules to
   * @param rules List of host rules. It is a list of objects containing `from` and `to` properties.
   * @return Evaluated URL with hosts rules.
   */
  static applyHosts(value, rules) {
    if (!rules || !rules.length) {
      return value;
    }
    for (let i = 0; i < rules.length; i++) {
      const rule = rules[i];
      const result = HostRule.evaluateRule(value, rule);
      if (result) {
        value = result;
      }
    }
    return value;
  }

  /**
   * Evaluates hosts rule and applies it to the `url`.
   * @param {string} url The URL to evaluate
   * @param {HostRule} rule The host rule definition
   * @return {string} Processed url.
   */
  static evaluateRule(url, rule) {
    if (!rule || !rule.from || !rule.to) {
      return;
    }
    const re = HostRule.createRuleRe(rule.from);
    if (!re.test(url)) {
      return;
    }
    return url.replace(re, rule.to);
  }

  /**
   * @param input Rule body
   * @return Regular expression for the rule.
   */
  static createRuleRe(input): <fim_suffix> {
    input = input.replace(/\*/g, '(.*)');
    return new RegExp(input, 'gi');
  }
}
<fim_middle>",correct,3409
131,131,131,131,RegExp,RegExp,54795a90e2bd17f0016b0a39e21d9821b144d333,"<fim_prefix>/// <reference no-default-lib=""true""/>
/// <reference lib=""es6"" />

(function () {
  type primitiveObject = boolean | number | string;
  type primitive = primitiveObject | null | undefined;
  type ObjectCoercible = primitiveObject | {
      toString ();
    } | {
      valueOf ();
    };
  type anyNotSymbol = ObjectCoercible | null | undefined;
  interface StandardString {
    endsWith? (this, searchString, pos?);
    endsWith? (this, searchString?, pos?);
    includes? (this, searchString, pos?);
    includes? (this, searchString?, pos?);
    startsWith? (this, searchString, pos?);
    startsWith? (this, searchString?, pos?);
  }

  const symMatch = typeof Symbol === ""function"" && typeof Symbol.match === ""symbol"" &&
                    (Symbol.match as symbol | string as ""Symbol(Symbol.match)""),
  // eslint-disable-next-line id-denylist
  StrCls = String as StringConstructor & { readonly prototype: StandardString }, TECls = TypeError,
  StrProto = StrCls.prototype,
  toStr = Object.prototype.toString;

  """".startsWith || (
  StrProto.startsWith = function startsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""startsWith""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    return a.lastIndexOf(b, c) === c;
  });

  """".endsWith || (
  StrProto.endsWith = function endsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""endsWith""));
    }
    let b = StrCls(searchString), args = arguments, u: undefined, c: number
      , p: primitive | object = args.length > 1 ? args[1] : u, l = a.length;
    c = (p === u ? l : (c = +<number | string> p) > 0 ? c | 0 : 0) - b.length;
    c > l && (c = l);
    return c >= 0 && a.indexOf(b, c) === c;
  });

  """".includes || (
  StrProto.includes = function includes(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""includes""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    // eslint-disable-next-line @typescript-eslint/prefer-includes
    return a.indexOf(b, c) >= 0;
  });

  function check(a, b) {
    /** note: should never call `valueOf` or `toString` on a / b */
    if (a == null) { return ""String.prototype.${func} called on null or undefined""; }
    if (!b) { return 0; }
    let t: 0 | 1 | 2 = typeof a === ""symbol"" ? 1 : typeof b === ""symbol"" ? 2 : 0;
    if (t) { return t; }
    interface PossibleTypeOfB {
      [key: string]: ((this, re: <fim_suffix>) => boolean) | primitive;
    }
    let f: PossibleTypeOfB[string], u: undefined
      , i = symMatch && (f = (b as PossibleTypeOfB)[symMatch]) !== u ? f
          : toStr.call(b) === ""[object RegExp]"";
    return i ? ""First argument to String.prototype.${func} must not be a regular expression"" : 0;
  }
})();
<fim_middle>",correct,4571
132,132,132,132,Resolved,Resolved,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?: <fim_suffix>) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use() {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query) {
  return new StrictQuery(query)
}
<fim_middle>",correct,541
133,133,133,133,Rgb,Rgb,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l): <fim_suffix> => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,775
134,134,134,134,Role,Role,7f13942c6e9e03b58ec207e726168e13dd86cef1,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IRole {
    id?: string;
    name?: string;
    oauth_client_id?: string;
}

export default class Role {
    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _oauth_client_id: string | undefined;

    get oauthClientId() {
        return this._oauth_client_id;
    }

    constructor(props) {
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.oauth_client_id === 'string') {
            this._oauth_client_id = props.oauth_client_id.trim();
        }
    }

    serialize() {
        const data: IRole = {};
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._oauth_client_id !== 'undefined') {
            data.oauth_client_id = this._oauth_client_id;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            oauth_client_id: !this._oauth_client_id
                ? true
                : typeof this._oauth_client_id === 'string' &&
                  !this._oauth_client_id
                ? true
                : this._oauth_client_id,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Role({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,4821
135,135,135,135,Rule,Rule,326d9d855454c3462da30894d82c92685bff1b6e,"<fim_prefix>export interface Rule {
    calculateNewValue(cellValue, neighbourValues)
}

export function normalizeToOneOrZero(values) {
    return values.map(v => {
        if (v > 0) return 1
        else return 0
    })
}

function countLivingNeighbours(neighbourValues) {
    const normalizedValues = normalizeToOneOrZero(neighbourValues)
    return normalizedValues.reduce((sum, current) => sum + current, 0)
}

export class BSRule implements Rule {
    readonly born: Array<number>
    readonly stay: Array<number>

    constructor(born, stayAlive) {
        this.born = born
        this.stay = stayAlive
    }

    calculateNewValue(cellValue, neighbourValues) {
        const livingNeighbours = countLivingNeighbours(neighbourValues)
        if(cellValue > 0 && this.stay.indexOf(livingNeighbours) >= 0) {
            return cellValue
        }
        else if(cellValue == 0 && this.born.indexOf(livingNeighbours) >= 0) {
            return 1
        }
        return 0
    }

    static convert(rule: <fim_suffix>) {
        if(rule instanceof EEFFRule) {
            const eeffRule = rule as EEFFRule
            var born = Array<number>();
            for(var i = eeffRule.fl; i <= eeffRule.fu; i++) {
                born.push(i)
            }
            var stay = Array<number>();
            for(var i = eeffRule.el; i <= eeffRule.eu; i++) {
                stay.push(i)
            }
            return new BSRule(born, stay)
        }
        else if(rule instanceof BSRule) {
            return rule as BSRule
        }
        throw new Error(`can not convert rule: ${rule}`)
    }
}

export class EEFFRule implements Rule {
    readonly el: number
    readonly eu: number
    readonly fl: number
    readonly fu: number

    constructor(el, eu, fl, fu) {
        this.el = el
        this.eu = eu
        this.fl = fl
        this.fu = fu
    }
    
    calculateNewValue(cellValue, neighbourValues) {
        const livingNeighbours = countLivingNeighbours(neighbourValues)
        if(cellValue > 0 && (livingNeighbours < this.el || livingNeighbours > this.eu)) {
            return 0
        }
        else if(cellValue == 0 && (livingNeighbours >= this.fl && livingNeighbours <= this.fu)) {
            return 1
        }
        return cellValue
    }
}
<fim_middle>",correct,2598
136,136,136,136,Rule,Rule,0543f4f2b9cde1baf6a4d3e67f630175d9c7dcae,"<fim_prefix>interface Rule {
  ruleRaw: string,
  ruleIndex: number,
  ruleString: string,
  ruleRegex: string
}

const getRulesAndData = (input) => {
  let rules = input.filter(line => line !== '' && line.includes(':'));
  let data = input.filter(line => line !== '' && !line.includes(':'));

  return { 
    rules,
    data
  }
}

export function parseRules(rules) {
  return rules.map(rule => {
    const [ruleIndex, ruleString] = rule.split(': ');

    return {
      ruleRaw: rule,
      ruleIndex: parseInt(ruleIndex),
      ruleString,
      ruleRegex: ''
    }
  });
}

export function transformRuleToRegex(rule: <fim_suffix>, rules) {
  const ruleString = rule.ruleString;

  // Part 2 handle loop
  if (rule.ruleIndex === 8 && rule.ruleString.includes('8')) {
    // f(x) = x | x f(x) means a succession of 1 or more 'x'
    // ex: x
    // ex: xx
    // ex: xxx
    // ex: xxxx
    const correspondingRule = rules.find(rule => rule.ruleIndex === 42)!;
    const regex = '(' + transformRuleToRegex(correspondingRule, rules) + ')';

    return `${regex}+`;
  } else if (rule.ruleIndex === 11 && rule.ruleString.includes('11')) {
    // f(x, y) = xy | x f(xy) y means a succession of 1 or more 'x' then 1 or more 'y' but with same number of each
    // ex: xy
    // ex: xxyy
    // ex: xxxyyy
    // ex: xxxxyyyy
    const correspondingRule1 = rules.find(rule => rule.ruleIndex === 42)!;
    const regex1 = '(' + transformRuleToRegex(correspondingRule1, rules) + ')';

    const correspondingRule2 = rules.find(rule => rule.ruleIndex === 31)!;
    const regex2 = '(' + transformRuleToRegex(correspondingRule2, rules) + ')';

    const case1 = `(${regex1}{1}${regex2}{1})`;
    const case2 = `(${regex1}{2}${regex2}{2})`;
    const case3 = `(${regex1}{3}${regex2}{3})`;
    const case4 = `(${regex1}{4}${regex2}{4})`;

    return `((${case1})|(${case2})|(${case3})|(${case4}))`;
  } 
  // Part 1
  else {
    const regex = ruleString
      .split(' | ')
      .map(rulePart => {
        const partRegex = rulePart
          .split(' ')
          .map(ruleIndex => {
            const correspondingRule = rules.find(rule => rule.ruleIndex === parseInt(ruleIndex))!;
            
            if(correspondingRule.ruleString.includes('""')) {
              return correspondingRule.ruleString.replace(/\""/gi, '');
            } else {
              return '(' + transformRuleToRegex(correspondingRule, rules) + ')'
            }
          })
          .join('')
  
        return '(' + partRegex + ')';
      })
      .join('|');
  
    return regex;
  }

}

export function getRule0ToRegex(rules) {
  const rule0 = rules.find(rule => rule.ruleIndex === 0)!;

  const regex = transformRuleToRegex(rule0, rules)

  return regex;
}

export function getNumberOfMatchingLines(input) {
  const { rules, data } = getRulesAndData(input)

  const regexStr = '^' + getRule0ToRegex(parseRules(rules)) + '$';

  const regex = RegExp(regexStr);

  const matchingLines = data.filter(line => {
    return regex.test(line);
  });

  return matchingLines.length
}<fim_middle>",correct,3439
137,137,137,137,Schema,Schema,181ec44034d7ff44d9293788b657b1a2036d874b,"<fim_prefix>type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema: <fim_suffix>) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance) {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance, schema, location) {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance) {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
<fim_middle>",correct,235
138,138,138,138,SearchResult,SearchResult,2f9ed4c5926a0fcede392151f980e017c0c93acb,"<fim_prefix>interface WordCoord {
  start: number[]
  end: number[]
}

interface SearchResult {
  [k: string]: WordCoord | undefined
}

export default class WordSearch {
  // For searching in all 8 directions
  static directions: { row: number; col: number }[] = [
    { row: 0, col: 1 }, // left to right
    { row: 0, col: -1 }, // right to left
    { row: 1, col: 0 }, // top to bottom
    { row: -1, col: 0 }, // bottom to top
    { row: 1, col: 1 }, // top left to bottom right
    { row: 1, col: -1 }, // top right to bottom left
    { row: -1, col: 1 }, // bottom left to top right
    { row: -1, col: -1 }, // bottom right to top left
  ]

  private rowLen: number
  private colLen: number

  constructor(private grid = []) {
    this.rowLen = this.grid.length
    this.colLen = this.grid[0]?.length || 0
  }

  find(words): <fim_suffix> {
    const result: SearchResult = {}

    for (const word of words) {
      for (let row = 0; row < this.rowLen; row++) {
        for (let col = 0; col < this.colLen; col++) {
          if (!result[word]) {
            result[word] = this.findWord(word, row, col)
          }
        }
      }
    }

    return result
  }

  findWord(word, row, col) {
    // Word is not found if the first letter doesn't match.
    if (this.grid[row][col] !== word[0]) {
      return
    }

    // Search in all directions starting from (row, col).
    for (const direction of WordSearch.directions) {
      let rowDir = row + direction.row
      let colDir = col + direction.col
      let i = 0

      // First letter is already checked, start searching from the second letter.
      for (i = 1; i < word.length; i++) {
        // Stop if out of bound.
        if (rowDir >= this.rowLen || rowDir < 0 || colDir >= this.colLen || colDir < 0) {
          break
        }

        // Stop if letter doesn't match.
        if (this.grid[rowDir][colDir] !== word[i]) {
          break
        }

        // Move in particular direction.
        rowDir += direction.row
        colDir += direction.col
      }

      // If all letters matched then value of i is equal to the length of the word.
      if (i === word.length) {
        // Result should be in math indexes which start from (1, 1).
        // So we need to add 1 to indexes but it depends on direction in which word was found.
        const rowAdd = 1 - direction.row
        const colAdd = 1 - direction.col

        return {
          start: [row + 1, col + 1],
          end: [rowDir + rowAdd, colDir + colAdd],
        }
      }
    }
  }
}
<fim_middle>",correct,643
139,139,139,139,Section,Section,4ab9eed9cbc53ed6e544dca10cf2f6417c2bdcd7,"<fim_prefix>export type Section = [number, number];

export function getPreviousTitleLine(lines, lineIndex) {
  do {
    const line = lines[lineIndex];

    if (line.match(/#+ /) !== null) {
      return lineIndex;
    }

    lineIndex--;
  } while (lineIndex >= 0);

  throw Error(""cannot find previous title"");
}

export function getEndOfSectionLine(lines, lineIndex, sectionDepth) {
  const nextHeaderRe = new RegExp(`^(\\#){1,${sectionDepth}} `);

  let cursor = lineIndex + 1;

  while (lines[cursor] !== undefined) {
    const line = lines[cursor];

    if (line.match(nextHeaderRe) && cursor !== 0) {
      return cursor - 1;
    }

    cursor++;
  }

  return lines.length - 1;
}

/**
 * @returns index of started / ended line index
 */
export function getSection(lines, lineIndex): <fim_suffix> {
  const titleLine = getPreviousTitleLine(lines, lineIndex);
  const sectionDeep = lines[titleLine].split("" "")[0].length;

  const lastLine = getEndOfSectionLine(lines, lineIndex, sectionDeep);

  return [titleLine, lastLine];
}

export function promote(lines, lineIndex) {
  const section = getSection(lines, lineIndex);
  const newLines = [...lines];

  for (let i = section[0]; i <= section[1]; i++) {
    const line = newLines[i];

    if (line.match(/^(\#){2,6} +/) !== null) {
      newLines[i] = line.substring(1);
    }
  }

  return newLines;
}

export function demote(lines, lineIndex) {
  const section = getSection(lines, lineIndex);
  const newLines = [...lines];

  for (let i = section[0]; i <= section[1]; i++) {
    const line = newLines[i];

    if (line.match(/^(\#){1,5} +/) !== null) {
      newLines[i] = ""#"".concat(line);
    }
  }

  return newLines;
}
<fim_middle>",correct,2156
140,140,140,140,Settings,Settings,7f5712ec06dabff06003ba15417bd3dcb2d15f53,"<fim_prefix>export type Settings = {
  parserName: string;
  typeHints: boolean;
  mainContents: string;
  mainName: string;
  cliName: string;
  argsName: string;
};

export const defaultSettings = () => {
  return {
    parserName: 'parser',
    typeHints: true,
    mainContents: '# Contents of main',
    mainName: 'main',
    cliName: 'cli',
    argsName: 'args',
  };
};

export type Argument = {
  name: string;
  type: string;
  variableName: string;
  default: string;
  required: boolean;
};

export const newArgument = (
  name,
  type,
  variableName = '',
  defaultValue = '',
  required = false,
) => {
  if (variableName === '') {
    variableName = name.replace(/-/g, '');
  }
  return { name, type, variableName, default: defaultValue, required };
};

function argumentToText(argument, parserName) {
  switch (argument.type) {
    case 'bool':
      return `${parserName}.add_argument(""${argument.name}"", action=""store_${argument.default}"")`;
    default:
      let defaultDisplay;

      if (argument.type === 'str') {
        defaultDisplay = `""${argument.default}""`;
      } else {
        defaultDisplay = argument.default;
      }

      if (argument.default === '') {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type})`;
      } else {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type}, default=${defaultDisplay})`;
      }
  }
}

const argumentToMainParams = (argument, typeHints) => {
  if (typeHints) {
    return `${argument.variableName}: ${argument.type}`;
  } else {
    return `${argument.variableName}`;
  }
};

export const argparseCode = (args, settings: <fim_suffix> = defaultSettings()) => {
  const parserName: string = settings.parserName;
  const argsName: string = settings.argsName;
  const mainParameters: string[] = args.map((arg) => argumentToMainParams(arg, settings.typeHints));
  const argumentsText: string[] = args.map((arg) => argumentToText(arg, parserName));
  const returnText: string[] = args.map((x) => {
    if (x.type === 'str') {
      return `""${x.variableName}"": ${argsName}.${x.variableName},`;
    } else {
      return `""${x.variableName}"": ${x.type}(${argsName}.${x.variableName}),`;
    }
  });

  const mainReturnType = settings.typeHints ? ' -> None' : '';
  const cliReturnType = settings.typeHints ? ' -> Dict[str, Any]' : '';
  const typeImports = settings.typeHints ? '\nfrom typing import Dict, Any' : '';

  const output = `import argparse${typeImports}


def ${settings.mainName}(${mainParameters.join(', ')})${mainReturnType}:
    ${settings.mainContents}
    return


def ${settings.cliName}()${cliReturnType}:
    formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ${parserName} = argparse.ArgumentParser(formatter_class=formatter_class)

    ${argumentsText.join('\n    ')}

    ${argsName} = ${parserName}.parse_args()

    return {${returnText.join('\n            ').slice(0, -1)}}


if __name__ == '__main__':
    ${argsName} = ${settings.cliName}()
    ${settings.mainName}(${args.map((x) => `${x.variableName}=${argsName}[""${x.variableName}""]`).join(',\n         ')})
`;
  return output;
};
<fim_middle>",correct,4829
141,141,141,141,Settings,Settings,7f5712ec06dabff06003ba15417bd3dcb2d15f53,"<fim_prefix>export type Settings = {
  parserName: string;
  typeHints: boolean;
  mainContents: string;
  mainName: string;
  cliName: string;
  argsName: string;
};

export const defaultSettings = (): <fim_suffix> => {
  return {
    parserName: 'parser',
    typeHints: true,
    mainContents: '# Contents of main',
    mainName: 'main',
    cliName: 'cli',
    argsName: 'args',
  };
};

export type Argument = {
  name: string;
  type: string;
  variableName: string;
  default: string;
  required: boolean;
};

export const newArgument = (
  name,
  type,
  variableName = '',
  defaultValue = '',
  required = false,
) => {
  if (variableName === '') {
    variableName = name.replace(/-/g, '');
  }
  return { name, type, variableName, default: defaultValue, required };
};

function argumentToText(argument, parserName) {
  switch (argument.type) {
    case 'bool':
      return `${parserName}.add_argument(""${argument.name}"", action=""store_${argument.default}"")`;
    default:
      let defaultDisplay;

      if (argument.type === 'str') {
        defaultDisplay = `""${argument.default}""`;
      } else {
        defaultDisplay = argument.default;
      }

      if (argument.default === '') {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type})`;
      } else {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type}, default=${defaultDisplay})`;
      }
  }
}

const argumentToMainParams = (argument, typeHints) => {
  if (typeHints) {
    return `${argument.variableName}: ${argument.type}`;
  } else {
    return `${argument.variableName}`;
  }
};

export const argparseCode = (args, settings = defaultSettings()) => {
  const parserName: string = settings.parserName;
  const argsName: string = settings.argsName;
  const mainParameters: string[] = args.map((arg) => argumentToMainParams(arg, settings.typeHints));
  const argumentsText: string[] = args.map((arg) => argumentToText(arg, parserName));
  const returnText: string[] = args.map((x) => {
    if (x.type === 'str') {
      return `""${x.variableName}"": ${argsName}.${x.variableName},`;
    } else {
      return `""${x.variableName}"": ${x.type}(${argsName}.${x.variableName}),`;
    }
  });

  const mainReturnType = settings.typeHints ? ' -> None' : '';
  const cliReturnType = settings.typeHints ? ' -> Dict[str, Any]' : '';
  const typeImports = settings.typeHints ? '\nfrom typing import Dict, Any' : '';

  const output = `import argparse${typeImports}


def ${settings.mainName}(${mainParameters.join(', ')})${mainReturnType}:
    ${settings.mainContents}
    return


def ${settings.cliName}()${cliReturnType}:
    formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ${parserName} = argparse.ArgumentParser(formatter_class=formatter_class)

    ${argumentsText.join('\n    ')}

    ${argsName} = ${parserName}.parse_args()

    return {${returnText.join('\n            ').slice(0, -1)}}


if __name__ == '__main__':
    ${argsName} = ${settings.cliName}()
    ${settings.mainName}(${args.map((x) => `${x.variableName}=${argsName}[""${x.variableName}""]`).join(',\n         ')})
`;
  return output;
};
<fim_middle>",correct,4841
142,142,142,142,Solution,Solution,782540af99146e3e07fdd0219b9a1b8603c98c86,"<fim_prefix>// Super fast physics simulations for JavaScript
// Copyright 2014 Ralph Thomas
// Licensed under the Apache License, Version 2.0
// https://github.com/iamralpht/gravitas.js

// Adapted to TypeScript and customized by Tanner Linsley (@tannerlinsley)

type Solution = {
  x: (num) => number
  dx: (num) => number
}

const epsilon = 0.001

function almostEqual(a, b) {
  if (Number.isNaN(a) && Number.isNaN(b)) {
    return true
  }
  return a > b - epsilon && a < b + epsilon
}

function almostZero(a) {
  return almostEqual(a, 0)
}

export class Spring {
  private _m: number
  private _k: number
  private _c: number
  private _solution: null | Solution
  private _startTime: number
  endPosition: number

  constructor(
    init,
    mass,
    springConstant,
    damping
  ) {
    this._m = mass
    this._k = springConstant
    this._c = damping
    this._solution = null
    this.endPosition = init
    this._startTime = 0
  }

  x(dt?) {
    if (dt === undefined) {
      dt = (new Date().getTime() - this._startTime) / 1000.0
    }
    return this._solution
      ? this.endPosition + this._solution.x(dt)
      : this.endPosition
  }

  private dx(dt?) {
    if (dt === undefined) {
      dt = (new Date().getTime() - this._startTime) / 1000.0
    }
    return this._solution ? this._solution.dx(dt) : 0
  }

  setEnd(x) {
    const t = new Date().getTime()

    let velocity = 0
    let position = this.endPosition
    if (this._solution) {
      // Don't whack incoming velocity.
      if (almostZero(velocity))
        velocity = this._solution.dx((t - this._startTime) / 1000.0)
      position = this._solution.x((t - this._startTime) / 1000.0)
      if (almostZero(velocity)) velocity = 0
      if (almostZero(position)) position = 0
      position += this.endPosition
    }
    if (this._solution && almostZero(position - x) && almostZero(velocity)) {
      return
    }
    this.endPosition = x
    this._solution = this._solve(position - this.endPosition, velocity)
    this._startTime = t
  }

  snap(x) {
    this._startTime = new Date().getTime()
    this.endPosition = x
    this._solution = {
      x() {
        return 0
      },
      dx() {
        return 0
      },
    }
  }

  done() {
    return almostEqual(this.x(), this.endPosition) && almostZero(this.dx())
  }

  // reconfigure(mass: number, springConstant: number, damping: number) {
  //   this._m = mass
  //   this._k = springConstant
  //   this._c = damping

  //   if (this.done()) {
  //     return
  //   }
  //   this._solution = this._solve(this.x() - this.endPosition, this.dx())
  //   this._startTime = new Date().getTime()
  // }

  // springConstant() {
  //   return this._k
  // }

  // damping() {
  //   return this._c
  // }

  private _solve(initial, velocity): <fim_suffix> {
    const c = this._c
    const m = this._m
    const k = this._k
    // Solve the quadratic equation; root = (-c +/- sqrt(c^2 - 4mk)) / 2m.
    const cmk = c * c - 4 * m * k
    if (cmk === 0) {
      // The spring is critically damped.
      // x = (c1 + c2*t) * e ^(-c/2m)*t
      const r = -c / (2 * m)
      const c1 = initial
      const c2 = velocity / (r * initial)
      return {
        x(t) {
          return (c1 + c2 * t) * Math.pow(Math.E, r * t)
        },
        dx(t) {
          const pow = Math.pow(Math.E, r * t)
          return r * (c1 + c2 * t) * pow + c2 * pow
        },
      }
    } else if (cmk > 0) {
      // The spring is overdamped; no bounces.
      // x = c1*e^(r1*t) + c2*e^(r2t)
      // Need to find r1 and r2, the roots, then solve c1 and c2.
      const r1 = (-c - Math.sqrt(cmk)) / (2 * m)
      const r2 = (-c + Math.sqrt(cmk)) / (2 * m)
      const c2 = (velocity - r1 * initial) / (r2 - r1)
      const c1 = initial - c2

      return {
        x(t) {
          return c1 * Math.pow(Math.E, r1 * t) + c2 * Math.pow(Math.E, r2 * t)
        },
        dx(t) {
          return (
            c1 * r1 * Math.pow(Math.E, r1 * t) +
            c2 * r2 * Math.pow(Math.E, r2 * t)
          )
        },
      }
    } else {
      // The spring is underdamped, it has imaginary roots.
      // r = -(c / 2*m) +- w*i
      // w = sqrt(4mk - c^2) / 2m
      // x = (e^-(c/2m)t) * (c1 * cos(wt) + c2 * sin(wt))
      const w = Math.sqrt(4 * m * k - c * c) / (2 * m)
      const r = -((c / 2) * m)
      const c1 = initial
      const c2 = (velocity - r * initial) / w

      return {
        x(t) {
          return (
            Math.pow(Math.E, r * t) *
            (c1 * Math.cos(w * t) + c2 * Math.sin(w * t))
          )
        },
        dx(t) {
          const power = Math.pow(Math.E, r * t)
          const cos = Math.cos(w * t)
          const sin = Math.sin(w * t)
          return (
            power * (c2 * w * cos - c1 * w * sin) +
            r * power * (c2 * sin + c1 * cos)
          )
        },
      }
    }
  }
}
<fim_middle>",correct,2754
143,143,143,143,Source,Source,de53b444284e879ad933dd4404a7e3f697c8dfe0,"<fim_prefix>export type Mapping<Source, Target> = {
  [P in keyof Target]:
    | keyof PickByType<Source, Target[P]>
    | ((source) => Target[P]);
};

export type KeysOfType<Base, Condition> = {
  [Key in keyof Base]: Base[Key] extends Condition ? Key : never;
}[keyof Base];

export type OmitByType<Base, Condition> = Omit<
  Base,
  KeysOfType<Base, Condition>
>;

export type PickByType<Base, Condition> = Pick<
  Base,
  KeysOfType<Base, Condition>
>;

export type MapTarget<Source> = {
  using: <Target>(mapping) => Target;
};
export type MapSource<Source> = (from) => MapTarget<Source>;

export const map = <Source>(source) => ({
  using: <S, Target>(mapping) => {
    const target = {} as Target;
    for (const targetKey of Object.keys(mapping)) {
      const value = mapping[targetKey];
      if (typeof value === 'string') {
        const sourceKey = value;
        target[targetKey] = source[sourceKey];
      } else if (typeof value === 'function') {
        const fn = value;
        target[targetKey] = fn(source);
      }
    }

    return target;
  },
});

export const using =
  <Source, Target>(mapping) =>
  (source: <fim_suffix>) =>
    map(source).using(mapping);

export function parsePage(
  defaultCount,
  page,
) {
  if (typeof page.first === 'number' || typeof page.after === 'string') {
    const count = page.first || defaultCount;
    return {
      count,
      uniqueId: page.after,
      limit: page.after ? count + 2 : count + 1,
      direction: 'forward',
    };
  } else if (typeof page.last === 'number' || typeof page.before === 'string') {
    const count = page.last || defaultCount;
    return {
      count,
      uniqueId: page.before,
      limit: page.before ? count + 2 : count + 1,
      direction: 'backward',
    };
  }

  return {
    count: defaultCount,
    limit: defaultCount + 1,
    direction: 'forward',
  };
}

export function buildPage<T>(
  items,
  count,
  usedCursor,
  direction,
  getUniqueId,
) {
  const previous = usedCursor ? items[0] : undefined;
  const next: T | undefined = usedCursor ? items[count + 1] : items[count];
  const data = usedCursor ? items.slice(1, count + 1) : items.slice(0, count);

  const first: T | undefined = data[0];
  const last: T | undefined = data[data.length - 1];

  if (direction === 'forward') {
    return {
      items: data,
      hasNextPage: !!next,
      hasPreviousPage: !!previous,
      startCursor: getUniqueId(first),
      endCursor: getUniqueId(last),
    };
  } else {
    return {
      items: data.reverse(),
      hasNextPage: !!previous,
      hasPreviousPage: !!next,
      startCursor: getUniqueId(first),
      endCursor: getUniqueId(last),
    };
  }
}

export function buildInClause<T>(
  items,
  startingAt = 1,
) {
  return {
    in: items.map((_, i) => `$${i + startingAt}`).join(', '),
    values: items,
  };
}
<fim_middle>",correct,5113
144,144,144,144,State,State,6fe76b5aaf422ac45ea3f391258b2aeb7c5ddf67,"<fim_prefix>export type State = {
	room_id: string,
	room_name: string,
	room_icon: string,
	owner_data: {
		client_id: string,
		client_name: string,
		client_profile: string
	}
	active_clients: {
		client_id: string,
		client_name: string,
		client_profile: string
	}[]
}

const roomDefault: State = {
	room_id: '',
	room_name: '',
	room_icon: '',
	owner_data: {
		client_id: '',
		client_name: '',
		client_profile: ''		
	},
	active_clients: [],
}

type ActionType = ""LOAD_ROOM_DATA"" | ""ROOM_BAN_ADD"" | ""ROOM_BAN_REMOVE"" | ""ROOM_MEMBER_UPDATE"" | ""ROOM_MEMBER_REMOVE"" | ""NEW_OWNER""| ""CHANGE_ROOM"" | ""SET_ONLINE_MEMBERS""
type ActionPayload = {
	ip?: string,
	client_id?: string,
	client_name?: string,
	client_profile?: string
	room_name?: string,
	room_icon?: string,
	room_id?: string
	active_clients: {
		client_id: string,
		client_name: string,
		client_profile: string
	}[],
	owner_data: {
		client_id: string,
		client_name: string,
		client_profile: string
	}
}

type Action = {
	type: ActionType,
	payload: ActionPayload
}



export const roomInfo = (state = roomDefault, action): <fim_suffix> => {
	switch(action.type){
		//LOAD ROOM DATA
		case ""LOAD_ROOM_DATA"": {
			const {room_icon, room_id, room_name, owner_data, active_clients} = action.payload
			
			return {
				room_id: room_id!,
				room_name: room_name!,
				room_icon: room_icon!,
				owner_data: owner_data,
				active_clients: active_clients,
			}
		}
		//WHEN OWNER GIVES NEW MEMBER OWNERHOST
		case ""NEW_OWNER"" : {
			const {client_id, client_name, client_profile} = action.payload
			
			return {
				...state,
				owner_data: {
					client_id: client_id!,
					client_name: client_name!,
					client_profile: client_profile!		
				},
			}
		}
		//MEMBER LEAVES ROOM
		case ""ROOM_MEMBER_REMOVE"": {
			const {client_id} = action.payload

			const memberLeft = state.active_clients.filter(e => e.client_id !== client_id)
			
			return {
				...state,
				active_clients: memberLeft
			}
		}
		case ""SET_ONLINE_MEMBERS"": {
			const {active_clients} = action.payload

			return {
				...state,
				active_clients: active_clients
			}
		}
		//MEMBER JOINS ROOM	
		case ""ROOM_MEMBER_UPDATE"": {
			const {client_id, client_name, client_profile} = action.payload
			const duplicateUser = state.active_clients.some(e => e.client_id === client_id)

			if(duplicateUser) return state

			return {
				...state,
				active_clients: [
					...state.active_clients,
					{
						client_id: client_id!,
						client_name: client_name!,
						client_profile: client_profile!
					}
				]
			}
		}
		case ""CHANGE_ROOM"": {
			return {
				...state,
				room_name: action.payload.room_name!,
				room_icon: action.payload.room_icon!
			}
		}
		default: return state
	}
}<fim_middle>",correct,2001
145,145,145,145,State,State,da0ef1973818334ec9af63eb9d4d8f9b49d3597e,"<fim_prefix>export type State = {
	username: string,
	profile_src: string,
	createdAt: string,
	client_id: string
	message: string,
	message_id: string,
	reply?: {
		reply_username: string,
		reply_picture: string,
		reply_message: string,
		reply_message_owner_id: string
	}
}

type Action = {
	type: ""SET_USER"" | ""MESSAGE_INPUT"" | ""CLEAR_MESSAGE_FIELD"" | ""SET_MESSAGE_ID"" | ""SET_REPLY_MESSAGE"" | ""CLEAR_REPLY"",
	payload: {
		username: string,
		profile_src: string,
		createdAt: string,
		client_id: string,
		message: string,
		message_id: string,
		reply_username?: string,
		reply_picture?: string,
		reply_message?: string,
		reply_message_id?: string
	}
}

const clientState: State = {
	username: '',
	profile_src: '',
	createdAt: '',
	client_id: '',
	message: '',
	message_id: ''
}

export const clientReducer = (state = clientState, action): <fim_suffix> => {
	
	switch(action.type){
		case ""SET_USER"": {
			const {username, message_id, profile_src, createdAt, client_id} = action.payload
			return {
				...state,
				username: username,
				profile_src: profile_src,
				createdAt: createdAt,
				client_id: client_id,
				message_id: message_id
			}
		}case ""MESSAGE_INPUT"": {
			const {message} = action.payload
			return {
				...state,
				message: message
			}
		}
		case ""CLEAR_MESSAGE_FIELD"": {
			return {
				...state,
				message: """"
			}
		}
		case ""SET_MESSAGE_ID"": {
			return {
				...state,
				message_id: action.payload.message_id
			}
		}
		case ""SET_REPLY_MESSAGE"": {
			const {reply_username, reply_picture, reply_message, reply_message_id} = action.payload

			return {
				...state,
				reply: {
					reply_username: reply_username as string,
					reply_picture: reply_picture as string,
					reply_message: reply_message as string,
					reply_message_owner_id: reply_message_id as string
				}
			}
		}
		case ""CLEAR_REPLY"": {
			return {
				...state,
				reply: undefined
			}
		}
		default: return state
	}
}<fim_middle>",correct,3545
146,146,146,146,State,State,da0ef1973818334ec9af63eb9d4d8f9b49d3597e,"<fim_prefix>export type State = {
	username: string,
	profile_src: string,
	createdAt: string,
	client_id: string
	message: string,
	message_id: string,
	reply?: {
		reply_username: string,
		reply_picture: string,
		reply_message: string,
		reply_message_owner_id: string
	}
}

type Action = {
	type: ""SET_USER"" | ""MESSAGE_INPUT"" | ""CLEAR_MESSAGE_FIELD"" | ""SET_MESSAGE_ID"" | ""SET_REPLY_MESSAGE"" | ""CLEAR_REPLY"",
	payload: {
		username: string,
		profile_src: string,
		createdAt: string,
		client_id: string,
		message: string,
		message_id: string,
		reply_username?: string,
		reply_picture?: string,
		reply_message?: string,
		reply_message_id?: string
	}
}

const clientState: State = {
	username: '',
	profile_src: '',
	createdAt: '',
	client_id: '',
	message: '',
	message_id: ''
}

export const clientReducer = (state: <fim_suffix> = clientState, action) => {
	
	switch(action.type){
		case ""SET_USER"": {
			const {username, message_id, profile_src, createdAt, client_id} = action.payload
			return {
				...state,
				username: username,
				profile_src: profile_src,
				createdAt: createdAt,
				client_id: client_id,
				message_id: message_id
			}
		}case ""MESSAGE_INPUT"": {
			const {message} = action.payload
			return {
				...state,
				message: message
			}
		}
		case ""CLEAR_MESSAGE_FIELD"": {
			return {
				...state,
				message: """"
			}
		}
		case ""SET_MESSAGE_ID"": {
			return {
				...state,
				message_id: action.payload.message_id
			}
		}
		case ""SET_REPLY_MESSAGE"": {
			const {reply_username, reply_picture, reply_message, reply_message_id} = action.payload

			return {
				...state,
				reply: {
					reply_username: reply_username as string,
					reply_picture: reply_picture as string,
					reply_message: reply_message as string,
					reply_message_owner_id: reply_message_id as string
				}
			}
		}
		case ""CLEAR_REPLY"": {
			return {
				...state,
				reply: undefined
			}
		}
		default: return state
	}
}<fim_middle>",correct,3547
147,147,147,147,StateMachine,StateMachine,4090fc569ef5576bf3bdce304e81cf32fca2f089,"<fim_prefix>export type StateMachineDefinition = {
    states: {
        [key: string]: {
            onEnter?: (subject) => void;
            onEntered?: (subject) => void;
            onExit?: (subject) => void;
            transitions: {
                [key: string]: {
                    to: keyof StateMachineDefinition['states'];
                    action?: (subject) => void;
                };
            };
        };
    };
};

export type StateMachine = {
    subject: any;
    transition: (transitionName) => void;
    canTransit: (transitionName) => boolean;
};
export function createStateMachine(
    subject,
    stateProperty,
    definition,
): <fim_suffix> {
    const { states } = definition;

    const actionInfos = (transitionName) => {
        const currentState = subject[stateProperty];
        const currentStateDefinition = states[currentState as keyof typeof states];
        const destinationTransition =
            currentStateDefinition.transitions[transitionName as keyof typeof currentStateDefinition.transitions];
        if (!destinationTransition) {
            throw new TransitionError(
                `Cannot find the transition '${transitionName}' on subject with state '${currentState}'.`,
            );
        }
        const destinationState = destinationTransition.to;
        const destinationStateDefinition = states[destinationState as keyof typeof states];
        if (!destinationStateDefinition) {
            throw new TransitionError(
                `Cannot transition to '${destinationState}' from '${currentState}'. It does not exist.`,
            );
        }

        return {
            currentStateDefinition,
            destinationTransition,
            destinationStateDefinition,
            destinationState,
        };
    };

    return {
        subject,
        transition(transitionName) {
            const { currentStateDefinition, destinationTransition, destinationStateDefinition, destinationState } =
                actionInfos(transitionName);

            if (destinationTransition.action) {
                destinationTransition.action(subject);
            }
            if (currentStateDefinition.onExit) {
                currentStateDefinition.onExit(subject);
            }
            if (destinationStateDefinition.onEnter) {
                destinationStateDefinition.onEnter(subject);
            }
            subject[stateProperty] = destinationState;
            if (destinationStateDefinition.onEntered) {
                destinationStateDefinition.onEntered(subject);
            }
        },
        canTransit(transitionName) {
            try {
                actionInfos(transitionName);
                return true;
            } catch (exception) {
                return false;
            }
        },
    };
}

export class TransitionError extends Error {
    code: number;
    constructor(message) {
        super(message);
        this.name = 'TransitionError';
        this.code = 400;
    }
}
<fim_middle>",correct,5083
148,148,148,148,StringField,StringField,5f2d2febe1a2a566772fc84aa89c133d84d3093b,"<fim_prefix>/**
 * Number
 */
type NumberField = {
  type: 'number';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const number = (options) => {
  return {
    type: 'number',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * BigInt
 */
type BigIntField = {
  type: 'bigint';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const bigInt = (options) => {
  return {
    type: 'bigint',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * String
 */
type StringField = {
  type: 'string';
  maxLength: number;
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const string = (options): <fim_suffix> => {
  return {
    type: 'string',
    maxLength: options.maxLength,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Boolean
 */
type BooleanField = {
  type: 'boolean';
  canBeNull: boolean;
  default: boolean | null;
  primaryKey: boolean;
};

export const boolean = (options) => {
  return {
    type: 'boolean',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Enumerated
 */
type EnumeratedField = {
  type: 'enumerated';
  values: string[];
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const enumerated = (options) => {
  return {
    type: 'enumerated',
    values: options.values,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * DateTime
 */
type DateTimeField = {
  type: 'datetime';
  canBeNull: boolean;
  default: Date | null;
  primaryKey: boolean;
};

export const dateTime = (options) => {
  return {
    type: 'datetime',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Any Field
 */
export type AnyField =
  | NumberField
  | BigIntField
  | StringField
  | BooleanField
  | EnumeratedField
  | DateTimeField;

export type Fields = {
  [key: string]: AnyField;
};
<fim_middle>",correct,4937
149,149,149,149,Student,Student,861ae1a426b6f731e00a301bff6f6c52ce26d4d9,"<fim_prefix>/* Defines the license entity */
export interface Student {
    adminNotes: string;
    appNum: string;
    appTitle: string;
    appURL: string;     
    applicationFee: number | null;
    authority: string;   
 //   authorityId: number;
    authURL: string;
    authEmail: string;
    authExt: string | null;
    authPhone: string;
    busCoordNotes: string;
    certification: string | null;   
    continuingedu: string | null;  
    coordURL: string;
    coordEmail: string;
    coordExt: string;
    coordPhone: string;
    criminal: string | null;
    duration: string;
    education: string | null;  
    exam: string | null;
    exemptions: string;
    experience: string | null;   
    id: number;
    inactive: string| null;
    keywords: string | null;
    licAuth: string;   
    licAuthId: string;   
    licDesc: string;   
    licNum: number;
    licNumType: string;   
    licTitle: string;   
    licenseId: string;   
    licenseType: string;   
    licenseUpdated: string; 
    licenseURL: string;
    markForAuthXfer: boolean;
    markForDelete: boolean;
    markForDeleteBLNC: boolean;  
    markForDeleteLEAD: boolean;
    miscFee: number;
    newLicFee: number;
    otherReq: string; 
    physical: string;  
    reasonForDelete: string;   
    reciprocity: string;   
    recipStates;
    renewalFee: number;
    ricipFee: number;
    socCode: string;   
    socDesc: string;   
    socTitle: string;
    updatedBy: string;   
    veteran: string;

    tagList: any;
    coordId: string;
    department: string;
    division: string;
    board: string;
    address1: string;
    address2: string;
    city: string;
    st: string;
    zip: string;
    multipleLocation: boolean;
    authphone: string;
    fax: string;
    contact: string;
    url: string;
    officeHours: string;
    coordName: string;
    hasOccProfile: boolean; 
  }
  
  export interface StudentResolved {
    student: any;
    error?: any;
  }

  export function newStudent() : <fim_suffix> {
    const l:Student = {
      adminNotes: '',     
      appNum: '',
      appTitle: '',
      appURL: '',    
      applicationFee: null,
      authority: '',  
      authEmail: '',
      authExt: '',
      authPhone: '',
      authURL: '',
      busCoordNotes: '',   
      certification: null,
      continuingedu: null,
      coordEmail: '',
      coordExt: '',
      coordPhone: '',
      coordURL: '',
      criminal: null, 
      duration: '',
      education: null, 
      exam: null,
      exemptions: '',   
      experience: null,
      id: 0,
      inactive: null,
      keywords: '',
      licAuth: '',   
      licAuthId: null,   
      licDesc: '',   
      licNum: null,
      licNumType: '',   
      licTitle: '',   
      licenseId: null, 
      licenseType: null, 
      licenseUpdated: '',
      licenseURL: '',
      markForAuthXfer: false,
      markForDelete: false,
      markForDeleteBLNC: false, 
      markForDeleteLEAD: false,
      miscFee: null,
      newLicFee: null,
      otherReq: '',
      physical: null,   
      reasonForDelete: '',  
      reciprocity: '',   
      recipStates: [],
      renewalFee: null,
      ricipFee: null,
      socCode: null,  
      socDesc: null,   
      socTitle: '',
      updatedBy: null,
      veteran: null,
      tagList: null,
      coordId: '',
      department: '',
      division: '',
      board: '',
      address1: '',
      address2: '',
      city: '',
      st: '',
      zip: '',
      multipleLocation: false,
      authphone: '',
      fax: '',
      contact: '',
      url: '',
      officeHours: '',
      coordName: '',
      hasOccProfile: false,        
    };
    return l;
  }

  export const enumFields=[
    {name: 'edu', col: 'education', label: 'Education:', sel: '--Please select'},
    {name: 'cert', col: 'certification', label: 'Certification:', sel: '--Please select'},
    {name: 'cedu', col: 'continuingedu', label: 'Continuing education:', sel: '--Please select'},
    {name: 'exp', col: 'experience', label: 'Experience:', sel: '--Please select'},
    {name: 'exam', col: 'exam', label: 'Exam:', sel: '--Please select'},
    {name: 'crim', col: 'criminal', label: 'Criminal:', sel: '--Please select'},
    {name: 'phy', col: 'physical', label: 'Physical requirements:', sel: '--Please select'},
    {name: 'vet', col: 'veteran', label: 'Veteran:', sel: '--Please select'},
    {name: 'active', col: 'inactive', label: 'Active status:', sel: '--Please select'},
    {name: 'types', col: 'licenseType', label: 'License Type:', sel: '--Please select'},
   ];  <fim_middle>",correct,3574
150,150,150,150,Suit,Suit,b1ab8c4be427c0afaf3d2a41ca821482dd787a9e,"<fim_prefix>type DotNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per dot (36)
type BamNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per bam (36)
type CrakNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per crak (36)
type WindNumber = ""East"" | ""West"" | ""South"" | ""North""; // 4 tiles per wind (16)
type DragonNumber = ""White"" | ""Green"" | ""Red""; // 4 tiles per wind (12)
type FlowerNumber = ""Rose"" | ""Lily"" | ""Tulip"" | ""Juniper""; // 2 tiles per flower (8)

export type Number = DotNumber | BamNumber | CrakNumber | WindNumber | DragonNumber | FlowerNumber;

export enum Suit {
  Dot = ""DOT"",
  Bam = ""BAM"",
  Crak = ""CRAK"",
  Wind = ""WIND"",
  Dragon = ""DRAGON"",
  Flower = ""FLOWER"",
}

export default class Tile {
  x: number;
  y: number;
  z: number;
  number: Number;
  suit: Suit;
  static dotNumbers: DotNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static bamNumbers: BamNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static crakNumbers: CrakNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static windNumbers: WindNumber[] = [""East"", ""West"", ""South"", ""North""];
  static dragonNumbers: DragonNumber[] = [""White"", ""Green"", ""Red""];
  static flowerNumbers: FlowerNumber[] = [""Rose"", ""Lily"", ""Tulip"", ""Juniper""];

  constructor(number, suit: <fim_suffix>) {
    this.number = number;
    this.suit = suit;
    this.x = -10
    this.y = -10
    this.z = -10
  }

  place({ z, x, y }) {
    this.z = z
    this.x = x
    this.y = y
  }

  get tileCells() {
    return [
      {
        z: this.z,
        x: this.x,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x,
        y: this.y + 1,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y + 1,
      },
    ];
  }

  get id() {
    return `${this.suit}_${this.number}_${this.x}_${this.y}_${this.z}`;
  }

  tileIsAdjacent(tile) {
    const t1Cells = this.tileCells;
    const t2Cells = tile.tileCells;

    let isAdjacent = false;

    t1Cells.forEach((t1) => {
      t2Cells.forEach((t2) => {
        // tile is above or below
        if ((t1.z === t2.z - 1 || t1.z === t2.z + 1) && t1.x === t2.x && t1.y === t2.y) {
          isAdjacent = true;
        }

        // tile is to the left or the right
        if (t1.z === t2.z && t1.y === t2.y && (t1.x === t2.x - 1 || t1.x === t2.x + 1)) {
          isAdjacent = true;
        }
      });
    });

    return isAdjacent;
  }
}
<fim_middle>",correct,1119
151,151,151,151,T,T,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB: <fim_suffix>
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,222
152,152,152,152,T,T,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB: <fim_suffix>
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,225
153,153,153,153,T,T,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use() {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query: <fim_suffix>) {
  return new StrictQuery(query)
}
<fim_middle>",correct,529
154,154,154,154,T,T,a502da435a6278844d221141f6cce947032e53cc,"<fim_prefix>export interface LanguageInterface {
  name: string;
  code: string;
  nativeName: string;
  layout: ""ltr"" | ""rtl"";
}

export interface LanguagesInterface {
  [key: string]: LanguageInterface;
}

export interface TranslatorOptions {
  cache?: boolean;
  defaultLanguage: string;
  currentLangauge: string;
  engine: TranslateEngine;
}

export type TranslationResponseShape = Record<string, string>;

export type TranslateEngine = (
  language,
  targets
) => Promise<TranslationResponseShape> | TranslationResponseShape;

export type CacheSetter = (key, value) => Promise<void> | void;
export type CacheGetter = (
  key
) => Promise<string | null> | string | null;

export class Translator {
  protected TranslationTargets: string[] = [];
  protected TranslationResults: Record<string, string> = {};
  protected CacheEngines?: {
    setter: CacheSetter;
    getter: CacheGetter;
  };

  // Global Metadata
  public metadata: Record<string, any> = {};

  constructor(protected Options) {
    // Validate Options
    this.setOptions(this.Options);
  }

  public setTranslations(
    translations
  ) {
    if (typeof translations === ""object"")
      this.TranslationTargets = translations;
    else if (typeof translations === ""function"") {
      this.TranslationTargets = translations(this.TranslationTargets);
    }

    return this;
  }

  public getTranslated() {
    return this.TranslationResults;
  }

  public setCacheEngines(setter, getter) {
    if (typeof setter !== ""function"")
      throw new Error(`Please provide a valid Cache Setter Function!`);
    else if (typeof getter !== ""function"")
      throw new Error(`Please provide a valid Cache Getter Function!`);

    this.CacheEngines = { setter, getter };
    return this;
  }

  public setOptions(options) {
    // Validate Options
    if (options.engine && typeof options.engine !== ""function"")
      throw new Error(`Please provide a valid Translation Engine Function!`);

    // Set Options
    this.Options = {
      ...this.Options,
      ...options,
    };

    return this;
  }

  public async setCache(key, value) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.setter === ""function""
    )
      this.CacheEngines.setter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key,
        value
      );
  }

  public async getCache(key) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.getter === ""function""
    )
      return this.CacheEngines.getter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key
      );
    else return null;
  }

  public async translate<T extends string | string[]>(
    targets?: <fim_suffix>
  ) {
    // Resolve Targets
    if (targets === undefined) targets = this.TranslationTargets as T;

    // Collect Translations from Cache
    let Translated: Record<string, string> = {
      ...(
        await Promise.all(
          (targets instanceof Array ? targets : [targets]).map(
            async (target) => {
              const value = await this.getCache(target);
              if (value || target === """")
                return {
                  key: target,
                  value: target === """" ? target : value,
                };
              else return undefined;
            }
          )
        )
      )
        .filter((v) => v !== undefined)
        .reduce(
          (object, item) => ({
            ...object,
            [item!.key]: item!.value,
          }),
          {}
        ),
    };

    // Get Translated Targets
    const TranslatedTargets = Object.keys(Translated);

    // Filter Remaining Targets
    const RemainingTranslations = (targets instanceof Array
      ? targets
      : [targets]
    ).filter((target) => !TranslatedTargets.includes(target));

    // Check Remaining Length
    if (RemainingTranslations.length) {
      try {
        // Fetch New Translations
        const Results =
          this.Options.defaultLanguage !== this.Options.currentLangauge
            ? await this.Options.engine(
                {
                  default: this.Options.defaultLanguage,
                  current: this.Options.currentLangauge,
                },
                RemainingTranslations
              )
            : RemainingTranslations.reduce<TranslationResponseShape>(
                (object, target) => ({ ...object, [target]: target }),
                {}
              );

        if (typeof Results === ""object"") {
          // Store Translation to Cache
          if (this.Options.defaultLanguage !== this.Options.currentLangauge)
            await Promise.all(
              Object.keys(Results).map((target) =>
                this.setCache(target, Results[target])
              )
            );

          // Combine Results
          Translated = {
            ...Translated,
            ...Results,
          };
        }
      } catch (e) {
        // Combine Results
        Translated = {
          ...Translated,
          ...RemainingTranslations.reduce<TranslationResponseShape>(
            (object, target) => ({ ...object, [target]: target }),
            {}
          ),
        };
      }
    }

    // Store Results
    this.TranslationResults = ((targets instanceof Array
      ? targets
      : [targets]) as string[]).reduce(
      (object, target) => ({
        ...object,
        [target]: Translated[target],
      }),
      {}
    );

    // Return Results
    return (typeof targets === ""string""
      ? Object.values(this.TranslationResults)[0]
      : this.TranslationResults) as any;
  }
}
<fim_middle>",correct,564
155,155,155,155,T,T,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone): <fim_suffix> {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date) {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",correct,697
156,156,156,156,T,T,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass: <fim_suffix>, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,999
157,157,157,157,TKey,TKey,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type: <fim_suffix>,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",correct,1707
158,158,158,158,TKey,TKey,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type: <fim_suffix>,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",correct,1710
159,159,159,159,TTT,TTT,ad15d5503f15235dd06d2738702575eb4dfe04e9,"<fim_prefix>export type XO = 'X' | 'O' | '';

export type Board = [[XO, XO, XO], [XO, XO, XO], [XO, XO, XO]];

export type Coordinate = {
  x: number;
  y: number;
};

export type TTT = {
  board: Board;
  lastPlay?: XO;
  winner?: XO;
  draw?: boolean;
};

export const isBoardFull = (x) => x.every((y) => y.every((z) => z));

export const newBoard = () =>
  [...Array(3)].map(() => Array(3).fill('')) as Board;

export const newTtt = (): <fim_suffix> => ({
  board: newBoard(),
});

export const getWinner = (x) => {
  const winners = new Set<XO>();

  for (let i = 0; i < 3; ++i) {
    if (x[0][i] && new Set([x[0][i], x[1][i], x[2][i]]).size === 1) {
      winners.add(x[0][i]);
    }
  }

  for (let i = 0; i < 3; ++i) {
    if (x[i][0] && new Set(x[i]).size === 1) {
      winners.add(x[i][0]);
    }
  }

  if (
    x[1][1] &&
    (new Set([x[0][0], x[1][1], x[2][2]]).size === 1 ||
      new Set([x[0][2], x[1][1], x[2][0]]).size === 1)
  ) {
    winners.add(x[1][1]);
  }

  if (!winners.size) {
    // completion check

    return isBoardFull(x) ? 'DRAW' : 'INCOMPLETE';
  }

  return winners.values().next().value as Exclude<XO, undefined>;
};

export const insertPlay = (x, c) => {
  if (x.board[c[0]][c[1]] || c[0] > 2 || c[1] > 2) return x;

  const winner = getWinner(x.board);
  if (['X', 'O', 'DRAW'].includes(winner.toUpperCase())) {
    if (winner === 'DRAW') {
      x.draw = true;
      return x;
    } else if (winner !== 'INCOMPLETE') {
      x.winner = winner;
      return x;
    }
  }

  x.lastPlay = x.lastPlay === 'X' ? 'O' : 'X';
  x.board[c[0]][c[1]] = x.lastPlay;

  const postWinner = getWinner(x.board);
  if (['X', 'O', 'DRAW'].includes(postWinner.toUpperCase())) {
    if (postWinner === 'DRAW') {
      x.draw = true;
      return x;
    } else if (postWinner !== 'INCOMPLETE') {
      x.winner = postWinner;
      return x;
    }
  }

  return x;
};
<fim_middle>",correct,2072
160,160,160,160,Terms,Terms,76a884ba965e8d7964d8852a0c0f228c1ae1d7ad,"<fim_prefix>type Language = 'en' | 'zh';

type Terms = {
  selfPick: string;
  noFlowers: string;
  flowers: string;
  commonHand: string;
  fullyConcealedHand: string;
  seatWind: string;
  roundWind: string;
  dragons: string;
  mixedOrphans: string;
  winByLastCatch: string;
  robbingKong: string;
  oneCompleteSetOfFlowers: string;
  twoCompleteSetOfFlowers: string;
  winByKong: string;
  mixedOneSuit: string;
  allInTriplets: string;
  flowerHand: string;
  smallDragon: string;
  allOneSuit: string;
  smallWind: string;
  greatDragon: string;
  greatWind: string;
  allHonors: string;
  orphans: string;
  thirteenOrphans: string;
  kaanKaanHand: string;
  winByDoubleKong: string;
  eightImmortalsCrossingTheSea: string;
  allKongs: string;
  nineGates: string;
  earthlyHand: string;
  heavenlyHand: string;
};

export default class Glossary {
  private static readonly CHINESE_MAP: Terms = {
    selfPick: '自摸',
    noFlowers: '無花',
    flowers: '正花',
    commonHand: '平糊',
    fullyConcealedHand: '門前清',
    seatWind: '門風',
    roundWind: '圈風',
    dragons: '中/發/白',
    mixedOrphans: '花幺',
    winByLastCatch: '海底撈月',
    robbingKong: '搶槓',
    oneCompleteSetOfFlowers: '一台花',
    twoCompleteSetOfFlowers: '兩台花',
    winByKong: '槓上自摸',
    mixedOneSuit: '混一色',
    allInTriplets: '對對糊',
    flowerHand: '花糊',
    smallDragon: '小三元',
    allOneSuit: '清一色',
    smallWind: '小四喜',
    greatDragon: '大三元',
    greatWind: '大四喜',
    allHonors: '字一色',
    orphans: '全幺九',
    thirteenOrphans: '十三幺',
    kaanKaanHand: '坎坎糊',
    winByDoubleKong: '槓上槓自摸',
    eightImmortalsCrossingTheSea: '八仙過海',
    allKongs: '十八羅漢',
    nineGates: '九子連環',
    earthlyHand: '地糊',
    heavenlyHand: '天糊',
  };

  private static readonly ENGLISH_MAP: Terms = {
    selfPick: 'self-pick',
    noFlowers: 'no flowers',
    flowers: 'flowers matching seat position',
    commonHand: 'common hand',
    fullyConcealedHand: 'fully concealed hand',
    seatWind: 'seat wind',
    roundWind: 'round wind',
    dragons: 'dragons',
    mixedOrphans: 'mixed orphans',
    winByLastCatch: 'win by last catch',
    robbingKong: 'robbing kong',
    oneCompleteSetOfFlowers: 'one complete set of flowers',
    twoCompleteSetOfFlowers: 'two complete set of flowers',
    winByKong: 'win by Kong',
    mixedOneSuit: 'mixed one suit',
    allInTriplets: 'all in triplets',
    flowerHand: 'flower hand',
    smallDragon: 'small dragon',
    allOneSuit: 'all one suit',
    smallWind: 'small wind',
    greatDragon: 'great dragon',
    greatWind: 'great wind',
    allHonors: 'all honors',
    orphans: 'orphans',
    thirteenOrphans: 'thirteen orphans',
    kaanKaanHand: 'kaan kaan hand',
    winByDoubleKong: 'win by double Kong',
    eightImmortalsCrossingTheSea: 'eight immortals crossing the sea',
    allKongs: 'all Kongs',
    nineGates: 'nine gates',
    earthlyHand: 'earthly hand',
    heavenlyHand: 'heavenly hand',
  };

  private static language: Language = 'en';

  public static get(): <fim_suffix> {
    if (this.language === 'en') {
      return this.ENGLISH_MAP;
    } else if (this.language === 'zh') {
      return this.CHINESE_MAP;
    } else {
      throw new Error('Language setting has not been configured appropriately.');
    }
  }

  public static setLanguage(languageInput) {
    if (languageInput === 'zh' || languageInput === 'en') {
      this.language = languageInput;
    } else {
      throw new Error('Invalid input of language setting.');
    }
  }
}
<fim_middle>",correct,2149
161,161,161,161,Thing,Thing,c638aa7811a23127f92dc64cfed37e179ef1cc7f,"<fim_prefix>export const Kind = 'Core#Thing';

/**
 * An interface describing a base metadata of a thing.
 */
export declare interface IThing {
  /**
   * The data kind. The application ignores the input with an unknown `kind`, unless it can be determined from the context.
   */
  kind?: typeof Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;
}

export class Thing {
  kind = Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;

  /**
   * Returns one in this order:
   * - displayName
   * - name
   * - 'Unnamed object'
   */
  get renderLabel() {
    return this.displayName || this.name || 'Unnamed object';
  }

  /**
   * Creates a basic description from a name.
   */
  static fromName(name): <fim_suffix> {
    const thing = new Thing({
      name,
      kind: Kind,
    });
    return thing;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IThing;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not a thing.
   */
  new(init) {
    if (!Thing.isThing(init)) {
      throw new Error(`Not a thing.`);
    }
    const { description, name, version, displayName } = init;
    this.kind = Kind;
    this.name = name;
    this.displayName = displayName;
    this.description = description;
    this.version = version;
  }

  /**
   * Checks whether the input is a definition of a server.
   */
  static isThing(input) {
    const typed = input as IThing;
    if (input && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IThing = {
      kind: Kind,
    };
    if (typeof this.name === 'string') {
      result.name = this.name;
    }
    if (typeof this.displayName === 'string') {
      result.displayName = this.displayName;
    }
    if (this.description) {
      result.description = this.description;
    }
    if (this.version) {
      result.version = this.version;
    }
    return result;
  }
}
<fim_middle>",correct,1812
162,162,162,162,Thing,Thing,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source): <fim_suffix> {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4927
163,163,163,163,Thing,Thing,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source: <fim_suffix>) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4928
164,164,164,164,Thing,Thing,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target: <fim_suffix>, source) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4929
165,165,165,165,Tile,Tile,b1ab8c4be427c0afaf3d2a41ca821482dd787a9e,"<fim_prefix>type DotNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per dot (36)
type BamNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per bam (36)
type CrakNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per crak (36)
type WindNumber = ""East"" | ""West"" | ""South"" | ""North""; // 4 tiles per wind (16)
type DragonNumber = ""White"" | ""Green"" | ""Red""; // 4 tiles per wind (12)
type FlowerNumber = ""Rose"" | ""Lily"" | ""Tulip"" | ""Juniper""; // 2 tiles per flower (8)

export type Number = DotNumber | BamNumber | CrakNumber | WindNumber | DragonNumber | FlowerNumber;

export enum Suit {
  Dot = ""DOT"",
  Bam = ""BAM"",
  Crak = ""CRAK"",
  Wind = ""WIND"",
  Dragon = ""DRAGON"",
  Flower = ""FLOWER"",
}

export default class Tile {
  x: number;
  y: number;
  z: number;
  number: Number;
  suit: Suit;
  static dotNumbers: DotNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static bamNumbers: BamNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static crakNumbers: CrakNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static windNumbers: WindNumber[] = [""East"", ""West"", ""South"", ""North""];
  static dragonNumbers: DragonNumber[] = [""White"", ""Green"", ""Red""];
  static flowerNumbers: FlowerNumber[] = [""Rose"", ""Lily"", ""Tulip"", ""Juniper""];

  constructor(number, suit) {
    this.number = number;
    this.suit = suit;
    this.x = -10
    this.y = -10
    this.z = -10
  }

  place({ z, x, y }) {
    this.z = z
    this.x = x
    this.y = y
  }

  get tileCells() {
    return [
      {
        z: this.z,
        x: this.x,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x,
        y: this.y + 1,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y + 1,
      },
    ];
  }

  get id() {
    return `${this.suit}_${this.number}_${this.x}_${this.y}_${this.z}`;
  }

  tileIsAdjacent(tile: <fim_suffix>) {
    const t1Cells = this.tileCells;
    const t2Cells = tile.tileCells;

    let isAdjacent = false;

    t1Cells.forEach((t1) => {
      t2Cells.forEach((t2) => {
        // tile is above or below
        if ((t1.z === t2.z - 1 || t1.z === t2.z + 1) && t1.x === t2.x && t1.y === t2.y) {
          isAdjacent = true;
        }

        // tile is to the left or the right
        if (t1.z === t2.z && t1.y === t2.y && (t1.x === t2.x - 1 || t1.x === t2.x + 1)) {
          isAdjacent = true;
        }
      });
    });

    return isAdjacent;
  }
}
<fim_middle>",correct,1117
166,166,166,166,Time,Time,c6f7caaa0590e6613ea1d397ac2df028f848091b,"<fim_prefix>interface Time {
  hours: number
  minutes: number
}

export const parseTime = (time) => {
  const values = (time || '').split(':')
  if (values.length >= 2) {
    let hours = Number.parseInt(values[0], 10)
    const minutes = Number.parseInt(values[1], 10)
    const timeUpper = time.toUpperCase()
    if (timeUpper.includes('AM') && hours === 12) {
      hours = 0
    } else if (timeUpper.includes('PM') && hours !== 12) {
      hours += 12
    }
    return {
      hours,
      minutes,
    }
  }

  return null
}

export const compareTime = (time1, time2) => {
  const value1 = parseTime(time1)
  if (!value1) return -1
  const value2 = parseTime(time2)
  if (!value2) return -1
  const minutes1 = value1.minutes + value1.hours * 60
  const minutes2 = value2.minutes + value2.hours * 60
  if (minutes1 === minutes2) {
    return 0
  }
  return minutes1 > minutes2 ? 1 : -1
}

export const padTime = (time) => {
  return `${time}`.padStart(2, '0')
}
export const formatTime = (time: <fim_suffix>) => {
  return `${padTime(time.hours)}:${padTime(time.minutes)}`
}

export const nextTime = (time, step) => {
  const timeValue = parseTime(time)
  if (!timeValue) return ''

  const stepValue = parseTime(step)
  if (!stepValue) return ''

  const next = {
    hours: timeValue.hours,
    minutes: timeValue.minutes,
  }
  next.minutes += stepValue.minutes
  next.hours += stepValue.hours
  next.hours += Math.floor(next.minutes / 60)
  next.minutes = next.minutes % 60
  return formatTime(next)
}
<fim_middle>",correct,1940
167,167,167,167,Triangle,Triangle,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle: <fim_suffix>,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3644
168,168,168,168,Triangle,Triangle,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle: <fim_suffix>,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3654
169,169,169,169,Type,Type,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing): <fim_suffix> {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4925
170,170,170,170,TypeDef,TypeDef,8dd4eba467cc4f8c283713bdfc23d3b71e87f31d,"<fim_prefix>export type BasePostMessageCallbackProps<T> = {
  onMessage?: (message) => void
  onInvalidMessageError?: (message, error) => void
}

// This is an internal error. Thrown when we are decoding a post message's
// metadata and we encourntered a missing field or an invalid value. This
// likely means there has been a change to the definition of a post message
// that we do not know about.
export class PostMessageFieldDecodeError extends Error {
  public messageType: string
  public field: string
  public expectedType: TypeDef
  public gotValue: unknown

  constructor(messageType, field, expectedType: <fim_suffix>, gotValue) {
    super(`Unable to decode '${field}' from '${messageType}'`)

    this.messageType = messageType
    this.field = field
    this.expectedType = expectedType
    this.gotValue = gotValue

    Object.setPrototypeOf(this, PostMessageFieldDecodeError.prototype)
  }
}

// This is an internal error. Thrown when we get a post message we don't konw
// about. This likely means there is a new post message that this package needs
// to define.
export class PostMessageUnknownTypeError extends Error {
  public postMessageType: string

  constructor(postMessageType) {
    super(`Unknown post message: ${postMessageType}`)

    this.postMessageType = postMessageType

    Object.setPrototypeOf(this, PostMessageUnknownTypeError.prototype)
  }
}

export type MessageEventData = {
  mx?: boolean
  metadata?: Metadata
  type?: string
}

export type Value = string | number
export type NestedValue = Record<string, Value>
export type TypeDef = string | Array<string> | Record<string, string>
export type Metadata = Record<string, Value | NestedValue>

export function assertMessageProp(
  container,
  postMessageType,
  field,
  expectedType,
) {
  const value = container[field]

  const valueIsDefined = typeof value !== ""undefined""
  const valueIsString = typeof value === ""string""
  const valueIsNumber = typeof value === ""number""
  const valueIsObject = typeof value === ""object"" && !Array.isArray(value)

  const typeIsString = expectedType === ""string""
  const typeIsNumber = expectedType === ""number""
  const typeIsArray = expectedType instanceof Array
  const typeIsObject = typeof expectedType === ""object"" && !Array.isArray(expectedType)

  if (!valueIsDefined) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsString && !valueIsString) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsNumber && !valueIsNumber) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsArray && !(valueIsString && expectedType.includes(value))) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && !valueIsObject) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && valueIsObject) {
    Object.keys(expectedType).forEach((field) => {
      assertMessageProp(value, postMessageType, field, expectedType[field])
    })
  }
}
<fim_middle>",correct,2991
171,171,171,171,U,U,a3c87e22c30072055cfbcdaba851bef6a0244dc3,"<fim_prefix>// /**
//  * DTOs must extends this class
//  */
export class DTOMapper {
  dtoMapperProfile () {
    return undefined;
  };
}

/**
 * DTO Mapper Option Type
 * @param T - Type of class
 */
export interface IDtoMapperOption<T> {
  mapToClass?: IDtoMapperToClass<T>;
  mapToPath?: IDtoMapperToPath;
}

// Mapping to class type
export interface IDtoMapperToClass<T> {
  mapFromKey: string;
  dtoClass: new () => T;
}
// mapping to path type
export interface IDtoMapperToPath {
  mapFromKey: string;
  valueFromPath: string;
}

/**
 * 
 * Map source object to destination class
 * 
 * @param {T} source - Source object to map from
 * @param {U} destination - Destination class to map to
 * @returns {U} An object of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);
/**
 * 
 * Map source object to destination class
 * 
 * @param {T[]} source  - Source array of objects to map from
 * @param {U} destination - Destination class to which map each object from the source
 * @returns {U[]} An array of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);

export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
) {
  if ( Array.isArray( source ) ) {
    return source.map( s => {
      return mapper( s, new destination() );
    } );
  }
  return mapper( source, new destination() );
}

// Mapper to map source to destination
function mapper<T, U extends DTOMapper> ( source, destination ): <fim_suffix> {
  Object.keys( destination ).forEach( key => {
    destination[ key as keyof U ] = <any>source[ key as keyof T ];
    if ( destination.dtoMapperProfile()?.length ) {
      destination.dtoMapperProfile()?.forEach( option => {
        // To class mapping (recursively)
        if ( option.mapToClass?.mapFromKey === key ) {
          if ( source[ key as keyof T ] ) {
            if ( Array.isArray( source[ key as keyof T ] ) ) {
              const result = Array.from( source[ key as keyof T ] as any ).map( el => {
                return mapper( el, new option.mapToClass!.dtoClass() );
              } );
              destination[ key as keyof U ] = result as any;
            } else {
              const result = mapper( source[ key as keyof T ], new option.mapToClass.dtoClass() );
              destination[ key as keyof U ] = result as any;
            }
          }
          // To value mapping
        } else if ( option.mapToPath?.mapFromKey === key ) {
          let sourceVal: any;
          if ( Array.isArray( option.mapToPath.valueFromPath.split( '.' ) ) ) {
            const paths = option.mapToPath.valueFromPath.split( '.' );
            paths.forEach( p => {
              if ( !sourceVal ) {
                sourceVal = source[ p as keyof T ];
              } else {
                sourceVal = sourceVal[ p ];
              }
            } );
          } else {
            sourceVal = <any>source[ option.mapToPath.valueFromPath as keyof T ];
          }

          destination[ key as keyof U ] = sourceVal;
        }
      } );
    }
  } );
  return destination;
}<fim_middle>",correct,2928
172,172,172,172,U,U,a3c87e22c30072055cfbcdaba851bef6a0244dc3,"<fim_prefix>// /**
//  * DTOs must extends this class
//  */
export class DTOMapper {
  dtoMapperProfile () {
    return undefined;
  };
}

/**
 * DTO Mapper Option Type
 * @param T - Type of class
 */
export interface IDtoMapperOption<T> {
  mapToClass?: IDtoMapperToClass<T>;
  mapToPath?: IDtoMapperToPath;
}

// Mapping to class type
export interface IDtoMapperToClass<T> {
  mapFromKey: string;
  dtoClass: new () => T;
}
// mapping to path type
export interface IDtoMapperToPath {
  mapFromKey: string;
  valueFromPath: string;
}

/**
 * 
 * Map source object to destination class
 * 
 * @param {T} source - Source object to map from
 * @param {U} destination - Destination class to map to
 * @returns {U} An object of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);
/**
 * 
 * Map source object to destination class
 * 
 * @param {T[]} source  - Source array of objects to map from
 * @param {U} destination - Destination class to which map each object from the source
 * @returns {U[]} An array of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);

export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
) {
  if ( Array.isArray( source ) ) {
    return source.map( s => {
      return mapper( s, new destination() );
    } );
  }
  return mapper( source, new destination() );
}

// Mapper to map source to destination
function mapper<T, U extends DTOMapper> ( source, destination: <fim_suffix> ) {
  Object.keys( destination ).forEach( key => {
    destination[ key as keyof U ] = <any>source[ key as keyof T ];
    if ( destination.dtoMapperProfile()?.length ) {
      destination.dtoMapperProfile()?.forEach( option => {
        // To class mapping (recursively)
        if ( option.mapToClass?.mapFromKey === key ) {
          if ( source[ key as keyof T ] ) {
            if ( Array.isArray( source[ key as keyof T ] ) ) {
              const result = Array.from( source[ key as keyof T ] as any ).map( el => {
                return mapper( el, new option.mapToClass!.dtoClass() );
              } );
              destination[ key as keyof U ] = result as any;
            } else {
              const result = mapper( source[ key as keyof T ], new option.mapToClass.dtoClass() );
              destination[ key as keyof U ] = result as any;
            }
          }
          // To value mapping
        } else if ( option.mapToPath?.mapFromKey === key ) {
          let sourceVal: any;
          if ( Array.isArray( option.mapToPath.valueFromPath.split( '.' ) ) ) {
            const paths = option.mapToPath.valueFromPath.split( '.' );
            paths.forEach( p => {
              if ( !sourceVal ) {
                sourceVal = source[ p as keyof T ];
              } else {
                sourceVal = sourceVal[ p ];
              }
            } );
          } else {
            sourceVal = <any>source[ option.mapToPath.valueFromPath as keyof T ];
          }

          destination[ key as keyof U ] = sourceVal;
        }
      } );
    }
  } );
  return destination;
}<fim_middle>",correct,2929
173,173,173,173,User,User,bb8faf8f1fabd1682a5c59c52cae3e16456eff95,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IUser {
    admin?: boolean;
    date_password?: string;
    email?: string;
    enabled?: boolean;
    id?: string;
    username?: string;
}

export default class User {
    readonly _admin: boolean | undefined;

    get admin() {
        return this._admin;
    }

    readonly _date_password: string | undefined;

    get datePassword() {
        return this._date_password;
    }

    readonly _email: string | undefined;

    get email() {
        return this._email;
    }

    readonly _enabled: boolean | undefined;

    get enabled() {
        return this._enabled;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _username: string | undefined;

    get username() {
        return this._username;
    }

    constructor(props) {
        if (typeof props.admin === 'boolean') {
            this._admin = props.admin;
        }
        if (typeof props.date_password === 'string') {
            this._date_password = props.date_password.trim();
        }
        if (typeof props.email === 'string') {
            this._email = props.email.trim();
        }
        if (typeof props.enabled === 'boolean') {
            this._enabled = props.enabled;
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.username === 'string') {
            this._username = props.username.trim();
        }
    }

    serialize() {
        const data: IUser = {};
        if (typeof this._admin !== 'undefined') {
            data.admin = this._admin;
        }
        if (typeof this._date_password !== 'undefined') {
            data.date_password = this._date_password;
        }
        if (typeof this._email !== 'undefined') {
            data.email = this._email;
        }
        if (typeof this._enabled !== 'undefined') {
            data.enabled = this._enabled;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._username !== 'undefined') {
            data.username = this._username;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            username: !this._username
                ? true
                : typeof this._username === 'string' && !this._username
                ? true
                : this._username,
            email: !this._email
                ? true
                : typeof this._email === 'string' && !this._email
                ? true
                : this._email,
            date_password: !this._date_password
                ? true
                : typeof this._date_password === 'string' &&
                  !this._date_password
                ? true
                : this._date_password,
            enabled: !this._enabled ? true : typeof this._enabled === 'boolean',
            admin: !this._admin ? true : typeof this._admin === 'boolean',
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new User({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,841
174,174,174,174,V,V,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value): <fim_suffix> {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1776
175,175,175,175,Value,Value,3b28605856ba363437dc8c991572f8f009158f06,"<fim_prefix>interface NestedRecord<V = any> {
  [k: string | number]: NestedRecord<V> | V
}

export function assignNestedKeys<Object = NestedRecord, Value = any>(
  obj,
  keys,
  value: <fim_suffix>,
) {
  let temp: Record<string, any> = obj
  keys.forEach((k, index) => {
    if (index === keys.length - 1) {
      if (temp && typeof temp === ""object"") {
        temp[k] = value
      }
    } else if (temp && typeof temp === ""object"") {
      if (!temp[k]) {
        temp[k] = {}
      }
      temp = temp[k]
    }
  })
}

export function walkObjectDeep<Value, T = Record<string, any>>(
  obj,
  callback,
  shouldSkipPaths?,
) {
  function recurse(object, parentKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (
        (!shouldSkipPaths ||
          (shouldSkipPaths && !shouldSkipPaths([...parentKeys, key]))) &&
        value !== undefined &&
        value !== null
      ) {
        if (typeof value === ""object"" && Object.keys(value).length > 0) {
          recurse(value, [...parentKeys, key])
        } else {
          callback([...parentKeys, key], value, object)
        }
      }
    })
  }
  recurse(obj)
}

function getCssValue(keys, value) {
  if (typeof value === ""number"") {
    if (
      [""lineHeight"", ""fontWeight"", ""opacity"", ""zIndex""].some((prop) =>
        keys.includes(prop),
      )
    ) {
      // CSS property that are unitless
      return value
    }
    const lastKey = keys[keys.length - 1]
    if (lastKey.toLowerCase().includes(""opacity"")) {
      // opacity values are unitless
      return value
    }
    return `${value}px`
  }
  return value
}

export function cssVarsParser<T extends Record<string, any>>(
  theme,
  options?,
) {
  const { prefix, basePrefix = """", shouldSkipGeneratingVar } = options || {}
  const css = {} as NestedRecord<string>
  const vars = {} as NestedRecord<string>
  const parsedTheme = {} as T

  walkObjectDeep(
    theme,
    (keys, value) => {
      if (typeof value === ""string"" || typeof value === ""number"") {
        if (typeof value === ""string"" && /var\(\s*--/.test(value)) {
          // for CSS variable, apply prefix or remove basePrefix from the variable
          if (!basePrefix && prefix) {
            // eslint-disable-next-line no-param-reassign
            value = value.replace(/var\(\s*--/g, `var(--${prefix}-`)
          } else {
            // eslint-disable-next-line no-param-reassign
            value = prefix
              ? value.replace(
                  new RegExp(`var\\(\\s*--${basePrefix}`, ""g""),
                  `var(--${prefix}`,
                ) // removing spaces
              : value.replace(
                  new RegExp(`var\\(\\s*--${basePrefix}-`, ""g""),
                  ""var(--"",
                )
          }
        }

        if (
          shouldSkipGeneratingVar == null ||
          shouldSkipGeneratingVar(keys, value)
        ) {
          // only create css & var if `shouldSkipGeneratingVar` return false
          const cssVar = `--${prefix ? `${prefix}-` : """"}${keys.join(""-"")}`
          Object.assign(css, { [cssVar]: getCssValue(keys, value) })

          assignNestedKeys(vars, keys, `var(${cssVar})`)
        }
      }
      assignNestedKeys(parsedTheme, keys, value)
    },
    (keys) => keys[0] === ""vars"", // skip 'vars/*' paths
  )

  return { css, vars, parsedTheme }
}
<fim_middle>",correct,589
176,176,176,176,ValueType,ValueType,251dc8a6bd0853f15cfeabfb12becc4052d3fe54,"<fim_prefix>type ValueType = string | number;

const isE = (number) => {
  const str = String(number);

  return !Number.isNaN(Number(str)) && str.includes('e');
};

export const trimNumber = (numStr) => {
  let str = numStr.trim();

  if (str === '' || str === '0') {
    return {
      negative: false,
      negativeStr: '',
      trimStr: '',
      integerStr: '0',
      decimalStr: '',
      fullStr: str,
    };
  }

  let negative = str.startsWith('-');

  if (negative) {
    str = str.slice(1);
  }

  str = str
    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
    .replace(/(\.\d*[^0])0*$/, '$1')
    // Remove useless decimal. `1.` => `1`
    .replace(/\.0*$/, '')
    // Remove integer 0. `0001` => `1`, 000.1' => `.1`
    .replace(/^0+/, '');

  if (str.startsWith('.')) {
    str = `0${str}`;
  }

  const trimStr = str || '0';
  const splitNumber = trimStr.split('.');

  const integerStr = splitNumber[0] || '0';
  const decimalStr = splitNumber[1] || '0';

  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }

  const negativeStr = negative ? '-' : '';

  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`,
  };
};

const validateNumber = (num) => {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }

  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
};

const getNumberPrecision = (number) => {
  const numStr = String(number);

  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));

    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch?.[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }

  return numStr.includes('.') && validateNumber(numStr)
    ? numStr.length - numStr.indexOf('.') - 1
    : 0;
};

const maxPrecision = (pre, cur: <fim_suffix>) =>
  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));

const add = (pre, cur) => {
  const preValue = Number(pre);
  const curValue = Number(cur);

  const totalValue = preValue + curValue;
  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {
    return bigIntDecimalAdd(pre, cur);
  }
  return totalValue.toFixed(maxPrecision(pre, cur));
};

const makeBigIntDecimal = (value) => {
  // We need convert back to Number since it require `toFixed` to handle this
  if (isE(value)) {
    value = Number(value);
  }

  value = typeof value === 'string' ? value : num2str(value);

  if (validateNumber(value)) {
    const trimRet = trimNumber(value);
    const numbers = trimRet.trimStr.split('.');
    const decimalStr = numbers[1] || '0';

    return {
      value: value,
      negative: trimRet.negative,
      integer: BigInt(numbers[0]),
      decimal: BigInt(decimalStr),
      decimalLen: decimalStr.length,
    };
  }
  return null;
};

type BigIntDecimalType = {
  value: string;
  negative: boolean;
  integer: BigInt;
  decimal: BigInt;
  decimalLen: number;
};

const bigIntDecimalAdd = (pre, cur) => {
  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;
  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;

  if (!preValue || !curValue) return '';

  const maxDecimalLength = Math.max(
    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,
    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,
  );
  const preDecimal = BigInt(
    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal
      .toString()
      .padStart(preValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );
  const curDecimal = BigInt(
    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal
      .toString()
      .padStart(curValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );

  const valueStr = (preDecimal + curDecimal).toString();

  // We need fill string length back to `maxDecimalLength` to avoid parser failed
  const { negativeStr, trimStr } = trimNumber(valueStr);
  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;

  return trimNumber(
    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,
  ).fullStr;
};

export const num2str = (value) => {
  let numIn = value.toString();
  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;
  let sign = ''; // To remember the number sign
  if (numIn.charAt(0) === '-') {
    numIn = numIn.substring(1);
    sign = '-';
  }
  let str = numIn.split(/[eE]/g); // Split numberic string at e or E

  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back

  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)
  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one

  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator
  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point

  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else """"
  let baseLH = str[0]; // LH base part.

  if (power > 0) {
    // ------- Positive Exponents (Process the RH Base Part)
    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with ""0"" at RH
    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base
    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it
  } else {
    // ------- Negative Exponents (Process the LH Base Part)
    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's
    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with ""0"" at LH
    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert ""."" at the correct place into LH base
    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add ""0""
  }
  return sign + baseLH + baseRH; // Return the long number (with sign)
};

export default add;
<fim_middle>",correct,4638
177,177,177,177,Variable,Variable,4b26b14a08d5cdfff6183540cb79049b3ed5038a,"<fim_prefix>/* eslint-disable no-constant-condition */

const EOF = '~EOF~'

class Parser {
  private pos = 0

  constructor(private input) {}

  next() {
    if (this.pos >= this.input.length) {
      return EOF
    }
    return this.input[this.pos++]
  }

  backup() {
    this.pos--
  }

  parseTemplate() {
    if (this.next() != '/') {
      throw new Error('binding URL should start with a slash')
    }
    
    return {
      segments: this.parseSegments(),
      verb: this.parseVerb(),
    }
  }

  private parseSegments() {
    let segments: Segment[] = []
    segments.push(this.parseSegment())

    while (true) {
      let r = this.next()
      switch (r) {
        case '/':
          segments.push(this.parseSegment())
          continue

        case ':':
        case '}':
          this.backup()
          return segments

        case EOF:
          return segments

        default:
          throw new Error(`unexpected ${r} in segments`)
      }
    }
  }

  private parseSegment() {
    let content = ''
    while (true) {
      let r = this.next()
      switch (r) {
        case EOF:
          if (!content.length) {
            throw new Error(`unexpected EOF in segment`)
          }
          return { content }

        case '{':
          return { content, variable: this.parseVariable() }

        case ':':
        case '/':
        case '}':
          this.backup()
          if (!content.length) {
            throw new Error(`unexpected ${r} in segment`)
          }
          return { content }

        default:
          content += r
      }
    }
  }

  private parseVariable(): <fim_suffix> {
    let v: Variable = {
      name: '',
    }
    while (true) {
      let r = this.next()
      switch (r) {
        case '}':
          if (!v.name.length) {
            throw new Error(`empty variable name`)
          }
          return v

        case '=':
          v.parts = this.parseSegments().map(segment => {
            if (!segment.content.length) {
              throw new Error(`unexpected empty segment`)
            }
            return segment.content
          })
          break

        case EOF:
          throw new Error(`unexpected EOF in variable ${v.name}`)

        default:
          v.name += r
      }
    }
  }

  private parseVerb() {
    let r = this.next()
    switch (r) {
      case ':':
        break

      case EOF:
        return ''

      default:
        throw new Error(`unexpected ${r} in verb`)
    }

    let verb = ''
    while (true) {
      let r = this.next()
      if (r === EOF) {
        if (!verb.length) {
          throw new Error(`empty verb`)
        }
        return verb
      }
      verb += r
    }
  }
}

interface Binding {
  segments: Segment[]
  verb: string
}

interface Segment {
  content: string
  variable?: Variable
}

interface Variable {
  name: string
  parts?: string[]
}

export function buildURL(template, params) {
  let parser = new Parser(template)
  let binding = parser.parseTemplate()

  let parts = binding.segments.map(segment => {
    if (segment.variable) {
      if (!params[segment.variable.name]) {
        throw new Error(`input parameter ${segment.variable.name} is required`)
      }

      return params[segment.variable.name]
    }
    return segment.content
  })
  let verb = binding.verb ? `:${binding.verb}` : ''
  return '/' + parts.join('/') + verb
}
<fim_middle>",correct,925
178,178,178,178,Variable,Variable,b6c4e1fb10e5beed8368e9e86826f11e965be6f5,"<fim_prefix>const DFG_VERSION = '0.18.1';

export enum QueryDetail {
  LABEL = 'LABEL',
  SKELETON = 'SKELETON',
  SUMMARY = 'SUMMARY',
  FULL = 'FULL',
}

export enum VariableType {
  POINT2 = 'RoME.Point2',
  POSE2 = 'RoME.Pose2',
}

export type Variable = {
  label: string;
  dataEntry: string;
  nstime: string;
  variableType: string;
  dataEntryType: string;
  ppeDict: string;
  solverDataDict: string;
  smallData: string;
  solvable: number;
  tags: string;
  timestamp: string;
  _version: string;
};

export function Variable(
  label,
  type,
  tags = ['VARIABLE'],
  timestamp = new Date().toISOString(),
): <fim_suffix> {
  const solverDataDict = {
    default: {
      vecval: [
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      ],
      dimval: 3,
      vecbw: [0.0, 0.0, 0.0],
      dimbw: 3,
      BayesNetOutVertIDs: [],
      dimIDs: [0, 1, 2],
      dims: 3,
      eliminated: false,
      BayesNetVertID: '_null',
      separator: [],
      variableType: type,
      initialized: false,
      infoPerCoord: [0.0, 0.0, 0.0],
      ismargin: false,
      dontmargin: false,
      solveInProgress: 0,
      solvedCount: 0,
      solveKey: 'default',
    },
  };
  const result: Variable = {
    label,
    dataEntry: '{}',
    nstime: '0',
    variableType: type,
    dataEntryType: '{}',
    ppeDict: '{}',
    solverDataDict: JSON.stringify(solverDataDict),
    smallData: '{}',
    solvable: 1,
    tags: JSON.stringify(tags),
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",correct,1023
179,179,179,179,Vector,Vector,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2): <fim_suffix> {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3403
180,180,180,180,Vector,Vector,d5ff2fa2b6826801f70c82d95dcdfcf780c62790,"<fim_prefix>const OCCUPIED_SEAT = '#';
const EMPTY_SEAT = 'L';
const FLOOR = '.';

interface Position {
  x: number,
  y: number
}

interface Vector {
  x: number,
  y: number
}

type AdjacentSeatFinder = (input, position, direction) => string;

export function getAdjacentSeat(input, position, direction: <fim_suffix>) {
  const adjacentLineIndex = position.y + direction.y;
  const adjacentColumnIndex = position.x + direction.x;
  
  const newPosition = { 
    x: position.x + direction.x,
    y: position.y + direction.y
  }

  if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length){
    return FLOOR;
  }

  return input[adjacentLineIndex][adjacentColumnIndex];
}


export function getFirstSeatAtDirection(input, position, direction) {
  let seat: string = FLOOR;

  let newPosition = position;
  while(true) {
    newPosition = { 
      x: newPosition.x + direction.x,
      y: newPosition.y + direction.y
    }

    if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length) break;

    const place = input[newPosition.y][newPosition.x];

    if (place !== FLOOR) {
      seat = place;
      break;
    }
  }

  return seat;
}

export function computeRound(input, adjacentSeatFinder, maximumAdjacentOccupiedSeats) {
  return input.map((line, lineIndex) => {
    return line
      .split('')
      .map((seat, seatIndex) => {
        if (seat === FLOOR) {
          return seat;
        }

        let numberOfAdjacentOccupiedSeat = 0;
        for (let iLine = -1; iLine <= 1; iLine++) {
          for (let iColumn = -1; iColumn <= 1; iColumn ++) {
            if(iLine === 0 && iColumn === 0) continue;

            const position = { x: seatIndex, y: lineIndex};
            const direction = { x: iColumn, y: iLine }
            const adjacentSeat = adjacentSeatFinder(input, position, direction);

            if (adjacentSeat === OCCUPIED_SEAT) {
              numberOfAdjacentOccupiedSeat++;
            }
          }
        }

        if (numberOfAdjacentOccupiedSeat === 0) {
          return OCCUPIED_SEAT;
        } else if (numberOfAdjacentOccupiedSeat >= maximumAdjacentOccupiedSeats) {
          return EMPTY_SEAT;
        } else {
          return seat;
        }
      })
      .join('');
  })
}

export function countNumberOfOccupiedSeatsAfterStabilization(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getAdjacentSeat, 4);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}

export function countNumberOfOccupiedSeatsAfterStabilizationWithRayCast(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getFirstSeatAtDirection, 5);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}
<fim_middle>",correct,4861
181,181,181,181,Vertex,Vertex,eaa92966cbe116f28e1b5c9c0f4b724a32bab041,"<fim_prefix>type Vertex = string;
type Weight = number;
type Graph = Record<string, Record<string, Weight>>;

/**
 * If a target is not provided, finds the single-source shortest path distance from the source vertex with positive or negative edge weights
 * (but with no negative weight cycles).
 * Else, it returns the shortest path as well as its distance from source vertex to target vertex.
 * In the case of negative weight cycles, if target is defined, then negative infinity and empty array path will be returned,
 * else, all distances from A will be returned with negative infinity.
 *
 * @param {Graph} graph Vertex with its fields being the neighboring vertices and value being the weight from vertex to neighboring vertices
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target Ending vertex in graph
 * @return {Record<string, number> | [number, Array<Vertex>]} An object mapping of the distance from the source vertex or an array containing the distance
 * and an array containing the path from source to target vertex
 */
function bellmanFord(
  graph,
  source,
  target?,
) {
  const vertices = Object.keys(graph);
  // if graph is empty, immediately return
  if (vertices.length === 0) {
    return target ? [0, []] : {};
  }

  if (!vertices.includes(source) || (target && !vertices.includes(target))) {
    return target ? [-Infinity, []] : {};
  }

  const distances = getDistances(vertices, source);
  const predecessor = getPredecessor(vertices);

  // requires only n - 1 iteration
  for (let i = 0; i < vertices.length - 1; i++) {
    for (let startVertex of vertices) {
      const neighbors = graph[startVertex];
      for (let endVertex in neighbors) {
        const weight = graph[startVertex][endVertex];
        // relaxation
        if (distances[startVertex] + weight < distances[endVertex]) {
          distances[endVertex] = distances[startVertex] + weight;
          predecessor[endVertex] = startVertex;
        }
      }
    }
  }

  // checks for any negative weight cycles. If true returns all distances as -Infinity as a sign negative weight cycles
  for (let startVertex of vertices) {
    const neighbors = graph[startVertex];
    for (let endVertex in neighbors) {
      const weight = graph[startVertex][endVertex];
      // if relaxation occurs here, negative weight cycles detected
      if (distances[startVertex] + weight < distances[endVertex]) {
        return target ? [-Infinity, []] : negativeWeightCycles(vertices);
      }
    }
  }

  if (!target) {
    return distances;
  }

  const shortestDistance = distances[target];
  const path = getPath(predecessor, source, target);
  return [shortestDistance, path];
}

/**
 * Returns an Object mapping of nodes to distance with values all being negative infinity to represent a negative weight cycle being present.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, number>} An object mapping of nodes with values being negative infinity
 */
function negativeWeightCycles(vertices) {
  return vertices.reduce((acc, curr) => {
    acc[curr] = -Infinity;
    return acc;
  }, {} as Record<string, number>);
}

/**
 * Initializes the distance mapping from source to rest of the vertices.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @param {Vertex} source Starting vertex in graph
 * @return {Record<string, number>} An object mapping of source to rest of vertices
 */
function getDistances(
  vertices,
  source,
) {
  const distances = vertices.reduce((acc, curr) => {
    acc[curr] = Infinity;
    return acc;
  }, {} as Record<string, number>);
  distances[source] = 0;
  return distances;
}

/**
 * Returns an array denoting the path from start vertex to end vertex.
 *
 * @param {Object} predecessor Mapping of child vertex pointing to parent vertex
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target End vertex in graph
 * @return {Array<String>} An array containing the path from source to target vertex
 */
function getPath(
  predecessor,
  source,
  target: <fim_suffix>,
) {
  const path = [target];
  while (target && target !== source) {
    const next = predecessor[target];
    target = next ?? source; // if next is undefined, it reaches source
    path.push(target);
  }
  return path.reverse();
}

/**
 * Generates a default object mapping of child vertex pointing to parent vertex which will be defaulted to undefined initially.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, Vertex | undefined>} An object mapping of child vertex pointing to parent vertex
 */
function getPredecessor(
  vertices,
) {
  const predecessor = {} as Record<string, Vertex | undefined>;
  for (let vertex of vertices) {
    predecessor[vertex] = undefined;
  }
  return predecessor;
}

export default bellmanFord;
<fim_middle>",correct,4126
182,182,182,182,WebApi,WebApi,784e0b27e79a2fe98c745e477d0f8c518b8f59ac,"<fim_prefix>export const Kind = 'Core#WebApi';

/**
 * @deprecated This was used in the old version of ARC.
 */
export interface ILegacyRestApi {
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   */
  data: string;
  /**
   * The AMF parser version used to parse this document.
   */
  amfVersion?: string;
}

export interface IWebApi {
  kind: typeof Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path: string;
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;
}

export class WebApi {
  kind = Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId = '';
  /**
   * Version name of the API
   */
  version = '';
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path = '';
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;

  /**
   * Checks whether the object represents a legacy way of storing the web API data.
   */
  get isLegacy() {
    return !!this.data;
  }

  /**
   * Checks whether the object is the legacy schema for web API (formally known as RestAPI)
   */
  static isLegacy(api) {
    const legacy = api as ILegacyRestApi;
    if (legacy.data) {
      return true;
    }
    return false;
  }

  static fromLegacy(api): <fim_suffix> {
    const { version, amfVersion, data, indexId } = api;
    const init: IWebApi = {
      kind: Kind,
      version,
      path: '',
      indexId,
    };
    if (amfVersion) {
      init.amfVersion = amfVersion;
    }
    if (data) {
      init.data = data;
    }
    return new WebApi(init);
  }

  /**
   * Creates an identifier of this web API object.
   * @param indexId The id of the corresponding index item. This is usually the base URI of the API.
   * @param version The version name of this web API.
   * @returns The unique and reversible identifier of this web API.
   */
  static createId(indexId, version) {
    return `${indexId}|${version}`;
  }

  constructor(input?) {
    let init: IWebApi;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        version: '',
        path: '',
        indexId: '',
      };
    }
    this.new(init);
  }

  new(init) {
    const { version, data, amfVersion, path, main, mime, vendor, indexId } = init;
    if (indexId) {
      this.indexId = indexId;
    } else {
      this.indexId = '';
    }
    if (version) {
      this.version = version;
    } else {
      this.version = '';
    }
    if (data) {
      this.data = data;
    } else {
      this.data = undefined;
    }
    if (amfVersion) {
      this.amfVersion = amfVersion;
    } else {
      this.amfVersion = undefined;
    }
    if (path) {
      this.path = path;
    } else {
      this.path = '';
    }
    if (main) {
      this.main = main;
    } else {
      this.main = undefined
    }
    if (mime) {
      this.mime = mime;
    } else {
      this.mime = mime;
    }
    if (vendor) {
      this.vendor = vendor;
    } else {
      this.vendor = undefined;
    }
  }

  toJSON() {
    const result: IWebApi = {
      kind: Kind,
      version: this.version,
      path: this.path,
      indexId: this.indexId,
    };
    if (this.data) {
      result.data = this.data;
    }
    if (this.amfVersion) {
      result.amfVersion = this.amfVersion;
    }
    if (this.main) {
      result.main = this.main;
    }
    if (this.mime) {
      result.mime = this.mime;
    }
    if (this.vendor) {
      result.vendor = this.vendor;
    }
    return result;
  }
}
<fim_middle>",correct,2777
183,183,183,183,Workflow,Workflow,6b2e48994d25dfb77d9f951487af828409217c22,"<fim_prefix>/* Types */

type Tx<T> = () => Promise<T>;
type Cx = () => Promise<unknown>;

export class ReadOnly<T> {
  constructor(public tx) {}
}

export class Mutating<T> {
  constructor(public tx, public cx) {}
}

export class Pivot<T> {
  constructor(public tx) {}
}

type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;

export type Workflow = Generator<Step<any>, void, any>;

/* Constructors */

export const readOnly = <T>(tx) => new ReadOnly<T>(tx);

export const mutating = <T>(tx, cx) =>
  new Mutating<T>(tx, cx);

export const pivot = <T>(tx) => new Pivot<T>(tx);

/* Workflow executor */

export async function run(workflow: <fim_suffix>) {
  // a list of compensating functions
  let cxs: Cx[] = [];
  // a number of pivot operations happened during the workflow
  let nPivots: number = 0;
  // should the workflow be unrolled
  let unrollReason: unknown;

  let next: IteratorResult<Step<unknown>>;
  let res: unknown;

  try {
    next = workflow.next();
  } catch (e) {
    unrollReason = e;
  }

  while (!unrollReason && !next!.done) {
    const flow = next!.value;

    try {
      // execute async operation
      res = await flow.tx();
    } catch (e1) {
      // async exception caught
      try {
        // try rethrowing into workflow -- this acquires a next workflow step;
        // compensating operation is not added, because the atomic forward
        // operation didn't succeed, so nothing to compensate
        next = workflow.throw(e1);
        continue;
      } catch (e2) {
        // rethrowing didn't succeed, unroll
        unrollReason = e2;
        break;
      }
    }

    // async operation succeeds, register its aftereffects
    if (flow instanceof Mutating) {
      cxs.push(flow.cx);
    } else if (flow instanceof Pivot) {
      nPivots++;
    }

    // try acquiring next workflow step
    try {
      next = workflow.next(res);
      continue;
    } catch (e) {
      // caught a sync exception that is not caught inside workflow, unroll
      unrollReason = e;
      break;
    }
  }

  // unroll if error happened
  if (unrollReason) {
    // workflow is not revertible if there were completed pivot operations
    if (nPivots) {
      throw unrollReason;
    }

    for (const cx of cxs.reverse()) {
      // compensating function error means the state is unknown
      // this can only be handled by a caller, so no try-catch
      await cx();
    }
    throw unrollReason;
  }
}
<fim_middle>",correct,3730
184,184,184,184,any,any,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON(): <fim_suffix> {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,70
185,185,185,185,any,any,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params: <fim_suffix> = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,71
186,186,186,186,any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional: <fim_suffix>) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,81
187,187,187,187,any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val): <fim_suffix> {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,92
188,188,188,188,any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val): <fim_suffix> {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,98
189,189,189,189,any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val: <fim_suffix>) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,99
190,190,190,190,bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration(): <fim_suffix> {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,615
191,191,191,191,bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd(): <fim_suffix> {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration() {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,616
192,192,192,192,bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart(): <fim_suffix> {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration() {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,617
193,193,193,193,bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?: <fim_suffix>) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration() {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,618
194,194,194,194,boolean,boolean,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit: <fim_suffix>
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,6
195,195,195,195,boolean,boolean,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit: <fim_suffix>
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,10
196,196,196,196,boolean,boolean,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit: <fim_suffix>) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,18
197,197,197,197,boolean,boolean,5015731de39d782d56f8a1e23bb6486643ab39bb,"<fim_prefix>interface IRowGenerateData {
	
	emailNotification: boolean | null;
	boxName: string;
	boxSensor: string;
	boxExposure: string;
	thresholdValue: string | number;
	date: Date;
	actions: string;
}




export function GetData(rowscount?, last?, hasNullValues?: <fim_suffix>) {
	const data: IRowGenerateData[] = new Array();

	if (rowscount === undefined) {
		rowscount = 100;
	}

	let startIndex = 0;

	if (last) {
		startIndex = rowscount;
		rowscount = last - rowscount;
	}

	const boxNames =
		[
			'PGKN FS02 - Rumphorst', 'BalkonBox Mindener Str.', 'BalkonBox Mindener Str.', 'Hoersterstr. 17', 'SteffenDroste', 'OC-WETTER', 'Fühlerbüchse', 'PGKN FS01 - Schule', 'KiTa Glühwürmchen', 'Westfälisches Pferdemuseum Münster', 'Hawerkamp 31', 'Martin', 'Botanischer Garten', 'Noise Sensor', 'CYBER Box', 'fancyBox3000', 'wullewup', 'Deipen4_A'
		];

	const boxSensors =
		[
			'Temperatur', 'rel. Luftfeuchte', 'Luftdruck', 'Beleuchtungsstärke', 'UV-Intensität', 'PM10', 'PM2.5'
		];

	const exposure =
		[
			'outdoor', 'indoor'
		];

	const actions =
		[
			'more than', 'less than'
		];

	const thresholdValues =
		[
			'2.25', '1.5', '3.0', '3.3', '4.5', '3.6', '3.8', '2.5', '5.0', '1.75', '3.25', '4.0'
		];

	for (let i = 0; i < rowscount; i++) {
		const row = {} as IRowGenerateData;

		const exposureindex = Math.floor(Math.random() * 2);
		const actionindex = Math.floor(Math.random() * actions.length);
		const thresholdValue = parseFloat(thresholdValues[exposureindex]);
		
		
		row.emailNotification = exposureindex % 2 === 0;

		if (hasNullValues === true) {
			if (exposureindex % 2 !== 0) {
				const random = Math.floor(Math.random() * rowscount);
				row.emailNotification = i % random === 0 ? null : false;
			}
		}

		row.boxName = boxNames[Math.floor(Math.random() * boxNames.length)];
		row.boxSensor = boxSensors[Math.floor(Math.random() * boxSensors.length)];
		row.boxExposure = exposure[exposureindex];
		row.actions = actions[actionindex];
		row.thresholdValue = thresholdValue;
		
		const date = new Date();
		date.setFullYear(2016, Math.floor(Math.random() * 11), Math.floor(Math.random() * 27));
		date.setHours(0, 0, 0, 0);
		row.date = date;

		data[i] = row;
	}

	return data;
}<fim_middle>",correct,41
198,198,198,198,boolean,boolean,357ad94655b55a5de65645b359f819f4f0054ef6,"<fim_prefix>
export const MAGIC_METHOD_REG = /^@magic\:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
export const MAGIC_METHOD = ""@magic:"";
export const SPLITTER = ""|"";
export const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
export const FUNC_START_CHARACTER = ""("";
export const FUNC_END_CHARACTER = "")"";

export interface PipeParam {
    type: string;
    value?: string;
    args?: string[];
    func?: string;    
}

export interface PipeObject {
    [key: string]: PipeParam[];
}

export interface MagicMethodResult {
    originalMethod: string;
    method: string;
    args: string[];
    pipes: PipeParam[];
    keys: PipeObject;
}

export default class MagicMethod {

    static make (str, ...args) {
        return `${MAGIC_METHOD}${str} ${args.join(SPLITTER)}`;
    }

    static check(str): <fim_suffix> {
        return str.match(MAGIC_METHOD_REG) !== null;
    }

    static parse (str)  {
        const matches = str.match(MAGIC_METHOD_REG);
    
        if (!matches) {
            return undefined;
        }    


        const result = matches[0].split(""@magic:"")[1].split(SPLITTER).map(item => item.trim());

        let [ initializer, ...pipes ] = result;
        const [ method, ...args ] = initializer.split("" "");

        const pipeList = pipes.map(it => {
            return this.parsePipe(it);
        }).filter(it => it.value);

        const pipeObjects: PipeObject = {
            'function': [],
            'keyword': [],
            'value': []
        };
        
        pipeList.forEach(pipe => {
            if (pipe.type === ""function"") {
                pipeObjects.function.push(pipe);
            } else if (pipe.type === ""keyword"") {
                pipeObjects.keyword.push(pipe);
            } else {
                pipeObjects.value.push(pipe);
            }
        });

        return {
            originalMethod: str,
            method,
            args,
            pipes: pipeList,
            keys: pipeObjects
        };
    }

    static parsePipe(it) {
        const result = it.match(FUNC_REGEXP);

        if (!result) {
            return {
                type: ""value"",
                value: it
            };
        }

        const [value] = result;

        if (value.includes(FUNC_START_CHARACTER)) {

            const [func, rest] = value.split(FUNC_START_CHARACTER)
            const [args] = rest.split(FUNC_END_CHARACTER);        
            return {
                type: ""function"",
                value,
                func,
                args: args.split("","").map(it => it.trim()).filter(Boolean)
            }
        } 

        return {
            type: ""keyword"",
            value: result[0]
        }
    }
}<fim_middle>",correct,54
199,199,199,199,boolean,boolean,1d39ec473347edb072e37f629ad2a9736fad5a7a,"<fim_prefix>export const Kind = 'Core#ResponseAuthorization';

export interface IResponseAuthorization {
  kind: typeof Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method: string;
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;
}

export class ResponseAuthorization {
  kind = Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method = 'unknown';
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;

  /**
   * @param input The response authorization definition used to restore the state.
   */
  constructor(input?) {
    let init: IResponseAuthorization;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        method: 'unknown',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new response authorization clearing anything that is so far defined.
   * 
   * Note, this throws an error when the object is not a response authorization.
   */
  new(init) {
    if (!ResponseAuthorization.isResponseAuthorization(init)) {
      throw new Error(`Not a response authorization.`);
    }
    const { method, state, headers, challengeHeader } = init;
    this.kind = Kind;
    this.method = method;
    this.state = state;
    this.headers = headers;
    this.challengeHeader = challengeHeader;
  }

  /**
   * Checks whether the input is a definition of a response authorization.
   */
  static isResponseAuthorization(input): <fim_suffix> {
    const typed = input as IResponseAuthorization;
    if (!input || !typed.method) {
      return false;
    }
    return true;
  }

  toJSON() {
    const result: IResponseAuthorization = {
      kind: Kind,
      method: this.method,
    };
    if (typeof this.state === 'number') {
      result.state = this.state;
    }
    if (this.headers) {
      result.headers = this.headers;
    }
    if (this.challengeHeader) {
      result.challengeHeader = this.challengeHeader;
    }
    return result;
  }
}
<fim_middle>",correct,75
200,200,200,200,never,never,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1107
201,201,201,201,never,never,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2438
202,202,202,202,never,never,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3092
203,203,203,203,never,never,6c5d24a5d99d75f367877e7cca717ee288b6d93d,"<fim_prefix>// To parse this data:
//
//   import { Convert, Intoto } from ""./file"";
//
//   const intoto = Convert.toIntoto(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for intoto object
 */
export interface Intoto {
    content: Content;
    /**
     * The public key that can verify the signature
     */
    publicKey: string;
}

export interface Content {
    /**
     * envelope
     */
    envelope?: string;
    /**
     * Specifies the hash algorithm and value encompassing the entire signed envelope
     */
    hash?: Hash;
    /**
     * Specifies the hash algorithm and value covering the payload within the DSSE envelope
     */
    payloadHash?: PayloadHash;
}

/**
 * Specifies the hash algorithm and value encompassing the entire signed envelope
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the archive
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Specifies the hash algorithm and value covering the payload within the DSSE envelope
 */
export interface PayloadHash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the envelope's payload
     */
    value: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toIntoto(json) {
        return cast(JSON.parse(json), r(""Intoto""));
    }

    public static intotoToJson(value) {
        return JSON.stringify(uncast(value, r(""Intoto"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Intoto"": o([
        { json: ""content"", js: ""content"", typ: r(""Content"") },
        { json: ""publicKey"", js: ""publicKey"", typ: """" },
    ], ""any""),
    ""Content"": o([
        { json: ""envelope"", js: ""envelope"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
        { json: ""payloadHash"", js: ""payloadHash"", typ: u(undefined, r(""PayloadHash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""PayloadHash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3537
204,204,204,204,never,never,86981395b1f95d3beda99682c5bde85ff62ff1af,"<fim_prefix>// To parse this data:
//
//   import { Convert, Rfc3161 } from ""./file"";
//
//   const rfc3161 = Convert.toRfc3161(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for RFC3161 entries
 */
export interface Rfc3161 {
    /**
     * Information about the tsr file associated with the entry
     */
    tsr: TSR;
}

/**
 * Information about the tsr file associated with the entry
 */
export interface TSR {
    /**
     * Specifies the tsr file content inline within the document
     */
    content: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toRfc3161(json) {
        return cast(JSON.parse(json), r(""Rfc3161""));
    }

    public static rfc3161ToJson(value) {
        return JSON.stringify(uncast(value, r(""Rfc3161"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Rfc3161"": o([
        { json: ""tsr"", js: ""tsr"", typ: r(""TSR"") },
    ], ""any""),
    ""TSR"": o([
        { json: ""content"", js: ""content"", typ: """" },
    ], ""any""),
};
<fim_middle>",correct,3616
205,205,205,205,never,never,c345024143db0e7f2d60174bc07a582029bfedc5,"<fim_prefix>// To parse this data:
//
//   import { Convert, Rekord } from ""./file"";
//
//   const rekord = Convert.toRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Rekord object
 */
export interface Rekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the content inline within the document
     */
    content?: string;
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content: string;
    /**
     * Specifies the format of the signature
     */
    format: Format;
    /**
     * The public key that can verify the signature
     */
    publicKey: PublicKey;
}

/**
 * Specifies the format of the signature
 */
export enum Format {
    Minisign = ""minisign"",
    PGP = ""pgp"",
    SSH = ""ssh"",
    X509 = ""x509"",
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toRekord(json) {
        return cast(JSON.parse(json), r(""Rekord""));
    }

    public static rekordToJson(value) {
        return JSON.stringify(uncast(value, r(""Rekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Rekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: """" },
        { json: ""format"", js: ""format"", typ: r(""Format"") },
        { json: ""publicKey"", js: ""publicKey"", typ: r(""PublicKey"") },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
    ""Format"": [
        ""minisign"",
        ""pgp"",
        ""ssh"",
        ""x509"",
    ],
};
<fim_middle>",correct,3704
206,206,206,206,number,number,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day: <fim_suffix>) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,0
207,207,207,207,number,number,d136cbb659cd7f40984bcec5a5dcf88567bffb4d,"<fim_prefix>export type BookTitle = string;

const booksToChaptersMap: { [name: string]: number } = {
  Genesis: 50,
  Exodus: 40,
  Leviticus: 27,
  Numbers: 36,
  Deuteronomy: 34,
  Joshua: 24,
  Judges: 21,
  Ruth: 4,
  '1 Samuel': 31,
  '2 Samuel': 24,
  '1 Kings': 22,
  '2 Kings': 25,
  '1 Chronicles': 29,
  '2 Chronicles': 36,
  Ezra: 10,
  Nehemiah: 13,
  Esther: 10,
  Job: 42,
  Psalms: 150,
  Proverbs: 31,
  Ecclesiastes: 12,
  'Song of Solomon': 8,
  Isaiah: 66,
  Jeremiah: 52,
  Lamentations: 5,
  Ezekial: 48,
  Daniel: 12,
  Hosea: 14,
  Joel: 3,
  Amos: 9,
  Obadiah: 1,
  Jonah: 4,
  Micah: 7,
  Nahum: 3,
  Habakkuk: 3,
  Zephaniah: 3,
  Haggai: 2,
  Zechariah: 14,
  Malachi: 4,
  Matthew: 28,
  Mark: 16,
  Luke: 24,
  John: 21,
  Acts: 28,
  Romans: 16,
  '1 Corinthians': 16,
  '2 Corinthians': 13,
  Galatians: 6,
  Ephesians: 6,
  Philippians: 4,
  Colossians: 4,
  '1 Thessalonians': 5,
  '2 Thessalonians': 3,
  '1 Timothy': 6,
  '2 Timothy': 4,
  Titus: 3,
  Philemon: 1,
  Hebrews: 13,
  James: 5,
  '1 Peter': 5,
  '2 Peter': 3,
  '1 John': 5,
  '2 John': 1,
  '3 John': 1,
  Jude: 1,
  Revelation: 22,
};

const possibleTitles: string[] = Array.from(Object.keys(booksToChaptersMap));

let i = 0;
export const hebrewScriptures: BookInfo[] = possibleTitles
  .slice(0, 39)
  .map((x) => {
    i++;
    return { id: i, title: x, chapters: booksToChaptersMap[x] };
  });

export const newTestament: BookInfo[] = possibleTitles.slice(39).map((x) => {
  i++;
  return { id: i, title: x, chapters: booksToChaptersMap[x] };
});

export const getBookTitleFromSlug = (
  bookTitle,
) => {
  if (typeof bookTitle !== 'string') {
    throw new Error(`Booktitle ${bookTitle} is not even string`);
  }

  const found = possibleTitles.find(
    (x) => bookTitle === x.replace(' ', '-').toLowerCase(),
  );

  if (found === undefined) {
    throw new Error('There is not such book title:${bookParam}');
  }

  return found;
};

export const getChapterFromSlug = (
  chapter,
  book,
): <fim_suffix> => {
  if (isNaN(Number(chapter))) {
    throw new Error(`Chapter ""${chapter}"" is not a number`);
  }
  if (!Number.isInteger(Number(chapter))) {
    throw new Error(`Chapter ""${chapter}"" is not integer`);
  }
  if (Number(chapter) > booksToChaptersMap[book]) {
    throw new Error(`Chapter ""${chapter}"" is too hight`);
  }
  if (Number(chapter) < 1) {
    throw new Error(`Chapter ""${chapter}"" is too low`);
  }
  return Number(chapter);
};

export interface BookInfo {
  id: number;
  title: string;
  chapters: number;
}
<fim_middle>",correct,34
208,208,208,208,number,number,5015731de39d782d56f8a1e23bb6486643ab39bb,"<fim_prefix>interface IRowGenerateData {
	
	emailNotification: boolean | null;
	boxName: string;
	boxSensor: string;
	boxExposure: string;
	thresholdValue: string | number;
	date: Date;
	actions: string;
}




export function GetData(rowscount?, last?: <fim_suffix>, hasNullValues?) {
	const data: IRowGenerateData[] = new Array();

	if (rowscount === undefined) {
		rowscount = 100;
	}

	let startIndex = 0;

	if (last) {
		startIndex = rowscount;
		rowscount = last - rowscount;
	}

	const boxNames =
		[
			'PGKN FS02 - Rumphorst', 'BalkonBox Mindener Str.', 'BalkonBox Mindener Str.', 'Hoersterstr. 17', 'SteffenDroste', 'OC-WETTER', 'Fühlerbüchse', 'PGKN FS01 - Schule', 'KiTa Glühwürmchen', 'Westfälisches Pferdemuseum Münster', 'Hawerkamp 31', 'Martin', 'Botanischer Garten', 'Noise Sensor', 'CYBER Box', 'fancyBox3000', 'wullewup', 'Deipen4_A'
		];

	const boxSensors =
		[
			'Temperatur', 'rel. Luftfeuchte', 'Luftdruck', 'Beleuchtungsstärke', 'UV-Intensität', 'PM10', 'PM2.5'
		];

	const exposure =
		[
			'outdoor', 'indoor'
		];

	const actions =
		[
			'more than', 'less than'
		];

	const thresholdValues =
		[
			'2.25', '1.5', '3.0', '3.3', '4.5', '3.6', '3.8', '2.5', '5.0', '1.75', '3.25', '4.0'
		];

	for (let i = 0; i < rowscount; i++) {
		const row = {} as IRowGenerateData;

		const exposureindex = Math.floor(Math.random() * 2);
		const actionindex = Math.floor(Math.random() * actions.length);
		const thresholdValue = parseFloat(thresholdValues[exposureindex]);
		
		
		row.emailNotification = exposureindex % 2 === 0;

		if (hasNullValues === true) {
			if (exposureindex % 2 !== 0) {
				const random = Math.floor(Math.random() * rowscount);
				row.emailNotification = i % random === 0 ? null : false;
			}
		}

		row.boxName = boxNames[Math.floor(Math.random() * boxNames.length)];
		row.boxSensor = boxSensors[Math.floor(Math.random() * boxSensors.length)];
		row.boxExposure = exposure[exposureindex];
		row.actions = actions[actionindex];
		row.thresholdValue = thresholdValue;
		
		const date = new Date();
		date.setFullYear(2016, Math.floor(Math.random() * 11), Math.floor(Math.random() * 27));
		date.setHours(0, 0, 0, 0);
		row.date = date;

		data[i] = row;
	}

	return data;
}<fim_middle>",correct,42
209,209,209,209,number,number,5015731de39d782d56f8a1e23bb6486643ab39bb,"<fim_prefix>interface IRowGenerateData {
	
	emailNotification: boolean | null;
	boxName: string;
	boxSensor: string;
	boxExposure: string;
	thresholdValue: string | number;
	date: Date;
	actions: string;
}




export function GetData(rowscount?: <fim_suffix>, last?, hasNullValues?) {
	const data: IRowGenerateData[] = new Array();

	if (rowscount === undefined) {
		rowscount = 100;
	}

	let startIndex = 0;

	if (last) {
		startIndex = rowscount;
		rowscount = last - rowscount;
	}

	const boxNames =
		[
			'PGKN FS02 - Rumphorst', 'BalkonBox Mindener Str.', 'BalkonBox Mindener Str.', 'Hoersterstr. 17', 'SteffenDroste', 'OC-WETTER', 'Fühlerbüchse', 'PGKN FS01 - Schule', 'KiTa Glühwürmchen', 'Westfälisches Pferdemuseum Münster', 'Hawerkamp 31', 'Martin', 'Botanischer Garten', 'Noise Sensor', 'CYBER Box', 'fancyBox3000', 'wullewup', 'Deipen4_A'
		];

	const boxSensors =
		[
			'Temperatur', 'rel. Luftfeuchte', 'Luftdruck', 'Beleuchtungsstärke', 'UV-Intensität', 'PM10', 'PM2.5'
		];

	const exposure =
		[
			'outdoor', 'indoor'
		];

	const actions =
		[
			'more than', 'less than'
		];

	const thresholdValues =
		[
			'2.25', '1.5', '3.0', '3.3', '4.5', '3.6', '3.8', '2.5', '5.0', '1.75', '3.25', '4.0'
		];

	for (let i = 0; i < rowscount; i++) {
		const row = {} as IRowGenerateData;

		const exposureindex = Math.floor(Math.random() * 2);
		const actionindex = Math.floor(Math.random() * actions.length);
		const thresholdValue = parseFloat(thresholdValues[exposureindex]);
		
		
		row.emailNotification = exposureindex % 2 === 0;

		if (hasNullValues === true) {
			if (exposureindex % 2 !== 0) {
				const random = Math.floor(Math.random() * rowscount);
				row.emailNotification = i % random === 0 ? null : false;
			}
		}

		row.boxName = boxNames[Math.floor(Math.random() * boxNames.length)];
		row.boxSensor = boxSensors[Math.floor(Math.random() * boxSensors.length)];
		row.boxExposure = exposure[exposureindex];
		row.actions = actions[actionindex];
		row.thresholdValue = thresholdValue;
		
		const date = new Date();
		date.setFullYear(2016, Math.floor(Math.random() * 11), Math.floor(Math.random() * 27));
		date.setHours(0, 0, 0, 0);
		row.date = date;

		data[i] = row;
	}

	return data;
}<fim_middle>",correct,43
210,210,210,210,number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n: <fim_suffix>) {
  return new Num(n)
}
<fim_middle>",correct,135
211,211,211,211,number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?: <fim_suffix>) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,140
212,212,212,212,offsets,offsets,bf991cf13e41beda6a1e948184ea7f39b759886d,"<fim_prefix>interface offsets {
  vertical: number
  horizontal: number
}
export function measureOffsets (
  text,
  fontFamily,
  fontSize,
  createCanvas
): <fim_suffix> {
  const canvas = createCanvas()
  const ctx = canvas.getContext('2d')
  ctx.font = `${fontSize}px ${fontFamily}`

  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize
  ctx.font = `${fontSize}px ${fontFamily}`
  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize

  ctx.font = `${fontSize}px ${fontFamily}`
  ctx.textBaseline = 'alphabetic'
  ctx.textAlign = 'center'
  ctx.fillStyle = 'white'
  ctx.fillText(text, canvas.width / 2, canvas.height / 2)

  const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data

  let textTop = 0
  let textBottom = 0
  for (let y = 0; y <= canvas.height; y++) {
    for (let x = 0; x <= canvas.width; x++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]
      if (rValue === 255) {
        if (textTop === 0) {
          textTop = y
        }
        textBottom = y
        break
      }
    }
  }
  const canvasHorizontalCenterLine = canvas.height / 2
  const textHorizontalCenterLine = (textBottom - textTop) / 2 + textTop

  let textLeft = 0
  let textRight = 0
  for (let x = 0; x <= canvas.width; x++) {
    for (let y = 0; y <= canvas.height; y++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]

      if (rValue === 255) {
        if (textLeft === 0) {
          textLeft = x
        }
        textRight = x
        break
      }
    }
  }

  const canvasVerticalCenterLine = canvas.width / 2
  const textVerticalCenterLine = (textRight - textLeft) / 2 + textLeft

  return {
    vertical: canvasHorizontalCenterLine - textHorizontalCenterLine,
    horizontal: canvasVerticalCenterLine - textVerticalCenterLine
  }
}
<fim_middle>",correct,4433
213,213,213,213,string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name: <fim_suffix>) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,22
214,214,214,214,string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name: <fim_suffix>) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,23
215,215,215,215,string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name: <fim_suffix>,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,28
216,216,216,216,string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name: <fim_suffix>) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,30
217,217,217,217,string,string,5e419a4136fb3538201beb1ba127f65816d4e1af,"<fim_prefix>/**
 * This is the sightseeings dataset for CHINADLE.
 *
 * https://github.com/z0gSh1u/chinadle
 */

// prettier-ignore
type ChinaProvinceOrCity =
  | '北京市'  | '广东省'
  | '山东省'  | '江苏省'
  | '河南省'  | '上海市'
  | '河北省'  | '浙江省'
  | '香港特别行政区'
  | '陕西省'  | '湖南省'
  | '重庆市'  | '福建省'
  | '天津市'  | '云南省'
  | '四川省'  | '广西壮族自治区'
  | '安徽省'  | '海南省'
  | '江西省'  | '湖北省'
  | '山西省'  | '辽宁省'
  | '黑龙江'  | '内蒙古自治区'
  | '澳门特别行政区'
  | '贵州省'  | '甘肃省'
  | '青海省'  | '新疆维吾尔自治区'
  | '西藏自治区'  | '吉林省'
  | '宁夏回族自治区'
  | '台湾'

export interface Sight {
  name: string
  coord: {
    lon: number
    lat: number
  }
  belong: ChinaProvinceOrCity
  brief: string
}

function makeSight(
  name,
  coord,
  belong,
  brief: <fim_suffix>
) {
  const _coord = coord.split(',').map(parseFloat)
  return {
    name,
    coord: {
      lon: _coord[0],
      lat: _coord[1],
    },
    belong,
    brief,
  } as Sight
}

export const ChinaSights: Sight[] = [
  makeSight(
    '泰山',
    '117.094738,36.269893',
    '山东省',
    '“直通帝座”的天堂，百姓崇拜，帝王告祭的神山。'
  ),

  makeSight(
    '黄山',
    '118.168089,30.13039',
    '安徽省',
    '被联合国教科文组织公布为世界地质公园。'
  ),

  makeSight(
    '长白山',
    '128.083986,42.066898',
    '吉林省',
    '中国满族的发祥地和满族文化圣山。'
  ),

  makeSight(
    '日月潭',
    '120.911881,23.854467',
    '台湾',
    '北半湖形状如圆日，南半湖形状如弯月。'
  ),

  makeSight(
    '故宫',
    '116.403414,39.924091',
    '北京市',
    '明清两代的皇家宫殿，旧称紫禁城。'
  ),

  makeSight(
    '黄鹤楼',
    '114.309043,30.550317',
    '湖北省',
    '因唐代诗人崔颢登楼所题《黄鹤楼》一诗而名扬四海。'
  ),

  makeSight(
    '黄果树瀑布',
    '105.679142,25.985778',
    '贵州省',
    '世界上最大的瀑布群'
  ),

  makeSight('秦始皇兵马俑', '109.2851,34.389417', '陕西省', '世界第八大奇迹'),

  makeSight(
    '武夷山',
    '117.963042,27.668108',
    '福建省',
    '典型的丹霞地貌，《世界遗产名录》'
  ),

  makeSight(
    '九寨沟',
    '103.921224,33.163223',
    '四川省',
    '中国第一个以保护自然风景为主要目的的自然保护区'
  ),

  makeSight(
    '布达拉宫',
    '91.125038,29.660346',
    '西藏自治区',
    '吐蕃王朝赞普松赞干布为迎娶文成公主而兴建。'
  ),

  makeSight(
    '东方明珠',
    '121.506379,31.245414',
    '上海市',
    '集都市观光、时尚餐饮、购物娱乐、历史陈列、浦江游览、会展演出、广播电视发射等多功能于一体的上海市标志性建筑之一。'
  ),

  makeSight(
    '井冈山',
    '114.143789,26.636167',
    '江西省',
    '开创了中国第一个农村革命根据地。'
  ),

  makeSight(
    '滕王阁',
    '115.887675,28.687376',
    '江西省',
    '滕王高阁临江渚，佩玉鸣鸾罢歌舞。阁中帝子今何在？槛外长江空自流。'
  ),

  makeSight(
    '天坛',
    '116.417246,39.888243',
    '北京市',
    '天坛公园在明、清两代是帝王祭祀皇天、祈五谷丰登之场所。'
  ),

  makeSight(
    '张家界',
    '110.441345,29.321096',
    '湖南省',
    '中国第一个国家森林公园。'
  ),

  makeSight(
    '鼓浪屿',
    '118.073467,24.450968',
    '福建省',
    '国家5A级旅游景区、全国重点文物保护单位。'
  ),
  
  makeSight(
    '丽江古城',
    '100.242047,26.876464',
    '云南省',
    '街道依山傍水修建，以红色角砾岩铺就。'
  ),

  makeSight(
    '天山天池',
    '88.135728,43.8873826',
    '新疆维吾尔自治区',
    '联合国教科文组织世界遗产名录。'
  ),

  makeSight(
    '中山陵',
    '118.861453,32.059739',
    '江苏省',
    '中国近代伟大的民主革命先行者孙中山先生的陵寝及其附属纪念建筑群。'
  ),
]
<fim_middle>",correct,44
218,218,218,218,string,string,5e419a4136fb3538201beb1ba127f65816d4e1af,"<fim_prefix>/**
 * This is the sightseeings dataset for CHINADLE.
 *
 * https://github.com/z0gSh1u/chinadle
 */

// prettier-ignore
type ChinaProvinceOrCity =
  | '北京市'  | '广东省'
  | '山东省'  | '江苏省'
  | '河南省'  | '上海市'
  | '河北省'  | '浙江省'
  | '香港特别行政区'
  | '陕西省'  | '湖南省'
  | '重庆市'  | '福建省'
  | '天津市'  | '云南省'
  | '四川省'  | '广西壮族自治区'
  | '安徽省'  | '海南省'
  | '江西省'  | '湖北省'
  | '山西省'  | '辽宁省'
  | '黑龙江'  | '内蒙古自治区'
  | '澳门特别行政区'
  | '贵州省'  | '甘肃省'
  | '青海省'  | '新疆维吾尔自治区'
  | '西藏自治区'  | '吉林省'
  | '宁夏回族自治区'
  | '台湾'

export interface Sight {
  name: string
  coord: {
    lon: number
    lat: number
  }
  belong: ChinaProvinceOrCity
  brief: string
}

function makeSight(
  name,
  coord: <fim_suffix>,
  belong,
  brief
) {
  const _coord = coord.split(',').map(parseFloat)
  return {
    name,
    coord: {
      lon: _coord[0],
      lat: _coord[1],
    },
    belong,
    brief,
  } as Sight
}

export const ChinaSights: Sight[] = [
  makeSight(
    '泰山',
    '117.094738,36.269893',
    '山东省',
    '“直通帝座”的天堂，百姓崇拜，帝王告祭的神山。'
  ),

  makeSight(
    '黄山',
    '118.168089,30.13039',
    '安徽省',
    '被联合国教科文组织公布为世界地质公园。'
  ),

  makeSight(
    '长白山',
    '128.083986,42.066898',
    '吉林省',
    '中国满族的发祥地和满族文化圣山。'
  ),

  makeSight(
    '日月潭',
    '120.911881,23.854467',
    '台湾',
    '北半湖形状如圆日，南半湖形状如弯月。'
  ),

  makeSight(
    '故宫',
    '116.403414,39.924091',
    '北京市',
    '明清两代的皇家宫殿，旧称紫禁城。'
  ),

  makeSight(
    '黄鹤楼',
    '114.309043,30.550317',
    '湖北省',
    '因唐代诗人崔颢登楼所题《黄鹤楼》一诗而名扬四海。'
  ),

  makeSight(
    '黄果树瀑布',
    '105.679142,25.985778',
    '贵州省',
    '世界上最大的瀑布群'
  ),

  makeSight('秦始皇兵马俑', '109.2851,34.389417', '陕西省', '世界第八大奇迹'),

  makeSight(
    '武夷山',
    '117.963042,27.668108',
    '福建省',
    '典型的丹霞地貌，《世界遗产名录》'
  ),

  makeSight(
    '九寨沟',
    '103.921224,33.163223',
    '四川省',
    '中国第一个以保护自然风景为主要目的的自然保护区'
  ),

  makeSight(
    '布达拉宫',
    '91.125038,29.660346',
    '西藏自治区',
    '吐蕃王朝赞普松赞干布为迎娶文成公主而兴建。'
  ),

  makeSight(
    '东方明珠',
    '121.506379,31.245414',
    '上海市',
    '集都市观光、时尚餐饮、购物娱乐、历史陈列、浦江游览、会展演出、广播电视发射等多功能于一体的上海市标志性建筑之一。'
  ),

  makeSight(
    '井冈山',
    '114.143789,26.636167',
    '江西省',
    '开创了中国第一个农村革命根据地。'
  ),

  makeSight(
    '滕王阁',
    '115.887675,28.687376',
    '江西省',
    '滕王高阁临江渚，佩玉鸣鸾罢歌舞。阁中帝子今何在？槛外长江空自流。'
  ),

  makeSight(
    '天坛',
    '116.417246,39.888243',
    '北京市',
    '天坛公园在明、清两代是帝王祭祀皇天、祈五谷丰登之场所。'
  ),

  makeSight(
    '张家界',
    '110.441345,29.321096',
    '湖南省',
    '中国第一个国家森林公园。'
  ),

  makeSight(
    '鼓浪屿',
    '118.073467,24.450968',
    '福建省',
    '国家5A级旅游景区、全国重点文物保护单位。'
  ),
  
  makeSight(
    '丽江古城',
    '100.242047,26.876464',
    '云南省',
    '街道依山傍水修建，以红色角砾岩铺就。'
  ),

  makeSight(
    '天山天池',
    '88.135728,43.8873826',
    '新疆维吾尔自治区',
    '联合国教科文组织世界遗产名录。'
  ),

  makeSight(
    '中山陵',
    '118.861453,32.059739',
    '江苏省',
    '中国近代伟大的民主革命先行者孙中山先生的陵寝及其附属纪念建筑群。'
  ),
]
<fim_middle>",correct,46
219,219,219,219,unknown,unknown,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name
) => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value: <fim_suffix>) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,205
220,220,220,220,unknown,unknown,8dd4eba467cc4f8c283713bdfc23d3b71e87f31d,"<fim_prefix>export type BasePostMessageCallbackProps<T> = {
  onMessage?: (message) => void
  onInvalidMessageError?: (message, error) => void
}

// This is an internal error. Thrown when we are decoding a post message's
// metadata and we encourntered a missing field or an invalid value. This
// likely means there has been a change to the definition of a post message
// that we do not know about.
export class PostMessageFieldDecodeError extends Error {
  public messageType: string
  public field: string
  public expectedType: TypeDef
  public gotValue: unknown

  constructor(messageType, field, expectedType, gotValue: <fim_suffix>) {
    super(`Unable to decode '${field}' from '${messageType}'`)

    this.messageType = messageType
    this.field = field
    this.expectedType = expectedType
    this.gotValue = gotValue

    Object.setPrototypeOf(this, PostMessageFieldDecodeError.prototype)
  }
}

// This is an internal error. Thrown when we get a post message we don't konw
// about. This likely means there is a new post message that this package needs
// to define.
export class PostMessageUnknownTypeError extends Error {
  public postMessageType: string

  constructor(postMessageType) {
    super(`Unknown post message: ${postMessageType}`)

    this.postMessageType = postMessageType

    Object.setPrototypeOf(this, PostMessageUnknownTypeError.prototype)
  }
}

export type MessageEventData = {
  mx?: boolean
  metadata?: Metadata
  type?: string
}

export type Value = string | number
export type NestedValue = Record<string, Value>
export type TypeDef = string | Array<string> | Record<string, string>
export type Metadata = Record<string, Value | NestedValue>

export function assertMessageProp(
  container,
  postMessageType,
  field,
  expectedType,
) {
  const value = container[field]

  const valueIsDefined = typeof value !== ""undefined""
  const valueIsString = typeof value === ""string""
  const valueIsNumber = typeof value === ""number""
  const valueIsObject = typeof value === ""object"" && !Array.isArray(value)

  const typeIsString = expectedType === ""string""
  const typeIsNumber = expectedType === ""number""
  const typeIsArray = expectedType instanceof Array
  const typeIsObject = typeof expectedType === ""object"" && !Array.isArray(expectedType)

  if (!valueIsDefined) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsString && !valueIsString) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsNumber && !valueIsNumber) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsArray && !(valueIsString && expectedType.includes(value))) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && !valueIsObject) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && valueIsObject) {
    Object.keys(expectedType).forEach((field) => {
      assertMessageProp(value, postMessageType, field, expectedType[field])
    })
  }
}
<fim_middle>",correct,2990
221,221,221,221,unknown,unknown,b898174dc9208306ba4726075f110ac026c56fe6,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// This file contains generic TypeScript types, and predicate methods
type VoidReturn = void | undefined;

export type VoidCallback<Args extends unknown[] = []> = Args extends []
	? ((arg?) => VoidReturn)
	: ((...args) => VoidReturn);

export type DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};

export type AsyncVoidCallback<Args extends unknown[] = []> = AsyncCallback<
	VoidReturn,
	Args
>;

export type AsyncCallback<Return, Args extends unknown[] = []> = Args extends []
	? (() => Return | Promise<Return>)
	: ((...args) => Return | Promise<Return>);

export type ErrorCallback<Err extends Error = Error> = (err) => void;

export type MapKey<T> = T extends Map<infer K, unknown> ? K : never;

export type MapValue<T> = T extends Map<unknown, infer V> ? V : never;

export type SetValue<T> = T extends Set<infer V> ? V : never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export type UnionToIntersection<U> = (U extends any ? (k) => void : never) extends ((
	k,
) => void)
	? I
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
type ClassConstructorParams<T> = T extends {
	new (
		...args
	): any;
}
	? R
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export interface Class<T, Args extends any[] = ClassConstructorParams<T>> {
	new (
		...args
	): T;
	prototype: T;
}

export type Dict<T> = Record<string, T>;

export type RequiredProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]-?: NonNullable<Obj[Key]>
};

export type OptionalProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]?: Obj[Key]
};

export type TaggedTemplateFunction<Ret, Sub> = (
	strs,
	...substitutions
) => Ret;

// Turn a type that contains interfaces into regular objects
export type InterfaceToObject<T> = T extends {}
	? {[K in keyof T]: InterfaceToObject<T[K]>}
	: T;

export type UnknownObject = Dict<unknown>;

export type UnknownFunction = (...args) => unknown;

export function isObject(obj): obj is UnknownObject {
	return typeof obj === ""object"" && obj !== null && !Array.isArray(obj);
}

export function isPlainObject(obj): obj is UnknownObject {
	// Weird duck typing for cross-realm objects
	return (
		isObject(obj) &&
		obj.constructor !== undefined &&
		obj.constructor.name === ""Object""
	);
}

export function isIterable(obj: <fim_suffix>): obj is Iterable<unknown> {
	if (typeof obj === ""object"" && obj != null) {
		// @ts-ignore
		return typeof obj[Symbol.iterator] === ""function"";
	} else {
		return false;
	}
}

// TypeScript has awful behaviour where it treats optional properties and undefined values as the same
// eg. https://www.typescriptlang.org/play/index.html?ssl=3&ssc=1&pln=1&pc=1#code/C4TwDgpgBAChBOBnA9gOygXigbwFBQKgDMBLJYAOQEMBbCALikWHhNQHMBufQgGyubU6jZqw7cAvt1wBjNMyhgq8YCSq84SNIzyEo-QbQgB+ESzbsANLgmYcPAgcpHGAV1QATCKVQQP1qVxZeWBFBBRURk0Iu11CUnIhBigAIgBlCAAjAVUqVBTrPSckxhSKdxAqAocoADp6pRU1DXC0AOkAeg79HKSoEkQody8fPyhM11CAFTSoD2QIRFQAclCEeGR4XEgtVFrio0wMLGHvNj9OIA
// https://github.com/microsoft/TypeScript/issues/13195
// This means that places where we expect to receive a value when object spreading in a partial object
// can actually have undefined values!
export function mergeObjects<A extends object>(
	a,
	b,
) {
	if (b === undefined) {
		return a;
	}

	const newObj: A = {
		...a,
		...b,
	};

	// If b contains undefined properties then use the value from A
	for (const key in b) {
		if (b[key] === undefined) {
			// @ts-ignore
			newObj[key] = a[key];
		}
	}

	return newObj;
}

export function equalArray<A extends unknown[], B extends unknown[]>(
	a,
	b,
): a is B {
	if (a.length !== b.length) {
		return false;
	}

	if (a === b) {
		return true;
	}

	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

// Check if a value is instance of a class, disallowing inheritance
// rome-ignore lint/ts/noExplicitAny: Necessary
export function isSafeInstanceof<ClassType extends new (
	...args
) => any>(inst, Class): inst is InstanceType<ClassType> {
	return inst instanceof Class && inst.constructor === Class;
}
<fim_middle>",correct,3221
222,222,222,222,unknown,unknown,b898174dc9208306ba4726075f110ac026c56fe6,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// This file contains generic TypeScript types, and predicate methods
type VoidReturn = void | undefined;

export type VoidCallback<Args extends unknown[] = []> = Args extends []
	? ((arg?) => VoidReturn)
	: ((...args) => VoidReturn);

export type DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};

export type AsyncVoidCallback<Args extends unknown[] = []> = AsyncCallback<
	VoidReturn,
	Args
>;

export type AsyncCallback<Return, Args extends unknown[] = []> = Args extends []
	? (() => Return | Promise<Return>)
	: ((...args) => Return | Promise<Return>);

export type ErrorCallback<Err extends Error = Error> = (err) => void;

export type MapKey<T> = T extends Map<infer K, unknown> ? K : never;

export type MapValue<T> = T extends Map<unknown, infer V> ? V : never;

export type SetValue<T> = T extends Set<infer V> ? V : never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export type UnionToIntersection<U> = (U extends any ? (k) => void : never) extends ((
	k,
) => void)
	? I
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
type ClassConstructorParams<T> = T extends {
	new (
		...args
	): any;
}
	? R
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export interface Class<T, Args extends any[] = ClassConstructorParams<T>> {
	new (
		...args
	): T;
	prototype: T;
}

export type Dict<T> = Record<string, T>;

export type RequiredProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]-?: NonNullable<Obj[Key]>
};

export type OptionalProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]?: Obj[Key]
};

export type TaggedTemplateFunction<Ret, Sub> = (
	strs,
	...substitutions
) => Ret;

// Turn a type that contains interfaces into regular objects
export type InterfaceToObject<T> = T extends {}
	? {[K in keyof T]: InterfaceToObject<T[K]>}
	: T;

export type UnknownObject = Dict<unknown>;

export type UnknownFunction = (...args) => unknown;

export function isObject(obj): obj is UnknownObject {
	return typeof obj === ""object"" && obj !== null && !Array.isArray(obj);
}

export function isPlainObject(obj: <fim_suffix>): obj is UnknownObject {
	// Weird duck typing for cross-realm objects
	return (
		isObject(obj) &&
		obj.constructor !== undefined &&
		obj.constructor.name === ""Object""
	);
}

export function isIterable(obj): obj is Iterable<unknown> {
	if (typeof obj === ""object"" && obj != null) {
		// @ts-ignore
		return typeof obj[Symbol.iterator] === ""function"";
	} else {
		return false;
	}
}

// TypeScript has awful behaviour where it treats optional properties and undefined values as the same
// eg. https://www.typescriptlang.org/play/index.html?ssl=3&ssc=1&pln=1&pc=1#code/C4TwDgpgBAChBOBnA9gOygXigbwFBQKgDMBLJYAOQEMBbCALikWHhNQHMBufQgGyubU6jZqw7cAvt1wBjNMyhgq8YCSq84SNIzyEo-QbQgB+ESzbsANLgmYcPAgcpHGAV1QATCKVQQP1qVxZeWBFBBRURk0Iu11CUnIhBigAIgBlCAAjAVUqVBTrPSckxhSKdxAqAocoADp6pRU1DXC0AOkAeg79HKSoEkQody8fPyhM11CAFTSoD2QIRFQAclCEeGR4XEgtVFrio0wMLGHvNj9OIA
// https://github.com/microsoft/TypeScript/issues/13195
// This means that places where we expect to receive a value when object spreading in a partial object
// can actually have undefined values!
export function mergeObjects<A extends object>(
	a,
	b,
) {
	if (b === undefined) {
		return a;
	}

	const newObj: A = {
		...a,
		...b,
	};

	// If b contains undefined properties then use the value from A
	for (const key in b) {
		if (b[key] === undefined) {
			// @ts-ignore
			newObj[key] = a[key];
		}
	}

	return newObj;
}

export function equalArray<A extends unknown[], B extends unknown[]>(
	a,
	b,
): a is B {
	if (a.length !== b.length) {
		return false;
	}

	if (a === b) {
		return true;
	}

	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

// Check if a value is instance of a class, disallowing inheritance
// rome-ignore lint/ts/noExplicitAny: Necessary
export function isSafeInstanceof<ClassType extends new (
	...args
) => any>(inst, Class): inst is InstanceType<ClassType> {
	return inst instanceof Class && inst.constructor === Class;
}
<fim_middle>",correct,3222
223,223,223,223,unknown,unknown,9df566c660a96ca1ea9c774ead4166eff4ea2801,"<fim_prefix>export interface AsyncPushCallbacks<T> {
  next: (value) => void;
  done: () => void;
  error: (err: <fim_suffix>) => void;
}

export function createAsyncIterable<T = unknown>(
  listener
) {
  let done = false;
  let error: unknown | null = null;

  const pushQueue: T[] = [];
  const pullQueue: Array<
    [
      (x) => void,
      (err) => void
    ]
  > = [];

  return {
    [Symbol.asyncIterator]() {
      listener({
        next: (value) => {
          if (done || error) return;
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[0]({ value, done: false });
          } else {
            pushQueue.push(value);
          }
        },
        error: (err) => {
          if (done || error) return;
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[1](err);
          }
          error = err;
        },
        done: () => {
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[0]({ value: undefined, done: true });
          }
          done = true;
        },
      });

      return {
        next() {
          return new Promise<{ value: T | undefined; done: boolean }>(
            (resolve, reject) => {
              if (pushQueue.length > 0) {
                resolve({ value: pushQueue.shift(), done: false });
              } else if (done) {
                resolve({ value: undefined, done: true });
              } else if (error) {
                reject(error);
              } else {
                pullQueue.push([resolve, reject]);
              }
            }
          );
        },
      };
    },
  } as AsyncIterable<T>;
}
<fim_middle>",correct,4185
224,224,224,224,unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error: <fim_suffix>) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4414
225,225,225,225,void,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,61
226,226,226,226,void,void,1d39ec473347edb072e37f629ad2a9736fad5a7a,"<fim_prefix>export const Kind = 'Core#ResponseAuthorization';

export interface IResponseAuthorization {
  kind: typeof Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method: string;
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;
}

export class ResponseAuthorization {
  kind = Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method = 'unknown';
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;

  /**
   * @param input The response authorization definition used to restore the state.
   */
  constructor(input?) {
    let init: IResponseAuthorization;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        method: 'unknown',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new response authorization clearing anything that is so far defined.
   * 
   * Note, this throws an error when the object is not a response authorization.
   */
  new(init): <fim_suffix> {
    if (!ResponseAuthorization.isResponseAuthorization(init)) {
      throw new Error(`Not a response authorization.`);
    }
    const { method, state, headers, challengeHeader } = init;
    this.kind = Kind;
    this.method = method;
    this.state = state;
    this.headers = headers;
    this.challengeHeader = challengeHeader;
  }

  /**
   * Checks whether the input is a definition of a response authorization.
   */
  static isResponseAuthorization(input) {
    const typed = input as IResponseAuthorization;
    if (!input || !typed.method) {
      return false;
    }
    return true;
  }

  toJSON() {
    const result: IResponseAuthorization = {
      kind: Kind,
      method: this.method,
    };
    if (typeof this.state === 'number') {
      result.state = this.state;
    }
    if (this.headers) {
      result.headers = this.headers;
    }
    if (this.challengeHeader) {
      result.challengeHeader = this.challengeHeader;
    }
    return result;
  }
}
<fim_middle>",correct,77
227,227,227,227,void,void,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops): <fim_suffix>
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,436
228,228,228,228,void,void,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified): <fim_suffix>
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,476
229,229,229,229,void,void,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors): <fim_suffix> {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,637
230,230,230,230,void,void,4b26b14a08d5cdfff6183540cb79049b3ed5038a,"<fim_prefix>/* eslint-disable no-constant-condition */

const EOF = '~EOF~'

class Parser {
  private pos = 0

  constructor(private input) {}

  next() {
    if (this.pos >= this.input.length) {
      return EOF
    }
    return this.input[this.pos++]
  }

  backup(): <fim_suffix> {
    this.pos--
  }

  parseTemplate() {
    if (this.next() != '/') {
      throw new Error('binding URL should start with a slash')
    }
    
    return {
      segments: this.parseSegments(),
      verb: this.parseVerb(),
    }
  }

  private parseSegments() {
    let segments: Segment[] = []
    segments.push(this.parseSegment())

    while (true) {
      let r = this.next()
      switch (r) {
        case '/':
          segments.push(this.parseSegment())
          continue

        case ':':
        case '}':
          this.backup()
          return segments

        case EOF:
          return segments

        default:
          throw new Error(`unexpected ${r} in segments`)
      }
    }
  }

  private parseSegment() {
    let content = ''
    while (true) {
      let r = this.next()
      switch (r) {
        case EOF:
          if (!content.length) {
            throw new Error(`unexpected EOF in segment`)
          }
          return { content }

        case '{':
          return { content, variable: this.parseVariable() }

        case ':':
        case '/':
        case '}':
          this.backup()
          if (!content.length) {
            throw new Error(`unexpected ${r} in segment`)
          }
          return { content }

        default:
          content += r
      }
    }
  }

  private parseVariable() {
    let v: Variable = {
      name: '',
    }
    while (true) {
      let r = this.next()
      switch (r) {
        case '}':
          if (!v.name.length) {
            throw new Error(`empty variable name`)
          }
          return v

        case '=':
          v.parts = this.parseSegments().map(segment => {
            if (!segment.content.length) {
              throw new Error(`unexpected empty segment`)
            }
            return segment.content
          })
          break

        case EOF:
          throw new Error(`unexpected EOF in variable ${v.name}`)

        default:
          v.name += r
      }
    }
  }

  private parseVerb() {
    let r = this.next()
    switch (r) {
      case ':':
        break

      case EOF:
        return ''

      default:
        throw new Error(`unexpected ${r} in verb`)
    }

    let verb = ''
    while (true) {
      let r = this.next()
      if (r === EOF) {
        if (!verb.length) {
          throw new Error(`empty verb`)
        }
        return verb
      }
      verb += r
    }
  }
}

interface Binding {
  segments: Segment[]
  verb: string
}

interface Segment {
  content: string
  variable?: Variable
}

interface Variable {
  name: string
  parts?: string[]
}

export function buildURL(template, params) {
  let parser = new Parser(template)
  let binding = parser.parseTemplate()

  let parts = binding.segments.map(segment => {
    if (segment.variable) {
      if (!params[segment.variable.name]) {
        throw new Error(`input parameter ${segment.variable.name} is required`)
      }

      return params[segment.variable.name]
    }
    return segment.content
  })
  let verb = binding.verb ? `:${binding.verb}` : ''
  return '/' + parts.join('/') + verb
}
<fim_middle>",correct,929
