generated,solution,hexsha,prompt,correctness,id,original_prog,renamed
Actions,Actions,ebfbabd6e86ee48c24c3828f4ee1b92f6ff39f68,"<fim_prefix>export interface AppSetting {
  shouldSplitMemoWord: boolean;
  shouldHideImageUrl: boolean;
  shouldUseMarkdownParser: boolean;
  useTinyUndoHistoryCache: boolean;
}

export interface State extends AppSetting {
  markMemoId: string;
  editMemoId: string;
  commentMemoId: string;
  isMobileView: boolean;
  showSiderbarInMobileView: boolean;
  changedByMemos: boolean;
}

interface SetMarkMemoIdAction {
  type: 'SET_MARK_MEMO_ID';
  payload: {
    markMemoId: string;
  };
}

interface SetEditMemoIdAction {
  type: 'SET_EDIT_MEMO_ID';
  payload: {
    editMemoId: string;
  };
}

interface SetCommentMemoIdAction {
  type: 'SET_COMMENT_MEMO_ID';
  payload: {
    commentMemoId: string;
  };
}

interface SetMobileViewAction {
  type: 'SET_MOBILE_VIEW';
  payload: {
    isMobileView: boolean;
  };
}

interface SetChangedByMemosAction {
  type: 'SET_CHANGED_BY_MEMOS';
  payload: {
    changedByMemos: boolean;
  };
}

interface SetShowSidebarAction {
  type: 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW';
  payload: {
    showSiderbarInMobileView: boolean;
  };
}

interface SetAppSettingAction {
  type: 'SET_APP_SETTING';
  payload: Partial<AppSetting>;
}

export type Actions =
  | SetMobileViewAction
  | SetShowSidebarAction
  | SetEditMemoIdAction
  | SetCommentMemoIdAction
  | SetMarkMemoIdAction
  | SetChangedByMemosAction
  | SetAppSettingAction;

export function reducer(state, action: <fim_suffix>) {
  switch (action.type) {
    case 'SET_MARK_MEMO_ID': {
      if (action.payload.markMemoId === state.markMemoId) {
        return state;
      }

      return {
        ...state,
        markMemoId: action.payload.markMemoId,
      };
    }
    case 'SET_EDIT_MEMO_ID': {
      if (action.payload.editMemoId === state.editMemoId) {
        return state;
      }

      return {
        ...state,
        editMemoId: action.payload.editMemoId,
      };
    }
    case 'SET_COMMENT_MEMO_ID': {
      if (action.payload.commentMemoId === state.commentMemoId) {
        return state;
      }

      return {
        ...state,
        commentMemoId: action.payload.commentMemoId,
      };
    }
    case 'SET_MOBILE_VIEW': {
      if (action.payload.isMobileView === state.isMobileView) {
        return state;
      }

      return {
        ...state,
        isMobileView: action.payload.isMobileView,
      };
    }
    case 'SET_CHANGED_BY_MEMOS': {
      if (action.payload.changedByMemos === state.changedByMemos) {
        return state;
      }

      return {
        ...state,
        changedByMemos: action.payload.changedByMemos,
      };
    }
    case 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW': {
      if (action.payload.showSiderbarInMobileView === state.showSiderbarInMobileView) {
        return state;
      }

      return {
        ...state,
        showSiderbarInMobileView: action.payload.showSiderbarInMobileView,
      };
    }
    case 'SET_APP_SETTING': {
      return {
        ...state,
        ...action.payload,
      };
    }
    default: {
      return state;
    }
  }
}

export const defaultState: State = {
  markMemoId: '',
  editMemoId: '',
  commentMemoId: '',
  shouldSplitMemoWord: true,
  shouldHideImageUrl: true,
  shouldUseMarkdownParser: true,
  useTinyUndoHistoryCache: false,
  isMobileView: false,
  showSiderbarInMobileView: false,
  changedByMemos: false,
};
<fim_middle>",correct,236,"export interface AppSetting {
  shouldSplitMemoWord: boolean;
  shouldHideImageUrl: boolean;
  shouldUseMarkdownParser: boolean;
  useTinyUndoHistoryCache: boolean;
}

export interface State extends AppSetting {
  markMemoId: string;
  editMemoId: string;
  commentMemoId: string;
  isMobileView: boolean;
  showSiderbarInMobileView: boolean;
  changedByMemos: boolean;
}

interface SetMarkMemoIdAction {
  type: 'SET_MARK_MEMO_ID';
  payload: {
    markMemoId: string;
  };
}

interface SetEditMemoIdAction {
  type: 'SET_EDIT_MEMO_ID';
  payload: {
    editMemoId: string;
  };
}

interface SetCommentMemoIdAction {
  type: 'SET_COMMENT_MEMO_ID';
  payload: {
    commentMemoId: string;
  };
}

interface SetMobileViewAction {
  type: 'SET_MOBILE_VIEW';
  payload: {
    isMobileView: boolean;
  };
}

interface SetChangedByMemosAction {
  type: 'SET_CHANGED_BY_MEMOS';
  payload: {
    changedByMemos: boolean;
  };
}

interface SetShowSidebarAction {
  type: 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW';
  payload: {
    showSiderbarInMobileView: boolean;
  };
}

interface SetAppSettingAction {
  type: 'SET_APP_SETTING';
  payload: Partial<AppSetting>;
}

export type Actions =
  | SetMobileViewAction
  | SetShowSidebarAction
  | SetEditMemoIdAction
  | SetCommentMemoIdAction
  | SetMarkMemoIdAction
  | SetChangedByMemosAction
  | SetAppSettingAction;

export function reducer(state: State, action: Actions) {
  switch (action.type) {
    case 'SET_MARK_MEMO_ID': {
      if (action.payload.markMemoId === state.markMemoId) {
        return state;
      }

      return {
        ...state,
        markMemoId: action.payload.markMemoId,
      };
    }
    case 'SET_EDIT_MEMO_ID': {
      if (action.payload.editMemoId === state.editMemoId) {
        return state;
      }

      return {
        ...state,
        editMemoId: action.payload.editMemoId,
      };
    }
    case 'SET_COMMENT_MEMO_ID': {
      if (action.payload.commentMemoId === state.commentMemoId) {
        return state;
      }

      return {
        ...state,
        commentMemoId: action.payload.commentMemoId,
      };
    }
    case 'SET_MOBILE_VIEW': {
      if (action.payload.isMobileView === state.isMobileView) {
        return state;
      }

      return {
        ...state,
        isMobileView: action.payload.isMobileView,
      };
    }
    case 'SET_CHANGED_BY_MEMOS': {
      if (action.payload.changedByMemos === state.changedByMemos) {
        return state;
      }

      return {
        ...state,
        changedByMemos: action.payload.changedByMemos,
      };
    }
    case 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW': {
      if (action.payload.showSiderbarInMobileView === state.showSiderbarInMobileView) {
        return state;
      }

      return {
        ...state,
        showSiderbarInMobileView: action.payload.showSiderbarInMobileView,
      };
    }
    case 'SET_APP_SETTING': {
      return {
        ...state,
        ...action.payload,
      };
    }
    default: {
      return state;
    }
  }
}

export const defaultState: State = {
  markMemoId: '',
  editMemoId: '',
  commentMemoId: '',
  shouldSplitMemoWord: true,
  shouldHideImageUrl: true,
  shouldUseMarkdownParser: true,
  useTinyUndoHistoryCache: false,
  isMobileView: false,
  showSiderbarInMobileView: false,
  changedByMemos: false,
};
",False
Container,Container,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args): <fim_suffix> {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,994,"export type Constructor<T = any> = { new (...args: any[]): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass: T, ...args: any[]): Container {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className: T, ...args: any[]): Container {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className: Constructor, ...newArgs: any[]): void {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className: Constructor<T>): T {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className: Constructor): void {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className: Constructor): void {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className: Constructor): boolean {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className: Constructor): boolean {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message: string) {
    super();
  }
}
",False
G,G,cc966119a9d0804aa81737f900326caade60f340,"<fim_prefix>interface ErrorOption {
  cause?: Error;
  status?: number;
}

interface Convertable {
  [key: string]: string | number;
}

type ConvertString<T extends Convertable, Group extends string> = {
  [P in keyof T]: P extends string
    ? T[P] extends number
      ? `${Uppercase<Group>}_${T[P]}`
      : never
    : never;
};

const codeGroup = new Set();

/**
 * Register error group and code, return the standard ErrorCode
 * @param errorGroup
 * @param errorCodeMapping
 */
export function registerErrorCode<T extends Convertable, G extends string>(
  errorGroup: <fim_suffix>,
  errorCodeMapping
) {
  if (codeGroup.has(errorGroup)) {
    throw new MidwayError(
      `Error group ${errorGroup} is duplicated, please check before adding.`
    );
  } else {
    codeGroup.add(errorGroup);
  }
  const newCodeEnum = {} as Convertable;
  // ERROR => GROUP_10000
  for (const errKey in errorCodeMapping) {
    newCodeEnum[errKey as string] =
      errorGroup.toUpperCase() +
      '_' +
      String(errorCodeMapping[errKey]).toUpperCase();
  }
  return newCodeEnum as ConvertString<T, G>;
}

export class MidwayError extends Error {
  code: number | string;
  cause: Error;

  constructor(message, options?);
  constructor(message, code, options?);
  constructor(message, code, options?) {
    super(message);
    if (!code || typeof code === 'object') {
      options = code;
      code = 'MIDWAY_10000';
    }
    this.name = this.constructor.name;
    this.code = code;
    this.cause = options?.cause;
  }
}

export type ResOrMessage = string | { message: string };

export class MidwayHttpError extends MidwayError {
  status: number;

  constructor(resOrMessage, status);
  constructor(
    resOrMessage,
    status,
    code,
    options?
  );
  constructor(
    resOrMessage,
    status,
    code?,
    options?
  ) {
    super(
      typeof resOrMessage === 'string' ? resOrMessage : resOrMessage.message,
      code ?? String(status),
      options
    );
    this.status = status;
  }
}
<fim_middle>",correct,2537,"interface ErrorOption {
  cause?: Error;
  status?: number;
}

interface Convertable {
  [key: string]: string | number;
}

type ConvertString<T extends Convertable, Group extends string> = {
  [P in keyof T]: P extends string
    ? T[P] extends number
      ? `${Uppercase<Group>}_${T[P]}`
      : never
    : never;
};

const codeGroup = new Set();

/**
 * Register error group and code, return the standard ErrorCode
 * @param errorGroup
 * @param errorCodeMapping
 */
export function registerErrorCode<T extends Convertable, G extends string>(
  errorGroup: G,
  errorCodeMapping: T
): ConvertString<T, G> {
  if (codeGroup.has(errorGroup)) {
    throw new MidwayError(
      `Error group ${errorGroup} is duplicated, please check before adding.`
    );
  } else {
    codeGroup.add(errorGroup);
  }
  const newCodeEnum = {} as Convertable;
  // ERROR => GROUP_10000
  for (const errKey in errorCodeMapping) {
    newCodeEnum[errKey as string] =
      errorGroup.toUpperCase() +
      '_' +
      String(errorCodeMapping[errKey]).toUpperCase();
  }
  return newCodeEnum as ConvertString<T, G>;
}

export class MidwayError extends Error {
  code: number | string;
  cause: Error;

  constructor(message: string, options?: ErrorOption);
  constructor(message: string, code: string, options?: ErrorOption);
  constructor(message: string, code: any, options?: ErrorOption) {
    super(message);
    if (!code || typeof code === 'object') {
      options = code;
      code = 'MIDWAY_10000';
    }
    this.name = this.constructor.name;
    this.code = code;
    this.cause = options?.cause;
  }
}

export type ResOrMessage = string | { message: string };

export class MidwayHttpError extends MidwayError {
  status: number;

  constructor(resOrMessage: ResOrMessage, status: number);
  constructor(
    resOrMessage: ResOrMessage,
    status: number,
    code: string,
    options?: ErrorOption
  );
  constructor(
    resOrMessage: any,
    status: number,
    code?: string,
    options?: ErrorOption
  ) {
    super(
      typeof resOrMessage === 'string' ? resOrMessage : resOrMessage.message,
      code ?? String(status),
      options
    );
    this.status = status;
  }
}
",False
Options,Options,e8163c19af6d0400d21846442a54c5e20ba9eac3,"<fim_prefix>export enum LongOption {
  NUMBER = 'number',
  LONG = 'long',
  STRING = 'string',
}

export enum DateOption {
  DATE = 'date',
  STRING = 'string',
  TIMESTAMP = 'timestamp',
}

export enum EnvOption {
  NODE = 'node',
  BROWSER = 'browser',
  BOTH = 'both',
}

export enum OneofOption {
  PROPERTIES = 'properties',
  UNIONS = 'unions',
}

export enum ServiceOption {
  GRPC = 'grpc-js',
  GENERIC = 'generic-definitions',
  DEFAULT = 'default',
  NONE = 'none',
}

export type Options = {
  context: boolean;
  snakeToCamel: Array<'json' | 'keys'>;
  forceLong: LongOption;
  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated
  useDate: DateOption;
  oneof: OneofOption;
  esModuleInterop: boolean;
  fileSuffix: string;
  outputEncodeMethods: boolean;
  outputJsonMethods: boolean;
  outputPartialMethods: boolean;
  outputTypeRegistry: boolean;
  stringEnums: boolean;
  constEnums: boolean;
  enumsAsLiterals: boolean;
  outputClientImpl: boolean | 'grpc-web';
  outputServices: ServiceOption;
  addGrpcMetadata: boolean;
  addNestjsRestParameter: boolean;
  returnObservable: boolean;
  lowerCaseServiceMethods: boolean;
  nestJs: boolean;
  env: EnvOption;
  unrecognizedEnum: boolean;
  exportCommonSymbols: boolean;
  outputSchema: boolean;
  // An alias of !output
  onlyTypes: boolean;
  emitImportedFiles: boolean;
  useExactTypes: boolean;
  delimitedMethods: boolean;
};

export function defaultOptions() {
  return {
    context: false,
    snakeToCamel: ['json', 'keys'],
    forceLong: LongOption.NUMBER,
    useOptionals: 'none',
    useDate: DateOption.DATE,
    oneof: OneofOption.PROPERTIES,
    esModuleInterop: false,
    fileSuffix: '',
    lowerCaseServiceMethods: false,
    outputEncodeMethods: true,
    outputJsonMethods: true,
    outputPartialMethods: true,
    outputTypeRegistry: false,
    stringEnums: false,
    constEnums: false,
    enumsAsLiterals: false,
    outputClientImpl: true,
    outputServices: ServiceOption.DEFAULT,
    returnObservable: false,
    addGrpcMetadata: false,
    addNestjsRestParameter: false,
    nestJs: false,
    env: EnvOption.BOTH,
    unrecognizedEnum: true,
    exportCommonSymbols: true,
    outputSchema: false,
    onlyTypes: false,
    emitImportedFiles: true,
    useExactTypes: true,
    delimitedMethods: false,
  };
}

const nestJsOptions: Partial<Options> = {
  lowerCaseServiceMethods: true,
  outputEncodeMethods: false,
  outputJsonMethods: false,
  outputPartialMethods: false,
  outputClientImpl: false,
  useDate: DateOption.TIMESTAMP,
};

export function optionsFromParameter(parameter): <fim_suffix> {
  const options = defaultOptions();
  if (parameter) {
    const parsed = parseParameter(parameter);
    if (parsed.nestJs) {
      Object.assign(options, nestJsOptions);
    }
    Object.assign(options, parsed);
  }
  // We should promote onlyTypes to its own documented flag, but just an alias for now
  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {
    options.onlyTypes = true;
  }

  // Treat forceLong=true as LONG
  if ((options.forceLong as any) === true) {
    options.forceLong = LongOption.LONG;
  }

  // Treat outputServices=false as NONE
  if ((options.outputServices as any) === false) {
    options.outputServices = ServiceOption.NONE;
  }

  if ((options.useDate as any) === true) {
    // Treat useDate=true as DATE
    options.useDate = DateOption.DATE;
  } else if ((options.useDate as any) === false) {
    // Treat useDate=false as TIMESTAMP
    options.useDate = DateOption.TIMESTAMP;
  }

  if ((options.snakeToCamel as any) === false) {
    options.snakeToCamel = [];
  } else if ((options.snakeToCamel as any) === true) {
    options.snakeToCamel = ['keys', 'json'];
  }

  return options;
}

// A very naive parse function, eventually could/should use iots/runtypes
function parseParameter(parameter) {
  const options = {} as any;
  const pairs = parameter.split(',').map((s) => s.split('='));
  pairs.forEach(([key, value]) => {
    options[key] = value === 'true' ? true : value === 'false' ? false : value;
  });
  return options;
}

export function getTsPoetOpts(options) {
  if (options.esModuleInterop) {
    return { forceDefaultImport: ['protobufjs/minimal'] };
  } else {
    return {};
  }
}
<fim_middle>",correct,3851,"export enum LongOption {
  NUMBER = 'number',
  LONG = 'long',
  STRING = 'string',
}

export enum DateOption {
  DATE = 'date',
  STRING = 'string',
  TIMESTAMP = 'timestamp',
}

export enum EnvOption {
  NODE = 'node',
  BROWSER = 'browser',
  BOTH = 'both',
}

export enum OneofOption {
  PROPERTIES = 'properties',
  UNIONS = 'unions',
}

export enum ServiceOption {
  GRPC = 'grpc-js',
  GENERIC = 'generic-definitions',
  DEFAULT = 'default',
  NONE = 'none',
}

export type Options = {
  context: boolean;
  snakeToCamel: Array<'json' | 'keys'>;
  forceLong: LongOption;
  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated
  useDate: DateOption;
  oneof: OneofOption;
  esModuleInterop: boolean;
  fileSuffix: string;
  outputEncodeMethods: boolean;
  outputJsonMethods: boolean;
  outputPartialMethods: boolean;
  outputTypeRegistry: boolean;
  stringEnums: boolean;
  constEnums: boolean;
  enumsAsLiterals: boolean;
  outputClientImpl: boolean | 'grpc-web';
  outputServices: ServiceOption;
  addGrpcMetadata: boolean;
  addNestjsRestParameter: boolean;
  returnObservable: boolean;
  lowerCaseServiceMethods: boolean;
  nestJs: boolean;
  env: EnvOption;
  unrecognizedEnum: boolean;
  exportCommonSymbols: boolean;
  outputSchema: boolean;
  // An alias of !output
  onlyTypes: boolean;
  emitImportedFiles: boolean;
  useExactTypes: boolean;
  delimitedMethods: boolean;
};

export function defaultOptions(): Options {
  return {
    context: false,
    snakeToCamel: ['json', 'keys'],
    forceLong: LongOption.NUMBER,
    useOptionals: 'none',
    useDate: DateOption.DATE,
    oneof: OneofOption.PROPERTIES,
    esModuleInterop: false,
    fileSuffix: '',
    lowerCaseServiceMethods: false,
    outputEncodeMethods: true,
    outputJsonMethods: true,
    outputPartialMethods: true,
    outputTypeRegistry: false,
    stringEnums: false,
    constEnums: false,
    enumsAsLiterals: false,
    outputClientImpl: true,
    outputServices: ServiceOption.DEFAULT,
    returnObservable: false,
    addGrpcMetadata: false,
    addNestjsRestParameter: false,
    nestJs: false,
    env: EnvOption.BOTH,
    unrecognizedEnum: true,
    exportCommonSymbols: true,
    outputSchema: false,
    onlyTypes: false,
    emitImportedFiles: true,
    useExactTypes: true,
    delimitedMethods: false,
  };
}

const nestJsOptions: Partial<Options> = {
  lowerCaseServiceMethods: true,
  outputEncodeMethods: false,
  outputJsonMethods: false,
  outputPartialMethods: false,
  outputClientImpl: false,
  useDate: DateOption.TIMESTAMP,
};

export function optionsFromParameter(parameter: string | undefined): Options {
  const options = defaultOptions();
  if (parameter) {
    const parsed = parseParameter(parameter);
    if (parsed.nestJs) {
      Object.assign(options, nestJsOptions);
    }
    Object.assign(options, parsed);
  }
  // We should promote onlyTypes to its own documented flag, but just an alias for now
  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {
    options.onlyTypes = true;
  }

  // Treat forceLong=true as LONG
  if ((options.forceLong as any) === true) {
    options.forceLong = LongOption.LONG;
  }

  // Treat outputServices=false as NONE
  if ((options.outputServices as any) === false) {
    options.outputServices = ServiceOption.NONE;
  }

  if ((options.useDate as any) === true) {
    // Treat useDate=true as DATE
    options.useDate = DateOption.DATE;
  } else if ((options.useDate as any) === false) {
    // Treat useDate=false as TIMESTAMP
    options.useDate = DateOption.TIMESTAMP;
  }

  if ((options.snakeToCamel as any) === false) {
    options.snakeToCamel = [];
  } else if ((options.snakeToCamel as any) === true) {
    options.snakeToCamel = ['keys', 'json'];
  }

  return options;
}

// A very naive parse function, eventually could/should use iots/runtypes
function parseParameter(parameter: string): Options {
  const options = {} as any;
  const pairs = parameter.split(',').map((s) => s.split('='));
  pairs.forEach(([key, value]) => {
    options[key] = value === 'true' ? true : value === 'false' ? false : value;
  });
  return options;
}

export function getTsPoetOpts(options: Options): { forceDefaultImport?: string[] } {
  if (options.esModuleInterop) {
    return { forceDefaultImport: ['protobufjs/minimal'] };
  } else {
    return {};
  }
}
",False
Point,Point,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2: <fim_suffix>, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3651,"const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1: number,
	y1: number,
	x2: number,
	y2: number,
	x3: number,
	y3: number
): Triangle => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle: Triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle: Triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
): Point => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1: Point, point2: Point, percent: number) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1: number, x2: number, percent: number) =>
	x1 + (x2 - x1) * percent

const average = (
	x1: number,
	x2: number,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle: Triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
",False
RegExp,RegExp,d7180447147db133f246707f18b8bdb014643e7a,"<fim_prefix>// Get balanced parentheses
// Ported from: https://github.com/juliangruber/balanced-match/blob/master/index.js

export interface Output {
	/**
	 * The index of the first match of a
	 */
	start: number;
	/**
	 * The index of the matching b
	 */
	end: number;
	/**
	 * The preamble, a and b not included
	 */
	pre: string;
	/**
	 * The match, a and b not included
	 */
	body: string;
	/**
	 * The postscript, a and b not included
	 */
	post: string;
}

function maybeMatch(reg: <fim_suffix>, str) {
	const m = str.match(reg);
	return m ? m[0] : null;
}

/**
 * For the first non-nested matching pair of a and b in str, return an object with those keys:
 * start the index of the first match of
 * `end` the index of the matching b
 * `pre` the preamble, a and b not included
 * `body` the match, a and b not included
 * `post` the postscript, a and b not included
 * If there's no match, `undefined` will be returned.
 * If the `str` contains more a than b / there are unmatched pairs,
 * the first match that was closed will be used.
 * For example, `{{a}` will match `['{', 'a', '']` and `{a}}` will match `['', 'a', '}']`
 */
export function balanced(
	a,
	b,
	str,
) {
	if (a instanceof RegExp) a = maybeMatch(a, str)!;
	if (b instanceof RegExp) b = maybeMatch(b, str)!;

	const r = range(a, b, str);

	return (
		r && {
			start: r[0] ?? 0,
			end: r[1] ?? 0,
			pre: str.slice(0, r[0]),
			body: str.slice(r[0]! + (a as string).length, r[1]),
			post: str.slice(r[1]! + (b as string).length),
		}
	);
}

/**
 * For the first non-nested matching pair of `a` and `b` in `str`,
 * return an array with indexes: `[ <a index>, <b index> ]`.
 */
export function range(a, b, str) {
	let begs, beg, left, right, result;
	let ai = str.indexOf(a);
	let bi = str.indexOf(b, ai + 1);
	let i = ai;

	if (ai >= 0 && bi > 0) {
		if (a === b) {
			return [ai, bi];
		}
		begs = [];
		left = str.length;

		while (i >= 0 && !result) {
			if (i === ai) {
				begs.push(i);
				ai = str.indexOf(a, i + 1);
			} else if (begs.length === 1) {
				result = [begs.pop(), bi];
			} else {
				beg = begs.pop();
				if (beg! < left!) {
					left = beg;
					right = bi;
				}

				bi = str.indexOf(b, i + 1);
			}

			i = ai < bi && ai >= 0 ? ai : bi;
		}

		if (begs.length) {
			result = [left, right];
		}
	}

	return result;
}

// Ported from: https://github.com/mugendi/balanced-match-all/blob/master/index.js
export function balancedAll(
	pre,
	post,
	str,
	includeInside = false,
	includeOutside = true,
	level = 0,
	arr = [],
) {
	const o = balanced(pre, post, str);

	if (o) {
		arr.push(o);
		const idx = arr.length - 1;

		if (idx > 0) {
			o.start += arr[idx - 1].start + pre.length;
			o.end += arr[idx - 1].start + post.length;
		}

		// loop till all are called
		if (includeInside) {
			arr = balancedAll(
				pre,
				post,
				o.body,
				includeInside,
				includeOutside,
				level++,
				arr,
			);
		}
		if (includeOutside && arr[idx].end < (str.length - 1)) {
			arr = balancedAll(
				pre,
				post,
				str.slice(arr[idx].end - 1),
				includeInside,
				true,
				0,
				arr,
			);
		}
	}

	return arr;
}
<fim_middle>",correct,1143,"// Get balanced parentheses
// Ported from: https://github.com/juliangruber/balanced-match/blob/master/index.js

export interface Output {
	/**
	 * The index of the first match of a
	 */
	start: number;
	/**
	 * The index of the matching b
	 */
	end: number;
	/**
	 * The preamble, a and b not included
	 */
	pre: string;
	/**
	 * The match, a and b not included
	 */
	body: string;
	/**
	 * The postscript, a and b not included
	 */
	post: string;
}

function maybeMatch(reg: RegExp, str: string): string | null {
	const m = str.match(reg);
	return m ? m[0] : null;
}

/**
 * For the first non-nested matching pair of a and b in str, return an object with those keys:
 * start the index of the first match of
 * `end` the index of the matching b
 * `pre` the preamble, a and b not included
 * `body` the match, a and b not included
 * `post` the postscript, a and b not included
 * If there's no match, `undefined` will be returned.
 * If the `str` contains more a than b / there are unmatched pairs,
 * the first match that was closed will be used.
 * For example, `{{a}` will match `['{', 'a', '']` and `{a}}` will match `['', 'a', '}']`
 */
export function balanced(
	a: string | RegExp,
	b: string | RegExp,
	str: string,
): Output | void {
	if (a instanceof RegExp) a = maybeMatch(a, str)!;
	if (b instanceof RegExp) b = maybeMatch(b, str)!;

	const r = range(a, b, str);

	return (
		r && {
			start: r[0] ?? 0,
			end: r[1] ?? 0,
			pre: str.slice(0, r[0]),
			body: str.slice(r[0]! + (a as string).length, r[1]),
			post: str.slice(r[1]! + (b as string).length),
		}
	);
}

/**
 * For the first non-nested matching pair of `a` and `b` in `str`,
 * return an array with indexes: `[ <a index>, <b index> ]`.
 */
export function range(a: string, b: string, str: string) {
	let begs, beg, left, right, result;
	let ai = str.indexOf(a);
	let bi = str.indexOf(b, ai + 1);
	let i = ai;

	if (ai >= 0 && bi > 0) {
		if (a === b) {
			return [ai, bi];
		}
		begs = [];
		left = str.length;

		while (i >= 0 && !result) {
			if (i === ai) {
				begs.push(i);
				ai = str.indexOf(a, i + 1);
			} else if (begs.length === 1) {
				result = [begs.pop(), bi];
			} else {
				beg = begs.pop();
				if (beg! < left!) {
					left = beg;
					right = bi;
				}

				bi = str.indexOf(b, i + 1);
			}

			i = ai < bi && ai >= 0 ? ai : bi;
		}

		if (begs.length) {
			result = [left, right];
		}
	}

	return result;
}

// Ported from: https://github.com/mugendi/balanced-match-all/blob/master/index.js
export function balancedAll(
	pre: string,
	post: string,
	str: string,
	includeInside = false,
	includeOutside = true,
	level = 0,
	arr: Output[] = [],
) {
	const o = balanced(pre, post, str);

	if (o) {
		arr.push(o);
		const idx = arr.length - 1;

		if (idx > 0) {
			o.start += arr[idx - 1].start + pre.length;
			o.end += arr[idx - 1].start + post.length;
		}

		// loop till all are called
		if (includeInside) {
			arr = balancedAll(
				pre,
				post,
				o.body,
				includeInside,
				includeOutside,
				level++,
				arr,
			);
		}
		if (includeOutside && arr[idx].end < (str.length - 1)) {
			arr = balancedAll(
				pre,
				post,
				str.slice(arr[idx].end - 1),
				includeInside,
				true,
				0,
				arr,
			);
		}
	}

	return arr;
}
",False
RegExp,RegExp,54795a90e2bd17f0016b0a39e21d9821b144d333,"<fim_prefix>/// <reference no-default-lib=""true""/>
/// <reference lib=""es6"" />

(function () {
  type primitiveObject = boolean | number | string;
  type primitive = primitiveObject | null | undefined;
  type ObjectCoercible = primitiveObject | {
      toString ();
    } | {
      valueOf ();
    };
  type anyNotSymbol = ObjectCoercible | null | undefined;
  interface StandardString {
    endsWith? (this, searchString, pos?);
    endsWith? (this, searchString?, pos?);
    includes? (this, searchString, pos?);
    includes? (this, searchString?, pos?);
    startsWith? (this, searchString, pos?);
    startsWith? (this, searchString?, pos?);
  }

  const symMatch = typeof Symbol === ""function"" && typeof Symbol.match === ""symbol"" &&
                    (Symbol.match as symbol | string as ""Symbol(Symbol.match)""),
  // eslint-disable-next-line id-denylist
  StrCls = String as StringConstructor & { readonly prototype: StandardString }, TECls = TypeError,
  StrProto = StrCls.prototype,
  toStr = Object.prototype.toString;

  """".startsWith || (
  StrProto.startsWith = function startsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""startsWith""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    return a.lastIndexOf(b, c) === c;
  });

  """".endsWith || (
  StrProto.endsWith = function endsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""endsWith""));
    }
    let b = StrCls(searchString), args = arguments, u: undefined, c: number
      , p: primitive | object = args.length > 1 ? args[1] : u, l = a.length;
    c = (p === u ? l : (c = +<number | string> p) > 0 ? c | 0 : 0) - b.length;
    c > l && (c = l);
    return c >= 0 && a.indexOf(b, c) === c;
  });

  """".includes || (
  StrProto.includes = function includes(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""includes""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    // eslint-disable-next-line @typescript-eslint/prefer-includes
    return a.indexOf(b, c) >= 0;
  });

  function check(a, b) {
    /** note: should never call `valueOf` or `toString` on a / b */
    if (a == null) { return ""String.prototype.${func} called on null or undefined""; }
    if (!b) { return 0; }
    let t: 0 | 1 | 2 = typeof a === ""symbol"" ? 1 : typeof b === ""symbol"" ? 2 : 0;
    if (t) { return t; }
    interface PossibleTypeOfB {
      [key: string]: ((this, re: <fim_suffix>) => boolean) | primitive;
    }
    let f: PossibleTypeOfB[string], u: undefined
      , i = symMatch && (f = (b as PossibleTypeOfB)[symMatch]) !== u ? f
          : toStr.call(b) === ""[object RegExp]"";
    return i ? ""First argument to String.prototype.${func} must not be a regular expression"" : 0;
  }
})();
<fim_middle>",correct,4571,"/// <reference no-default-lib=""true""/>
/// <reference lib=""es6"" />

(function (): void {
  type primitiveObject = boolean | number | string;
  type primitive = primitiveObject | null | undefined;
  type ObjectCoercible = primitiveObject | {
      toString (): primitive;
    } | {
      valueOf (): primitive;
    };
  type anyNotSymbol = ObjectCoercible | null | undefined;
  interface StandardString {
    endsWith? (this: string, searchString: string, pos?: number | undefined): boolean;
    endsWith? (this: ObjectCoercible, searchString?: anyNotSymbol, pos?: anyNotSymbol): boolean;
    includes? (this: string, searchString: string, pos?: number | undefined): boolean;
    includes? (this: ObjectCoercible, searchString?: anyNotSymbol, pos?: anyNotSymbol): boolean;
    startsWith? (this: string, searchString: string, pos?: number | undefined): boolean;
    startsWith? (this: ObjectCoercible, searchString?: anyNotSymbol, pos?: anyNotSymbol): boolean;
  }

  const symMatch = typeof Symbol === ""function"" && typeof Symbol.match === ""symbol"" &&
                    (Symbol.match as symbol | string as ""Symbol(Symbol.match)""),
  // eslint-disable-next-line id-denylist
  StrCls = String as StringConstructor & { readonly prototype: StandardString }, TECls = TypeError,
  StrProto = StrCls.prototype,
  toStr = Object.prototype.toString;

  """".startsWith || (
  StrProto.startsWith = function startsWith(this: ObjectCoercible, searchString: anyNotSymbol): boolean {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""startsWith""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    return a.lastIndexOf(b, c) === c;
  });

  """".endsWith || (
  StrProto.endsWith = function endsWith(this: ObjectCoercible, searchString: anyNotSymbol): boolean {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""endsWith""));
    }
    let b = StrCls(searchString), args = arguments, u: undefined, c: number
      , p: primitive | object = args.length > 1 ? args[1] : u, l = a.length;
    c = (p === u ? l : (c = +<number | string> p) > 0 ? c | 0 : 0) - b.length;
    c > l && (c = l);
    return c >= 0 && a.indexOf(b, c) === c;
  });

  """".includes || (
  StrProto.includes = function includes(this: ObjectCoercible, searchString: anyNotSymbol): boolean {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""includes""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    // eslint-disable-next-line @typescript-eslint/prefer-includes
    return a.indexOf(b, c) >= 0;
  });

  function check(a: primitive | object, b: primitive | object): 0 | string | 1 | 2 {
    /** note: should never call `valueOf` or `toString` on a / b */
    if (a == null) { return ""String.prototype.${func} called on null or undefined""; }
    if (!b) { return 0; }
    let t: 0 | 1 | 2 = typeof a === ""symbol"" ? 1 : typeof b === ""symbol"" ? 2 : 0;
    if (t) { return t; }
    interface PossibleTypeOfB {
      [key: string]: ((this: string, re: RegExp) => boolean) | primitive;
    }
    let f: PossibleTypeOfB[string], u: undefined
      , i = symMatch && (f = (b as PossibleTypeOfB)[symMatch]) !== u ? f
          : toStr.call(b) === ""[object RegExp]"";
    return i ? ""First argument to String.prototype.${func} must not be a regular expression"" : 0;
  }
})();
",False
Schema,Schema,181ec44034d7ff44d9293788b657b1a2036d874b,"<fim_prefix>type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema: <fim_suffix>) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance) {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance, schema, location) {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance) {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
<fim_middle>",correct,235,"type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema: Schema) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance: any): ValidationResult {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance: any, schema: Schema, location: string): ValidationResult {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance: any): InstanceType {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
",False
U,U,a3c87e22c30072055cfbcdaba851bef6a0244dc3,"<fim_prefix>// /**
//  * DTOs must extends this class
//  */
export class DTOMapper {
  dtoMapperProfile () {
    return undefined;
  };
}

/**
 * DTO Mapper Option Type
 * @param T - Type of class
 */
export interface IDtoMapperOption<T> {
  mapToClass?: IDtoMapperToClass<T>;
  mapToPath?: IDtoMapperToPath;
}

// Mapping to class type
export interface IDtoMapperToClass<T> {
  mapFromKey: string;
  dtoClass: new () => T;
}
// mapping to path type
export interface IDtoMapperToPath {
  mapFromKey: string;
  valueFromPath: string;
}

/**
 * 
 * Map source object to destination class
 * 
 * @param {T} source - Source object to map from
 * @param {U} destination - Destination class to map to
 * @returns {U} An object of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);
/**
 * 
 * Map source object to destination class
 * 
 * @param {T[]} source  - Source array of objects to map from
 * @param {U} destination - Destination class to which map each object from the source
 * @returns {U[]} An array of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);

export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
) {
  if ( Array.isArray( source ) ) {
    return source.map( s => {
      return mapper( s, new destination() );
    } );
  }
  return mapper( source, new destination() );
}

// Mapper to map source to destination
function mapper<T, U extends DTOMapper> ( source, destination: <fim_suffix> ) {
  Object.keys( destination ).forEach( key => {
    destination[ key as keyof U ] = <any>source[ key as keyof T ];
    if ( destination.dtoMapperProfile()?.length ) {
      destination.dtoMapperProfile()?.forEach( option => {
        // To class mapping (recursively)
        if ( option.mapToClass?.mapFromKey === key ) {
          if ( source[ key as keyof T ] ) {
            if ( Array.isArray( source[ key as keyof T ] ) ) {
              const result = Array.from( source[ key as keyof T ] as any ).map( el => {
                return mapper( el, new option.mapToClass!.dtoClass() );
              } );
              destination[ key as keyof U ] = result as any;
            } else {
              const result = mapper( source[ key as keyof T ], new option.mapToClass.dtoClass() );
              destination[ key as keyof U ] = result as any;
            }
          }
          // To value mapping
        } else if ( option.mapToPath?.mapFromKey === key ) {
          let sourceVal: any;
          if ( Array.isArray( option.mapToPath.valueFromPath.split( '.' ) ) ) {
            const paths = option.mapToPath.valueFromPath.split( '.' );
            paths.forEach( p => {
              if ( !sourceVal ) {
                sourceVal = source[ p as keyof T ];
              } else {
                sourceVal = sourceVal[ p ];
              }
            } );
          } else {
            sourceVal = <any>source[ option.mapToPath.valueFromPath as keyof T ];
          }

          destination[ key as keyof U ] = sourceVal;
        }
      } );
    }
  } );
  return destination;
}<fim_middle>",correct,2929,"// /**
//  * DTOs must extends this class
//  */
export class DTOMapper {
  dtoMapperProfile (): IDtoMapperOption<any>[] | undefined {
    return undefined;
  };
}

/**
 * DTO Mapper Option Type
 * @param T - Type of class
 */
export interface IDtoMapperOption<T> {
  mapToClass?: IDtoMapperToClass<T>;
  mapToPath?: IDtoMapperToPath;
}

// Mapping to class type
export interface IDtoMapperToClass<T> {
  mapFromKey: string;
  dtoClass: new () => T;
}
// mapping to path type
export interface IDtoMapperToPath {
  mapFromKey: string;
  valueFromPath: string;
}

/**
 * 
 * Map source object to destination class
 * 
 * @param {T} source - Source object to map from
 * @param {U} destination - Destination class to map to
 * @returns {U} An object of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source: T extends Array<any> ? never : T,
  destination: new () => U
): U;
/**
 * 
 * Map source object to destination class
 * 
 * @param {T[]} source  - Source array of objects to map from
 * @param {U} destination - Destination class to which map each object from the source
 * @returns {U[]} An array of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source: T[],
  destination: new () => U
): U[];

export function dtoMapper<T, U extends DTOMapper> (
  source: T | T[],
  destination: new () => U
): U | U[] {
  if ( Array.isArray( source ) ) {
    return source.map( s => {
      return mapper( s, new destination() );
    } );
  }
  return mapper( source, new destination() );
}

// Mapper to map source to destination
function mapper<T, U extends DTOMapper> ( source: T, destination: U ): U {
  Object.keys( destination ).forEach( key => {
    destination[ key as keyof U ] = <any>source[ key as keyof T ];
    if ( destination.dtoMapperProfile()?.length ) {
      destination.dtoMapperProfile()?.forEach( option => {
        // To class mapping (recursively)
        if ( option.mapToClass?.mapFromKey === key ) {
          if ( source[ key as keyof T ] ) {
            if ( Array.isArray( source[ key as keyof T ] ) ) {
              const result = Array.from( source[ key as keyof T ] as any ).map( el => {
                return mapper( el, new option.mapToClass!.dtoClass() );
              } );
              destination[ key as keyof U ] = result as any;
            } else {
              const result = mapper( source[ key as keyof T ], new option.mapToClass.dtoClass() );
              destination[ key as keyof U ] = result as any;
            }
          }
          // To value mapping
        } else if ( option.mapToPath?.mapFromKey === key ) {
          let sourceVal: any;
          if ( Array.isArray( option.mapToPath.valueFromPath.split( '.' ) ) ) {
            const paths = option.mapToPath.valueFromPath.split( '.' );
            paths.forEach( p => {
              if ( !sourceVal ) {
                sourceVal = source[ p as keyof T ];
              } else {
                sourceVal = sourceVal[ p ];
              }
            } );
          } else {
            sourceVal = <any>source[ option.mapToPath.valueFromPath as keyof T ];
          }

          destination[ key as keyof U ] = sourceVal;
        }
      } );
    }
  } );
  return destination;
}",False
any,any,361d89bb4743deb2ef0a6d1cd847cd5a2c9cb7db,"<fim_prefix>export interface WorkerMessage {
  type: string;
  id: number;
}

export function isWorkerMessage(value: <fim_suffix>): value is WorkerMessage {
  return (
    value && typeof value.type === ""string"" && typeof value.id === ""number""
  );
}

export interface StatusRequest extends WorkerMessage {
  type: ""status-req"";
}

export function isStatusRequest(value): value is StatusRequest {
  return isWorkerMessage(value) && value.type === ""status-req"";
}

export interface StatusResponse extends WorkerMessage {
  type: ""status-resp"";
  status: ""stopped"" | ""waiting"" | ""running"" | ""partial"";
  memorySize: number;
  debugging: boolean;
}

export function isStatusResponse(value): value is StatusResponse {
  return (
    value &&
    value.type === ""status-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.status === ""string"" &&
    (value.status === ""stopped"" ||
      value.status === ""waiting"" ||
      value.status === ""running"" ||
      value.status === ""partial"") &&
    typeof value.memorySize === ""number"" &&
    typeof value.debugging === ""boolean""
  );
}

export interface ErrorMessage extends WorkerMessage {
  type: ""error"";
  err: string;
}

export function isErrorMessage(value): value is ErrorMessage {
  return value && value.type === ""error"" && typeof value.err === ""string"";
}

export interface OutputMessage extends WorkerMessage {
  type: ""output"";
  content: string;
}

export function isOutputMessage(value): value is OutputMessage {
  return (
    value &&
    value.type === ""output"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface InputMessage extends WorkerMessage {
  type: ""input"";
  content: string;
}

export function isInputMessage(value): value is InputMessage {
  return (
    value &&
    value.type === ""input"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface StartMessage extends WorkerMessage {
  type: ""start"";
}

export function isStartMessage(value): value is StartMessage {
  return isWorkerMessage(value) && value.type === ""start"";
}

export interface MemoryMessage extends WorkerMessage {
  type: ""memory"";
  memory: ArrayBuffer;
}

export interface StartedMessage extends WorkerMessage {
  type: ""started"";
  heap: number;
}

export function isStartedMessage(value): value is StartedMessage {
  return value && value.type === ""started"" && typeof value.heap === ""number"";
}

export function isMemoryMessage(value): value is MemoryMessage {
  return (
    value &&
    value.type === ""memory"" &&
    typeof value.memory === ""object"" &&
    value.memory instanceof ArrayBuffer
  );
}

export interface PrintRequest extends WorkerMessage {
  type: ""print-req"";
  ptr: number;
}

export function isPrintRequest(value): value is PrintRequest {
  return (
    value &&
    value.type === ""print-req"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number""
  );
}

export interface PrintResponse extends WorkerMessage {
  type: ""print-resp"";
  content: string;
}

export function isPrintResponse(value): value is PrintResponse {
  return (
    value &&
    value.type === ""print-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface HeapRequest extends WorkerMessage {
  type: ""heap-req"";
  ptr: number;
}

export function isHeapRequest(value): value is HeapRequest {
  return value && value.type === ""heap-req"" && typeof value.ptr === ""number"";
}

export interface HeapResponse extends WorkerMessage {
  type: ""heap-resp"";
  ptr: number;
  size: number;
  free: number;
  next: number;
  entries: ArrayBuffer;
}

export function isHeapResponse(value): value is HeapResponse {
  return (
    value &&
    value.type === ""heap-resp"" &&
    typeof value.ptr === ""number"" &&
    typeof value.size === ""number"" &&
    typeof value.free === ""number"" &&
    typeof value.next === ""number"" &&
    typeof value.entries === ""object"" &&
    value.entries instanceof ArrayBuffer
  );
}

export interface GcRequest extends WorkerMessage {
  type: ""gc-req"";
  collect: boolean;
}

export function isGcRequest(value): value is GcRequest {
  return (
    value &&
    typeof value.id === ""number"" &&
    value.type === ""gc-req"" &&
    typeof value.collect === ""boolean""
  );
}

export interface GcResponse extends WorkerMessage {
  type: ""gc-resp"";
  output: string;
  isCollecting: boolean;
  collectionCount: number;
  collected: number;
  notCollected: number;
  totalCollected: number;
  totalNotCollected: number;
}

export function isGcResponse(value): value is GcResponse {
  return (
    value &&
    value.type == ""gc-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.output === ""string"" &&
    typeof value.collectionCount === ""number"" &&
    typeof value.collected === ""number"" &&
    typeof value.notCollected === ""number"" &&
    typeof value.totalCollected === ""number"" &&
    typeof value.totalNotCollected === ""number""
  );
}

export interface EnableDebug extends WorkerMessage {
  type: ""enable-debug"";
  enabled: boolean;
}

export function isEnableDebug(value): value is EnableDebug {
  return (
    value &&
    value.type === ""enable-debug"" &&
    typeof value.id === ""number"" &&
    typeof value.enabled === ""boolean""
  );
}

export interface DebugBreak extends WorkerMessage {
  type: ""debug-break"";
  ptr: number;
  env: number;
  expr: string;
}

export function isDebugBreak(value): value is DebugBreak {
  return (
    value &&
    value.type === ""debug-break"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number"" &&
    typeof value.env === ""number"" &&
    typeof value.expr === ""string""
  );
}

export interface DebugStep extends WorkerMessage {
  type: ""debug-step"";
  resultStep: boolean;
}

export function isDebugStep(value): value is DebugStep {
  return (
    value &&
    value.type === ""debug-step"" &&
    typeof value.id === ""number"" &&
    typeof value.resultStep === ""boolean""
  );
}

export interface EnvRequest extends WorkerMessage {
  type: ""env-req"";
  env: number;
}

export function isEnvRequest(value): value is EnvRequest {
  return (
    value &&
    value.type === ""env-req"" &&
    typeof value.id === ""number"" &&
    typeof value.env === ""number""
  );
}

export interface EnvEntry {
  name: string;
  value: string;
}

export function isEnvEntry(value): value is EnvEntry {
  return (
    value && typeof value.name === ""string"" && typeof value.value === ""string""
  );
}

export interface EnvResponse extends WorkerMessage {
  type: ""env-resp"";
  ptr: number;
  next: number;
  entries: EnvEntry[];
}

export function isEnvResponse(value): value is EnvResponse {
  return (
    value &&
    value.type === ""env-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number"" &&
    typeof value.next === ""number"" &&
    Array.isArray(value.entries) &&
    (value.entries as any[]).every(isEnvEntry)
  );
}
<fim_middle>",correct,612,"export interface WorkerMessage {
  type: string;
  id: number;
}

export function isWorkerMessage(value: any): value is WorkerMessage {
  return (
    value && typeof value.type === ""string"" && typeof value.id === ""number""
  );
}

export interface StatusRequest extends WorkerMessage {
  type: ""status-req"";
}

export function isStatusRequest(value: any): value is StatusRequest {
  return isWorkerMessage(value) && value.type === ""status-req"";
}

export interface StatusResponse extends WorkerMessage {
  type: ""status-resp"";
  status: ""stopped"" | ""waiting"" | ""running"" | ""partial"";
  memorySize: number;
  debugging: boolean;
}

export function isStatusResponse(value: any): value is StatusResponse {
  return (
    value &&
    value.type === ""status-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.status === ""string"" &&
    (value.status === ""stopped"" ||
      value.status === ""waiting"" ||
      value.status === ""running"" ||
      value.status === ""partial"") &&
    typeof value.memorySize === ""number"" &&
    typeof value.debugging === ""boolean""
  );
}

export interface ErrorMessage extends WorkerMessage {
  type: ""error"";
  err: string;
}

export function isErrorMessage(value: any): value is ErrorMessage {
  return value && value.type === ""error"" && typeof value.err === ""string"";
}

export interface OutputMessage extends WorkerMessage {
  type: ""output"";
  content: string;
}

export function isOutputMessage(value: any): value is OutputMessage {
  return (
    value &&
    value.type === ""output"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface InputMessage extends WorkerMessage {
  type: ""input"";
  content: string;
}

export function isInputMessage(value: any): value is InputMessage {
  return (
    value &&
    value.type === ""input"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface StartMessage extends WorkerMessage {
  type: ""start"";
}

export function isStartMessage(value: any): value is StartMessage {
  return isWorkerMessage(value) && value.type === ""start"";
}

export interface MemoryMessage extends WorkerMessage {
  type: ""memory"";
  memory: ArrayBuffer;
}

export interface StartedMessage extends WorkerMessage {
  type: ""started"";
  heap: number;
}

export function isStartedMessage(value: any): value is StartedMessage {
  return value && value.type === ""started"" && typeof value.heap === ""number"";
}

export function isMemoryMessage(value: any): value is MemoryMessage {
  return (
    value &&
    value.type === ""memory"" &&
    typeof value.memory === ""object"" &&
    value.memory instanceof ArrayBuffer
  );
}

export interface PrintRequest extends WorkerMessage {
  type: ""print-req"";
  ptr: number;
}

export function isPrintRequest(value: any): value is PrintRequest {
  return (
    value &&
    value.type === ""print-req"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number""
  );
}

export interface PrintResponse extends WorkerMessage {
  type: ""print-resp"";
  content: string;
}

export function isPrintResponse(value: any): value is PrintResponse {
  return (
    value &&
    value.type === ""print-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface HeapRequest extends WorkerMessage {
  type: ""heap-req"";
  ptr: number;
}

export function isHeapRequest(value: any): value is HeapRequest {
  return value && value.type === ""heap-req"" && typeof value.ptr === ""number"";
}

export interface HeapResponse extends WorkerMessage {
  type: ""heap-resp"";
  ptr: number;
  size: number;
  free: number;
  next: number;
  entries: ArrayBuffer;
}

export function isHeapResponse(value: any): value is HeapResponse {
  return (
    value &&
    value.type === ""heap-resp"" &&
    typeof value.ptr === ""number"" &&
    typeof value.size === ""number"" &&
    typeof value.free === ""number"" &&
    typeof value.next === ""number"" &&
    typeof value.entries === ""object"" &&
    value.entries instanceof ArrayBuffer
  );
}

export interface GcRequest extends WorkerMessage {
  type: ""gc-req"";
  collect: boolean;
}

export function isGcRequest(value: any): value is GcRequest {
  return (
    value &&
    typeof value.id === ""number"" &&
    value.type === ""gc-req"" &&
    typeof value.collect === ""boolean""
  );
}

export interface GcResponse extends WorkerMessage {
  type: ""gc-resp"";
  output: string;
  isCollecting: boolean;
  collectionCount: number;
  collected: number;
  notCollected: number;
  totalCollected: number;
  totalNotCollected: number;
}

export function isGcResponse(value: any): value is GcResponse {
  return (
    value &&
    value.type == ""gc-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.output === ""string"" &&
    typeof value.collectionCount === ""number"" &&
    typeof value.collected === ""number"" &&
    typeof value.notCollected === ""number"" &&
    typeof value.totalCollected === ""number"" &&
    typeof value.totalNotCollected === ""number""
  );
}

export interface EnableDebug extends WorkerMessage {
  type: ""enable-debug"";
  enabled: boolean;
}

export function isEnableDebug(value: any): value is EnableDebug {
  return (
    value &&
    value.type === ""enable-debug"" &&
    typeof value.id === ""number"" &&
    typeof value.enabled === ""boolean""
  );
}

export interface DebugBreak extends WorkerMessage {
  type: ""debug-break"";
  ptr: number;
  env: number;
  expr: string;
}

export function isDebugBreak(value: any): value is DebugBreak {
  return (
    value &&
    value.type === ""debug-break"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number"" &&
    typeof value.env === ""number"" &&
    typeof value.expr === ""string""
  );
}

export interface DebugStep extends WorkerMessage {
  type: ""debug-step"";
  resultStep: boolean;
}

export function isDebugStep(value: any): value is DebugStep {
  return (
    value &&
    value.type === ""debug-step"" &&
    typeof value.id === ""number"" &&
    typeof value.resultStep === ""boolean""
  );
}

export interface EnvRequest extends WorkerMessage {
  type: ""env-req"";
  env: number;
}

export function isEnvRequest(value: any): value is EnvRequest {
  return (
    value &&
    value.type === ""env-req"" &&
    typeof value.id === ""number"" &&
    typeof value.env === ""number""
  );
}

export interface EnvEntry {
  name: string;
  value: string;
}

export function isEnvEntry(value: any): value is EnvEntry {
  return (
    value && typeof value.name === ""string"" && typeof value.value === ""string""
  );
}

export interface EnvResponse extends WorkerMessage {
  type: ""env-resp"";
  ptr: number;
  next: number;
  entries: EnvEntry[];
}

export function isEnvResponse(value: any): value is EnvResponse {
  return (
    value &&
    value.type === ""env-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number"" &&
    typeof value.next === ""number"" &&
    Array.isArray(value.entries) &&
    (value.entries as any[]).every(isEnvEntry)
  );
}
",False
any,any,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc: <fim_suffix>) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",correct,832,"interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object: any) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj: Function) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn: Function, klass: Function, ...rest: any[]) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn: Function, desType: DesType, args: any[]) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc: any) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target: any) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn: Function) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args: any[]) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
",False
any,any,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object: <fim_suffix>) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",correct,840,"interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object: any) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj: Function) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn: Function, klass: Function, ...rest: any[]) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn: Function, desType: DesType, args: any[]) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc: any) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target: any) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn: Function) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args: any[]) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
",False
any,any,9232371dfa21a47ce397b18f5fd76f02d4b0d2b1,"<fim_prefix>type WithEvents = {
  addEventListener(type, callbackfn);
  removeEventListener(type, callbackfn);
}

export const isAsyncIterable = (v): v is AsyncIterable<any> => Symbol.asyncIterator in Object(v);

export const isIterable = (v): v is Iterable<any> => Symbol.iterator in Object(v);

export const eventsToIterable = <V>(eventSource, eventType) => {
  const pullQueue: any[] = [];
  const pushQueue: any[] = [];
  let done = false;
  const pushValue = async (args) => {
    if (pullQueue.length !== 0) {
      const resolver = pullQueue.shift();
      resolver(...args);
    } else {
      pushQueue.push(args);
    }
  };

  const pullValue = () => {
    return new Promise<V>((resolve) => {
      if (pushQueue.length !== 0) {
        const args = pushQueue.shift();
        // @ts-ignore
        resolve(...args);
      } else {
        pullQueue.push(resolve);
      }
    });
  };

  const handler = (...args: <fim_suffix>) => {
    pushValue(args);
  };

  eventSource.addEventListener(eventType, handler);
  const r = {
    next: async () => {
      if (done) return {done: true, value: undefined};
      return {
        done: false,
        value: await pullValue()
      };
    },
    return: async () => {
      done = true;
      eventSource.removeEventListener(eventType, handler);
      return {done: true, value: undefined};
    },
    throw: async (error) => {
      done = true;
      return {
        done: true,
        value: Promise.reject(error)
      };
    }
  };
  return r;
};<fim_middle>",correct,952,"type WithEvents = {
  addEventListener(type: string, callbackfn: any): void;
  removeEventListener(type: string, callbackfn: any): void;
}

export const isAsyncIterable = (v: any): v is AsyncIterable<any> => Symbol.asyncIterator in Object(v);

export const isIterable = (v: any): v is Iterable<any> => Symbol.iterator in Object(v);

export const eventsToIterable = <V>(eventSource: WithEvents, eventType: string): AsyncIterator<any, any, undefined> => {
  const pullQueue: any[] = [];
  const pushQueue: any[] = [];
  let done = false;
  const pushValue = async (args: any) => {
    if (pullQueue.length !== 0) {
      const resolver = pullQueue.shift();
      resolver(...args);
    } else {
      pushQueue.push(args);
    }
  };

  const pullValue = (): Promise<V> => {
    return new Promise<V>((resolve) => {
      if (pushQueue.length !== 0) {
        const args = pushQueue.shift();
        // @ts-ignore
        resolve(...args);
      } else {
        pullQueue.push(resolve);
      }
    });
  };

  const handler = (...args: any) => {
    pushValue(args);
  };

  eventSource.addEventListener(eventType, handler);
  const r = {
    next: async (): Promise<IteratorResult<V>> => {
      if (done) return {done: true, value: undefined};
      return {
        done: false,
        value: await pullValue()
      };
    },
    return: async (): Promise<IteratorResult<V>> => {
      done = true;
      eventSource.removeEventListener(eventType, handler);
      return {done: true, value: undefined};
    },
    throw: async (error: any): Promise<IteratorResult<V>> => {
      done = true;
      return {
        done: true,
        value: Promise.reject(error)
      };
    }
  };
  return r;
};",False
any,any,9eb078d7d68852e0860617c539c62b7d3a9f0a9a,"<fim_prefix>/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key) => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current,
    index,
    path,
    value,
    destroyArrays,
) => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state, key, value: <fim_suffix>) => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
<fim_middle>",correct,2053,"/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string: string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key: string): string[] => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current: State,
    index: number,
    path: string[],
    value: any,
    destroyArrays: boolean,
): State => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state: {}, key: string, value: any): any => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
",False
any,any,9eb078d7d68852e0860617c539c62b7d3a9f0a9a,"<fim_prefix>/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key) => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current,
    index,
    path,
    value: <fim_suffix>,
    destroyArrays,
) => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state, key, value) => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
<fim_middle>",correct,2058,"/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string: string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key: string): string[] => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current: State,
    index: number,
    path: string[],
    value: any,
    destroyArrays: boolean,
): State => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state: {}, key: string, value: any): any => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
",False
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2433,"// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json: string): Tuf {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value: Tuf): string {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ: any, val: any, key: any = ''): never {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ: any): any {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
    function transformPrimitive(typ: string, val: any): any {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs: any[], val: any): any {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases: string[], val: any): any {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ: any, val: any): any {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val: any): any {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
    return transform(val, typ, jsToJSONProps);
}

function a(typ: any) {
    return { arrayItems: typ };
}

function u(...typs: any[]) {
    return { unionMembers: typs };
}

function o(props: any[], additional: any) {
    return { props, additional };
}

function m(additional: any) {
    return { props: [], additional };
}

function r(name: string) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
",False
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3087,"// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json: string): HashedRekord {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value: HashedRekord): string {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ: any, val: any, key: any = ''): never {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ: any): any {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
    function transformPrimitive(typ: string, val: any): any {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs: any[], val: any): any {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases: string[], val: any): any {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ: any, val: any): any {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val: any): any {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
    return transform(val, typ, jsToJSONProps);
}

function a(typ: any) {
    return { arrayItems: typ };
}

function u(...typs: any[]) {
    return { unionMembers: typs };
}

function o(props: any[], additional: any) {
    return { props, additional };
}

function m(additional: any) {
    return { props: [], additional };
}

function r(name: string) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
",False
any,any,6c5d24a5d99d75f367877e7cca717ee288b6d93d,"<fim_prefix>// To parse this data:
//
//   import { Convert, Intoto } from ""./file"";
//
//   const intoto = Convert.toIntoto(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for intoto object
 */
export interface Intoto {
    content: Content;
    /**
     * The public key that can verify the signature
     */
    publicKey: string;
}

export interface Content {
    /**
     * envelope
     */
    envelope?: string;
    /**
     * Specifies the hash algorithm and value encompassing the entire signed envelope
     */
    hash?: Hash;
    /**
     * Specifies the hash algorithm and value covering the payload within the DSSE envelope
     */
    payloadHash?: PayloadHash;
}

/**
 * Specifies the hash algorithm and value encompassing the entire signed envelope
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the archive
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Specifies the hash algorithm and value covering the payload within the DSSE envelope
 */
export interface PayloadHash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the envelope's payload
     */
    value: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toIntoto(json) {
        return cast(JSON.parse(json), r(""Intoto""));
    }

    public static intotoToJson(value) {
        return JSON.stringify(uncast(value, r(""Intoto"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Intoto"": o([
        { json: ""content"", js: ""content"", typ: r(""Content"") },
        { json: ""publicKey"", js: ""publicKey"", typ: """" },
    ], ""any""),
    ""Content"": o([
        { json: ""envelope"", js: ""envelope"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
        { json: ""payloadHash"", js: ""payloadHash"", typ: u(undefined, r(""PayloadHash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""PayloadHash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3532,"// To parse this data:
//
//   import { Convert, Intoto } from ""./file"";
//
//   const intoto = Convert.toIntoto(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for intoto object
 */
export interface Intoto {
    content: Content;
    /**
     * The public key that can verify the signature
     */
    publicKey: string;
}

export interface Content {
    /**
     * envelope
     */
    envelope?: string;
    /**
     * Specifies the hash algorithm and value encompassing the entire signed envelope
     */
    hash?: Hash;
    /**
     * Specifies the hash algorithm and value covering the payload within the DSSE envelope
     */
    payloadHash?: PayloadHash;
}

/**
 * Specifies the hash algorithm and value encompassing the entire signed envelope
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the archive
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Specifies the hash algorithm and value covering the payload within the DSSE envelope
 */
export interface PayloadHash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the envelope's payload
     */
    value: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toIntoto(json: string): Intoto {
        return cast(JSON.parse(json), r(""Intoto""));
    }

    public static intotoToJson(value: Intoto): string {
        return JSON.stringify(uncast(value, r(""Intoto"")), null, 2);
    }
}

function invalidValue(typ: any, val: any, key: any = ''): never {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ: any): any {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
    function transformPrimitive(typ: string, val: any): any {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs: any[], val: any): any {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases: string[], val: any): any {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ: any, val: any): any {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val: any): any {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
    return transform(val, typ, jsToJSONProps);
}

function a(typ: any) {
    return { arrayItems: typ };
}

function u(...typs: any[]) {
    return { unionMembers: typs };
}

function o(props: any[], additional: any) {
    return { props, additional };
}

function m(additional: any) {
    return { props: [], additional };
}

function r(name: string) {
    return { ref: name };
}

const typeMap: any = {
    ""Intoto"": o([
        { json: ""content"", js: ""content"", typ: r(""Content"") },
        { json: ""publicKey"", js: ""publicKey"", typ: """" },
    ], ""any""),
    ""Content"": o([
        { json: ""envelope"", js: ""envelope"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
        { json: ""payloadHash"", js: ""payloadHash"", typ: u(undefined, r(""PayloadHash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""PayloadHash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
",False
any,any,c345024143db0e7f2d60174bc07a582029bfedc5,"<fim_prefix>// To parse this data:
//
//   import { Convert, Rekord } from ""./file"";
//
//   const rekord = Convert.toRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Rekord object
 */
export interface Rekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the content inline within the document
     */
    content?: string;
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content: string;
    /**
     * Specifies the format of the signature
     */
    format: Format;
    /**
     * The public key that can verify the signature
     */
    publicKey: PublicKey;
}

/**
 * Specifies the format of the signature
 */
export enum Format {
    Minisign = ""minisign"",
    PGP = ""pgp"",
    SSH = ""ssh"",
    X509 = ""x509"",
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toRekord(json) {
        return cast(JSON.parse(json), r(""Rekord""));
    }

    public static rekordToJson(value) {
        return JSON.stringify(uncast(value, r(""Rekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Rekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: """" },
        { json: ""format"", js: ""format"", typ: r(""Format"") },
        { json: ""publicKey"", js: ""publicKey"", typ: r(""PublicKey"") },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
    ""Format"": [
        ""minisign"",
        ""pgp"",
        ""ssh"",
        ""x509"",
    ],
};
<fim_middle>",correct,3699,"// To parse this data:
//
//   import { Convert, Rekord } from ""./file"";
//
//   const rekord = Convert.toRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Rekord object
 */
export interface Rekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the content inline within the document
     */
    content?: string;
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content: string;
    /**
     * Specifies the format of the signature
     */
    format: Format;
    /**
     * The public key that can verify the signature
     */
    publicKey: PublicKey;
}

/**
 * Specifies the format of the signature
 */
export enum Format {
    Minisign = ""minisign"",
    PGP = ""pgp"",
    SSH = ""ssh"",
    X509 = ""x509"",
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toRekord(json: string): Rekord {
        return cast(JSON.parse(json), r(""Rekord""));
    }

    public static rekordToJson(value: Rekord): string {
        return JSON.stringify(uncast(value, r(""Rekord"")), null, 2);
    }
}

function invalidValue(typ: any, val: any, key: any = ''): never {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ: any): any {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: any): any {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: any) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: any, typ: any, getProps: any, key: any = ''): any {
    function transformPrimitive(typ: string, val: any): any {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs: any[], val: any): any {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases: string[], val: any): any {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ: any, val: any): any {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val: any): any {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props: { [k: string]: any }, additional: any, val: any): any {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val: any, typ: any): T {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val: T, typ: any): any {
    return transform(val, typ, jsToJSONProps);
}

function a(typ: any) {
    return { arrayItems: typ };
}

function u(...typs: any[]) {
    return { unionMembers: typs };
}

function o(props: any[], additional: any) {
    return { props, additional };
}

function m(additional: any) {
    return { props: [], additional };
}

function r(name: string) {
    return { ref: name };
}

const typeMap: any = {
    ""Rekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: """" },
        { json: ""format"", js: ""format"", typ: r(""Format"") },
        { json: ""publicKey"", js: ""publicKey"", typ: r(""PublicKey"") },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
    ""Format"": [
        ""minisign"",
        ""pgp"",
        ""ssh"",
        ""x509"",
    ],
};
",False
any,any,bf712f9fe76a6eeeb69b15794f6333cb9c774f5e,"<fim_prefix>/* eslint-disable @typescript-eslint/naming-convention */
export type ResponseMessage = {
    status: string;
    message: any;
};

export type ErrorResponse = {
    error: string;
    message?: string;
};

export type Fields = {
    id?: boolean;
    title?: boolean;
    main_picture?: boolean;
    alternative_titles?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    synopsis?: boolean;
    mean?: boolean;
    rank?: boolean;
    popularity?: boolean;
    num_list_users?: boolean;
    num_scoring_users?: boolean;
    nsfw?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    media_type?: boolean;
    status?: boolean;
    genres?: boolean;
    my_list_status?: boolean | Fields; // different possible fields
    num_episodes?: boolean;
    start_season?: boolean;
    broadcast?: boolean;
    source?: boolean;
    average_episode_duration?: boolean;
    rating?: boolean;
    pictures?: boolean;
    background?: boolean;
    related_anime?: boolean | Fields;
    related_manga?: boolean | Fields;
    recommendations?: boolean | Fields;
    studios?: boolean;
    statistics?: boolean;
    videos?: boolean;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function fieldsToString(fields) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    const entries = Object.entries(fields);
    let str = """";

    for (const entry of entries) {
        if (str.length > 0) {
            str += "","";
        }
        str += entry[0];
        if (entry[1] !== true && entry[1] !== false) {
            str += `{${fieldsToString(entry[1] as any)}}`;
        }
    }
    return str;
}

export function extractFields(str) {
    let subject = str;

    if (subject[0] === ""{"") {
        subject = subject.substr(1, subject.length);
    }

    let currentObject = """";
    const createdObj: any = {};

    function addObject(stri, val) {
        if (stri === """") return;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        createdObj[currentObject] = val;
        currentObject = """";
    }

    function skipSubject() {
        subject = subject.substr(1, subject.length);
    }

    while (subject.length > 0) {
        const subjZero = subject[0];

        if (subjZero === "" "") {
            skipSubject();
            if (subject.length === 0) {
                addObject(currentObject, true);
            }
            continue;
        }

        if (subjZero === ""{"") {
            const res = extractFields(subject);
            addObject(currentObject, res.fields);
            subject = res.remaining;
            continue;
        }
        if (subjZero === ""}"") {
            addObject(currentObject, true);

            skipSubject();
            if (subject[0] === "","") skipSubject();

            return {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                fields: createdObj,
                remaining: subject,
            };
        }
        if (subjZero === "","") {
            addObject(currentObject, true);
            skipSubject();
            continue;
        }

        currentObject += subjZero;
        skipSubject();

        if (subject.length === 0) {
            addObject(currentObject, true);
        }
    }

    return {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        fields: createdObj,
        remaining: """",
    };
}

export function allFields() {
    return {
        alternative_titles: true,
        average_episode_duration: true,
        background: true,
        broadcast: true,
        created_at: true,
        end_date: true,
        genres: true,
        id: true,
        main_picture: true,
        mean: true,
        media_type: true,
        my_list_status: true,
        nsfw: true,
        num_episodes: true,
        num_list_users: true,
        num_scoring_users: true,
        pictures: true,
        popularity: true,
        rank: true,
        rating: true,
        recommendations: true,
        related_anime: true,
        related_manga: true,
        source: true,
        start_date: true,
        start_season: true,
        statistics: true,
        status: true,
        studios: true,
        synopsis: true,
        title: true,
        updated_at: true,
    };
}

type Relation = MediaNode & {
    relation_type: string;
    relation_type_formatted: string;
};

export type StatusNode = MediaNode & {
    list_status: ListStatus;
};

export type Media = {
    id: number;
    title: string;
    main_picture: Picture;
    alternative_titles?: {
        synonyms?: string[];
        en?: string;
        ja?: string;
    };
    start_date?: string;
    end_date?: string;
    synopsis?: string;
    mean?: number;
    rank?: number;
    popularity?: number;
    num_list_users?: number;
    num_scoring_users?: number;
    nsfw?: string;
    created_at?: string;
    updated_at?: string;
    media_type?: string;
    status?: string;
    genres?: Genre[];
    my_list_status?: ListStatus;
    num_episodes?: number;
    start_season?: Season;
    broadcast?: {
        day_of_the_week?: string;
        start_time?: string;
    };
    source?: string;
    average_episode_duration?: number;
    rating?: string;
    pictures?: Picture[];
    background?: string;
    related_anime?: Relation[];
    related_manga?: Relation[];
    recommendations?: (MediaNode & {
        num_recommendations?: number;
    })[];
    studios?: Studio[];
    statistics?: {
        status?: {
            watching?: string;
            completed?: string;
            on_hold?: string;
            dropped?: string;
            plan_to_watch?: string;
        };
        num_list_users?: number;
    };
};

export type tokenResponse = {
    token_type: ""Bearer"";
    expires_in: number;
    access_token: string;
    refresh_token: string;
};

export type Picture = {
    medium: string;
    large: string;
};

export type Genre = {
    id: number;
    name: string;
};

export type ListStatus = {
    status: ""watching"" | ""completed"" | ""on_hold"" | ""dropped"" | ""plan_to_watch"";
    score: number;
    num_episodes_watched: number;
    is_rewatching: boolean;
    updated_at: string;
};

export type ListPagination<T> = {
    data: T[];
    paging: {
        next: string;
        previous?: string | undefined;
    };
};

export type RequestResponse<T> = {
    response:
        | {
              response: T;
              tokens: tokenResponse;
          }
        | ErrorResponse;
};

export type MediaNode = {
    node: Media;
};

export type Season = {
    year: number;
    season: string;
};

export type Studio = {
    id: number;
    name: string;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isTokenResponse(obj): obj is tokenResponse {
    return ""tokenType"" in obj;
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isErrResp(obj: <fim_suffix>): obj is ErrorResponse {
    return ""error"" in obj;
}
<fim_middle>",correct,4424,"/* eslint-disable @typescript-eslint/naming-convention */
export type ResponseMessage = {
    status: string;
    message: any;
};

export type ErrorResponse = {
    error: string;
    message?: string;
};

export type Fields = {
    id?: boolean;
    title?: boolean;
    main_picture?: boolean;
    alternative_titles?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    synopsis?: boolean;
    mean?: boolean;
    rank?: boolean;
    popularity?: boolean;
    num_list_users?: boolean;
    num_scoring_users?: boolean;
    nsfw?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    media_type?: boolean;
    status?: boolean;
    genres?: boolean;
    my_list_status?: boolean | Fields; // different possible fields
    num_episodes?: boolean;
    start_season?: boolean;
    broadcast?: boolean;
    source?: boolean;
    average_episode_duration?: boolean;
    rating?: boolean;
    pictures?: boolean;
    background?: boolean;
    related_anime?: boolean | Fields;
    related_manga?: boolean | Fields;
    recommendations?: boolean | Fields;
    studios?: boolean;
    statistics?: boolean;
    videos?: boolean;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function fieldsToString(fields: any): string {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    const entries = Object.entries(fields);
    let str = """";

    for (const entry of entries) {
        if (str.length > 0) {
            str += "","";
        }
        str += entry[0];
        if (entry[1] !== true && entry[1] !== false) {
            str += `{${fieldsToString(entry[1] as any)}}`;
        }
    }
    return str;
}

export function extractFields(str: string): {
    fields: Fields;
    remaining: string;
} {
    let subject = str;

    if (subject[0] === ""{"") {
        subject = subject.substr(1, subject.length);
    }

    let currentObject = """";
    const createdObj: any = {};

    function addObject(stri: string, val: any) {
        if (stri === """") return;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        createdObj[currentObject] = val;
        currentObject = """";
    }

    function skipSubject() {
        subject = subject.substr(1, subject.length);
    }

    while (subject.length > 0) {
        const subjZero = subject[0];

        if (subjZero === "" "") {
            skipSubject();
            if (subject.length === 0) {
                addObject(currentObject, true);
            }
            continue;
        }

        if (subjZero === ""{"") {
            const res = extractFields(subject);
            addObject(currentObject, res.fields);
            subject = res.remaining;
            continue;
        }
        if (subjZero === ""}"") {
            addObject(currentObject, true);

            skipSubject();
            if (subject[0] === "","") skipSubject();

            return {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                fields: createdObj,
                remaining: subject,
            };
        }
        if (subjZero === "","") {
            addObject(currentObject, true);
            skipSubject();
            continue;
        }

        currentObject += subjZero;
        skipSubject();

        if (subject.length === 0) {
            addObject(currentObject, true);
        }
    }

    return {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        fields: createdObj,
        remaining: """",
    };
}

export function allFields(): Fields {
    return {
        alternative_titles: true,
        average_episode_duration: true,
        background: true,
        broadcast: true,
        created_at: true,
        end_date: true,
        genres: true,
        id: true,
        main_picture: true,
        mean: true,
        media_type: true,
        my_list_status: true,
        nsfw: true,
        num_episodes: true,
        num_list_users: true,
        num_scoring_users: true,
        pictures: true,
        popularity: true,
        rank: true,
        rating: true,
        recommendations: true,
        related_anime: true,
        related_manga: true,
        source: true,
        start_date: true,
        start_season: true,
        statistics: true,
        status: true,
        studios: true,
        synopsis: true,
        title: true,
        updated_at: true,
    };
}

type Relation = MediaNode & {
    relation_type: string;
    relation_type_formatted: string;
};

export type StatusNode = MediaNode & {
    list_status: ListStatus;
};

export type Media = {
    id: number;
    title: string;
    main_picture: Picture;
    alternative_titles?: {
        synonyms?: string[];
        en?: string;
        ja?: string;
    };
    start_date?: string;
    end_date?: string;
    synopsis?: string;
    mean?: number;
    rank?: number;
    popularity?: number;
    num_list_users?: number;
    num_scoring_users?: number;
    nsfw?: string;
    created_at?: string;
    updated_at?: string;
    media_type?: string;
    status?: string;
    genres?: Genre[];
    my_list_status?: ListStatus;
    num_episodes?: number;
    start_season?: Season;
    broadcast?: {
        day_of_the_week?: string;
        start_time?: string;
    };
    source?: string;
    average_episode_duration?: number;
    rating?: string;
    pictures?: Picture[];
    background?: string;
    related_anime?: Relation[];
    related_manga?: Relation[];
    recommendations?: (MediaNode & {
        num_recommendations?: number;
    })[];
    studios?: Studio[];
    statistics?: {
        status?: {
            watching?: string;
            completed?: string;
            on_hold?: string;
            dropped?: string;
            plan_to_watch?: string;
        };
        num_list_users?: number;
    };
};

export type tokenResponse = {
    token_type: ""Bearer"";
    expires_in: number;
    access_token: string;
    refresh_token: string;
};

export type Picture = {
    medium: string;
    large: string;
};

export type Genre = {
    id: number;
    name: string;
};

export type ListStatus = {
    status: ""watching"" | ""completed"" | ""on_hold"" | ""dropped"" | ""plan_to_watch"";
    score: number;
    num_episodes_watched: number;
    is_rewatching: boolean;
    updated_at: string;
};

export type ListPagination<T> = {
    data: T[];
    paging: {
        next: string;
        previous?: string | undefined;
    };
};

export type RequestResponse<T> = {
    response:
        | {
              response: T;
              tokens: tokenResponse;
          }
        | ErrorResponse;
};

export type MediaNode = {
    node: Media;
};

export type Season = {
    year: number;
    season: string;
};

export type Studio = {
    id: number;
    name: string;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isTokenResponse(obj: any): obj is tokenResponse {
    return ""tokenType"" in obj;
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isErrResp(obj: any): obj is ErrorResponse {
    return ""error"" in obj;
}
",False
any,any,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item: <fim_suffix>): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4930,"export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item: any): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target: Thing, source: Thing): Thing {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing: Type): Type {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a: AlmostAnything, b: AlmostAnything): boolean {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input: any) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input: string) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp: string) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn: (...args: any[]) => any | Promise<any>) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
",False
boolean,boolean,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?: <fim_suffix>,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1030,"function keys(obj: object, hasKey: (obj: object, key: string) => boolean) {
    var keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj: any, key: string) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj: any, key: string) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj: any): boolean {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName: string, value: unknown) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj: any) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a: any, b: any) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a: any, b: any) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a: any,
    b: any,
    aStack: Array<unknown>,
    bStack: Array<unknown>,
    customTesters: Array<Tester>,
    hasKey: any,
): boolean => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a: unknown,
    b: unknown,
    isStrictCheck?: boolean,
    options?: {
        customTesters?: Array<Tester>,
    },
): boolean {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
",False
boolean,boolean,5bf8f0f2946da835300025c6804a609bef4277ab,"<fim_prefix>// @strict: true
// @declaration: true

type T01 = {} & string;  // string
type T02 = {} & 'a';  // 'a'
type T03 = {} & object;  // object
type T04 = {} & { x: number };  // { x: number }
type T05 = {} & null;  // never
type T06 = {} & undefined;  // never
type T07 = undefined & void;  // undefined

type T10 = string & {};  // Specially preserved
type T11 = number & {};  // Specially preserved
type T12 = bigint & {};  // Specially preserved

type ThisNode = {};
type ThatNode = {};
type ThisOrThatNode = ThisNode | ThatNode;

function f01(u) {
    let x1: {} = u;  // Error
    let x2: {} | null | undefined = u;
    let x3: {} | { x: string } | null | undefined = u;
    let x4: ThisOrThatNode | null | undefined = u;
}

function f10(x) {
    if (x) {
        x;  // {}
    }
    else {
        x;  // unknown
    }
    if (!x) {
        x;  // unknown
    }
    else {
        x;  // {}
    }
}

function f11<T>(x) {
    if (x) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (!x) {
        x;  // T
    }
    else {
        x;  // T & {}
    }
}

function f12<T extends {}>(x) {
    if (x) {
        x;  // T
    }
    else {
        x;  // T
    }
}

function f20(x) {
    if (x !== undefined) {
        x;  // {} | null
    }
    else {
        x;  // undefined
    }
    if (x !== null) {
        x;  // {} | undefined
    }
    else {
        x;  // null
    }
    if (x !== undefined && x !== null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != undefined) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
}

function f21<T>(x) {
    if (x !== undefined) {
        x;  // T & ({} | null)
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T & ({} | undefined)
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f22<T extends {} | undefined>(x) {
    if (x !== undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f23<T>(x) {
    if (x !== undefined) {
        x;  // T & {} | null
    }
    if (x !== null) {
        x;  // T & {} | undefined
    }
    if (x != undefined) {
        x;  // T & {}
    }
    if (x != null) {
        x;  // T & {}
    }
}

function f30(x) {
    if (typeof x === ""object"") {
        x;  // object
    }
}

function f31<T>(x) {
    if (typeof x === ""object"") {
        x;  // T & object | T & null
    }
    if (x && typeof x === ""object"") {
        x;  // T & object
    }
    if (typeof x === ""object"" && x) {
        x;  // T & object
    }
}

function f32<T extends {} | undefined>(x) {
    if (typeof x === ""object"") {
        x;  // T & object
    }
}

function possiblyNull<T>(x) {
    return !!true ? x : null;  // T | null
}

function possiblyUndefined<T>(x) {
    return !!true ? x : undefined;  // T | undefined
}

function possiblyNullOrUndefined<T>(x) {
    return possiblyUndefined(possiblyNull(x));  // T | null | undefined
}

function ensureNotNull<T>(x) {
    if (x === null) throw Error();
    return x;  // T & ({} | undefined)
}

function ensureNotUndefined<T>(x) {
    if (x === undefined) throw Error();
    return x;  // T & ({} | null)
}

function ensureNotNullOrUndefined<T>(x) {
    return ensureNotUndefined(ensureNotNull(x));  // T & {}
}

function f40(a, b) {
    let a1 = ensureNotNullOrUndefined(a);  // string
    let b1 = ensureNotNullOrUndefined(b);  // number
}

type QQ<T> = NonNullable<NonNullable<NonNullable<T>>>;

function f41<T>(a) {
    let a1 = ensureNotUndefined(ensureNotNull(a));  // T & {}
    let a2 = ensureNotNull(ensureNotUndefined(a));  // T & {}
    let a3 = ensureNotNull(ensureNotNull(a));  // T & {} | T & undefined
    let a4 = ensureNotUndefined(ensureNotUndefined(a));  // T & {} | T & null
    let a5 = ensureNotNullOrUndefined(ensureNotNullOrUndefined(a));  // T & {}
    let a6 = ensureNotNull(possiblyNullOrUndefined(a));  // T & {} | undefined
    let a7 = ensureNotUndefined(possiblyNullOrUndefined(a));  // T & {} | null
    let a8 = ensureNotNull(possiblyUndefined(a));  // T & {} | undefined
    let a9 = ensureNotUndefined(possiblyNull(a));  // T & {} | null
}

// Repro from #48468

function deepEquals<T>(a, b): <fim_suffix> {
    if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) {
        return false;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        return false;
    }
    if (Object.keys(a).length !== Object.keys(b).length) { // Error here
        return false;
    }
    return true;
}

// Repro from #49386

function foo<T>(x) {
    let y = x;
    if (y !== null) {
        y;
    }
}
<fim_middle>",correct,1958,"// @strict: true
// @declaration: true

type T01 = {} & string;  // string
type T02 = {} & 'a';  // 'a'
type T03 = {} & object;  // object
type T04 = {} & { x: number };  // { x: number }
type T05 = {} & null;  // never
type T06 = {} & undefined;  // never
type T07 = undefined & void;  // undefined

type T10 = string & {};  // Specially preserved
type T11 = number & {};  // Specially preserved
type T12 = bigint & {};  // Specially preserved

type ThisNode = {};
type ThatNode = {};
type ThisOrThatNode = ThisNode | ThatNode;

function f01(u: unknown) {
    let x1: {} = u;  // Error
    let x2: {} | null | undefined = u;
    let x3: {} | { x: string } | null | undefined = u;
    let x4: ThisOrThatNode | null | undefined = u;
}

function f10(x: unknown) {
    if (x) {
        x;  // {}
    }
    else {
        x;  // unknown
    }
    if (!x) {
        x;  // unknown
    }
    else {
        x;  // {}
    }
}

function f11<T>(x: T) {
    if (x) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (!x) {
        x;  // T
    }
    else {
        x;  // T & {}
    }
}

function f12<T extends {}>(x: T) {
    if (x) {
        x;  // T
    }
    else {
        x;  // T
    }
}

function f20(x: unknown) {
    if (x !== undefined) {
        x;  // {} | null
    }
    else {
        x;  // undefined
    }
    if (x !== null) {
        x;  // {} | undefined
    }
    else {
        x;  // null
    }
    if (x !== undefined && x !== null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != undefined) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
}

function f21<T>(x: T) {
    if (x !== undefined) {
        x;  // T & ({} | null)
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T & ({} | undefined)
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f22<T extends {} | undefined>(x: T) {
    if (x !== undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f23<T>(x: T | undefined | null) {
    if (x !== undefined) {
        x;  // T & {} | null
    }
    if (x !== null) {
        x;  // T & {} | undefined
    }
    if (x != undefined) {
        x;  // T & {}
    }
    if (x != null) {
        x;  // T & {}
    }
}

function f30(x: {}) {
    if (typeof x === ""object"") {
        x;  // object
    }
}

function f31<T>(x: T) {
    if (typeof x === ""object"") {
        x;  // T & object | T & null
    }
    if (x && typeof x === ""object"") {
        x;  // T & object
    }
    if (typeof x === ""object"" && x) {
        x;  // T & object
    }
}

function f32<T extends {} | undefined>(x: T) {
    if (typeof x === ""object"") {
        x;  // T & object
    }
}

function possiblyNull<T>(x: T) {
    return !!true ? x : null;  // T | null
}

function possiblyUndefined<T>(x: T) {
    return !!true ? x : undefined;  // T | undefined
}

function possiblyNullOrUndefined<T>(x: T) {
    return possiblyUndefined(possiblyNull(x));  // T | null | undefined
}

function ensureNotNull<T>(x: T) {
    if (x === null) throw Error();
    return x;  // T & ({} | undefined)
}

function ensureNotUndefined<T>(x: T) {
    if (x === undefined) throw Error();
    return x;  // T & ({} | null)
}

function ensureNotNullOrUndefined<T>(x: T) {
    return ensureNotUndefined(ensureNotNull(x));  // T & {}
}

function f40(a: string | undefined, b: number | null | undefined) {
    let a1 = ensureNotNullOrUndefined(a);  // string
    let b1 = ensureNotNullOrUndefined(b);  // number
}

type QQ<T> = NonNullable<NonNullable<NonNullable<T>>>;

function f41<T>(a: T) {
    let a1 = ensureNotUndefined(ensureNotNull(a));  // T & {}
    let a2 = ensureNotNull(ensureNotUndefined(a));  // T & {}
    let a3 = ensureNotNull(ensureNotNull(a));  // T & {} | T & undefined
    let a4 = ensureNotUndefined(ensureNotUndefined(a));  // T & {} | T & null
    let a5 = ensureNotNullOrUndefined(ensureNotNullOrUndefined(a));  // T & {}
    let a6 = ensureNotNull(possiblyNullOrUndefined(a));  // T & {} | undefined
    let a7 = ensureNotUndefined(possiblyNullOrUndefined(a));  // T & {} | null
    let a8 = ensureNotNull(possiblyUndefined(a));  // T & {} | undefined
    let a9 = ensureNotUndefined(possiblyNull(a));  // T & {} | null
}

// Repro from #48468

function deepEquals<T>(a: T, b: T): boolean {
    if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) {
        return false;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        return false;
    }
    if (Object.keys(a).length !== Object.keys(b).length) { // Error here
        return false;
    }
    return true;
}

// Repro from #49386

function foo<T>(x: T | null) {
    let y = x;
    if (y !== null) {
        y;
    }
}
",False
boolean,boolean,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover: <fim_suffix> = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2320,"interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function ():void {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name:string, callback:Function):busEv=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name:string, fn?:Function):Array<busEv>=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name:string, fn?:Function):void=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name:string, fn?:Function):void=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn:Function):void=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name:string, packet:object):boolean=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name:string, fn:Function, cover:boolean = false):busEv=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name:string, fn:Function, cover:boolean = false):void=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name:string, data:object):void=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}",False
number,number,d7888589a5edea554ef38b5038cfe5db0eca64de,"<fim_prefix>type StateType = [number, number, TURN]

type ResultType = [
    mouseResult: [result: RESULT_FLAG, move: number],
    catResult: [result: RESULT_FLAG, move: number],
]

enum TURN {
  MOUSE_TURN = 0,
  CAT_TURN = 1,
}

enum RESULT_FLAG {
  UNKNOWN = 0,
  MOUSE_WIN = 1,
  CAT_WIN = 2,
}

const MAX_MOVES = 1000
const DIRS = [[-1, 0], [1, 0], [0, -1], [0, 1]]

/**
 * 拓扑排序
 * @desc 时间复杂度 O(M²N²(M+N))  空间复杂度 O(M²N²)
 * @param grid
 * @param catJump
 * @param mouseJump
 * @returns
 */
export function canMouseWin(
  grid,
  catJump,
  mouseJump,
) {
  const rows = grid.length
  const cols = grid[0].length
  let startMouse = -1
  let startCat = -1
  let food = -1
  const getPosKey = (row, col): <fim_suffix> => row * cols + col
  const getPos = (key) => [(key / cols) >> 0, key % cols]

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const c = grid[i][j]
      if (c === 'M')
        startMouse = getPosKey(i, j)
      else if (c === 'C')
        startCat = getPosKey(i, j)
      else if (c === 'F')
        food = getPosKey(i, j)
    }
  }

  const total = rows * cols
  const degrees: [mouse: number, cat: number][][]
  = new Array(total).fill(0).map(() => new Array(total).fill(0).map(() => [0, 0]))

  // 计算每个状态的度
  for (let mouse = 0; mouse < total; mouse++) {
    const [mouseRow, mouseCol] = getPos(mouse)
    if (grid[mouseRow][mouseCol] === '#') continue

    for (let cat = 0; cat < total; cat++) {
      const [catRow, catCol] = getPos(cat)
      if (grid[catRow][catCol] === '#') continue

      degrees[mouse][cat][TURN.MOUSE_TURN]++
      degrees[mouse][cat][TURN.CAT_TURN]++

      for (const dir of DIRS) {
        for (
          let row = mouseRow + dir[0], col = mouseCol + dir[1], jump = 1;
          row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] !== '#' && jump <= mouseJump;
          row += dir[0], col += dir[1], jump++
        ) {
          const nextMouse = getPosKey(row, col)
          const nextCat = getPosKey(catRow, catCol)
          degrees[nextMouse][nextCat][TURN.MOUSE_TURN]++
        }

        for (
          let row = catRow + dir[0], col = catCol + dir[1], jump = 1;
          row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] !== '#' && jump <= catJump;
          row += dir[0], col += dir[1], jump++
        ) {
          const nextMouse = getPosKey(mouseRow, mouseCol)
          const nextCat = getPosKey(row, col)
          degrees[nextMouse][nextCat][TURN.CAT_TURN]++
        }
      }
    }
  }

  const results: ResultType[][]
  = new Array(total).fill(0)
    .map(() => new Array(total).fill(0)
      .map(() => [[RESULT_FLAG.UNKNOWN, 0], [RESULT_FLAG.UNKNOWN, 0]]),
    )
  const queue: StateType[] = []

  // 猫和老鼠在同一个单元格，猫获胜
  for (let pos = 0; pos < total; pos++) {
    const [row, col] = getPos(pos)
    if (grid[row][col] === '#') continue

    results[pos][pos][TURN.MOUSE_TURN][0] = RESULT_FLAG.CAT_WIN
    results[pos][pos][TURN.MOUSE_TURN][1] = 0
    results[pos][pos][TURN.CAT_TURN][0] = RESULT_FLAG.CAT_WIN
    results[pos][pos][TURN.CAT_TURN][1] = 0
    queue.push([pos, pos, TURN.MOUSE_TURN])
    queue.push([pos, pos, TURN.CAT_TURN])
  }

  // 猫和食物在同一个单元格，猫获胜
  for (let mouse = 0; mouse < total; mouse++) {
    const [mouseRow, mouseCol] = getPos(mouse)
    if (grid[mouseRow][mouseCol] === '#' || mouse === food) continue

    results[mouse][food][TURN.MOUSE_TURN][0] = RESULT_FLAG.CAT_WIN
    results[mouse][food][TURN.MOUSE_TURN][1] = 0
    results[mouse][food][TURN.CAT_TURN][0] = RESULT_FLAG.CAT_WIN
    results[mouse][food][TURN.CAT_TURN][1] = 0
    queue.push([mouse, food, TURN.MOUSE_TURN])
    queue.push([mouse, food, TURN.CAT_TURN])
  }

  // 老鼠和食物在同一个单元格且猫和食物不在同一个单元格，老鼠获胜
  for (let cat = 0; cat < total; cat++) {
    const [catRow, catCol] = getPos(cat)
    if (grid[catRow][catCol] === '#' || cat === food) continue

    results[food][cat][TURN.MOUSE_TURN][0] = RESULT_FLAG.MOUSE_WIN
    results[food][cat][TURN.MOUSE_TURN][1] = 0
    results[food][cat][TURN.CAT_TURN][0] = RESULT_FLAG.MOUSE_WIN
    results[food][cat][TURN.CAT_TURN][1] = 0
    queue.push([food, cat, TURN.MOUSE_TURN])
    queue.push([food, cat, TURN.CAT_TURN])
  }

  // 拓扑排序
  while (queue.length) {
    const [mouse, cat, turn] = queue.shift()!
    const [result, moves] = results[mouse][cat][turn]
    const prevStates = getPrevStates(mouse, cat, turn)
    for (const prevState of prevStates) {
      const [prevMouse, prevCat, prevTurn] = prevState
      if (results[prevMouse][prevCat][prevTurn][0] === RESULT_FLAG.UNKNOWN) {
        const canWin
        = (result === RESULT_FLAG.MOUSE_WIN && prevTurn === TURN.MOUSE_TURN)
        || (result === RESULT_FLAG.CAT_WIN && prevTurn === TURN.CAT_TURN)
        if (canWin) {
          results[prevMouse][prevCat][prevTurn][0] = result
          results[prevMouse][prevCat][prevTurn][1] = moves + 1
          queue.push([prevMouse, prevCat, prevTurn])
        }
        else {
          degrees[prevMouse][prevCat][prevTurn]--
          if (degrees[prevMouse][prevCat][prevTurn] === 0) {
            const loseResult = prevTurn === TURN.MOUSE_TURN ? RESULT_FLAG.CAT_WIN : RESULT_FLAG.MOUSE_WIN
            results[prevMouse][prevCat][prevTurn][0] = loseResult
            results[prevMouse][prevCat][prevTurn][1] = moves + 1
            queue.push([prevMouse, prevCat, prevTurn])
          }
        }
      }
    }
  }

  const [result, move] = results[startMouse][startCat][TURN.MOUSE_TURN]
  return result === RESULT_FLAG.MOUSE_WIN && move <= MAX_MOVES

  function getPrevStates(mouse, cat, turn) {
    const prevStates: StateType[] = []
    const [mouseRow, mouseCol] = getPos(mouse)
    const [catRow, catCol] = getPos(cat)
    const prevTurn = turn === TURN.MOUSE_TURN ? TURN.CAT_TURN : TURN.MOUSE_TURN
    const maxJump = prevTurn === TURN.MOUSE_TURN ? mouseJump : catJump
    const startRow = prevTurn === TURN.MOUSE_TURN ? mouseRow : catRow
    const startCol = prevTurn === TURN.MOUSE_TURN ? mouseCol : catCol
    prevStates.push([mouse, cat, prevTurn])

    for (const dir of DIRS) {
      for (
        let i = startRow + dir[0], j = startCol + dir[1], jump = 1;
        i >= 0 && i < rows && j >= 0 && j < cols && grid[i][j] !== '#' && jump <= maxJump;
        i += dir[0], j += dir[1], jump++
      ) {
        const prevMouseRow = prevTurn === TURN.MOUSE_TURN ? i : mouseRow
        const prevMouseCol = prevTurn === TURN.MOUSE_TURN ? j : mouseCol
        const prevCatRow = prevTurn === TURN.MOUSE_TURN ? catRow : i
        const prevCatCol = prevTurn === TURN.MOUSE_TURN ? catCol : j
        const prevMouse = getPosKey(prevMouseRow, prevMouseCol)
        const prevCat = getPosKey(prevCatRow, prevCatCol)
        prevStates.push([prevMouse, prevCat, prevTurn])
      }
    }

    return prevStates
  }
}
<fim_middle>",correct,1171,"type StateType = [number, number, TURN]

type ResultType = [
    mouseResult: [result: RESULT_FLAG, move: number],
    catResult: [result: RESULT_FLAG, move: number],
]

enum TURN {
  MOUSE_TURN = 0,
  CAT_TURN = 1,
}

enum RESULT_FLAG {
  UNKNOWN = 0,
  MOUSE_WIN = 1,
  CAT_WIN = 2,
}

const MAX_MOVES = 1000
const DIRS = [[-1, 0], [1, 0], [0, -1], [0, 1]]

/**
 * 拓扑排序
 * @desc 时间复杂度 O(M²N²(M+N))  空间复杂度 O(M²N²)
 * @param grid
 * @param catJump
 * @param mouseJump
 * @returns
 */
export function canMouseWin(
  grid: string[],
  catJump: number,
  mouseJump: number,
): boolean {
  const rows = grid.length
  const cols = grid[0].length
  let startMouse = -1
  let startCat = -1
  let food = -1
  const getPosKey = (row: number, col: number): number => row * cols + col
  const getPos = (key: number): [number, number] => [(key / cols) >> 0, key % cols]

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const c = grid[i][j]
      if (c === 'M')
        startMouse = getPosKey(i, j)
      else if (c === 'C')
        startCat = getPosKey(i, j)
      else if (c === 'F')
        food = getPosKey(i, j)
    }
  }

  const total = rows * cols
  const degrees: [mouse: number, cat: number][][]
  = new Array(total).fill(0).map(() => new Array(total).fill(0).map(() => [0, 0]))

  // 计算每个状态的度
  for (let mouse = 0; mouse < total; mouse++) {
    const [mouseRow, mouseCol] = getPos(mouse)
    if (grid[mouseRow][mouseCol] === '#') continue

    for (let cat = 0; cat < total; cat++) {
      const [catRow, catCol] = getPos(cat)
      if (grid[catRow][catCol] === '#') continue

      degrees[mouse][cat][TURN.MOUSE_TURN]++
      degrees[mouse][cat][TURN.CAT_TURN]++

      for (const dir of DIRS) {
        for (
          let row = mouseRow + dir[0], col = mouseCol + dir[1], jump = 1;
          row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] !== '#' && jump <= mouseJump;
          row += dir[0], col += dir[1], jump++
        ) {
          const nextMouse = getPosKey(row, col)
          const nextCat = getPosKey(catRow, catCol)
          degrees[nextMouse][nextCat][TURN.MOUSE_TURN]++
        }

        for (
          let row = catRow + dir[0], col = catCol + dir[1], jump = 1;
          row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] !== '#' && jump <= catJump;
          row += dir[0], col += dir[1], jump++
        ) {
          const nextMouse = getPosKey(mouseRow, mouseCol)
          const nextCat = getPosKey(row, col)
          degrees[nextMouse][nextCat][TURN.CAT_TURN]++
        }
      }
    }
  }

  const results: ResultType[][]
  = new Array(total).fill(0)
    .map(() => new Array(total).fill(0)
      .map(() => [[RESULT_FLAG.UNKNOWN, 0], [RESULT_FLAG.UNKNOWN, 0]]),
    )
  const queue: StateType[] = []

  // 猫和老鼠在同一个单元格，猫获胜
  for (let pos = 0; pos < total; pos++) {
    const [row, col] = getPos(pos)
    if (grid[row][col] === '#') continue

    results[pos][pos][TURN.MOUSE_TURN][0] = RESULT_FLAG.CAT_WIN
    results[pos][pos][TURN.MOUSE_TURN][1] = 0
    results[pos][pos][TURN.CAT_TURN][0] = RESULT_FLAG.CAT_WIN
    results[pos][pos][TURN.CAT_TURN][1] = 0
    queue.push([pos, pos, TURN.MOUSE_TURN])
    queue.push([pos, pos, TURN.CAT_TURN])
  }

  // 猫和食物在同一个单元格，猫获胜
  for (let mouse = 0; mouse < total; mouse++) {
    const [mouseRow, mouseCol] = getPos(mouse)
    if (grid[mouseRow][mouseCol] === '#' || mouse === food) continue

    results[mouse][food][TURN.MOUSE_TURN][0] = RESULT_FLAG.CAT_WIN
    results[mouse][food][TURN.MOUSE_TURN][1] = 0
    results[mouse][food][TURN.CAT_TURN][0] = RESULT_FLAG.CAT_WIN
    results[mouse][food][TURN.CAT_TURN][1] = 0
    queue.push([mouse, food, TURN.MOUSE_TURN])
    queue.push([mouse, food, TURN.CAT_TURN])
  }

  // 老鼠和食物在同一个单元格且猫和食物不在同一个单元格，老鼠获胜
  for (let cat = 0; cat < total; cat++) {
    const [catRow, catCol] = getPos(cat)
    if (grid[catRow][catCol] === '#' || cat === food) continue

    results[food][cat][TURN.MOUSE_TURN][0] = RESULT_FLAG.MOUSE_WIN
    results[food][cat][TURN.MOUSE_TURN][1] = 0
    results[food][cat][TURN.CAT_TURN][0] = RESULT_FLAG.MOUSE_WIN
    results[food][cat][TURN.CAT_TURN][1] = 0
    queue.push([food, cat, TURN.MOUSE_TURN])
    queue.push([food, cat, TURN.CAT_TURN])
  }

  // 拓扑排序
  while (queue.length) {
    const [mouse, cat, turn] = queue.shift()!
    const [result, moves] = results[mouse][cat][turn]
    const prevStates = getPrevStates(mouse, cat, turn)
    for (const prevState of prevStates) {
      const [prevMouse, prevCat, prevTurn] = prevState
      if (results[prevMouse][prevCat][prevTurn][0] === RESULT_FLAG.UNKNOWN) {
        const canWin
        = (result === RESULT_FLAG.MOUSE_WIN && prevTurn === TURN.MOUSE_TURN)
        || (result === RESULT_FLAG.CAT_WIN && prevTurn === TURN.CAT_TURN)
        if (canWin) {
          results[prevMouse][prevCat][prevTurn][0] = result
          results[prevMouse][prevCat][prevTurn][1] = moves + 1
          queue.push([prevMouse, prevCat, prevTurn])
        }
        else {
          degrees[prevMouse][prevCat][prevTurn]--
          if (degrees[prevMouse][prevCat][prevTurn] === 0) {
            const loseResult = prevTurn === TURN.MOUSE_TURN ? RESULT_FLAG.CAT_WIN : RESULT_FLAG.MOUSE_WIN
            results[prevMouse][prevCat][prevTurn][0] = loseResult
            results[prevMouse][prevCat][prevTurn][1] = moves + 1
            queue.push([prevMouse, prevCat, prevTurn])
          }
        }
      }
    }
  }

  const [result, move] = results[startMouse][startCat][TURN.MOUSE_TURN]
  return result === RESULT_FLAG.MOUSE_WIN && move <= MAX_MOVES

  function getPrevStates(mouse: number, cat: number, turn: TURN): StateType[] {
    const prevStates: StateType[] = []
    const [mouseRow, mouseCol] = getPos(mouse)
    const [catRow, catCol] = getPos(cat)
    const prevTurn = turn === TURN.MOUSE_TURN ? TURN.CAT_TURN : TURN.MOUSE_TURN
    const maxJump = prevTurn === TURN.MOUSE_TURN ? mouseJump : catJump
    const startRow = prevTurn === TURN.MOUSE_TURN ? mouseRow : catRow
    const startCol = prevTurn === TURN.MOUSE_TURN ? mouseCol : catCol
    prevStates.push([mouse, cat, prevTurn])

    for (const dir of DIRS) {
      for (
        let i = startRow + dir[0], j = startCol + dir[1], jump = 1;
        i >= 0 && i < rows && j >= 0 && j < cols && grid[i][j] !== '#' && jump <= maxJump;
        i += dir[0], j += dir[1], jump++
      ) {
        const prevMouseRow = prevTurn === TURN.MOUSE_TURN ? i : mouseRow
        const prevMouseCol = prevTurn === TURN.MOUSE_TURN ? j : mouseCol
        const prevCatRow = prevTurn === TURN.MOUSE_TURN ? catRow : i
        const prevCatCol = prevTurn === TURN.MOUSE_TURN ? catCol : j
        const prevMouse = getPosKey(prevMouseRow, prevMouseCol)
        const prevCat = getPosKey(prevCatRow, prevCatCol)
        prevStates.push([prevMouse, prevCat, prevTurn])
      }
    }

    return prevStates
  }
}
",False
number,number,5516cd8e1144e5e75d37e49c3a7ed54395946de6,"<fim_prefix>export const NORTH_CODE = 'N';
export const EAST_CODE = 'E';
export const WEST_CODE = 'W';
export const SOUTH_CODE = 'S';
 
export const FORWARD_CODE = 'F';
 
export const RIGHT_CODE = 'R';
export const LEFT_CODE = 'L';

interface ShipPosition  {
  horizontal: number,
  vertical: number,
  direction: string
}

interface Position {
  horizontal: number,
  vertical: number,
}

interface ShipWithWaypoint  {
  ship: Position,
  waypoint: Position
}

const getRotatedDirection = (direction, angle, clockwise) => {
  const directions = [
    EAST_CODE,
    SOUTH_CODE,
    WEST_CODE,
    NORTH_CODE
  ];

  if (!clockwise) {
    directions.reverse();
  }

  const currentDirectionIndex = directions.indexOf(direction);
  const numberOfRotations = angle / 90;

  const newDirectionIndex = (currentDirectionIndex + numberOfRotations) % 4;

  return directions[newDirectionIndex];
}

const getDirectionVector = (direction) => {
  const directions: { [id: string]: Position; } = {}
  directions[EAST_CODE] = { horizontal: 1, vertical: 0 };
  directions[WEST_CODE] = { horizontal: -1, vertical: 0 };
  directions[NORTH_CODE] = { horizontal: 0, vertical: 1 };
  directions[SOUTH_CODE] = { horizontal: 0, vertical: -1 };

  return directions[direction];
}

const getMovedShip = (shipPosition, distance: <fim_suffix>, direction) => {
  const vector = getDirectionVector(direction);

  return {
    ...shipPosition,
    horizontal: shipPosition.horizontal + (vector.horizontal * distance),
    vertical: shipPosition.vertical + (vector.vertical * distance),
  }
}

export function getNewShipPosition(shipPosition, instruction) {
  const [instructionCode, ...value] = instruction.split('');
  const instructionValue = parseInt(value.join(''));

  let newShipPosition = { ...shipPosition };

  switch (instructionCode) {
    case RIGHT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, true);
      break;
    case LEFT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, false);
      break;
    case FORWARD_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, shipPosition.direction);
      break;
    case EAST_CODE:
    case WEST_CODE:
    case NORTH_CODE:
    case SOUTH_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, instructionCode);
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

const getRotatedWaypoint = (position, angle, clockwise) => {
  let rotatedPosition = {...position};

  const numberOfRotations = angle / 90;
  const clockwiseMultiplier = clockwise ? 1 : -1;

  for (let i = 1; i <= numberOfRotations; i++) {
    const horizontal = rotatedPosition.horizontal;
    const vertical = rotatedPosition.vertical;
    rotatedPosition.horizontal = vertical * clockwiseMultiplier;
    rotatedPosition.vertical = horizontal * (-clockwiseMultiplier);
  }

  return rotatedPosition;
}

export function getNewShipPositionWithWaypoint(shipPosition, instruction) {
  const [instructionCode, ...value] = instruction.split('');
  const intValue = parseInt(value.join(''));

  let newShipPosition = JSON.parse(JSON.stringify(shipPosition));

  switch (instructionCode) {
    case FORWARD_CODE:
      newShipPosition.ship.horizontal += shipPosition.waypoint.horizontal * intValue;
      newShipPosition.ship.vertical += shipPosition.waypoint.vertical * intValue;
      break;
    case EAST_CODE:
      newShipPosition.waypoint.horizontal += intValue;
      break;
    case WEST_CODE:
      newShipPosition.waypoint.horizontal -= intValue;
      break;
    case NORTH_CODE:
      newShipPosition.waypoint.vertical += intValue;
      break;
    case SOUTH_CODE:
      newShipPosition.waypoint.vertical -= intValue;
      break;
    case RIGHT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, true)
      break;
    case LEFT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, false)
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

export function getShipManhattanDistance(input) {
  let shipPosition = {
    horizontal: 0,
    vertical: 0,
    direction: EAST_CODE
  }

  for (let line of input) {
    shipPosition = getNewShipPosition(shipPosition, line)
  }

  return Math.abs(shipPosition.horizontal) + Math.abs(shipPosition.vertical);
}

export function getShipManhattanDistanceWithWaypoint(input) {
  let shipPositionWithWaypoint = {
    ship: {
        horizontal: 0,
        vertical: 0
    },
    waypoint: {
        horizontal: 10,
        vertical: 1
    }
  }

  for (let line of input) {
    shipPositionWithWaypoint = getNewShipPositionWithWaypoint(shipPositionWithWaypoint, line)
  }

  return Math.abs(shipPositionWithWaypoint.ship.horizontal) + Math.abs(shipPositionWithWaypoint.ship.vertical);
}
<fim_middle>",correct,2181,"export const NORTH_CODE = 'N';
export const EAST_CODE = 'E';
export const WEST_CODE = 'W';
export const SOUTH_CODE = 'S';
 
export const FORWARD_CODE = 'F';
 
export const RIGHT_CODE = 'R';
export const LEFT_CODE = 'L';

interface ShipPosition  {
  horizontal: number,
  vertical: number,
  direction: string
}

interface Position {
  horizontal: number,
  vertical: number,
}

interface ShipWithWaypoint  {
  ship: Position,
  waypoint: Position
}

const getRotatedDirection = (direction: string, angle: number, clockwise: boolean) => {
  const directions = [
    EAST_CODE,
    SOUTH_CODE,
    WEST_CODE,
    NORTH_CODE
  ];

  if (!clockwise) {
    directions.reverse();
  }

  const currentDirectionIndex = directions.indexOf(direction);
  const numberOfRotations = angle / 90;

  const newDirectionIndex = (currentDirectionIndex + numberOfRotations) % 4;

  return directions[newDirectionIndex];
}

const getDirectionVector = (direction: string) => {
  const directions: { [id: string]: Position; } = {}
  directions[EAST_CODE] = { horizontal: 1, vertical: 0 };
  directions[WEST_CODE] = { horizontal: -1, vertical: 0 };
  directions[NORTH_CODE] = { horizontal: 0, vertical: 1 };
  directions[SOUTH_CODE] = { horizontal: 0, vertical: -1 };

  return directions[direction];
}

const getMovedShip = (shipPosition: ShipPosition, distance: number, direction: string): ShipPosition => {
  const vector = getDirectionVector(direction);

  return {
    ...shipPosition,
    horizontal: shipPosition.horizontal + (vector.horizontal * distance),
    vertical: shipPosition.vertical + (vector.vertical * distance),
  }
}

export function getNewShipPosition(shipPosition: ShipPosition, instruction: string): ShipPosition {
  const [instructionCode, ...value] = instruction.split('');
  const instructionValue = parseInt(value.join(''));

  let newShipPosition = { ...shipPosition };

  switch (instructionCode) {
    case RIGHT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, true);
      break;
    case LEFT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, false);
      break;
    case FORWARD_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, shipPosition.direction);
      break;
    case EAST_CODE:
    case WEST_CODE:
    case NORTH_CODE:
    case SOUTH_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, instructionCode);
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

const getRotatedWaypoint = (position: Position, angle: number, clockwise: boolean) => {
  let rotatedPosition = {...position};

  const numberOfRotations = angle / 90;
  const clockwiseMultiplier = clockwise ? 1 : -1;

  for (let i = 1; i <= numberOfRotations; i++) {
    const horizontal = rotatedPosition.horizontal;
    const vertical = rotatedPosition.vertical;
    rotatedPosition.horizontal = vertical * clockwiseMultiplier;
    rotatedPosition.vertical = horizontal * (-clockwiseMultiplier);
  }

  return rotatedPosition;
}

export function getNewShipPositionWithWaypoint(shipPosition: ShipWithWaypoint, instruction: string): ShipWithWaypoint {
  const [instructionCode, ...value] = instruction.split('');
  const intValue = parseInt(value.join(''));

  let newShipPosition = JSON.parse(JSON.stringify(shipPosition));

  switch (instructionCode) {
    case FORWARD_CODE:
      newShipPosition.ship.horizontal += shipPosition.waypoint.horizontal * intValue;
      newShipPosition.ship.vertical += shipPosition.waypoint.vertical * intValue;
      break;
    case EAST_CODE:
      newShipPosition.waypoint.horizontal += intValue;
      break;
    case WEST_CODE:
      newShipPosition.waypoint.horizontal -= intValue;
      break;
    case NORTH_CODE:
      newShipPosition.waypoint.vertical += intValue;
      break;
    case SOUTH_CODE:
      newShipPosition.waypoint.vertical -= intValue;
      break;
    case RIGHT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, true)
      break;
    case LEFT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, false)
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

export function getShipManhattanDistance(input: string[]): number {
  let shipPosition = {
    horizontal: 0,
    vertical: 0,
    direction: EAST_CODE
  }

  for (let line of input) {
    shipPosition = getNewShipPosition(shipPosition, line)
  }

  return Math.abs(shipPosition.horizontal) + Math.abs(shipPosition.vertical);
}

export function getShipManhattanDistanceWithWaypoint(input: string[]): number {
  let shipPositionWithWaypoint = {
    ship: {
        horizontal: 0,
        vertical: 0
    },
    waypoint: {
        horizontal: 10,
        vertical: 1
    }
  }

  for (let line of input) {
    shipPositionWithWaypoint = getNewShipPositionWithWaypoint(shipPositionWithWaypoint, line)
  }

  return Math.abs(shipPositionWithWaypoint.ship.horizontal) + Math.abs(shipPositionWithWaypoint.ship.vertical);
}
",False
number,number,4e77d6fefc465d02bbfde5576d003dda41ab6508,"<fim_prefix>export type Pitch = number;

export const C = 0 as Pitch;
export const CIS = 1 as Pitch;
export const D = 2 as Pitch;
export const DIS = 3 as Pitch;
export const E = 4 as Pitch;
export const F = 5 as Pitch;
export const FIS = 6 as Pitch;
export const G = 7 as Pitch;
export const GIS = 8 as Pitch;
export const A = 9 as Pitch;
export const AIS = 10 as Pitch;
export const B = 11 as Pitch;

export const NUM_PITCHES = 12;
export const PITCHES = Array.from(Array(NUM_PITCHES).keys()) as Pitch[];

export function getPitchWithOctave(index, octave) {
    const pitch = getPitch(index);
    const octaveFixed = octave + (index / NUM_PITCHES);
    return pitch + octaveFixed;
}

export function getPitch(index: <fim_suffix>) {
    switch (index % NUM_PITCHES) {
        case C:
            return ""C"";
        case CIS:
            return ""C#"";
        case D:
            return ""D"";
        case DIS:
            return ""D#"";
        case E:
            return ""E"";
        case F:
            return ""F"";
        case FIS:
            return ""F#"";
        case G:
            return ""G"";
        case GIS:
            return ""G#"";
        case A:
            return ""A"";
        case AIS:
            return ""A#"";
        case B:
            return ""B"";
        default:
            throw new Error(""Invalid pitch"");
    }
}

export function isBlack(index) {
    return [CIS, DIS, FIS, GIS, AIS].includes(index % NUM_PITCHES);
}

<fim_middle>",correct,3782,"export type Pitch = number;

export const C = 0 as Pitch;
export const CIS = 1 as Pitch;
export const D = 2 as Pitch;
export const DIS = 3 as Pitch;
export const E = 4 as Pitch;
export const F = 5 as Pitch;
export const FIS = 6 as Pitch;
export const G = 7 as Pitch;
export const GIS = 8 as Pitch;
export const A = 9 as Pitch;
export const AIS = 10 as Pitch;
export const B = 11 as Pitch;

export const NUM_PITCHES = 12;
export const PITCHES = Array.from(Array(NUM_PITCHES).keys()) as Pitch[];

export function getPitchWithOctave(index: Pitch, octave: number): string {
    const pitch = getPitch(index);
    const octaveFixed = octave + (index / NUM_PITCHES);
    return pitch + octaveFixed;
}

export function getPitch(index: number): string {
    switch (index % NUM_PITCHES) {
        case C:
            return ""C"";
        case CIS:
            return ""C#"";
        case D:
            return ""D"";
        case DIS:
            return ""D#"";
        case E:
            return ""E"";
        case F:
            return ""F"";
        case FIS:
            return ""F#"";
        case G:
            return ""G"";
        case GIS:
            return ""G#"";
        case A:
            return ""A"";
        case AIS:
            return ""A#"";
        case B:
            return ""B"";
        default:
            throw new Error(""Invalid pitch"");
    }
}

export function isBlack(index: number): boolean {
    return [CIS, DIS, FIS, GIS, AIS].includes(index % NUM_PITCHES);
}

",False
number,number,5138dfd36b6faf2623d71cd5a35b381d02adc19f,"<fim_prefix>export function getHoursAndMinutes(value) {
  let digits = value.split(':').map((digit) => digit.replace(/\D/g, '') || '0');

  if (digits.length === 2) {
    return [Number.parseInt(digits[0], 10), Number.parseInt(digits[1], 10)];
  }

  const timeValue = digits[0];

  if (timeValue.length <= 2) {
    return [Number.parseInt(timeValue, 10), 0];
  }

  return [
    Number.parseInt(timeValue.substr(0, Math.floor(timeValue.length / 2)), 10),
    Number.parseInt(timeValue.substr(Math.floor(timeValue.length / 2), 2), 10),
  ];
}

type TimePeriod = 'AM' | 'PM' | null;

export function getTimePeriod(value) {
  const lowercaseValue = value.toLowerCase();

  if (lowercaseValue.includes('p')) {
    return 'PM';
  }

  if (lowercaseValue.includes('a')) {
    return 'AM';
  }

  return null;
}

export function convertTo12Hour(
  hours,
  minutes,
  timePeriod,
  padHoursWithZero = false,
) {
  let _hours = hours;
  let _minutes = minutes;
  let _timePeriod = timePeriod;

  if (hours > 24) {
    _hours = 12;
  }

  if (timePeriod === null) {
    _timePeriod = 'AM';
  }

  if (hours >= 12 && hours < 24 && timePeriod !== 'AM') {
    _timePeriod = 'PM';
  }

  if (minutes > 59) {
    _minutes = 0;
  }

  _hours = _hours % 12;
  _hours = _hours ? _hours : 12;

  return `${
    padHoursWithZero ? addLeadingZero(_hours) : _hours
  }:${addLeadingZero(_minutes)} ${_timePeriod}`;
}

export function convertTo24Hour(
  hours,
  minutes,
  timePeriod,
) {
  let _hours = hours;
  let _minutes = minutes;

  if (hours >= 0 && hours < 12 && timePeriod === 'PM') {
    _hours += 12;
  }

  if (hours > 23 || (hours === 12 && timePeriod === 'AM')) {
    _hours = 0;
  }

  if (minutes > 59) {
    _minutes = 0;
  }

  return `${addLeadingZero(_hours)}:${addLeadingZero(_minutes)}`;
}

function addLeadingZero(value: <fim_suffix>) {
  return value < 10 ? '0' + value : value.toString();
}
<fim_middle>",correct,4245,"export function getHoursAndMinutes(value: string): [number, number] {
  let digits = value.split(':').map((digit) => digit.replace(/\D/g, '') || '0');

  if (digits.length === 2) {
    return [Number.parseInt(digits[0], 10), Number.parseInt(digits[1], 10)];
  }

  const timeValue = digits[0];

  if (timeValue.length <= 2) {
    return [Number.parseInt(timeValue, 10), 0];
  }

  return [
    Number.parseInt(timeValue.substr(0, Math.floor(timeValue.length / 2)), 10),
    Number.parseInt(timeValue.substr(Math.floor(timeValue.length / 2), 2), 10),
  ];
}

type TimePeriod = 'AM' | 'PM' | null;

export function getTimePeriod(value: string): TimePeriod {
  const lowercaseValue = value.toLowerCase();

  if (lowercaseValue.includes('p')) {
    return 'PM';
  }

  if (lowercaseValue.includes('a')) {
    return 'AM';
  }

  return null;
}

export function convertTo12Hour(
  hours: number,
  minutes: number,
  timePeriod: TimePeriod,
  padHoursWithZero: boolean = false,
) {
  let _hours = hours;
  let _minutes = minutes;
  let _timePeriod = timePeriod;

  if (hours > 24) {
    _hours = 12;
  }

  if (timePeriod === null) {
    _timePeriod = 'AM';
  }

  if (hours >= 12 && hours < 24 && timePeriod !== 'AM') {
    _timePeriod = 'PM';
  }

  if (minutes > 59) {
    _minutes = 0;
  }

  _hours = _hours % 12;
  _hours = _hours ? _hours : 12;

  return `${
    padHoursWithZero ? addLeadingZero(_hours) : _hours
  }:${addLeadingZero(_minutes)} ${_timePeriod}`;
}

export function convertTo24Hour(
  hours: number,
  minutes: number,
  timePeriod: TimePeriod,
) {
  let _hours = hours;
  let _minutes = minutes;

  if (hours >= 0 && hours < 12 && timePeriod === 'PM') {
    _hours += 12;
  }

  if (hours > 23 || (hours === 12 && timePeriod === 'AM')) {
    _hours = 0;
  }

  if (minutes > 59) {
    _minutes = 0;
  }

  return `${addLeadingZero(_hours)}:${addLeadingZero(_minutes)}`;
}

function addLeadingZero(value: number): string {
  return value < 10 ? '0' + value : value.toString();
}
",False
number,number,54882c1b4f5afd785ff8918678f1ada0fdf4020a,"<fim_prefix>// Product Tag
export type ProductTags = 'nike' | 'puma' | 'lifestyle' | 'caprese';

// Product Colors
export type ProductColor = 'white' | 'black' | 'red' | 'green' | 'purple' | 'yellow' | 'blue' | 'gray' | 'orange' | 'pink';


export class Product {
  id?: number;
  name?: string;
  price?: number;
  quantity?: number;
  type?: string;
  // tslint:disable-next-line:variable-name
  discount_price?: number;
  discount?: number;
  pictures?: string;
  // tslint:disable-next-line:variable-name
  image_url?: string;
  state?: string;
  // tslint:disable-next-line:variable-name
  is_used?: boolean;
  // tslint:disable-next-line:variable-name
  short_description?: string;
  description?: string;
  stock?: number;
  newPro?: boolean;
  brand?: string;
  sale?: boolean;
  category?: string;
  tags?: ProductTags[];
  colors?: ProductColor[];

  constructor(
    id?,
    name?,
    price?,
    quantity?,
    // tslint:disable-next-line:variable-name
    discount_price?,
    discount?,
    pictures?,
    type?,
    // tslint:disable-next-line:variable-name
    short_description?,
    description?,
    // tslint:disable-next-line:variable-name
    is_used?,
    stock?: <fim_suffix>,
    state?,
    newPro?,
    brand?,
    sale?,
    category?,
    tags?,
    colors?
  ) {
    this.id = id;
    this.name = name;
    this.price = price;
    this.quantity = quantity;
    this.type = type;
    this.is_used = is_used;
    this.discount_price = discount_price;
    this.discount = discount;
    this.pictures = pictures;
    this.short_description = short_description;
    this.description = description;
    this.stock = stock;
    this.newPro = newPro;
    this.brand = brand;
    this.sale = sale;
    this.category = category;
    this.tags = tags;
    this.colors = colors;
    this.state = state;
  }

}

// Color Filter
export interface ColorFilter {
  color?: ProductColor;
}
<fim_middle>",correct,4619,"// Product Tag
export type ProductTags = 'nike' | 'puma' | 'lifestyle' | 'caprese';

// Product Colors
export type ProductColor = 'white' | 'black' | 'red' | 'green' | 'purple' | 'yellow' | 'blue' | 'gray' | 'orange' | 'pink';


export class Product {
  id?: number;
  name?: string;
  price?: number;
  quantity?: number;
  type?: string;
  // tslint:disable-next-line:variable-name
  discount_price?: number;
  discount?: number;
  pictures?: string;
  // tslint:disable-next-line:variable-name
  image_url?: string;
  state?: string;
  // tslint:disable-next-line:variable-name
  is_used?: boolean;
  // tslint:disable-next-line:variable-name
  short_description?: string;
  description?: string;
  stock?: number;
  newPro?: boolean;
  brand?: string;
  sale?: boolean;
  category?: string;
  tags?: ProductTags[];
  colors?: ProductColor[];

  constructor(
    id?: number,
    name?: string,
    price?: number,
    quantity?: number,
    // tslint:disable-next-line:variable-name
    discount_price?: number,
    discount?: number,
    pictures?: string,
    type?: string,
    // tslint:disable-next-line:variable-name
    short_description?: string,
    description?: string,
    // tslint:disable-next-line:variable-name
    is_used?: boolean,
    stock?: number,
    state?: string,
    newPro?: boolean,
    brand?: string,
    sale?: boolean,
    category?: string,
    tags?: ProductTags[],
    colors?: ProductColor[]
  ) {
    this.id = id;
    this.name = name;
    this.price = price;
    this.quantity = quantity;
    this.type = type;
    this.is_used = is_used;
    this.discount_price = discount_price;
    this.discount = discount;
    this.pictures = pictures;
    this.short_description = short_description;
    this.description = description;
    this.stock = stock;
    this.newPro = newPro;
    this.brand = brand;
    this.sale = sale;
    this.category = category;
    this.tags = tags;
    this.colors = colors;
    this.state = state;
  }

}

// Color Filter
export interface ColorFilter {
  color?: ProductColor;
}
",False
string,string,9561f88ffc8f31e9c7d0151d058ab8d7dc194fb3,"<fim_prefix>
const literalTypes = () => {
  let places: 'sea' | 'mountain';
  let numbers: 5 | 4 | 3 | 2 | 1;
  
  type Mixed = string | number
  const age1: Mixed = 25
  const age2: Mixed = '25'

  places = 'sea';
  places = 'mountain';

  // numbers = 10;
  numbers = 3
  numbers = 1
}

const restType = () => {
  const myCollections: string[] = ['1', '2', '3']

  const myNewCollections = [
    ...myCollections,
    '4',
    '5'
  ]
}

// variadic tuple
const typeTuple = () => {
  const myTup: [string, boolean] = ['John', true]
  
  const anotherTup: [string, number, (a, b) => boolean] = [
    'john',
    18,
    function (first, second) {
      return (first + second) % 10 === 0
    }
  ]

  type RestAndBool = [...any[], boolean]
  const restAndBool: RestAndBool = [
    true,
    1,
    2,
    'as',
    true,
  ]

  type StringAndRest = [string, ...any[]]
  const stringAndRest: StringAndRest = [
    '1',
    '2',
    true,
  ]
}

const typeArrayFunction = () => {
  // @ts-ignore
  const arrFns: [() => string] = [
    () => {
      return 'valid'
    },
    (a, b): <fim_suffix> => {
      const h = a + b
      return a + b as unknown as string
    }
  ]

  const arrFns2: Array<() => string> = [
    () => {
      return 'valid'
    },
  ]

  const objFn: { () }[] = [
    () => 'still ok',
    () => {
      return 'also ok'
    },
  ]
}

const fnJSONType = () => {
  const myJson: { [key: string]: any } = {
    abc: 'foo',
    def: 'bar',
    num: 123
  }
}<fim_middle>",correct,398,"
const literalTypes = () => {
  let places: 'sea' | 'mountain';
  let numbers: 5 | 4 | 3 | 2 | 1;
  
  type Mixed = string | number
  const age1: Mixed = 25
  const age2: Mixed = '25'

  places = 'sea';
  places = 'mountain';

  // numbers = 10;
  numbers = 3
  numbers = 1
}

const restType = () => {
  const myCollections: string[] = ['1', '2', '3']

  const myNewCollections = [
    ...myCollections,
    '4',
    '5'
  ]
}

// variadic tuple
const typeTuple = () => {
  const myTup: [string, boolean] = ['John', true]
  
  const anotherTup: [string, number, (a: number, b: number) => boolean] = [
    'john',
    18,
    function (first: number, second: number): boolean {
      return (first + second) % 10 === 0
    }
  ]

  type RestAndBool = [...any[], boolean]
  const restAndBool: RestAndBool = [
    true,
    1,
    2,
    'as',
    true,
  ]

  type StringAndRest = [string, ...any[]]
  const stringAndRest: StringAndRest = [
    '1',
    '2',
    true,
  ]
}

const typeArrayFunction = () => {
  // @ts-ignore
  const arrFns: [() => string] = [
    (): string => {
      return 'valid'
    },
    (a: number, b: number): string => {
      const h = a + b
      return a + b as unknown as string
    }
  ]

  const arrFns2: Array<() => string> = [
    (): string => {
      return 'valid'
    },
  ]

  const objFn: { (): string }[] = [
    (): string => 'still ok',
    (): string => {
      return 'also ok'
    },
  ]
}

const fnJSONType = () => {
  const myJson: { [key: string]: any } = {
    abc: 'foo',
    def: 'bar',
    num: 123
  }
}",False
string,string,1b0e94bf7d3c6477c0f89caf09f284b1c8441493,"<fim_prefix>export const InputBufferAddresses = {
    globalLockAddr: 0,
    mouseMoveFlagAddr: 1,
    mouseMoveXDeltaAddr: 2,
    mouseMoveYDeltaAddr: 3,
    mouseButtonStateAddr: 4,
    keyEventFlagAddr: 5,
    keyCodeAddr: 6,
    keyStateAddr: 7,
    stopFlagAddr: 8,
};

export type EmulatorMouseEvent =
    | {type: ""mousemove""; dx: number; dy: number}
    | {type: ""mousedown""}
    | {type: ""mouseup""};
export type EmulatorTouchEvent = {type: ""touchstart""; dx: number; dy: number};
export type EmulatorKeyboardEvent = {
    type: ""keydown"" | ""keyup"";
    keyCode: number;
};
export type EmulatorStopEvent = {
    type: ""stop"";
};

export type EmulatorInputEvent =
    | EmulatorMouseEvent
    | EmulatorTouchEvent
    | EmulatorKeyboardEvent
    | EmulatorStopEvent;

export enum LockStates {
    READY_FOR_UI_THREAD,
    UI_THREAD_LOCK,
    READY_FOR_EMUL_THREAD,
    EMUL_THREAD_LOCK,
}

export type EmulatorChunkedFileSpec = {
    baseUrl: string;
    totalSize: number;
    chunkCount: number;
    chunkSize: number;
    version: string;
    prefetchChunks: number[];
};

export function generateChunkUrl(
    spec,
    chunk
): <fim_suffix> {
    return `${spec.baseUrl}.${chunk}.br?v=${spec.version}`;
}

export type EmulatorWorkerConfig = {
    jsUrl: string;
    wasmUrl: string;
    disk: EmulatorChunkedFileSpec;
    autoloadFiles: {[name: string]: ArrayBuffer};
    persistedData?: EmulatorWorkerDirectorExtraction;
    arguments: string[];
    video: EmulatorWorkerVideoConfig;
    input: EmulatorWorkerInputConfig;
    audio: EmulatorWorkerAudioConfig;
    files: EmulatorWorkerFilesConfig;
};

export type EmulatorWorkerVideoConfig =
    | EmulatorWorkerSharedMemoryVideoConfig
    | EmulatorWorkerFallbackVideoConfig;

export type EmulatorWorkerSharedMemoryVideoConfig = {
    type: ""shared-memory"";
    screenBuffer: SharedArrayBuffer;
    screenBufferSize: number;
    videoModeBuffer: SharedArrayBuffer;
    videoModeBufferSize: number;
    screenWidth: number;
    screenHeight: number;
};

export type EmulatorWorkerFallbackVideoConfig = {type: ""fallback""};

export type EmulatorWorkerVideoBlit =
    | EmulatorWorkerSharedMemoryVideoBlit
    | EmulatorWorkerFallbackVideoBlit;

export type EmulatorWorkerSharedMemoryVideoBlit = {
    type: ""shared-memory"";
};

export type EmulatorWorkerFallbackVideoBlit = {
    type: ""fallback"";
    data: Uint8Array;
    width: number;
    height: number;
    depth: number;
    usingPalette: number;
};

export type EmulatorWorkerInputConfig =
    | EmulatorWorkerSharedMemoryInputConfig
    | EmulatorWorkerFallbackInputConfig;

export type EmulatorWorkerSharedMemoryInputConfig = {
    type: ""shared-memory"";
    inputBuffer: SharedArrayBuffer;
    inputBufferSize: number;
};

export type EmulatorWorkerFallbackInputConfig = {
    type: ""fallback"";
    inputBufferSize: number;
};

export type EmulatorWorkerAudioConfig =
    | EmulatorWorkerSharedMemoryAudioConfig
    | EmulatorWorkerFallbackAudioConfig;

export type EmulatorWorkerSharedMemoryAudioConfig = {
    type: ""shared-memory"";
    audioDataBuffer: SharedArrayBuffer;
    audioDataBufferSize: number;
    audioBlockBufferSize: number;
    audioBlockChunkSize: number;
};

export type EmulatorWorkerFallbackAudioConfig = {type: ""fallback""};

export type EmulatorWorkerFilesConfig =
    | EmulatorWorkerSharedMemoryFilesConfig
    | EmulatorWorkerFallbackFilesConfig;

export type EmulatorWorkerSharedMemoryFilesConfig = {
    type: ""shared-memory"";
    filesBuffer: SharedArrayBuffer;
    filesBufferSize: number;
};

export type EmulatorFileActions = {
    uploads: EmulatorFileUpload[];
};

export type EmulatorWorkerFallbackFilesConfig = {
    type: ""fallback"";
};

export type EmulatorFileUpload = {name: string; url: string; size: number};

export type EmulatorFallbackCommand =
    | EmulatorFallbackInputCommand
    | EmulatorFallbackUploadFileCommand;

export type EmulatorFallbackInputCommand = {
    type: ""input"";
    event: EmulatorInputEvent;
};

export type EmulatorFallbackUploadFileCommand = {
    type: ""upload_file"";
    upload: EmulatorFileUpload;
};

export function updateInputBufferWithEvents(
    inputEvents,
    inputBufferView
) {
    let hasMouseMove = false;
    let mouseMoveX = 0;
    let mouseMoveY = 0;
    let mouseButtonState = -1;
    let hasKeyEvent = false;
    let keyCode = -1;
    let keyState = -1;
    let hasStop = false;
    // currently only one key event can be sent per sync
    // TODO: better key handling code
    const remainingEvents: EmulatorInputEvent[] = [];
    for (const inputEvent of inputEvents) {
        switch (inputEvent.type) {
            case ""touchstart"":
                // We need to make sure that the mouse is first moved to the
                // current location and then we send the mousedown, otherwise
                // the Mac thinks that the mouse was moved with the button down,
                // and interprets it as a drag.
                hasMouseMove = true;
                mouseMoveX += inputEvent.dx;
                mouseMoveY += inputEvent.dy;
                remainingEvents.push({type: ""mousedown""});
                break;
            case ""mousemove"":
                if (hasMouseMove) {
                    break;
                }
                hasMouseMove = true;
                mouseMoveX += inputEvent.dx;
                mouseMoveY += inputEvent.dy;
                break;
            case ""mousedown"":
            case ""mouseup"":
                mouseButtonState = inputEvent.type === ""mousedown"" ? 1 : 0;
                break;
            case ""keydown"":
            case ""keyup"":
                if (hasKeyEvent) {
                    remainingEvents.push(inputEvent);
                    break;
                }
                hasKeyEvent = true;
                keyState = inputEvent.type === ""keydown"" ? 1 : 0;
                keyCode = inputEvent.keyCode;
                break;
            case ""stop"":
                hasStop = true;
                break;
        }
    }
    if (hasMouseMove) {
        inputBufferView[InputBufferAddresses.mouseMoveFlagAddr] = 1;
        inputBufferView[InputBufferAddresses.mouseMoveXDeltaAddr] = mouseMoveX;
        inputBufferView[InputBufferAddresses.mouseMoveYDeltaAddr] = mouseMoveY;
    }
    inputBufferView[InputBufferAddresses.mouseButtonStateAddr] =
        mouseButtonState;
    if (hasKeyEvent) {
        inputBufferView[InputBufferAddresses.keyEventFlagAddr] = 1;
        inputBufferView[InputBufferAddresses.keyCodeAddr] = keyCode;
        inputBufferView[InputBufferAddresses.keyStateAddr] = keyState;
    }
    if (hasStop) {
        inputBufferView[InputBufferAddresses.stopFlagAddr] = 1;
    }
    return remainingEvents;
}
export type EmulatorWorkerDirectorExtractionEntry =
    | {
          name: string;
          contents: Uint8Array;
      }
    | {name: string; contents: EmulatorWorkerDirectorExtractionEntry[]};

export type EmulatorWorkerDirectorExtraction = {
    name: string;
    contents: EmulatorWorkerDirectorExtractionEntry[];
};
<fim_middle>",correct,1328,"export const InputBufferAddresses = {
    globalLockAddr: 0,
    mouseMoveFlagAddr: 1,
    mouseMoveXDeltaAddr: 2,
    mouseMoveYDeltaAddr: 3,
    mouseButtonStateAddr: 4,
    keyEventFlagAddr: 5,
    keyCodeAddr: 6,
    keyStateAddr: 7,
    stopFlagAddr: 8,
};

export type EmulatorMouseEvent =
    | {type: ""mousemove""; dx: number; dy: number}
    | {type: ""mousedown""}
    | {type: ""mouseup""};
export type EmulatorTouchEvent = {type: ""touchstart""; dx: number; dy: number};
export type EmulatorKeyboardEvent = {
    type: ""keydown"" | ""keyup"";
    keyCode: number;
};
export type EmulatorStopEvent = {
    type: ""stop"";
};

export type EmulatorInputEvent =
    | EmulatorMouseEvent
    | EmulatorTouchEvent
    | EmulatorKeyboardEvent
    | EmulatorStopEvent;

export enum LockStates {
    READY_FOR_UI_THREAD,
    UI_THREAD_LOCK,
    READY_FOR_EMUL_THREAD,
    EMUL_THREAD_LOCK,
}

export type EmulatorChunkedFileSpec = {
    baseUrl: string;
    totalSize: number;
    chunkCount: number;
    chunkSize: number;
    version: string;
    prefetchChunks: number[];
};

export function generateChunkUrl(
    spec: EmulatorChunkedFileSpec,
    chunk: number
): string {
    return `${spec.baseUrl}.${chunk}.br?v=${spec.version}`;
}

export type EmulatorWorkerConfig = {
    jsUrl: string;
    wasmUrl: string;
    disk: EmulatorChunkedFileSpec;
    autoloadFiles: {[name: string]: ArrayBuffer};
    persistedData?: EmulatorWorkerDirectorExtraction;
    arguments: string[];
    video: EmulatorWorkerVideoConfig;
    input: EmulatorWorkerInputConfig;
    audio: EmulatorWorkerAudioConfig;
    files: EmulatorWorkerFilesConfig;
};

export type EmulatorWorkerVideoConfig =
    | EmulatorWorkerSharedMemoryVideoConfig
    | EmulatorWorkerFallbackVideoConfig;

export type EmulatorWorkerSharedMemoryVideoConfig = {
    type: ""shared-memory"";
    screenBuffer: SharedArrayBuffer;
    screenBufferSize: number;
    videoModeBuffer: SharedArrayBuffer;
    videoModeBufferSize: number;
    screenWidth: number;
    screenHeight: number;
};

export type EmulatorWorkerFallbackVideoConfig = {type: ""fallback""};

export type EmulatorWorkerVideoBlit =
    | EmulatorWorkerSharedMemoryVideoBlit
    | EmulatorWorkerFallbackVideoBlit;

export type EmulatorWorkerSharedMemoryVideoBlit = {
    type: ""shared-memory"";
};

export type EmulatorWorkerFallbackVideoBlit = {
    type: ""fallback"";
    data: Uint8Array;
    width: number;
    height: number;
    depth: number;
    usingPalette: number;
};

export type EmulatorWorkerInputConfig =
    | EmulatorWorkerSharedMemoryInputConfig
    | EmulatorWorkerFallbackInputConfig;

export type EmulatorWorkerSharedMemoryInputConfig = {
    type: ""shared-memory"";
    inputBuffer: SharedArrayBuffer;
    inputBufferSize: number;
};

export type EmulatorWorkerFallbackInputConfig = {
    type: ""fallback"";
    inputBufferSize: number;
};

export type EmulatorWorkerAudioConfig =
    | EmulatorWorkerSharedMemoryAudioConfig
    | EmulatorWorkerFallbackAudioConfig;

export type EmulatorWorkerSharedMemoryAudioConfig = {
    type: ""shared-memory"";
    audioDataBuffer: SharedArrayBuffer;
    audioDataBufferSize: number;
    audioBlockBufferSize: number;
    audioBlockChunkSize: number;
};

export type EmulatorWorkerFallbackAudioConfig = {type: ""fallback""};

export type EmulatorWorkerFilesConfig =
    | EmulatorWorkerSharedMemoryFilesConfig
    | EmulatorWorkerFallbackFilesConfig;

export type EmulatorWorkerSharedMemoryFilesConfig = {
    type: ""shared-memory"";
    filesBuffer: SharedArrayBuffer;
    filesBufferSize: number;
};

export type EmulatorFileActions = {
    uploads: EmulatorFileUpload[];
};

export type EmulatorWorkerFallbackFilesConfig = {
    type: ""fallback"";
};

export type EmulatorFileUpload = {name: string; url: string; size: number};

export type EmulatorFallbackCommand =
    | EmulatorFallbackInputCommand
    | EmulatorFallbackUploadFileCommand;

export type EmulatorFallbackInputCommand = {
    type: ""input"";
    event: EmulatorInputEvent;
};

export type EmulatorFallbackUploadFileCommand = {
    type: ""upload_file"";
    upload: EmulatorFileUpload;
};

export function updateInputBufferWithEvents(
    inputEvents: EmulatorInputEvent[],
    inputBufferView: Int32Array
): EmulatorInputEvent[] {
    let hasMouseMove = false;
    let mouseMoveX = 0;
    let mouseMoveY = 0;
    let mouseButtonState = -1;
    let hasKeyEvent = false;
    let keyCode = -1;
    let keyState = -1;
    let hasStop = false;
    // currently only one key event can be sent per sync
    // TODO: better key handling code
    const remainingEvents: EmulatorInputEvent[] = [];
    for (const inputEvent of inputEvents) {
        switch (inputEvent.type) {
            case ""touchstart"":
                // We need to make sure that the mouse is first moved to the
                // current location and then we send the mousedown, otherwise
                // the Mac thinks that the mouse was moved with the button down,
                // and interprets it as a drag.
                hasMouseMove = true;
                mouseMoveX += inputEvent.dx;
                mouseMoveY += inputEvent.dy;
                remainingEvents.push({type: ""mousedown""});
                break;
            case ""mousemove"":
                if (hasMouseMove) {
                    break;
                }
                hasMouseMove = true;
                mouseMoveX += inputEvent.dx;
                mouseMoveY += inputEvent.dy;
                break;
            case ""mousedown"":
            case ""mouseup"":
                mouseButtonState = inputEvent.type === ""mousedown"" ? 1 : 0;
                break;
            case ""keydown"":
            case ""keyup"":
                if (hasKeyEvent) {
                    remainingEvents.push(inputEvent);
                    break;
                }
                hasKeyEvent = true;
                keyState = inputEvent.type === ""keydown"" ? 1 : 0;
                keyCode = inputEvent.keyCode;
                break;
            case ""stop"":
                hasStop = true;
                break;
        }
    }
    if (hasMouseMove) {
        inputBufferView[InputBufferAddresses.mouseMoveFlagAddr] = 1;
        inputBufferView[InputBufferAddresses.mouseMoveXDeltaAddr] = mouseMoveX;
        inputBufferView[InputBufferAddresses.mouseMoveYDeltaAddr] = mouseMoveY;
    }
    inputBufferView[InputBufferAddresses.mouseButtonStateAddr] =
        mouseButtonState;
    if (hasKeyEvent) {
        inputBufferView[InputBufferAddresses.keyEventFlagAddr] = 1;
        inputBufferView[InputBufferAddresses.keyCodeAddr] = keyCode;
        inputBufferView[InputBufferAddresses.keyStateAddr] = keyState;
    }
    if (hasStop) {
        inputBufferView[InputBufferAddresses.stopFlagAddr] = 1;
    }
    return remainingEvents;
}
export type EmulatorWorkerDirectorExtractionEntry =
    | {
          name: string;
          contents: Uint8Array;
      }
    | {name: string; contents: EmulatorWorkerDirectorExtractionEntry[]};

export type EmulatorWorkerDirectorExtraction = {
    name: string;
    contents: EmulatorWorkerDirectorExtractionEntry[];
};
",False
string,string,97dca01248d8bc1f3e4e2fc93faa08dceabb61d6,"<fim_prefix>type NeonValue =
	| NeonConfig
	| NeonArray
	| string
	| number
	| boolean
	| RegExp
	| InvalidNeonValue;
interface NeonConfig {
	[key: string]: NeonValue;
}
export interface InvalidNeonValue {
	readonly invalid: true;
	source: string;
}
type NeonArray = NeonValue[];

export type NeonFile = NeonConfig;

interface IndexHolder {
	index: number;
}

function _parseSpecialValue(value: <fim_suffix>) {
	if (value === 'true') {
		return true;
	}
	if (value === 'false') {
		return false;
	}
	if (/^[0-9]+(\.[0-9]+)?$/.test(value)) {
		return parseFloat(value);
	}
	if (
		(value.startsWith(""'"") && value.endsWith(""'"")) ||
		(value.startsWith('""') && value.endsWith('""'))
	) {
		value = value.slice(1, -1);
	}
	if (value.startsWith('#') && value.endsWith('#')) {
		try {
			return new RegExp(value.slice(1, -1).replace(/\\\\/g, '\\'));
		} catch (e) {
			return new RegExp(value.slice(1, -1).replace(/\\\\/g, '\\'));
		}
	}
	return value;
}

function parseSpecialValue(value) {
	try {
		return _parseSpecialValue(value);
	} catch (e) {
		return {
			invalid: true,
			source: value,
		};
	}
}

function parseNeonArray(lines, holder) {
	const arr: NeonArray = [];
	for (; holder.index < lines.length; holder.index++) {
		const line = filterOutComment(lines[holder.index]).trim();
		if (line === '') {
			continue;
		}
		if (!line.includes('-')) {
			holder.index--;
			break;
		}

		const [, ...value] = line.split('-');
		if (value.join('-').trim().length > 0) {
			arr.push(parseSpecialValue(value.join('-').trim()));
		} else {
			// Object
			holder.index++;
			const parsed = tryParse(lines, holder);
			if (parsed) {
				arr.push(parsed);
			}
		}
	}
	return arr;
}

function filterOutComment(line) {
	let stringDelimiter: '""' | ""'"" | null = null;
	for (let i = 0; i < line.length; i++) {
		if ((line[i] === '""' || line[i] === ""'"") && line[i - 1] !== '\\') {
			if (line[i] === stringDelimiter) {
				stringDelimiter = null;
			} else if (stringDelimiter === null) {
				stringDelimiter = line[i] as '""' | ""'"";
			}
		}
		if (line[i] === '#' && stringDelimiter === null) {
			return line.slice(0, i);
		}
	}
	return line;
}

// TODO: fix hashes in the center of the strings
function parseNeonObject(lines, holder) {
	const obj: NeonConfig = {};
	for (; holder.index < lines.length; holder.index++) {
		const line = lines[holder.index].trim();
		const unCommented = filterOutComment(line).trim();
		if (unCommented === '') {
			continue;
		}
		if (unCommented === '-') {
			holder.index--;
			break;
		}

		const [key, ...value] = unCommented.split(':');
		if (value.length && value.join(':').trim().length > 0) {
			obj[key] = parseSpecialValue(value.join(':').trim());
		} else {
			// Special value
			holder.index++;
			const parsed = tryParse(lines, holder);
			if (parsed) {
				obj[key] = parsed;
			}
		}
	}
	return obj;
}

function tryParse(
	lines,
	holder
) {
	const line = lines[holder.index];
	if (!line) {
		return null;
	}
	if (line.includes(':')) {
		return parseNeonObject(lines, holder);
	} else if (line.includes('-')) {
		return parseNeonArray(lines, holder);
	} else {
		holder.index++;
		return tryParse(lines, holder);
	}
}

export function parseNeonFile(content) {
	return parseNeonObject(content.split('\n'), { index: 0 });
}
<fim_middle>",correct,1664,"type NeonValue =
	| NeonConfig
	| NeonArray
	| string
	| number
	| boolean
	| RegExp
	| InvalidNeonValue;
interface NeonConfig {
	[key: string]: NeonValue;
}
export interface InvalidNeonValue {
	readonly invalid: true;
	source: string;
}
type NeonArray = NeonValue[];

export type NeonFile = NeonConfig;

interface IndexHolder {
	index: number;
}

function _parseSpecialValue(value: string): NeonValue {
	if (value === 'true') {
		return true;
	}
	if (value === 'false') {
		return false;
	}
	if (/^[0-9]+(\.[0-9]+)?$/.test(value)) {
		return parseFloat(value);
	}
	if (
		(value.startsWith(""'"") && value.endsWith(""'"")) ||
		(value.startsWith('""') && value.endsWith('""'))
	) {
		value = value.slice(1, -1);
	}
	if (value.startsWith('#') && value.endsWith('#')) {
		try {
			return new RegExp(value.slice(1, -1).replace(/\\\\/g, '\\'));
		} catch (e) {
			return new RegExp(value.slice(1, -1).replace(/\\\\/g, '\\'));
		}
	}
	return value;
}

function parseSpecialValue(value: string): NeonValue {
	try {
		return _parseSpecialValue(value);
	} catch (e) {
		return {
			invalid: true,
			source: value,
		};
	}
}

function parseNeonArray(lines: string[], holder: IndexHolder): NeonArray {
	const arr: NeonArray = [];
	for (; holder.index < lines.length; holder.index++) {
		const line = filterOutComment(lines[holder.index]).trim();
		if (line === '') {
			continue;
		}
		if (!line.includes('-')) {
			holder.index--;
			break;
		}

		const [, ...value] = line.split('-');
		if (value.join('-').trim().length > 0) {
			arr.push(parseSpecialValue(value.join('-').trim()));
		} else {
			// Object
			holder.index++;
			const parsed = tryParse(lines, holder);
			if (parsed) {
				arr.push(parsed);
			}
		}
	}
	return arr;
}

function filterOutComment(line: string): string {
	let stringDelimiter: '""' | ""'"" | null = null;
	for (let i = 0; i < line.length; i++) {
		if ((line[i] === '""' || line[i] === ""'"") && line[i - 1] !== '\\') {
			if (line[i] === stringDelimiter) {
				stringDelimiter = null;
			} else if (stringDelimiter === null) {
				stringDelimiter = line[i] as '""' | ""'"";
			}
		}
		if (line[i] === '#' && stringDelimiter === null) {
			return line.slice(0, i);
		}
	}
	return line;
}

// TODO: fix hashes in the center of the strings
function parseNeonObject(lines: string[], holder: IndexHolder): NeonConfig {
	const obj: NeonConfig = {};
	for (; holder.index < lines.length; holder.index++) {
		const line = lines[holder.index].trim();
		const unCommented = filterOutComment(line).trim();
		if (unCommented === '') {
			continue;
		}
		if (unCommented === '-') {
			holder.index--;
			break;
		}

		const [key, ...value] = unCommented.split(':');
		if (value.length && value.join(':').trim().length > 0) {
			obj[key] = parseSpecialValue(value.join(':').trim());
		} else {
			// Special value
			holder.index++;
			const parsed = tryParse(lines, holder);
			if (parsed) {
				obj[key] = parsed;
			}
		}
	}
	return obj;
}

function tryParse(
	lines: string[],
	holder: IndexHolder
): NeonConfig | NeonArray | null {
	const line = lines[holder.index];
	if (!line) {
		return null;
	}
	if (line.includes(':')) {
		return parseNeonObject(lines, holder);
	} else if (line.includes('-')) {
		return parseNeonArray(lines, holder);
	} else {
		holder.index++;
		return tryParse(lines, holder);
	}
}

export function parseNeonFile(content: string): NeonConfig {
	return parseNeonObject(content.split('\n'), { index: 0 });
}
",False
string,string,f5af1e91356527eb5d685f57986a63f3cc187b56,"<fim_prefix>export interface BadSmellTableData {
  key?: string;
  dimension: string;
  badSmell: string;
  condition: string;
  threshold: number;
  rowspan?: number;
}

export const BadSmellThresholdTableColumns = [
  {
    title: ""评估维度"",
    dataIndex: ""dimension"",
    key: ""dimension"",
    render: (text: <fim_suffix>, row) => {
      if (row.rowspan !== undefined) {
        return {
          children: text,
          props: {
            rowSpan: row.rowspan,
          },
        };
      }
      return text;
    },
  },
  {
    title: ""坏味道"",
    dataIndex: ""badSmell"",
    key: ""badSmell"",
  },
  {
    title: ""判断条件"",
    dataIndex: ""condition"",
    key: ""condition"",
  },
  {
    title: ""指标阈值"",
    dataIndex: ""threshold"",
    key: ""threshold"",
  },
];

export const BadSmellThresholdTableData = [
  {
    name: ""体量维度"",
    threshold: [
      {
        name: ""过大的方法"",
        condition: ""方法代码行数 > 指标阈值"",
        value: 30,
      },
      {
        name: ""过大的方法"",
        condition: ""方法个数 > 指标阈值"",
        value: 20,
      },
    ],
  },
  {
    name: ""耦合维度"",
    threshold: [
      {
        key: ""dataMud"",
        name: ""数据泥团"",
        condition: ""缺乏内聚指标LCOM4 > 指标阈值"",
        value: 6,
      },
      {
        key: ""deepInheritance"",
        name: ""过深继承"",
        condition: ""继承深度 > 指标阈值"",
        value: 6,
      },
    ],
  },
];
<fim_middle>",correct,2396,"export interface BadSmellTableData {
  key?: string;
  dimension: string;
  badSmell: string;
  condition: string;
  threshold: number;
  rowspan?: number;
}

export const BadSmellThresholdTableColumns = [
  {
    title: ""评估维度"",
    dataIndex: ""dimension"",
    key: ""dimension"",
    render: (text: string, row: BadSmellTableData) => {
      if (row.rowspan !== undefined) {
        return {
          children: text,
          props: {
            rowSpan: row.rowspan,
          },
        };
      }
      return text;
    },
  },
  {
    title: ""坏味道"",
    dataIndex: ""badSmell"",
    key: ""badSmell"",
  },
  {
    title: ""判断条件"",
    dataIndex: ""condition"",
    key: ""condition"",
  },
  {
    title: ""指标阈值"",
    dataIndex: ""threshold"",
    key: ""threshold"",
  },
];

export const BadSmellThresholdTableData = [
  {
    name: ""体量维度"",
    threshold: [
      {
        name: ""过大的方法"",
        condition: ""方法代码行数 > 指标阈值"",
        value: 30,
      },
      {
        name: ""过大的方法"",
        condition: ""方法个数 > 指标阈值"",
        value: 20,
      },
    ],
  },
  {
    name: ""耦合维度"",
    threshold: [
      {
        key: ""dataMud"",
        name: ""数据泥团"",
        condition: ""缺乏内聚指标LCOM4 > 指标阈值"",
        value: 6,
      },
      {
        key: ""deepInheritance"",
        name: ""过深继承"",
        condition: ""继承深度 > 指标阈值"",
        value: 6,
      },
    ],
  },
];
",False
string,string,2cb59d73168b34abd1b1fdfe682092c10381edc8,"<fim_prefix>export type StringMap = Record<string, string>;

const PROPERTY_NAME_DENY_LIST = Object.freeze(['__proto__', 'prototype']);

// TODO: unit tests
export class QueryString {
  static parseDeep(queryString: <fim_suffix>) {
    const obj = this.parse(queryString);
    return this.deepen(obj);
  }

  static stringifyDeep(obj) {
    const map = this.flatten(obj);
    return this.stringify(map);
  }

  static parse(queryString) {
    const query: StringMap = {};
    const pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
    for (let i = 0; i < pairs.length; i++) {
      const pair = pairs[i].split('=');
      // TODO: node support?
      try {
        query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
      } catch (error) {
        // Ignore malformed URI components
      }
    }
    return query;
  }

  static stringify(map) {
    let str = '';
    for (const key in map) {
      if (map.hasOwnProperty(key)) {
        const value = map[key];
        if (str) {
          str += '&';
        }
        str += encodeURIComponent(key) + '=' + encodeURIComponent(value);
      }
    }
    return str;
  }

  static deepen(map) {
    // FIXME; Should be type Tree = Record<string, string | Tree>
    // requires a typescript upgrade.
    const output: any = Object.create(null);
    for (const k in map) {
      let t = output;
      const parts = k.split('.');
      const key = parts.pop()!;
      for (const part of parts) {
        assertAllowedPropertyName(part);
        t = t[part] = t[part] || Object.create(null);
      }
      t[key] = map[k];
    }
    return output;
  }

  static flatten(obj, _current?, _res = {}) {
    for (const key in obj) {
      const value = obj[key];
      const newKey = _current ? _current + '.' + key : key;
      if (value && typeof value === 'object') {
        this.flatten(value, newKey, _res);
      } else {
        _res[newKey] = value;
      }
    }

    return _res;
  }
}

function assertAllowedPropertyName(name): asserts name {
  if (PROPERTY_NAME_DENY_LIST.indexOf(name) >= 0)
    throw new Error(`Property name ""${name}"" is not allowed`);
}
<fim_middle>",correct,3128,"export type StringMap = Record<string, string>;

const PROPERTY_NAME_DENY_LIST = Object.freeze(['__proto__', 'prototype']);

// TODO: unit tests
export class QueryString {
  static parseDeep(queryString: string) {
    const obj = this.parse(queryString);
    return this.deepen(obj);
  }

  static stringifyDeep(obj: any) {
    const map = this.flatten(obj);
    return this.stringify(map);
  }

  static parse(queryString: string): StringMap {
    const query: StringMap = {};
    const pairs = (queryString[0] === '?' ? queryString.substr(1) : queryString).split('&');
    for (let i = 0; i < pairs.length; i++) {
      const pair = pairs[i].split('=');
      // TODO: node support?
      try {
        query[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1] || '');
      } catch (error) {
        // Ignore malformed URI components
      }
    }
    return query;
  }

  static stringify(map: StringMap) {
    let str = '';
    for (const key in map) {
      if (map.hasOwnProperty(key)) {
        const value = map[key];
        if (str) {
          str += '&';
        }
        str += encodeURIComponent(key) + '=' + encodeURIComponent(value);
      }
    }
    return str;
  }

  static deepen(map: StringMap) {
    // FIXME; Should be type Tree = Record<string, string | Tree>
    // requires a typescript upgrade.
    const output: any = Object.create(null);
    for (const k in map) {
      let t = output;
      const parts = k.split('.');
      const key = parts.pop()!;
      for (const part of parts) {
        assertAllowedPropertyName(part);
        t = t[part] = t[part] || Object.create(null);
      }
      t[key] = map[k];
    }
    return output;
  }

  static flatten(obj: any, _current?: any, _res: any = {}): StringMap {
    for (const key in obj) {
      const value = obj[key];
      const newKey = _current ? _current + '.' + key : key;
      if (value && typeof value === 'object') {
        this.flatten(value, newKey, _res);
      } else {
        _res[newKey] = value;
      }
    }

    return _res;
  }
}

function assertAllowedPropertyName(name: string): asserts name {
  if (PROPERTY_NAME_DENY_LIST.indexOf(name) >= 0)
    throw new Error(`Property name ""${name}"" is not allowed`);
}
",False
string,string,16ee3eb3e397ea016970eaa94a1f44aa8c2ad71d,"<fim_prefix>export class Coin {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  cmcRank: number;
  numMarketPairs: number;
  circulatingSupply: number;
  totalSupply: number;
  maxSupply: number;
  lastUpdated: Date;
  dateAdded: Date;
  tags: string[];
  platform: Platform;
  quote: Quotes;

  getColour(value): <fim_suffix> {
    if (value > 0) {
      return 'green';
    }
    if (value < 0) {
      return 'red';
    }

    return '';
  }

  // we would like to map properties to javascript naming convention
  constructor(coin) {
    // TODO: add defensive checks
    this.id = coin.id;
    this.name = coin.name;
    this.symbol = coin.symbol;
    this.slug = coin.slug;
    this.cmcRank = coin.cmc_rank;
    this.numMarketPairs = coin.num_market_pairs;
    this.circulatingSupply = coin.circulating_supply;
    this.totalSupply = coin.total_supply;
    this.maxSupply = coin.max_supply;
    this.lastUpdated = coin.last_updated;
    this.dateAdded = coin.date_added;
    this.tags = coin.tags;
    this.platform = coin.platform && new Platform(coin.platform);
    this.quote = coin.quote && new Quotes(coin.quote);
  }
}

export class Platform {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  tokenAddress: string;

  constructor(platform) {
    this.id = platform.id;
    this.name = platform.name;
    this.symbol = platform.symbol;
    this.slug = platform.slug;
    this.tokenAddress = platform.token_address;
  }
}

export class Quotes {
  [key: string]: Quote;

  constructor(quotes) {
    Object.entries(quotes).forEach(([key, value]) => this[key] = new Quote(value));
  }
}

export class Quote {
  price: number;
  volume24h: number;
  volume24hReported: number;
  volume7d: number;
  volume7dReported: number;
  volume30d: number;
  volume30dReported: number;
  marketCap: number;
  change1h: number;
  change24h: number;
  change7d: number;
  lastUpdated: Date;

  constructor(quote) {
    this.price = quote.price;
    this.volume24h = quote.volume_24h;
    this.volume24hReported = quote.volume_24h_reported;
    this.volume7d = quote.volume_7d;
    this.volume7dReported = quote.volume_7d_reported;
    this.volume30d = quote.volume_30d;
    this.volume30dReported = quote.volume_30d_reported;
    this.marketCap = quote.market_cap;
    this.change1h = quote.percent_change_1h / 100;
    this.change24h = quote.percent_change_24h / 100;
    this.change7d = quote.percent_change_7d / 100;
    this.lastUpdated = quote.last_updated;
  }
}

export interface IListingsResponse {
  data: ICoin[];
}

export interface IQuotesResponse {
  data: { [key: string]: ICoin; };
}

export interface ICoin {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  cmc_rank: number;
  num_market_pairs: number;
  circulating_supply: number;
  total_supply: number;
  max_supply: number;
  last_updated: Date;
  date_added: Date;
  tags: string[];
  platform: IPlatform;
  quote: IQuotes;
}

export interface IPlatform {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  token_address: string;
}

export interface IQuotes {
  [key: string]: IQuote;
}

export interface IQuote {
  price: number;
  volume_24h: number;
  volume_24h_reported: number;
  volume_7d: number;
  volume_7d_reported: number;
  volume_30d: number;
  volume_30d_reported: number;
  market_cap: number;
  percent_change_1h: number;
  percent_change_24h: number;
  percent_change_7d: number;
  last_updated: Date;
}
<fim_middle>",correct,3154,"export class Coin {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  cmcRank: number;
  numMarketPairs: number;
  circulatingSupply: number;
  totalSupply: number;
  maxSupply: number;
  lastUpdated: Date;
  dateAdded: Date;
  tags: string[];
  platform: Platform;
  quote: Quotes;

  getColour(value: number): string {
    if (value > 0) {
      return 'green';
    }
    if (value < 0) {
      return 'red';
    }

    return '';
  }

  // we would like to map properties to javascript naming convention
  constructor(coin: ICoin) {
    // TODO: add defensive checks
    this.id = coin.id;
    this.name = coin.name;
    this.symbol = coin.symbol;
    this.slug = coin.slug;
    this.cmcRank = coin.cmc_rank;
    this.numMarketPairs = coin.num_market_pairs;
    this.circulatingSupply = coin.circulating_supply;
    this.totalSupply = coin.total_supply;
    this.maxSupply = coin.max_supply;
    this.lastUpdated = coin.last_updated;
    this.dateAdded = coin.date_added;
    this.tags = coin.tags;
    this.platform = coin.platform && new Platform(coin.platform);
    this.quote = coin.quote && new Quotes(coin.quote);
  }
}

export class Platform {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  tokenAddress: string;

  constructor(platform: IPlatform) {
    this.id = platform.id;
    this.name = platform.name;
    this.symbol = platform.symbol;
    this.slug = platform.slug;
    this.tokenAddress = platform.token_address;
  }
}

export class Quotes {
  [key: string]: Quote;

  constructor(quotes: IQuotes) {
    Object.entries(quotes).forEach(([key, value]) => this[key] = new Quote(value));
  }
}

export class Quote {
  price: number;
  volume24h: number;
  volume24hReported: number;
  volume7d: number;
  volume7dReported: number;
  volume30d: number;
  volume30dReported: number;
  marketCap: number;
  change1h: number;
  change24h: number;
  change7d: number;
  lastUpdated: Date;

  constructor(quote: IQuote) {
    this.price = quote.price;
    this.volume24h = quote.volume_24h;
    this.volume24hReported = quote.volume_24h_reported;
    this.volume7d = quote.volume_7d;
    this.volume7dReported = quote.volume_7d_reported;
    this.volume30d = quote.volume_30d;
    this.volume30dReported = quote.volume_30d_reported;
    this.marketCap = quote.market_cap;
    this.change1h = quote.percent_change_1h / 100;
    this.change24h = quote.percent_change_24h / 100;
    this.change7d = quote.percent_change_7d / 100;
    this.lastUpdated = quote.last_updated;
  }
}

export interface IListingsResponse {
  data: ICoin[];
}

export interface IQuotesResponse {
  data: { [key: string]: ICoin; };
}

export interface ICoin {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  cmc_rank: number;
  num_market_pairs: number;
  circulating_supply: number;
  total_supply: number;
  max_supply: number;
  last_updated: Date;
  date_added: Date;
  tags: string[];
  platform: IPlatform;
  quote: IQuotes;
}

export interface IPlatform {
  id: number;
  name: string;
  symbol: string;
  slug: string;
  token_address: string;
}

export interface IQuotes {
  [key: string]: IQuote;
}

export interface IQuote {
  price: number;
  volume_24h: number;
  volume_24h_reported: number;
  volume_7d: number;
  volume_7d_reported: number;
  volume_30d: number;
  volume_30d_reported: number;
  market_cap: number;
  percent_change_1h: number;
  percent_change_24h: number;
  percent_change_7d: number;
  last_updated: Date;
}
",False
string,string,2807516d2c064ba25b7c27dc711ae21133bfb5af,"<fim_prefix>interface Point {
  x: number,
  y: number,
  z: number,
  value: boolean
}

export const ACTIVE = '#';
export const INACTIVE = '.';

export function getHyperForeigners(pocketDimension, w, z, x, y) {
  const foreigners: string[] = [];

  for (let wi = w-1; wi <= w+1; wi++) {
    if (wi < 0 || wi >= pocketDimension.length) {
      const sizeZ = 3;
      const sizeX = 3;
      const sizeY = 3;
      const insertedInactive = new Array(sizeZ * sizeX * sizeY).fill(INACTIVE)
      foreigners.push(...insertedInactive);
      continue;
    };

    const planZ = pocketDimension[wi];
    for (let zi = z-1; zi <= z+1; zi++) {
      if (zi < 0 || zi >= pocketDimension[0].length) {
        const sizeX = 3;
        const sizeY = 3;
        const insertedInactive = new Array(sizeX * sizeY).fill(INACTIVE)
        foreigners.push(...insertedInactive);
        continue;
      };

      const planX = planZ[zi];
      for (let xi = x-1; xi <= x+1; xi++) {
        if (xi < 0 || xi >= pocketDimension[0][0].length) {
          const sizeY = 3;
          const insertedInactive = new Array(sizeY).fill(INACTIVE)
          foreigners.push(...insertedInactive);
          continue;
        };

        const planY = planX[xi];
        for (let yi = y-1; yi <= y+1; yi++) {
          if (yi < 0 || yi >= pocketDimension[0][0][0].length) {
            foreigners.push(INACTIVE);
            continue;
          };

          if (x === xi && y === yi && z === zi && w === wi) {
            continue;
          }

          const hypercube = planY[yi];
          foreigners.push(hypercube)
        }
      }
    }
  }

  return foreigners;
}

export function getForeigners(pocketDimension, z, x, y) {
  const foreigners: string[] = [];

  for (let zi = z-1; zi <= z+1; zi++) {
    if (zi < 0 || zi >= pocketDimension.length) {
      const sizeX = 3;
      const sizeY = 3;
      const insertedInactive = new Array(sizeX * sizeY).fill(INACTIVE)
      foreigners.push(...insertedInactive);
      continue;
    };

    const planX = pocketDimension[zi];
    for (let xi = x-1; xi <= x+1; xi++) {
      if (xi < 0 || xi >= pocketDimension[0].length) {
        const sizeY = 3;
        const insertedInactive = new Array(sizeY).fill(INACTIVE)
        foreigners.push(...insertedInactive);
        continue;
      };

      const planY = planX[xi];
      for (let yi = y-1; yi <= y+1; yi++) {
        if (yi < 0 || yi >= pocketDimension[0][0].length) {
          foreigners.push(INACTIVE);
          continue;
        };

        if (x === xi && y === yi && z === zi) {
          continue;
        }

        const cube = planY[yi];
        foreigners.push(cube)
      }
    }
  }

  return foreigners;
}

export function getEmptyYGrow(pocketDimension): <fim_suffix> {
  return INACTIVE;
}
export function getEmptyXGrow(pocketDimension) {
  const y = getEmptyYGrow(pocketDimension);

  const x = new Array(pocketDimension[0][0].length + 2).fill(y);

  return x;
}
export function getEmptyZGrow(pocketDimension) {
  const x = getEmptyXGrow(pocketDimension);

  const z = new Array(pocketDimension[0].length + 2).fill(x);

  return z;
}

export function getEmptyHyperYGrow() {
  return INACTIVE;
}
export function getEmptyHyperXGrow(pocketDimension) {
  const y = getEmptyHyperYGrow();

  const x = new Array(pocketDimension[0][0][0].length + 2).fill(y);

  return x;
}
export function getEmptyHyperZGrow(pocketDimension) {
  const x = getEmptyHyperXGrow(pocketDimension);

  const z = new Array(pocketDimension[0][0].length + 2).fill(x);

  return z;
}
export function getEmptyHyperWGrow(pocketDimension) {
  const z = getEmptyHyperZGrow(pocketDimension);

  const w = new Array(pocketDimension[0].length + 2).fill(z);

  return w;
}

const growPocketDimension = (pocketDimension) => {
  return [
    getEmptyZGrow(pocketDimension),
    ...pocketDimension.map(planZ => {
      return [
        getEmptyXGrow(pocketDimension),
        ...planZ.map(planX => {
          return [
            getEmptyYGrow(pocketDimension),
            ...planX,
            getEmptyYGrow(pocketDimension)
          ]
        }),
        getEmptyXGrow(pocketDimension),
      ]
    }),
    getEmptyZGrow(pocketDimension),
  ]
}

const growPocketHyperDimension = (pocketDimension) => {
  return [
    getEmptyHyperWGrow(pocketDimension),
    ...pocketDimension.map(planW => {
      return [
        getEmptyHyperZGrow(pocketDimension),
        ...planW.map(planZ => {
          return [
            getEmptyHyperXGrow(pocketDimension),
            ...planZ.map(planX => {
              return [
                getEmptyHyperYGrow(),
                ...planX,
                getEmptyHyperYGrow()
              ]
            }),
            getEmptyHyperXGrow(pocketDimension)
          ]
        }),
        getEmptyHyperZGrow(pocketDimension),
      ]
    }),
    getEmptyHyperWGrow(pocketDimension),
  ]
}

export function playCycle(pocketDimension) {
  const grownPocketDimension = growPocketDimension(pocketDimension);
  return grownPocketDimension.map((planZ, z) => {
    return planZ.map((planX, x) => {
      return planX.map((planY, y) => {
        const foreigners = getForeigners(grownPocketDimension, z, x, y);
        const numberOfActiveForeigners = foreigners.filter(f => f === ACTIVE).length;
        if (planY === ACTIVE && (numberOfActiveForeigners === 2 || numberOfActiveForeigners === 3)) {
          return ACTIVE;
        } else if (planY === INACTIVE && numberOfActiveForeigners === 3) {
          return ACTIVE;
        } else {
          return INACTIVE;
        }
      });
    });
  });
}

export function playHyperCycle(pocketDimension) {
  const grownPocketDimension = growPocketHyperDimension(pocketDimension);
  return grownPocketDimension.map((planW, w) => {
    return planW.map((planZ, z) => {
      return planZ.map((planX, x) => {
        return planX.map((planY, y) => {
          const foreigners = getHyperForeigners(grownPocketDimension, w, z, x, y);
          const numberOfActiveForeigners = foreigners.filter(f => f === ACTIVE).length;
          if (planY === ACTIVE && (numberOfActiveForeigners === 2 || numberOfActiveForeigners === 3)) {
            return ACTIVE;
          } else if (planY === INACTIVE && numberOfActiveForeigners === 3) {
            return ACTIVE;
          } else {
            return INACTIVE;
          }
        });
      });
    });
  });
}

export function getPocketDimension(input) {
  return [
    input.map(line => line.split(''))
  ];
}

const countActives = (pocketDimension) => {
  return pocketDimension
    .flatMap(z => z)
    .flatMap(z => z)
    .filter(cube => cube === ACTIVE)
    .length;
}

const countHyperActives = (pocketDimension) => {
  return pocketDimension
    .flatMap(z => z)
    .flatMap(z => z)
    .flatMap(z => z)
    .filter(cube => cube === ACTIVE)
    .length;
}

export function countActiveCubes(input) {
  const pocketDimension = getPocketDimension(input);
  const round1 = playCycle(pocketDimension);
  const round2 = playCycle(round1);
  const round3 = playCycle(round2);
  const round4 = playCycle(round3);
  const round5 = playCycle(round4);
  const round6 = playCycle(round5);

  countActives(pocketDimension);
  countActives(round1);
  countActives(round2);
  countActives(round3);
  countActives(round4);
  countActives(round5);
  countActives(round6);


  return countActives(round6);;
}

export function countActiveHypercubes(input) {
  const pocketDimension = [getPocketDimension(input)];
  const round1 = playHyperCycle(pocketDimension);
  const round2 = playHyperCycle(round1);
  const round3 = playHyperCycle(round2);
  const round4 = playHyperCycle(round3);
  const round5 = playHyperCycle(round4);
  const round6 = playHyperCycle(round5);

  countHyperActives(pocketDimension);
  countHyperActives(round1);
  countHyperActives(round2);
  countHyperActives(round3);
  countHyperActives(round4);
  countHyperActives(round5);
  countHyperActives(round6);


  return countHyperActives(round6);
}<fim_middle>",correct,4058,"interface Point {
  x: number,
  y: number,
  z: number,
  value: boolean
}

export const ACTIVE = '#';
export const INACTIVE = '.';

export function getHyperForeigners(pocketDimension: string[][][][], w: number, z: number, x: number, y: number) {
  const foreigners: string[] = [];

  for (let wi = w-1; wi <= w+1; wi++) {
    if (wi < 0 || wi >= pocketDimension.length) {
      const sizeZ = 3;
      const sizeX = 3;
      const sizeY = 3;
      const insertedInactive = new Array(sizeZ * sizeX * sizeY).fill(INACTIVE)
      foreigners.push(...insertedInactive);
      continue;
    };

    const planZ = pocketDimension[wi];
    for (let zi = z-1; zi <= z+1; zi++) {
      if (zi < 0 || zi >= pocketDimension[0].length) {
        const sizeX = 3;
        const sizeY = 3;
        const insertedInactive = new Array(sizeX * sizeY).fill(INACTIVE)
        foreigners.push(...insertedInactive);
        continue;
      };

      const planX = planZ[zi];
      for (let xi = x-1; xi <= x+1; xi++) {
        if (xi < 0 || xi >= pocketDimension[0][0].length) {
          const sizeY = 3;
          const insertedInactive = new Array(sizeY).fill(INACTIVE)
          foreigners.push(...insertedInactive);
          continue;
        };

        const planY = planX[xi];
        for (let yi = y-1; yi <= y+1; yi++) {
          if (yi < 0 || yi >= pocketDimension[0][0][0].length) {
            foreigners.push(INACTIVE);
            continue;
          };

          if (x === xi && y === yi && z === zi && w === wi) {
            continue;
          }

          const hypercube = planY[yi];
          foreigners.push(hypercube)
        }
      }
    }
  }

  return foreigners;
}

export function getForeigners(pocketDimension: string[][][], z: number, x: number, y: number) {
  const foreigners: string[] = [];

  for (let zi = z-1; zi <= z+1; zi++) {
    if (zi < 0 || zi >= pocketDimension.length) {
      const sizeX = 3;
      const sizeY = 3;
      const insertedInactive = new Array(sizeX * sizeY).fill(INACTIVE)
      foreigners.push(...insertedInactive);
      continue;
    };

    const planX = pocketDimension[zi];
    for (let xi = x-1; xi <= x+1; xi++) {
      if (xi < 0 || xi >= pocketDimension[0].length) {
        const sizeY = 3;
        const insertedInactive = new Array(sizeY).fill(INACTIVE)
        foreigners.push(...insertedInactive);
        continue;
      };

      const planY = planX[xi];
      for (let yi = y-1; yi <= y+1; yi++) {
        if (yi < 0 || yi >= pocketDimension[0][0].length) {
          foreigners.push(INACTIVE);
          continue;
        };

        if (x === xi && y === yi && z === zi) {
          continue;
        }

        const cube = planY[yi];
        foreigners.push(cube)
      }
    }
  }

  return foreigners;
}

export function getEmptyYGrow(pocketDimension: string[][][]): string {
  return INACTIVE;
}
export function getEmptyXGrow(pocketDimension: string[][][]): string[] {
  const y = getEmptyYGrow(pocketDimension);

  const x = new Array(pocketDimension[0][0].length + 2).fill(y);

  return x;
}
export function getEmptyZGrow(pocketDimension: string[][][]): string[][] {
  const x = getEmptyXGrow(pocketDimension);

  const z = new Array(pocketDimension[0].length + 2).fill(x);

  return z;
}

export function getEmptyHyperYGrow(): string {
  return INACTIVE;
}
export function getEmptyHyperXGrow(pocketDimension: string[][][][]): string[] {
  const y = getEmptyHyperYGrow();

  const x = new Array(pocketDimension[0][0][0].length + 2).fill(y);

  return x;
}
export function getEmptyHyperZGrow(pocketDimension: string[][][][]): string[][] {
  const x = getEmptyHyperXGrow(pocketDimension);

  const z = new Array(pocketDimension[0][0].length + 2).fill(x);

  return z;
}
export function getEmptyHyperWGrow(pocketDimension: string[][][][]): string[][][] {
  const z = getEmptyHyperZGrow(pocketDimension);

  const w = new Array(pocketDimension[0].length + 2).fill(z);

  return w;
}

const growPocketDimension = (pocketDimension: string[][][]): string[][][] => {
  return [
    getEmptyZGrow(pocketDimension),
    ...pocketDimension.map(planZ => {
      return [
        getEmptyXGrow(pocketDimension),
        ...planZ.map(planX => {
          return [
            getEmptyYGrow(pocketDimension),
            ...planX,
            getEmptyYGrow(pocketDimension)
          ]
        }),
        getEmptyXGrow(pocketDimension),
      ]
    }),
    getEmptyZGrow(pocketDimension),
  ]
}

const growPocketHyperDimension = (pocketDimension: string[][][][]): string[][][][] => {
  return [
    getEmptyHyperWGrow(pocketDimension),
    ...pocketDimension.map(planW => {
      return [
        getEmptyHyperZGrow(pocketDimension),
        ...planW.map(planZ => {
          return [
            getEmptyHyperXGrow(pocketDimension),
            ...planZ.map(planX => {
              return [
                getEmptyHyperYGrow(),
                ...planX,
                getEmptyHyperYGrow()
              ]
            }),
            getEmptyHyperXGrow(pocketDimension)
          ]
        }),
        getEmptyHyperZGrow(pocketDimension),
      ]
    }),
    getEmptyHyperWGrow(pocketDimension),
  ]
}

export function playCycle(pocketDimension: string[][][]): string[][][] {
  const grownPocketDimension = growPocketDimension(pocketDimension);
  return grownPocketDimension.map((planZ, z) => {
    return planZ.map((planX, x) => {
      return planX.map((planY, y) => {
        const foreigners = getForeigners(grownPocketDimension, z, x, y);
        const numberOfActiveForeigners = foreigners.filter(f => f === ACTIVE).length;
        if (planY === ACTIVE && (numberOfActiveForeigners === 2 || numberOfActiveForeigners === 3)) {
          return ACTIVE;
        } else if (planY === INACTIVE && numberOfActiveForeigners === 3) {
          return ACTIVE;
        } else {
          return INACTIVE;
        }
      });
    });
  });
}

export function playHyperCycle(pocketDimension: string[][][][]): string[][][][] {
  const grownPocketDimension = growPocketHyperDimension(pocketDimension);
  return grownPocketDimension.map((planW, w) => {
    return planW.map((planZ, z) => {
      return planZ.map((planX, x) => {
        return planX.map((planY, y) => {
          const foreigners = getHyperForeigners(grownPocketDimension, w, z, x, y);
          const numberOfActiveForeigners = foreigners.filter(f => f === ACTIVE).length;
          if (planY === ACTIVE && (numberOfActiveForeigners === 2 || numberOfActiveForeigners === 3)) {
            return ACTIVE;
          } else if (planY === INACTIVE && numberOfActiveForeigners === 3) {
            return ACTIVE;
          } else {
            return INACTIVE;
          }
        });
      });
    });
  });
}

export function getPocketDimension(input: string[]): string[][][] {
  return [
    input.map(line => line.split(''))
  ];
}

const countActives = (pocketDimension: string[][][]) => {
  return pocketDimension
    .flatMap(z => z)
    .flatMap(z => z)
    .filter(cube => cube === ACTIVE)
    .length;
}

const countHyperActives = (pocketDimension: string[][][][]) => {
  return pocketDimension
    .flatMap(z => z)
    .flatMap(z => z)
    .flatMap(z => z)
    .filter(cube => cube === ACTIVE)
    .length;
}

export function countActiveCubes(input: string[]): number {
  const pocketDimension = getPocketDimension(input);
  const round1 = playCycle(pocketDimension);
  const round2 = playCycle(round1);
  const round3 = playCycle(round2);
  const round4 = playCycle(round3);
  const round5 = playCycle(round4);
  const round6 = playCycle(round5);

  countActives(pocketDimension);
  countActives(round1);
  countActives(round2);
  countActives(round3);
  countActives(round4);
  countActives(round5);
  countActives(round6);


  return countActives(round6);;
}

export function countActiveHypercubes(input: string[]): number {
  const pocketDimension = [getPocketDimension(input)];
  const round1 = playHyperCycle(pocketDimension);
  const round2 = playHyperCycle(round1);
  const round3 = playHyperCycle(round2);
  const round4 = playHyperCycle(round3);
  const round5 = playHyperCycle(round4);
  const round6 = playHyperCycle(round5);

  countHyperActives(pocketDimension);
  countHyperActives(round1);
  countHyperActives(round2);
  countHyperActives(round3);
  countHyperActives(round4);
  countHyperActives(round5);
  countHyperActives(round6);


  return countHyperActives(round6);
}",False
string,string,9d3356dc252d0a156c06c36e698d23701b6776da,"<fim_prefix>export function prettify(x):: <fim_suffix>{
  return x.toLocaleString('en', { useGrouping: true });
}

export type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;

interface InnerNumber {
  integer: number;
  fractional: boolean | digit[];
}

interface Number {
  x?: InnerNumber;
}

export class WorkingNumber {
  n: Number;

  constructor() {
    this.n = { x: undefined };
  }

  unset() {
    this.n.x = undefined;
  }

  toNumber() {
    const x = this.n.x;
    if (x) {
      const fractional = Array.isArray(x.fractional) && x.fractional.length > 0 ?
        Number.parseFloat('.' + x.fractional.join('')) : 0;
      return x.integer + fractional;
    }
    return undefined;
  }

  toString() {
    if (this.n.x) {
      let out = prettify(this.n.x.integer);
      if (this.n.x.fractional !== false) {
        out += '.';
      }
      if (Array.isArray(this.n.x.fractional)) {
        out += this.n.x.fractional.join('');
      }
      return out;
    }
    return ""0"";
  }

  appendDigit(digit) {
    if (this.n.x == undefined) {
      this.zeroOut();
    }

    this.n.x = <InnerNumber> this.n.x;  // TS hint

    if (this.n.x.fractional === true) {
      this.n.x.fractional = [];
    }

    if (this.n.x.fractional) {
      this.n.x.fractional.push(digit);
    } else {
      this.n.x.integer = this.n.x.integer * 10 + digit;
    }
  }

  enterFractional() {
    if (this.n.x === undefined) {
      this.zeroOut();
    }

    this.n.x = <InnerNumber> this.n.x;  // TS hint

    if (typeof this.n.x.fractional === 'boolean') {
      this.n.x.fractional = !this.n.x.fractional;
    }
  }

  deleteDigit() {
    if (this.n.x) {
      if (Array.isArray(this.n.x.fractional)) {
        this.n.x.fractional.pop();
        if (this.n.x.fractional.length === 0) {
          this.n.x.fractional = true;
        }
      } else if (this.n.x.fractional === true) {
        this.n.x.fractional = false;
      } else {
        this.n.x.integer = Math.trunc(this.n.x.integer / 10);
        if (this.n.x.integer === 0) {
          this.unset();
        }
      }
    }
  }

  private zeroOut() {
    this.n.x = {
      integer: 0,
      fractional: false,
    };
  }
}
<fim_middle>",correct,4174,"export function prettify(x: number): string {
  return x.toLocaleString('en', { useGrouping: true });
}

export type digit = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;

interface InnerNumber {
  integer: number;
  fractional: boolean | digit[];
}

interface Number {
  x?: InnerNumber;
}

export class WorkingNumber {
  n: Number;

  constructor() {
    this.n = { x: undefined };
  }

  unset() {
    this.n.x = undefined;
  }

  toNumber(): number | undefined {
    const x = this.n.x;
    if (x) {
      const fractional = Array.isArray(x.fractional) && x.fractional.length > 0 ?
        Number.parseFloat('.' + x.fractional.join('')) : 0;
      return x.integer + fractional;
    }
    return undefined;
  }

  toString(): string {
    if (this.n.x) {
      let out = prettify(this.n.x.integer);
      if (this.n.x.fractional !== false) {
        out += '.';
      }
      if (Array.isArray(this.n.x.fractional)) {
        out += this.n.x.fractional.join('');
      }
      return out;
    }
    return ""0"";
  }

  appendDigit(digit: digit) {
    if (this.n.x == undefined) {
      this.zeroOut();
    }

    this.n.x = <InnerNumber> this.n.x;  // TS hint

    if (this.n.x.fractional === true) {
      this.n.x.fractional = [];
    }

    if (this.n.x.fractional) {
      this.n.x.fractional.push(digit);
    } else {
      this.n.x.integer = this.n.x.integer * 10 + digit;
    }
  }

  enterFractional() {
    if (this.n.x === undefined) {
      this.zeroOut();
    }

    this.n.x = <InnerNumber> this.n.x;  // TS hint

    if (typeof this.n.x.fractional === 'boolean') {
      this.n.x.fractional = !this.n.x.fractional;
    }
  }

  deleteDigit() {
    if (this.n.x) {
      if (Array.isArray(this.n.x.fractional)) {
        this.n.x.fractional.pop();
        if (this.n.x.fractional.length === 0) {
          this.n.x.fractional = true;
        }
      } else if (this.n.x.fractional === true) {
        this.n.x.fractional = false;
      } else {
        this.n.x.integer = Math.trunc(this.n.x.integer / 10);
        if (this.n.x.integer === 0) {
          this.unset();
        }
      }
    }
  }

  private zeroOut() {
    this.n.x = {
      integer: 0,
      fractional: false,
    };
  }
}
",False
void,void,ccee70850d7be59ff29044ffd01e8ec90a3de543,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

// to suit your point format, run search/replace for '[0]' and '[1]';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

type Point = [number, number];

// square distance between 2 points
const getSqDist = (p1, p2) => {
  const dx = p1[0] - p2[0];
  const dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
};

// square distance from a point to a segment
const getSqSegDist = (p, p1, p2) => {
  let [x, y] = p1;
  let dx = p2[0] - x;
  let dy = p2[1] - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      [x, y] = p2;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
};
// rest of the code doesn't care about point format

// basic distance-based simplification
const simplifyRadialDist = (points, sqTolerance) => {
  if (points.length === 0) return [];

  let prevPoint = points[0];
  const newPoints = [prevPoint];
  let point: Point | null = null;

  points.forEach((d) => {
    point = d;
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  });

  if (prevPoint !== point) newPoints.push(point as unknown as Point);

  return newPoints;
};

const simplifyDPStep = (
  points,
  first,
  last,
  sqTolerance,
  simplified,
): <fim_suffix> => {
  let maxSqDist = sqTolerance;
  let index: number | null = null;

  for (let i = first + 1; i < last; i += 1) {
    const sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if ((index as number) - first > 1) {
      simplifyDPStep(points, first, (index as number), sqTolerance, simplified);
    }
    simplified.push(points[(index as number)]);
    if (last - (index as number) > 1) {
      simplifyDPStep(points, (index as number), last, sqTolerance, simplified);
    }
  }
};

// simplification using Ramer-Douglas-Peucker algorithm
const simplifyDouglasPeucker = (points, sqTolerance) => {
  const last = points.length - 1;

  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);

  return simplified;
};

// both algorithms combined for awesome performance
export default (
  points,
  tolerance,
  highestQuality,
) => {
  if (points.length <= 2) return points;

  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
  let simplified = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  simplified = simplifyDouglasPeucker(points, sqTolerance);
  return simplified;
};
<fim_middle>",correct,2563,"// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

// to suit your point format, run search/replace for '[0]' and '[1]';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

type Point = [number, number];

// square distance between 2 points
const getSqDist = (p1: Point, p2: Point): number => {
  const dx = p1[0] - p2[0];
  const dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
};

// square distance from a point to a segment
const getSqSegDist = (p: Point, p1: Point, p2: Point): number => {
  let [x, y] = p1;
  let dx = p2[0] - x;
  let dy = p2[1] - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      [x, y] = p2;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
};
// rest of the code doesn't care about point format

// basic distance-based simplification
const simplifyRadialDist = (points: Point[], sqTolerance: number): Point[] => {
  if (points.length === 0) return [];

  let prevPoint = points[0];
  const newPoints = [prevPoint];
  let point: Point | null = null;

  points.forEach((d) => {
    point = d;
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  });

  if (prevPoint !== point) newPoints.push(point as unknown as Point);

  return newPoints;
};

const simplifyDPStep = (
  points: Point[],
  first: number,
  last: number,
  sqTolerance: number,
  simplified: Point[],
): void => {
  let maxSqDist = sqTolerance;
  let index: number | null = null;

  for (let i = first + 1; i < last; i += 1) {
    const sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if ((index as number) - first > 1) {
      simplifyDPStep(points, first, (index as number), sqTolerance, simplified);
    }
    simplified.push(points[(index as number)]);
    if (last - (index as number) > 1) {
      simplifyDPStep(points, (index as number), last, sqTolerance, simplified);
    }
  }
};

// simplification using Ramer-Douglas-Peucker algorithm
const simplifyDouglasPeucker = (points: Point[], sqTolerance: number): Point[] => {
  const last = points.length - 1;

  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);

  return simplified;
};

// both algorithms combined for awesome performance
export default (
  points: Point[],
  tolerance: number,
  highestQuality: boolean,
): Point[] => {
  if (points.length <= 2) return points;

  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
  let simplified = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  simplified = simplifyDouglasPeucker(points, sqTolerance);
  return simplified;
};
",False
void,void,4ecebdfe2a83e32ca2665144d05b64c53181178a,"<fim_prefix>/**
 *
 *
 * Copied direcly from: https://github.com/pmndrs/jotai/blob/main/src/utils/weakCache.ts
 *
 * Eventually just import it from Jotai if it's exported.
 *
 *
 *
 */
export type WeakCache<T> = WeakMap<object, [WeakCache<T>] | [WeakCache<T>, T]>;

const getWeakCacheItem = <T>(
  cache,
  deps
) => {
  while (true) {
    const [dep, ...rest] = deps;
    const entry = cache.get(dep as object);
    if (!entry) {
      return;
    }
    if (!rest.length) {
      return entry[1];
    }
    cache = entry[0];
    deps = rest;
  }
};

const setWeakCacheItem = <T>(
  cache,
  deps,
  item
): <fim_suffix> => {
  while (true) {
    const [dep, ...rest] = deps;
    let entry = cache.get(dep as object);
    if (!entry) {
      entry = [new WeakMap()];
      cache.set(dep as object, entry);
    }
    if (!rest.length) {
      entry[1] = item;
      return;
    }
    cache = entry[0];
    deps = rest;
  }
};

export const createMemoizeAtom = () => {
  const cache: WeakCache<{}> = new WeakMap();
  const memoizeAtom = <T extends {}, Deps extends readonly object[]>(
    createAtom,
    deps
  ) => {
    const cachedAtom = getWeakCacheItem(cache, deps);
    if (cachedAtom) {
      return cachedAtom as T;
    }
    const createdAtom = createAtom();
    setWeakCacheItem(cache, deps, createdAtom);
    return createdAtom;
  };
  return memoizeAtom;
};
<fim_middle>",correct,3788,"/**
 *
 *
 * Copied direcly from: https://github.com/pmndrs/jotai/blob/main/src/utils/weakCache.ts
 *
 * Eventually just import it from Jotai if it's exported.
 *
 *
 *
 */
export type WeakCache<T> = WeakMap<object, [WeakCache<T>] | [WeakCache<T>, T]>;

const getWeakCacheItem = <T>(
  cache: WeakCache<T>,
  deps: readonly object[]
): T | undefined => {
  while (true) {
    const [dep, ...rest] = deps;
    const entry = cache.get(dep as object);
    if (!entry) {
      return;
    }
    if (!rest.length) {
      return entry[1];
    }
    cache = entry[0];
    deps = rest;
  }
};

const setWeakCacheItem = <T>(
  cache: WeakCache<T>,
  deps: readonly object[],
  item: T
): void => {
  while (true) {
    const [dep, ...rest] = deps;
    let entry = cache.get(dep as object);
    if (!entry) {
      entry = [new WeakMap()];
      cache.set(dep as object, entry);
    }
    if (!rest.length) {
      entry[1] = item;
      return;
    }
    cache = entry[0];
    deps = rest;
  }
};

export const createMemoizeAtom = () => {
  const cache: WeakCache<{}> = new WeakMap();
  const memoizeAtom = <T extends {}, Deps extends readonly object[]>(
    createAtom: () => T,
    deps: Deps
  ) => {
    const cachedAtom = getWeakCacheItem(cache, deps);
    if (cachedAtom) {
      return cachedAtom as T;
    }
    const createdAtom = createAtom();
    setWeakCacheItem(cache, deps, createdAtom);
    return createdAtom;
  };
  return memoizeAtom;
};
",False
