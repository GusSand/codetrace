,generated,solution,hexsha,prompt,correctness,id
0,A,A,f3813017e9bb14bf831177d63f99b8ab50b44ad4,"<fim_prefix>export type Empty = {
    readonly _tag: 'Empty';
};
export type BeregnButton = {
    readonly _tag: 'BeregnButton';
};
export type BeregnButtonAndErrorSummary<E> = {
    readonly _tag: 'BeregnButtonAndErrorSummary';
    readonly errors: E;
};
export type NoValidChildrenOrange = {
    readonly _tag: 'NoValidChildrenOrange';
};
export type ResultBox<A> = {
    readonly _tag: 'ResultBox';
    readonly result: A;
};

export type ResultView<E, A> =
    | Empty
    | BeregnButton
    | BeregnButtonAndErrorSummary<E>
    | NoValidChildrenOrange
    | ResultBox<A>;

// constructors
export const empty: ResultView<never, never> = {
    _tag: 'Empty',
};
export const beregnButton: ResultView<never, never> = {
    _tag: 'BeregnButton',
};
export const beregnButtonAndErrorSummary = <E>(errors) => ({
    _tag: 'BeregnButtonAndErrorSummary',
    errors,
});
export const noValidChildrenOrange: ResultView<never, never> = {
    _tag: 'NoValidChildrenOrange',
};
export const resultBox = <A>(result: <fim_suffix>) => ({
    _tag: 'ResultBox',
    result,
});
// filters
export const isEmpty = (data): data is Empty => data._tag === 'Empty';
export const isBeregnButton = (data): data is BeregnButton =>
    data._tag === 'BeregnButton';
export const isBeregnButtonAndErrorSummary = <E>(
    data
): data is BeregnButtonAndErrorSummary<E> => data._tag === 'BeregnButtonAndErrorSummary';
export const isNoValidChildrenOrange = (data): data is NoValidChildrenOrange =>
    data._tag === 'NoValidChildrenOrange';
export const isResultBox = <A>(data): data is ResultBox<A> => data._tag === 'ResultBox';

// fold
export const caseResultViewOf =
    <E, A, B>(
        empty,
        beregnButton,
        beregnButtonAndErrorSummary,
        noValidChildrenOrange,
        resultBox
    ) =>
    (resultView) => {
        switch (resultView._tag) {
            case 'Empty': {
                return empty();
            }
            case 'BeregnButton': {
                return beregnButton();
            }
            case 'BeregnButtonAndErrorSummary': {
                return beregnButtonAndErrorSummary(resultView.errors);
            }
            case 'NoValidChildrenOrange': {
                return noValidChildrenOrange();
            }
            case 'ResultBox': {
                return resultBox(resultView.result);
            }
        }
    };
<fim_middle>",correct,3887
1,Action,Action,566e0bf1c5e4eafebc876c82fc048623ab53ab35,"<fim_prefix>type Action =
  | { type: 'closeTag', tag: string }
  | { type: 'showInput' }
  | { type: 'confirmInput', tag?: string }
  | { type: 'reset' }
  | { type: 'addIngredient' }
  | { type: 'removeIngredient', id: number }
  | { type: 'addDirection' }
  | { type: 'removeDirection', id: number }

interface State {
  tags: string[]
  inputVisible: boolean
  ingredients: number[]
  directions: number[]
}


let ingredientId = 0
let directionId = 0
export const initialState = {
  tags: [],
  inputVisible: false,
  ingredients: [ingredientId],
  directions: [directionId],
}


const reducer = (state, action: <fim_suffix>) => {
  switch (action.type) {
    case 'closeTag':
      return { ...state, tags: state.tags.filter(tag => tag !== action.tag) }

    case 'reset':
      return initialState

    case 'showInput':
      return { ...state, inputVisible: true }
    case 'confirmInput':
      let tag = action.tag
      if (!tag) return { ...state, inputVisible: false }
      tag = tag.trim()

      const { tags } = state
      let newTags = tags

      if (tag && tags.indexOf(tag) === -1) newTags = [...tags, tag]

      return { ...state, inputVisible: false, tags: newTags }

    case 'addIngredient':
      ingredientId += 1
      return {
        ...state,
        ingredients: [...state.ingredients, ingredientId],
      }
    case 'removeIngredient':
      return {
        ...state,
        ingredients: state.ingredients.filter(index => index !== action.id),
      }

    case 'addDirection':
      directionId += 1
      return {
        ...state,
        directions: [...state.directions, directionId],
      }
    case 'removeDirection':
      return {
        ...state,
        directions: state.directions.filter(index => index !== action.id),
      }

    default:
      throw new Error('Unexpected action.')
  }
}


export default reducer
<fim_middle>",correct,20
2,Actions,Actions,ebfbabd6e86ee48c24c3828f4ee1b92f6ff39f68,"<fim_prefix>export interface AppSetting {
  shouldSplitMemoWord: boolean;
  shouldHideImageUrl: boolean;
  shouldUseMarkdownParser: boolean;
  useTinyUndoHistoryCache: boolean;
}

export interface State extends AppSetting {
  markMemoId: string;
  editMemoId: string;
  commentMemoId: string;
  isMobileView: boolean;
  showSiderbarInMobileView: boolean;
  changedByMemos: boolean;
}

interface SetMarkMemoIdAction {
  type: 'SET_MARK_MEMO_ID';
  payload: {
    markMemoId: string;
  };
}

interface SetEditMemoIdAction {
  type: 'SET_EDIT_MEMO_ID';
  payload: {
    editMemoId: string;
  };
}

interface SetCommentMemoIdAction {
  type: 'SET_COMMENT_MEMO_ID';
  payload: {
    commentMemoId: string;
  };
}

interface SetMobileViewAction {
  type: 'SET_MOBILE_VIEW';
  payload: {
    isMobileView: boolean;
  };
}

interface SetChangedByMemosAction {
  type: 'SET_CHANGED_BY_MEMOS';
  payload: {
    changedByMemos: boolean;
  };
}

interface SetShowSidebarAction {
  type: 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW';
  payload: {
    showSiderbarInMobileView: boolean;
  };
}

interface SetAppSettingAction {
  type: 'SET_APP_SETTING';
  payload: Partial<AppSetting>;
}

export type Actions =
  | SetMobileViewAction
  | SetShowSidebarAction
  | SetEditMemoIdAction
  | SetCommentMemoIdAction
  | SetMarkMemoIdAction
  | SetChangedByMemosAction
  | SetAppSettingAction;

export function reducer(state, action: <fim_suffix>) {
  switch (action.type) {
    case 'SET_MARK_MEMO_ID': {
      if (action.payload.markMemoId === state.markMemoId) {
        return state;
      }

      return {
        ...state,
        markMemoId: action.payload.markMemoId,
      };
    }
    case 'SET_EDIT_MEMO_ID': {
      if (action.payload.editMemoId === state.editMemoId) {
        return state;
      }

      return {
        ...state,
        editMemoId: action.payload.editMemoId,
      };
    }
    case 'SET_COMMENT_MEMO_ID': {
      if (action.payload.commentMemoId === state.commentMemoId) {
        return state;
      }

      return {
        ...state,
        commentMemoId: action.payload.commentMemoId,
      };
    }
    case 'SET_MOBILE_VIEW': {
      if (action.payload.isMobileView === state.isMobileView) {
        return state;
      }

      return {
        ...state,
        isMobileView: action.payload.isMobileView,
      };
    }
    case 'SET_CHANGED_BY_MEMOS': {
      if (action.payload.changedByMemos === state.changedByMemos) {
        return state;
      }

      return {
        ...state,
        changedByMemos: action.payload.changedByMemos,
      };
    }
    case 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW': {
      if (action.payload.showSiderbarInMobileView === state.showSiderbarInMobileView) {
        return state;
      }

      return {
        ...state,
        showSiderbarInMobileView: action.payload.showSiderbarInMobileView,
      };
    }
    case 'SET_APP_SETTING': {
      return {
        ...state,
        ...action.payload,
      };
    }
    default: {
      return state;
    }
  }
}

export const defaultState: State = {
  markMemoId: '',
  editMemoId: '',
  commentMemoId: '',
  shouldSplitMemoWord: true,
  shouldHideImageUrl: true,
  shouldUseMarkdownParser: true,
  useTinyUndoHistoryCache: false,
  isMobileView: false,
  showSiderbarInMobileView: false,
  changedByMemos: false,
};
<fim_middle>",correct,236
3,Application,Application,cae47631c7a90006a8af948c94a65fc0aa8379c0,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IApplication {
    client_type?: string;
    description?: string;
    grant_type?: string;
    id?: string;
    image?: string;
    name?: string;
    redirect_uri?: string;
    response_type?: string;
    url?: string;
}

export default class Application {
    readonly _client_type: string | undefined;

    get clientType() {
        return this._client_type;
    }

    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _grant_type: string | undefined;

    get grantType() {
        return this._grant_type;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _image: string | undefined;

    get image() {
        return this._image;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _redirect_uri: string | undefined;

    get redirectUri() {
        return this._redirect_uri;
    }

    readonly _response_type: string | undefined;

    get responseType() {
        return this._response_type;
    }

    readonly _url: string | undefined;

    get url() {
        return this._url;
    }

    constructor(props) {
        if (typeof props.client_type === 'string') {
            this._client_type = props.client_type.trim();
        }
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.grant_type === 'string') {
            this._grant_type = props.grant_type.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.image === 'string') {
            this._image = props.image.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.redirect_uri === 'string') {
            this._redirect_uri = props.redirect_uri.trim();
        }
        if (typeof props.response_type === 'string') {
            this._response_type = props.response_type.trim();
        }
        if (typeof props.url === 'string') {
            this._url = props.url.trim();
        }
    }

    serialize() {
        const data: IApplication = {};
        if (typeof this._client_type !== 'undefined') {
            data.client_type = this._client_type;
        }
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._grant_type !== 'undefined') {
            data.grant_type = this._grant_type;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._image !== 'undefined') {
            data.image = this._image;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._redirect_uri !== 'undefined') {
            data.redirect_uri = this._redirect_uri;
        }
        if (typeof this._response_type !== 'undefined') {
            data.response_type = this._response_type;
        }
        if (typeof this._url !== 'undefined') {
            data.url = this._url;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            image: !this._image
                ? true
                : typeof this._image === 'string' && !this._image
                ? true
                : this._image,
            url: !this._url
                ? true
                : typeof this._url === 'string' && !this._url
                ? true
                : this._url,
            redirect_uri: !this._redirect_uri
                ? true
                : typeof this._redirect_uri === 'string' && !this._redirect_uri
                ? true
                : this._redirect_uri,
            grant_type: !this._grant_type
                ? true
                : typeof this._grant_type === 'string' && !this._grant_type
                ? true
                : this._grant_type,
            response_type: !this._response_type
                ? true
                : typeof this._response_type === 'string' &&
                  !this._response_type
                ? true
                : this._response_type,
            client_type: !this._client_type
                ? true
                : typeof this._client_type === 'string' && !this._client_type
                ? true
                : this._client_type,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Application({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,2034
4,Argument,Argument,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x: <fim_suffix>) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3358
5,ArrayBuffer,ArrayBuffer,8942b9bffbeae8bdf02b8ff01a9a7a9bca89f53c,"<fim_prefix>const INDEX_BIT_COUNT = 12;
const LENGTH_BIT_COUNT = 4;
const WINDOW_SIZE = 1 << INDEX_BIT_COUNT;
const RAW_LOOK_AHEAD_SIZE = 1 << LENGTH_BIT_COUNT;
const BREAK_EVEN = Math.floor((1 + INDEX_BIT_COUNT + LENGTH_BIT_COUNT) / 9);
const LOOK_AHEAD_SIZE = RAW_LOOK_AHEAD_SIZE + BREAK_EVEN;
const TREE_ROOT = WINDOW_SIZE;
const UNUSED = -1;
const MOD_WINDOW = (a) => a & (WINDOW_SIZE - 1);

enum Child {
  Smaller = 0,
  Larger = 1,
}

interface DefTree {
  parent: number;
  children: [number, number];
}

let current_pos: number;
let match_pos: number;
const win = new Uint8Array(WINDOW_SIZE * 5);
const tree: DefTree[] = (() => {
  const t = new Array<DefTree>(WINDOW_SIZE + 2);
  for (let i = 0; i < t.length; i++) {
    t[i] = { parent: 0, children: [0, 0] };
  }
  return t;
})();

function initTree(r) {
  for (let i = 0; i <= WINDOW_SIZE; i++) {
    const node = tree[i];
    node.parent = UNUSED;
    node.children[Child.Smaller] = UNUSED;
    node.children[Child.Larger] = UNUSED;
  }
  tree[TREE_ROOT].children[Child.Larger] = r;
  tree[r].parent = TREE_ROOT;
  tree[-1] = tree[WINDOW_SIZE + 1];
}

function contractNode(old_node, new_node) {
  tree[new_node].parent = tree[old_node].parent;
  if (tree[tree[old_node].parent].children[Child.Larger] === old_node)
    tree[tree[old_node].parent].children[Child.Larger] = new_node;
  else tree[tree[old_node].parent].children[Child.Smaller] = new_node;
  tree[old_node].parent = UNUSED;
}

function copyNode(new_node, old_node) {
  tree[new_node].parent = tree[old_node].parent;
  tree[new_node].children[Child.Smaller] =
    tree[old_node].children[Child.Smaller];
  tree[new_node].children[Child.Larger] = tree[old_node].children[Child.Larger];
}

function replaceNode(old_node, new_node) {
  const parent = tree[old_node].parent;
  if (tree[parent].children[Child.Smaller] === old_node)
    tree[parent].children[Child.Smaller] = new_node;
  else tree[parent].children[Child.Larger] = new_node;
  copyNode(new_node, old_node);
  if (tree[new_node].children[Child.Smaller] !== UNUSED)
    tree[tree[new_node].children[Child.Smaller]].parent = new_node;
  if (tree[new_node].children[Child.Larger] !== UNUSED)
    tree[tree[new_node].children[Child.Larger]].parent = new_node;
  tree[old_node].parent = UNUSED;
}

function findNextNode(node) {
  let next = tree[node].children[Child.Smaller];
  while (tree[next].children[Child.Larger] !== UNUSED)
    next = tree[next].children[Child.Larger];
  return next;
}

function deleteString(p) {
  if (tree[p].parent === UNUSED) return;
  if (tree[p].children[Child.Larger] === UNUSED)
    contractNode(p, tree[p].children[Child.Smaller]);
  else if (tree[p].children[Child.Smaller] === UNUSED)
    contractNode(p, tree[p].children[Child.Larger]);
  else {
    const replacement = findNextNode(p);
    deleteString(replacement);
    replaceNode(p, replacement);
  }
}

function addString() {
  let i = 0;
  let delta = 0;
  let test_node = tree[TREE_ROOT].children[Child.Larger];
  let match_length = 0;
  for (;;) {
    for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
      delta = win[MOD_WINDOW(current_pos + i)] - win[MOD_WINDOW(test_node + i)];
      if (delta !== 0) break;
    }
    if (i >= match_length) {
      match_length = i;
      match_pos = test_node;
      if (match_length >= LOOK_AHEAD_SIZE) {
        replaceNode(test_node, current_pos);
        return match_length;
      }
    }
    const child_node = tree[test_node];
    const child_prop = delta >= 0 ? Child.Larger : Child.Smaller;
    if (child_node.children[child_prop] === UNUSED) {
      child_node.children[child_prop] = current_pos;
      tree[current_pos].parent = test_node;
      tree[current_pos].children[Child.Larger] = UNUSED;
      tree[current_pos].children[Child.Smaller] = UNUSED;
      return match_length;
    }
    test_node = child_node.children[child_prop];
  }
}

// Adapted from:
// https://github.com/2point21/lba2-classic/blob/main/SOURCES/LZSS.CPP
export function compressLZSS_LBA_type_1(data: <fim_suffix>) {
  let i: number;
  let read = 0;
  let write = 0;
  let info: number;
  let look_ahead_bytes: number;
  let replace_count: number;
  let match_length: number;
  let count_bits = 0;
  let mask = 1;
  let len = 0;
  let length = data.byteLength;

  const input = new Uint8Array(data);
  const output = new Uint8Array(length);

  const save_length = length;
  current_pos = 0;

  for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
    if (length === 0) break;
    win[current_pos + i] = input[read++];
    length--;
  }

  look_ahead_bytes = i;
  initTree(current_pos);
  match_length = 0;
  match_pos = 0;
  info = write++;

  if (++len >= save_length) return data;

  output[info] = 0;

  while (look_ahead_bytes > 0) {
    if (match_length > look_ahead_bytes) match_length = look_ahead_bytes;

    if (match_length <= BREAK_EVEN) {
      replace_count = 1;
      output[info] |= mask;
      output[write++] = win[current_pos];
      if (++len >= save_length) return data;
    } else {
      if ((len = len + 2) >= save_length) return data;

      const value =
        (MOD_WINDOW(current_pos - match_pos - 1) << LENGTH_BIT_COUNT) |
        (match_length - BREAK_EVEN - 1);
      const low = (value & 0xff00) >> 8;
      const high = value & 0xff;
      output[write] = high;
      output[write + 1] = low;

      write += 2;
      replace_count = match_length;
    }

    if (++count_bits === 8) {
      if (++len >= save_length) return data;
      info = write++;
      output[info] = 0;
      count_bits = 0;
      mask = 1;
    } else {
      mask = (mask << 1) & 0xff;
    }

    for (i = 0; i < replace_count; i++) {
      deleteString(MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE));
      if (length === 0) look_ahead_bytes--;
      else {
        win[MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE)] = input[read++];
        length--;
      }

      current_pos = MOD_WINDOW(current_pos + 1);
      if (look_ahead_bytes) match_length = addString();
    }
  }

  if (count_bits === 0) len--;
  return output.buffer.slice(0, len);
}
<fim_middle>",correct,4258
6,Binding,Binding,4b26b14a08d5cdfff6183540cb79049b3ed5038a,"<fim_prefix>/* eslint-disable no-constant-condition */

const EOF = '~EOF~'

class Parser {
  private pos = 0

  constructor(private input) {}

  next() {
    if (this.pos >= this.input.length) {
      return EOF
    }
    return this.input[this.pos++]
  }

  backup() {
    this.pos--
  }

  parseTemplate(): <fim_suffix> {
    if (this.next() != '/') {
      throw new Error('binding URL should start with a slash')
    }
    
    return {
      segments: this.parseSegments(),
      verb: this.parseVerb(),
    }
  }

  private parseSegments() {
    let segments: Segment[] = []
    segments.push(this.parseSegment())

    while (true) {
      let r = this.next()
      switch (r) {
        case '/':
          segments.push(this.parseSegment())
          continue

        case ':':
        case '}':
          this.backup()
          return segments

        case EOF:
          return segments

        default:
          throw new Error(`unexpected ${r} in segments`)
      }
    }
  }

  private parseSegment() {
    let content = ''
    while (true) {
      let r = this.next()
      switch (r) {
        case EOF:
          if (!content.length) {
            throw new Error(`unexpected EOF in segment`)
          }
          return { content }

        case '{':
          return { content, variable: this.parseVariable() }

        case ':':
        case '/':
        case '}':
          this.backup()
          if (!content.length) {
            throw new Error(`unexpected ${r} in segment`)
          }
          return { content }

        default:
          content += r
      }
    }
  }

  private parseVariable() {
    let v: Variable = {
      name: '',
    }
    while (true) {
      let r = this.next()
      switch (r) {
        case '}':
          if (!v.name.length) {
            throw new Error(`empty variable name`)
          }
          return v

        case '=':
          v.parts = this.parseSegments().map(segment => {
            if (!segment.content.length) {
              throw new Error(`unexpected empty segment`)
            }
            return segment.content
          })
          break

        case EOF:
          throw new Error(`unexpected EOF in variable ${v.name}`)

        default:
          v.name += r
      }
    }
  }

  private parseVerb() {
    let r = this.next()
    switch (r) {
      case ':':
        break

      case EOF:
        return ''

      default:
        throw new Error(`unexpected ${r} in verb`)
    }

    let verb = ''
    while (true) {
      let r = this.next()
      if (r === EOF) {
        if (!verb.length) {
          throw new Error(`empty verb`)
        }
        return verb
      }
      verb += r
    }
  }
}

interface Binding {
  segments: Segment[]
  verb: string
}

interface Segment {
  content: string
  variable?: Variable
}

interface Variable {
  name: string
  parts?: string[]
}

export function buildURL(template, params) {
  let parser = new Parser(template)
  let binding = parser.parseTemplate()

  let parts = binding.segments.map(segment => {
    if (segment.variable) {
      if (!params[segment.variable.name]) {
        throw new Error(`input parameter ${segment.variable.name} is required`)
      }

      return params[segment.variable.name]
    }
    return segment.content
  })
  let verb = binding.verb ? `:${binding.verb}` : ''
  return '/' + parts.join('/') + verb
}
<fim_middle>",correct,928
7,BooleanField,BooleanField,5f2d2febe1a2a566772fc84aa89c133d84d3093b,"<fim_prefix>/**
 * Number
 */
type NumberField = {
  type: 'number';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const number = (options) => {
  return {
    type: 'number',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * BigInt
 */
type BigIntField = {
  type: 'bigint';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const bigInt = (options) => {
  return {
    type: 'bigint',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * String
 */
type StringField = {
  type: 'string';
  maxLength: number;
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const string = (options) => {
  return {
    type: 'string',
    maxLength: options.maxLength,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Boolean
 */
type BooleanField = {
  type: 'boolean';
  canBeNull: boolean;
  default: boolean | null;
  primaryKey: boolean;
};

export const boolean = (options): <fim_suffix> => {
  return {
    type: 'boolean',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Enumerated
 */
type EnumeratedField = {
  type: 'enumerated';
  values: string[];
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const enumerated = (options) => {
  return {
    type: 'enumerated',
    values: options.values,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * DateTime
 */
type DateTimeField = {
  type: 'datetime';
  canBeNull: boolean;
  default: Date | null;
  primaryKey: boolean;
};

export const dateTime = (options) => {
  return {
    type: 'datetime',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Any Field
 */
export type AnyField =
  | NumberField
  | BigIntField
  | StringField
  | BooleanField
  | EnumeratedField
  | DateTimeField;

export type Fields = {
  [key: string]: AnyField;
};
<fim_middle>",correct,4935
8,ClassType,ClassType,b898174dc9208306ba4726075f110ac026c56fe6,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// This file contains generic TypeScript types, and predicate methods
type VoidReturn = void | undefined;

export type VoidCallback<Args extends unknown[] = []> = Args extends []
	? ((arg?) => VoidReturn)
	: ((...args) => VoidReturn);

export type DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};

export type AsyncVoidCallback<Args extends unknown[] = []> = AsyncCallback<
	VoidReturn,
	Args
>;

export type AsyncCallback<Return, Args extends unknown[] = []> = Args extends []
	? (() => Return | Promise<Return>)
	: ((...args) => Return | Promise<Return>);

export type ErrorCallback<Err extends Error = Error> = (err) => void;

export type MapKey<T> = T extends Map<infer K, unknown> ? K : never;

export type MapValue<T> = T extends Map<unknown, infer V> ? V : never;

export type SetValue<T> = T extends Set<infer V> ? V : never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export type UnionToIntersection<U> = (U extends any ? (k) => void : never) extends ((
	k,
) => void)
	? I
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
type ClassConstructorParams<T> = T extends {
	new (
		...args
	): any;
}
	? R
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export interface Class<T, Args extends any[] = ClassConstructorParams<T>> {
	new (
		...args
	): T;
	prototype: T;
}

export type Dict<T> = Record<string, T>;

export type RequiredProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]-?: NonNullable<Obj[Key]>
};

export type OptionalProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]?: Obj[Key]
};

export type TaggedTemplateFunction<Ret, Sub> = (
	strs,
	...substitutions
) => Ret;

// Turn a type that contains interfaces into regular objects
export type InterfaceToObject<T> = T extends {}
	? {[K in keyof T]: InterfaceToObject<T[K]>}
	: T;

export type UnknownObject = Dict<unknown>;

export type UnknownFunction = (...args) => unknown;

export function isObject(obj): obj is UnknownObject {
	return typeof obj === ""object"" && obj !== null && !Array.isArray(obj);
}

export function isPlainObject(obj): obj is UnknownObject {
	// Weird duck typing for cross-realm objects
	return (
		isObject(obj) &&
		obj.constructor !== undefined &&
		obj.constructor.name === ""Object""
	);
}

export function isIterable(obj): obj is Iterable<unknown> {
	if (typeof obj === ""object"" && obj != null) {
		// @ts-ignore
		return typeof obj[Symbol.iterator] === ""function"";
	} else {
		return false;
	}
}

// TypeScript has awful behaviour where it treats optional properties and undefined values as the same
// eg. https://www.typescriptlang.org/play/index.html?ssl=3&ssc=1&pln=1&pc=1#code/C4TwDgpgBAChBOBnA9gOygXigbwFBQKgDMBLJYAOQEMBbCALikWHhNQHMBufQgGyubU6jZqw7cAvt1wBjNMyhgq8YCSq84SNIzyEo-QbQgB+ESzbsANLgmYcPAgcpHGAV1QATCKVQQP1qVxZeWBFBBRURk0Iu11CUnIhBigAIgBlCAAjAVUqVBTrPSckxhSKdxAqAocoADp6pRU1DXC0AOkAeg79HKSoEkQody8fPyhM11CAFTSoD2QIRFQAclCEeGR4XEgtVFrio0wMLGHvNj9OIA
// https://github.com/microsoft/TypeScript/issues/13195
// This means that places where we expect to receive a value when object spreading in a partial object
// can actually have undefined values!
export function mergeObjects<A extends object>(
	a,
	b,
) {
	if (b === undefined) {
		return a;
	}

	const newObj: A = {
		...a,
		...b,
	};

	// If b contains undefined properties then use the value from A
	for (const key in b) {
		if (b[key] === undefined) {
			// @ts-ignore
			newObj[key] = a[key];
		}
	}

	return newObj;
}

export function equalArray<A extends unknown[], B extends unknown[]>(
	a,
	b,
): a is B {
	if (a.length !== b.length) {
		return false;
	}

	if (a === b) {
		return true;
	}

	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

// Check if a value is instance of a class, disallowing inheritance
// rome-ignore lint/ts/noExplicitAny: Necessary
export function isSafeInstanceof<ClassType extends new (
	...args
) => any>(inst, Class: <fim_suffix>): inst is InstanceType<ClassType> {
	return inst instanceof Class && inst.constructor === Class;
}
<fim_middle>",correct,3213
9,Color,Color,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random(): <fim_suffix> {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,383
10,Command,Command,c5055e95b1cf23c00d4f8174c39f7e7831a25a28,"<fim_prefix>/*--------------------------------------------------------------------------

MIT License

Copyright (c) smoke-pack 2019 Haydn Paterson (sinclair) <haydn.developer@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---------------------------------------------------------------------------*/


export interface InfoCommand   { kind: 'info',   message: string }

export interface ListCommand   { kind: 'list' }
export interface CreateCommand { kind: 'create', name: string, type: string }
export interface AddCommand    { kind: 'add',    name: string, type: string }
export interface RemoveCommand { kind: 'remove', name: string }
export interface LinkCommand   { kind: 'link',   name: string, dependency: string }
export interface UnlinkCommand { kind: 'unlink', name: string, dependency: string }

export interface CleanCommand  { kind: 'clean',  name:  string }
export interface BuildCommand  { kind: 'build',  name:  string }
export interface WatchCommand  { kind: 'watch',  names: string[] }
export interface StartCommand  { kind: 'start',  name:  string }
export interface TestCommand   { kind: 'test',   name:  string }
export interface PackCommand   { kind: 'pack',   name:  string }
export interface RunCommand    { kind: 'run',    name:  string, script: string }

export type Command =
// general
| InfoCommand 

// provision
| ListCommand
| CreateCommand 
| AddCommand 
| RemoveCommand 
| LinkCommand 
| UnlinkCommand

// automation 
| CleanCommand
| BuildCommand
| WatchCommand
| StartCommand 
| TestCommand 
| PackCommand
| RunCommand


/** Parses the given command line arguments. */
export function parse(args): <fim_suffix> {
  const forward = [args.shift()!, args.shift()!]

  if(args.length === 0) {
    const kind = 'info'
    const message = ''
    return { kind, message }
  }
  const commandKind   = args.shift()!
  switch(commandKind) {
    // ---------------------
    // provision
    // ---------------------
    case 'list': {
      const kind = 'list'
      return { kind }
    }
    // ---------------------
    // provision
    // ---------------------
    case 'create': {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <type> arguments.'
        return { kind, message }
      }
      const kind = 'create'
      const name = args.shift()!
      const type = args.shift()!
      return { kind, name, type }
    }
    case 'add': {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <type> arguments.'
        return { kind, message }
      }
      const kind = 'add'
      const name = args.shift()!
      const type = args.shift()!
      return { kind, name, type }
    }
    case 'remove': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'remove'
      const name = args.shift()!
      return { kind, name }
    }
    case ""link"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <dependency> arguments.'
        return { kind, message }
      }
      const kind       = 'link'
      const name       = args.shift()!
      const dependency = args.shift()!
      return { kind, name, dependency }
    }
    case ""unlink"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <dependency> arguments.'
        return { kind, message }
      }
      const kind       = 'unlink'
      const name       = args.shift()!
      const dependency = args.shift()!
      return { kind, name, dependency }
    }
    // ---------------------
    // automation
    // ---------------------
    case 'clean': {
      const kind = 'clean'
      if(args.length !== 1) {
        const name = '*'
        return { kind, name }
      }
      const name = args.shift()!
      return { kind, name }
    }
    case 'build': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'build'
      const name = args.shift()!
      return { kind, name }
    }
    case 'watch': {
      if(args.length < 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind  = 'watch'
      const names = [...args]
      return { kind, names }
    }
    case 'start': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'start'
      const name = args.shift()!
      return { kind, name }
    }
    case 'test': {
      if(args.length !== 1) {
        const kind = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'test'
      const name = args.shift()!
      return { kind, name }
    }
    case 'pack': {
      if(args.length !== 1) {
        const kind = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'pack'
      const name = args.shift()!
      return { kind, name }
    }
    case ""run"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <script> arguments.'
        return { kind, message }
      }
      const kind   = 'run'
      const name   = args.shift()!
      const script = args.shift()!
      return { kind, name, script }
    }
    default: {
      const kind    = 'info'
      const message = `Invalid command '${commandKind}'`
      return { kind, message }
    }
  }  
}
<fim_middle>",correct,2104
11,Config,Config,3916af040035d5fc03d4a8992d5ecdd8e2401645,"<fim_prefix>export interface Config {
    speedMultMalus: number;
    weaponSpeedMultOneHanderMalus: number;
    weaponSpeedMultTwoHanderMalus: number;
    weaponSpeedMultRangedMalus: number;
    staminaRateMultMalus: number;
    magickaRateMultMalus: number;
    powerAttackStaminaMultMalus: number;
    spellCostMalus: number;

    lightCuirassBase: number; 
    lightGauntletsBase: number; 
    lightBootsBase: number; 
    lightHelmetBase: number; 
    heavyCuirassBase: number; 
    heavyGauntletsBase: number; 
    heavyBootsBase: number; 
    heavyHelmetBase: number; 
    shieldBase: number; 

    enableSkillBonuses: boolean,
    speedMultLightArmorSkillBonus: number;
    speedMultHeavyArmorSkillBonus: number;
    weaponSpeedMultOneHandedSkillBonus: number;
    weaponSpeedMultTwoHandedSkillBonus: number;
    weaponSpeedMultMarksmanSkillBonus: number;
    staminaRateMultLightArmorSkillBonus: number;
    staminaRateMultHeavyArmorSkillBonus: number;
    magickaRateMultMagicSkillBonus: number;
    powerAttackStaminaOneHandedSkillBonus: number;
    powerAttackStaminaTwoHandedSkillBonus: number;
    spellCostSkillBonus: number;

    racialOffsets: Record<string, MalusOffset[]>;
    spellCostArgonianLightArmorRestorationPctOffset: number;
    spellCostArgonianLightArmorAlterationPctOffset: number;
    spellCostDunmerLightArmorFireDamagePctOffset: number;
    spellCostImperialHeavyArmorRestorationPctOffset: number;

    factionalOffsets: Record<string, MalusOffset[]>;
    spellCostThalmorLightArmorPctOffset: number;

    lightArmorPerkFormId: string;
    lightArmorPerkOffsetPct: number;
    heavyArmorPerkFormId: string;
    heavyArmorPerkOffsetPct: number;

    debug: boolean;
    useCloak: boolean;
}

type Types = ""string"" | ""number"" | ""boolean"" | ""object"";
export function asConfig(data): <fim_suffix> {
    const keyValidators: Record<keyof Config, Types> = {
        speedMultMalus: ""number"",
        weaponSpeedMultOneHanderMalus: ""number"",
        weaponSpeedMultTwoHanderMalus: ""number"",
        weaponSpeedMultRangedMalus: ""number"",
        staminaRateMultMalus: ""number"",
        magickaRateMultMalus: ""number"",
        powerAttackStaminaMultMalus: ""number"",
        spellCostMalus: ""number"",

        lightCuirassBase: ""number"", 
        lightGauntletsBase: ""number"", 
        lightBootsBase: ""number"", 
        lightHelmetBase: ""number"", 
        heavyCuirassBase: ""number"", 
        heavyGauntletsBase: ""number"", 
        heavyBootsBase: ""number"", 
        heavyHelmetBase: ""number"", 
        shieldBase: ""number"", 

        enableSkillBonuses: ""boolean"",
        speedMultLightArmorSkillBonus: ""number"",
        speedMultHeavyArmorSkillBonus: ""number"",
        weaponSpeedMultOneHandedSkillBonus: ""number"",
        weaponSpeedMultTwoHandedSkillBonus: ""number"",
        weaponSpeedMultMarksmanSkillBonus: ""number"",
        staminaRateMultLightArmorSkillBonus: ""number"",
        staminaRateMultHeavyArmorSkillBonus: ""number"",
        magickaRateMultMagicSkillBonus: ""number"",
        powerAttackStaminaOneHandedSkillBonus: ""number"",
        powerAttackStaminaTwoHandedSkillBonus: ""number"",
        spellCostSkillBonus: ""number"",

        racialOffsets: ""object"",
        spellCostArgonianLightArmorRestorationPctOffset: ""number"",
        spellCostArgonianLightArmorAlterationPctOffset: ""number"",
        spellCostDunmerLightArmorFireDamagePctOffset: ""number"",
        spellCostImperialHeavyArmorRestorationPctOffset: ""number"",

        factionalOffsets: ""object"",
        spellCostThalmorLightArmorPctOffset: ""number"",
    
        lightArmorPerkFormId: ""string"",
        lightArmorPerkOffsetPct: ""number"",
        heavyArmorPerkFormId: ""string"",
        heavyArmorPerkOffsetPct: ""number"",
    
        debug: ""boolean"",
        useCloak: ""boolean"",
    }

    if (typeof data === 'object' && data !== null) {
        let maybeConfig = data as Config
        for (const key of Object.keys(keyValidators) as Array<keyof Config>) {
            if (typeof maybeConfig[key] !== keyValidators[key]) {
                throw new Error(`data is not a Config: ${key} has type ${typeof maybeConfig[key]}`);
            }
            if (key === ""racialOffsets"") {
                const maybeOffsets = maybeConfig[key];
                Object.keys(maybeOffsets).map(key => maybeOffsets[key].map(maybeOffset => asMalusOffset(maybeOffset)));
            }
        }
        return maybeConfig;
    }

    throw new Error('data is not a Config');
}

type Malus = ""SpeedMult"" | ""WeaponSpeedMult"" | ""StaminaRateMult"" | ""MagickaRateMult"";
type ArmorKeyword = ""ArmorLight"" | ""ArmorHeavy"" | ""Any"";
type WeaponKeyword = ""WeapTypeSword"" | ""WeapTypeDagger"" | ""WeapTypeWarAxe"" | ""WeapTypeMace"" | ""WeapTypeGreatsword"" | ""WeapTypeBattleaxe"" | ""WeapTypeWarhammer"" | ""WeapTypeBow"" | ""WeapTypeCrossbow""  | ""Any"";
export interface MalusOffset {
    malus: Malus;
    armorKeyword: ArmorKeyword;
    weaponKeyword: WeaponKeyword;
    requiresShield: boolean;
    pctOffset: number;
}

export function asMalusOffset(data) {
    const keyValidators: Record<keyof MalusOffset, Types> = {
        malus: ""string"",
        armorKeyword: ""string"",
        weaponKeyword: ""string"",
        requiresShield: ""boolean"",
        pctOffset: ""number"",
    }

    if (typeof data === 'object' && data !== null) {
        let maybeMalusOffset = data as MalusOffset
        for (const key of Object.keys(keyValidators) as Array<keyof MalusOffset>) {
            if (typeof maybeMalusOffset[key] !== keyValidators[key]) {
                throw new Error(`data is not a MalusOffset: ${key} has type ${typeof maybeMalusOffset[key]}`);
            }
        }
        return maybeMalusOffset;
    }

    throw new Error('data is not a MalusOffset');
}
<fim_middle>",correct,1619
12,Container,Container,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args): <fim_suffix> {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,994
13,Context,Context,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name
) => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?: <fim_suffix>) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,204
14,Converter,Converter,447872004859a7953a492bb7f23a814bdf0b3451,"<fim_prefix>const BitLookup = [ 1, 2, 4, 8, 16, 32, 64, 128 ];

export interface Converter
{
  atob?: (s) => string;
  btoa?: (s) => string;
}

// In NodeJS:

// {
//  btoa: (s: string) => { return Buffer.from(s, 'binary').toString('base64') },
//  atob: (s: string) => { return Buffer.from(s, 'base64').toString('binary') },
// }

// In Browser:

// {
//  btoa: window.btoa,
//  atob: window.atob,
// }

export class ListToBitset
{
  list: string[];
  index: { [s: string]: number };
  size: number;
  converter: Converter;

  constructor(list, converter?: <fim_suffix>)
  {
    this.list = list;
    this.converter = converter;
  }

  toBits(l)
  {
    if (! this.index)
    {
      this.size = Math.floor((this.list.length+7)/8);
      this.index = {};
      this.list.forEach((s, i) => { this.index[s] = i });
    }
    let ab = new ArrayBuffer(this.size);
    let u8 = new Uint8Array(ab);
    if (l) l.forEach(s => {
        let n = this.index[s];
        let i = Math.floor(n/8);
        u8[i] |= BitLookup[n % 8];
      });
    return u8;
  }

  toList(u8)
  {
    let list: string[] = [];
    for (let i = 0; i < u8.length; i++)
    {
      let u = u8[i];
      if (u)
      {
        if (u & 1) list.push(this.list[i*8+0]);
        if (u & 2) list.push(this.list[i*8+1]);
        if (u & 4) list.push(this.list[i*8+2]);
        if (u & 8) list.push(this.list[i*8+3]);
        if (u & 16) list.push(this.list[i*8+4]);
        if (u & 32) list.push(this.list[i*8+5]);
        if (u & 64) list.push(this.list[i*8+6]);
        if (u & 128) list.push(this.list[i*8+7]);
      }
    }
    return list;
  }

  base64tou8(base64)
  {
    let raw = this.converter.atob(base64);
    let rawLength = raw.length;
    let u8 = new Uint8Array(new ArrayBuffer(rawLength));
    for (let i = 0; i < rawLength; i++)
      u8[i] = raw.charCodeAt(i);
    return u8;
  }

  u8ToBase64(u8)
  {
    let binary: string[] = [];
    let len = u8.byteLength;
    for (let i = 0; i < len; i++) {
        binary.push(String.fromCharCode(u8[i]));
    }
    return this.converter.btoa(binary.join(''));
}

  fromBitString(base64)
  {
    return this.toList(this.base64tou8(base64));
  }

  toBitString(l)
  {
    // Note: On server, Buffer.from(this.toBits(l)).toString('base64') probably faster
    return this.u8ToBase64(this.toBits(l));
  }
}
<fim_middle>",correct,5135
15,Currency,Currency,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest() {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency: <fim_suffix> = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions) {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",correct,2971
16,Cx,Cx,6b2e48994d25dfb77d9f951487af828409217c22,"<fim_prefix>/* Types */

type Tx<T> = () => Promise<T>;
type Cx = () => Promise<unknown>;

export class ReadOnly<T> {
  constructor(public tx) {}
}

export class Mutating<T> {
  constructor(public tx, public cx) {}
}

export class Pivot<T> {
  constructor(public tx) {}
}

type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;

export type Workflow = Generator<Step<any>, void, any>;

/* Constructors */

export const readOnly = <T>(tx) => new ReadOnly<T>(tx);

export const mutating = <T>(tx, cx: <fim_suffix>) =>
  new Mutating<T>(tx, cx);

export const pivot = <T>(tx) => new Pivot<T>(tx);

/* Workflow executor */

export async function run(workflow) {
  // a list of compensating functions
  let cxs: Cx[] = [];
  // a number of pivot operations happened during the workflow
  let nPivots: number = 0;
  // should the workflow be unrolled
  let unrollReason: unknown;

  let next: IteratorResult<Step<unknown>>;
  let res: unknown;

  try {
    next = workflow.next();
  } catch (e) {
    unrollReason = e;
  }

  while (!unrollReason && !next!.done) {
    const flow = next!.value;

    try {
      // execute async operation
      res = await flow.tx();
    } catch (e1) {
      // async exception caught
      try {
        // try rethrowing into workflow -- this acquires a next workflow step;
        // compensating operation is not added, because the atomic forward
        // operation didn't succeed, so nothing to compensate
        next = workflow.throw(e1);
        continue;
      } catch (e2) {
        // rethrowing didn't succeed, unroll
        unrollReason = e2;
        break;
      }
    }

    // async operation succeeds, register its aftereffects
    if (flow instanceof Mutating) {
      cxs.push(flow.cx);
    } else if (flow instanceof Pivot) {
      nPivots++;
    }

    // try acquiring next workflow step
    try {
      next = workflow.next(res);
      continue;
    } catch (e) {
      // caught a sync exception that is not caught inside workflow, unroll
      unrollReason = e;
      break;
    }
  }

  // unroll if error happened
  if (unrollReason) {
    // workflow is not revertible if there were completed pivot operations
    if (nPivots) {
      throw unrollReason;
    }

    for (const cx of cxs.reverse()) {
      // compensating function error means the state is unknown
      // this can only be handled by a caller, so no try-catch
      await cx();
    }
    throw unrollReason;
  }
}
<fim_middle>",correct,3734
17,Date,Date,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date): <fim_suffix> {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",correct,693
18,Deps,Deps,4ecebdfe2a83e32ca2665144d05b64c53181178a,"<fim_prefix>/**
 *
 *
 * Copied direcly from: https://github.com/pmndrs/jotai/blob/main/src/utils/weakCache.ts
 *
 * Eventually just import it from Jotai if it's exported.
 *
 *
 *
 */
export type WeakCache<T> = WeakMap<object, [WeakCache<T>] | [WeakCache<T>, T]>;

const getWeakCacheItem = <T>(
  cache,
  deps
) => {
  while (true) {
    const [dep, ...rest] = deps;
    const entry = cache.get(dep as object);
    if (!entry) {
      return;
    }
    if (!rest.length) {
      return entry[1];
    }
    cache = entry[0];
    deps = rest;
  }
};

const setWeakCacheItem = <T>(
  cache,
  deps,
  item
) => {
  while (true) {
    const [dep, ...rest] = deps;
    let entry = cache.get(dep as object);
    if (!entry) {
      entry = [new WeakMap()];
      cache.set(dep as object, entry);
    }
    if (!rest.length) {
      entry[1] = item;
      return;
    }
    cache = entry[0];
    deps = rest;
  }
};

export const createMemoizeAtom = () => {
  const cache: WeakCache<{}> = new WeakMap();
  const memoizeAtom = <T extends {}, Deps extends readonly object[]>(
    createAtom,
    deps: <fim_suffix>
  ) => {
    const cachedAtom = getWeakCacheItem(cache, deps);
    if (cachedAtom) {
      return cachedAtom as T;
    }
    const createdAtom = createAtom();
    setWeakCacheItem(cache, deps, createdAtom);
    return createdAtom;
  };
  return memoizeAtom;
};
<fim_middle>",correct,3786
19,Difficulty,Difficulty,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty: <fim_suffix>) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty) => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",correct,4729
20,Dim,Dim,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by: <fim_suffix>)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1215
21,ElementType,ElementType,8ab616f33f5bd10a91c24a82c6b27b64f543e801,"<fim_prefix>
export interface SelectionElement {
  get selected();
  set selected(val);
  get value();

  addOnChange: (callback) => (() => void);
};

export class SelectionState<T = any, ElementType extends SelectionElement = SelectionElement> {
  elements: { el: ElementType, listener: () => void }[] = [];
  value: T | T[];
  any: boolean;
  all: boolean;
  onChange: (val, all, any) => void;
  onUpdate: (state) => void;

  constructor(
    public readonly allowMultiple,
    public readonly initialValue,
  ) {
    this.value = initialValue || (allowMultiple ? [] : undefined);
    if (this.allowMultiple && !Array.isArray(this.value)) this.value = [this.value];
  }

  private changed(sender?) {
    if (this.allowMultiple) {
      let all = true;
      let any = false;
      const res = [];
      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el.selected) {
          res.push(element.el.value);
          any = true;
        }
        else all = false;
      }
      this.value = res;
      this.all = all;
      this.any = any;
      return;
    } else {
      this.all = false;
      let firstChecked = sender;

      if (!firstChecked) {
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (element.el.selected) {
            firstChecked = element.el;
            break;
          }
        }
      }

      if (!firstChecked) {
        this.value = undefined;
        this.any = false;
        return;
      }

      if (!firstChecked.selected) firstChecked.selected = true;

      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el !== firstChecked) element.el.selected = false;
      }

      this.value = firstChecked.value;
      this.any = true;
    }
  }

  triggerChange() {
    this.onChange?.(this.value, this.all, this.any);
  }

  triggerUpdate() {
    this.onUpdate?.(this);
  }

  register(el) {
    const listener = el.addOnChange(() => {
      this.changed(el);
      this.triggerChange();
      this.triggerUpdate();
    });

    this.elements.push({ el, listener });

    if (this.allowMultiple && Array.isArray(this.value)) el.selected = this.value.includes(el.value);
    else el.selected = this.value === el.value;

    if (this.allowMultiple) {
      if (this.all && !el.selected) {
        this.all = false;
        this.triggerChange();
      }

      if (!this.any && el.selected) {
        this.any = true;
        this.triggerChange();
      }
    }

    this.triggerUpdate();
  }

  unregister(el: <fim_suffix>) {
    const ind = this.elements.findIndex(x => x.el === el);
    if (ind >= 0) {
      const item = this.elements[ind];
      this.elements.splice(ind, 1);
      if (item.listener) item.listener();
    }

    this.triggerUpdate();
  }

  setAll(checked?) {
    if (!this.allowMultiple && checked) throw new Error('Multiple values cannot be selected for radio groups');
    checked = !!checked;

    this.all = checked;
    this.any = checked;

    const values = [];
    for (let index = 0; index < this.elements.length; index++) {
      const element = this.elements[index];
      element.el.selected = checked;
    }

    this.value = this.allowMultiple ? values : undefined;
    this.all = checked;
    this.any = checked;
    this.triggerChange();
    this.triggerUpdate();
  }

  getSelectedElements() {
    const res: ElementType[] = [];
    for (let index = 0; index < this.elements.length; index++) {
      const { el } = this.elements[index];

      const isSelected = this.allowMultiple && Array.isArray(this.value) ? this.value.includes(el.value) : this.value === el.value;
      if (isSelected) res.push(el);
    }

    return res;
  }
}
<fim_middle>",correct,4457
22,Error,Error,4626f86ebac17685496987c0b44d830041d92194,"<fim_prefix>export interface Part {
  name: string;
  group: PartGroupType;
  path: string;
  pathToSmallImage: string;
}

export interface PartsState {
  isLoading: boolean;
  error?: Error;
  backParts: Record<string, Part>;
  frontParts: Record<string, Part>;
  wordParts: Record<string, Part>;
}

export enum PartGroupType {
  BACK_NORMAL = 'BACK_NORMAL',
  BACK_SPECIAL = 'BACK_SPECIAL',
  FRONT_NORMAL = 'FRONT_NORMAL',
  FRONT_ANIMALS = 'FRONT_ANIMALS',
  FRONT_CODENAMES = 'FRONT_CODENAMES',
  FRONT_SPECIAL = 'FRONT_SPECIAL',
  WORD_NORMAL = 'WORD_NORMAL',
  WORD_PHONETIC = 'WORD_PHONETIC',
  WORD_CODENAMES = 'WORD_CODENAMES',
  WORD_NUMBER = 'WORD_NUMBER',
  WORD_LETTER = 'WORD_LETTER',
}

export const groupTypeDisplayNames = new Map([
  [PartGroupType.BACK_NORMAL, 'Normal'],
  [PartGroupType.BACK_SPECIAL, 'Special'],
  [PartGroupType.FRONT_NORMAL, 'Normal'],
  [PartGroupType.FRONT_SPECIAL, 'Special'],
  [PartGroupType.FRONT_ANIMALS, 'Animals'],
  [PartGroupType.FRONT_CODENAMES, 'Codenames'],
  [PartGroupType.WORD_NORMAL, 'Normal'],
  [PartGroupType.WORD_NUMBER, 'Numbers'],
  [PartGroupType.WORD_LETTER, 'Letter'],
  [PartGroupType.WORD_PHONETIC, 'Phonetic'],
  [PartGroupType.WORD_CODENAMES, 'Codenames'],
]);

export const backGroupTypes = new Set([
  PartGroupType.BACK_NORMAL,
  PartGroupType.BACK_SPECIAL,
]);

export const frontGroupTypes = new Set([
  PartGroupType.FRONT_NORMAL,
  PartGroupType.FRONT_ANIMALS,
  PartGroupType.FRONT_CODENAMES,
  PartGroupType.FRONT_SPECIAL,
]);

export const wordGroupTypes = new Set([
  PartGroupType.WORD_NORMAL,
  PartGroupType.WORD_PHONETIC,
  PartGroupType.WORD_CODENAMES,
  PartGroupType.WORD_NUMBER,
  PartGroupType.WORD_LETTER,
]);

export function loadingPartsState() {
  return {
    isLoading: true,
    backParts: {},
    frontParts: {},
    wordParts: {},
  };
}

export function successPartsState(json) {
  const backParts: Record<string, Part> = {};
  const frontParts: Record<string, Part> = {};
  const wordParts: Record<string, Part> = {};

  for (const id of Object.keys(json)) {
    const part = json[id];
    part.path = `/assets/images/${part.path}`;

    if (backGroupTypes.has(part.group)) {
      backParts[id] = part;
    } else if (frontGroupTypes.has(part.group)) {
      frontParts[id] = part;
    } else if (wordGroupTypes.has(part.group)) {
      wordParts[id] = part;
    }
  }

  return {
    isLoading: false,
    backParts,
    frontParts,
    wordParts,
  };
}

export function errorPartsState(error: <fim_suffix>) {
  return {
    isLoading: false,
    error,
    backParts: {},
    frontParts: {},
    wordParts: {},
  };
}
<fim_middle>",correct,1982
23,ErrorResponse,ErrorResponse,009999bb6cc1b9b148abc178a6579d671236e29a,"<fim_prefix>interface APIError {
	number: number
	field?: string
	message?: string
	object?: string
	value?: string
}

export type ErrorResponse =
	| { errors: APIError[] }
	| { code: string; message: string }

export default class APIClientError extends Error {
	name: string

	message: string

	code?: string

	errors?: APIError[]

	constructor(
		name,
		message,
		code?,
		errors?
	) {
		super()
		this.name = name
		this.message = message
		this.code = code
		this.errors = errors
	}
}

export const isErrorResponse = ({
	error,
	error_type: errorType,
	response,
}) => error || errorType || response.errors

export const transformErrorResponse = (errorResponse): <fim_suffix> => {
	const {
		response,
		error,
		error_description: errorDescription,
		error_type: errorType,
		message,
	} = errorResponse

	// singular error e.g., as returned by APIClient.users.me()
	if (error && errorDescription) {
		return {
			code: error,
			message: errorDescription,
		}
	}

	// not_found error
	if (errorType && message) {
		return {
			code: errorType,
			message,
		}
	}

	// general error supplied by valid endpoint
	return {
		errors: response.errors.map(
			({
				errno: number,
				field,
				message: msg,
				object,
				value,
			}) => ({
				number,
				field,
				message: msg,
				object,
				value,
			})
		),
	}
}
<fim_middle>",correct,3900
24,Factor,Factor,5854bf3dea0d67d8667446aaccf3a64dd1f826ee,"<fim_prefix>const DFG_VERSION = '0.18.1';
const PI = 3.14159;

export enum FactorType {
  PRIORPOSE2 = 'PriorPose2',
  POSE2POSE2 = 'Pose2Pose2',
  POSE2APRILTAG4CORNERS = 'Pose2AprilTag4Corners',
}

type FactorData = {
  eliminated: boolean;
  potentialused: boolean;
  edgeIDs: string[];
  fnc: any;
  multihypo: number[];
  certainhypo: number[];
  nullhypo: number;
  solveInProgress: number;
  inflation: number;
};

export type Factor = {
  label: string;
  nstime: string;
  fnctype: string;
  _variableOrderSymbols: string[];
  data: FactorData;
  solvable: number;
  tags: string[];
  timestamp: string;
  _version: string;
};

function InitializeFactorData() {
  return {
    eliminated: false,
    potentialused: false,
    edgeIDs: [],
    fnc: {},
    multihypo: [],
    certainhypo: [],
    nullhypo: 0.0,
    solveInProgress: 0,
    inflation: 3.0,
  };
}

export function PriorPose2Data(xythetaPrior = [0.0, 0.0, 0.0], xythetaCovars = [0.01, 0.01, 0.01]) {
  const fnc = {
    Z: {
      _type: 'IncrementalInference.PackedFullNormal',
      mu: xythetaPrior,
      cov: [xythetaCovars[0], 0.0, 0.0, 0.0, xythetaCovars[1], 0.0, 0.0, 0.0, xythetaCovars[2]],
    },
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1];
  return data;
}

export function Pose2Pose2Data(mus = [1, 0, 0.3333 * PI], sigmas = [0.01, 0.01, 0.01]) {
  const fnc = {
    Z: {
      _type: 'IncrementalInference.PackedFullNormal',
      mu: mus,
      cov: [sigmas[0], 0.0, 0.0, 0.0, sigmas[1], 0.0, 0.0, 0.0, sigmas[2]],
    },
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1, 2];
  return data;
}

export function Pose2AprilTag4CornersData(
  id,
  corners,
  homography,
  K = [300.0, 0.0, 0.0, 0.0, 300.0, 0.0, 180.0, 120.0, 1.0],
  taglength = 0.25,
) {
  const fnc = {
    _type: '/application/JuliaLang/PackedPose2AprilTag4Corners',
    corners,
    homography,
    K,
    taglength,
    id,
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1, 2];
  return data;
}

export function Factor(
  label,
  fncType,
  variableOrderSymbols,
  data,
  tags = ['FACTOR'],
  timestamp = new Date().toISOString(),
): <fim_suffix> {
  data.certainhypo = variableOrderSymbols.map((x, idx) => idx + 1);

  const result: Factor = {
    label,
    nstime: '0',
    fnctype: fncType,
    _variableOrderSymbols: variableOrderSymbols,
    data,
    solvable: 1,
    tags,
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",correct,2815
25,Fields,Fields,bf712f9fe76a6eeeb69b15794f6333cb9c774f5e,"<fim_prefix>/* eslint-disable @typescript-eslint/naming-convention */
export type ResponseMessage = {
    status: string;
    message: any;
};

export type ErrorResponse = {
    error: string;
    message?: string;
};

export type Fields = {
    id?: boolean;
    title?: boolean;
    main_picture?: boolean;
    alternative_titles?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    synopsis?: boolean;
    mean?: boolean;
    rank?: boolean;
    popularity?: boolean;
    num_list_users?: boolean;
    num_scoring_users?: boolean;
    nsfw?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    media_type?: boolean;
    status?: boolean;
    genres?: boolean;
    my_list_status?: boolean | Fields; // different possible fields
    num_episodes?: boolean;
    start_season?: boolean;
    broadcast?: boolean;
    source?: boolean;
    average_episode_duration?: boolean;
    rating?: boolean;
    pictures?: boolean;
    background?: boolean;
    related_anime?: boolean | Fields;
    related_manga?: boolean | Fields;
    recommendations?: boolean | Fields;
    studios?: boolean;
    statistics?: boolean;
    videos?: boolean;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function fieldsToString(fields) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    const entries = Object.entries(fields);
    let str = """";

    for (const entry of entries) {
        if (str.length > 0) {
            str += "","";
        }
        str += entry[0];
        if (entry[1] !== true && entry[1] !== false) {
            str += `{${fieldsToString(entry[1] as any)}}`;
        }
    }
    return str;
}

export function extractFields(str) {
    let subject = str;

    if (subject[0] === ""{"") {
        subject = subject.substr(1, subject.length);
    }

    let currentObject = """";
    const createdObj: any = {};

    function addObject(stri, val) {
        if (stri === """") return;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        createdObj[currentObject] = val;
        currentObject = """";
    }

    function skipSubject() {
        subject = subject.substr(1, subject.length);
    }

    while (subject.length > 0) {
        const subjZero = subject[0];

        if (subjZero === "" "") {
            skipSubject();
            if (subject.length === 0) {
                addObject(currentObject, true);
            }
            continue;
        }

        if (subjZero === ""{"") {
            const res = extractFields(subject);
            addObject(currentObject, res.fields);
            subject = res.remaining;
            continue;
        }
        if (subjZero === ""}"") {
            addObject(currentObject, true);

            skipSubject();
            if (subject[0] === "","") skipSubject();

            return {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                fields: createdObj,
                remaining: subject,
            };
        }
        if (subjZero === "","") {
            addObject(currentObject, true);
            skipSubject();
            continue;
        }

        currentObject += subjZero;
        skipSubject();

        if (subject.length === 0) {
            addObject(currentObject, true);
        }
    }

    return {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        fields: createdObj,
        remaining: """",
    };
}

export function allFields(): <fim_suffix> {
    return {
        alternative_titles: true,
        average_episode_duration: true,
        background: true,
        broadcast: true,
        created_at: true,
        end_date: true,
        genres: true,
        id: true,
        main_picture: true,
        mean: true,
        media_type: true,
        my_list_status: true,
        nsfw: true,
        num_episodes: true,
        num_list_users: true,
        num_scoring_users: true,
        pictures: true,
        popularity: true,
        rank: true,
        rating: true,
        recommendations: true,
        related_anime: true,
        related_manga: true,
        source: true,
        start_date: true,
        start_season: true,
        statistics: true,
        status: true,
        studios: true,
        synopsis: true,
        title: true,
        updated_at: true,
    };
}

type Relation = MediaNode & {
    relation_type: string;
    relation_type_formatted: string;
};

export type StatusNode = MediaNode & {
    list_status: ListStatus;
};

export type Media = {
    id: number;
    title: string;
    main_picture: Picture;
    alternative_titles?: {
        synonyms?: string[];
        en?: string;
        ja?: string;
    };
    start_date?: string;
    end_date?: string;
    synopsis?: string;
    mean?: number;
    rank?: number;
    popularity?: number;
    num_list_users?: number;
    num_scoring_users?: number;
    nsfw?: string;
    created_at?: string;
    updated_at?: string;
    media_type?: string;
    status?: string;
    genres?: Genre[];
    my_list_status?: ListStatus;
    num_episodes?: number;
    start_season?: Season;
    broadcast?: {
        day_of_the_week?: string;
        start_time?: string;
    };
    source?: string;
    average_episode_duration?: number;
    rating?: string;
    pictures?: Picture[];
    background?: string;
    related_anime?: Relation[];
    related_manga?: Relation[];
    recommendations?: (MediaNode & {
        num_recommendations?: number;
    })[];
    studios?: Studio[];
    statistics?: {
        status?: {
            watching?: string;
            completed?: string;
            on_hold?: string;
            dropped?: string;
            plan_to_watch?: string;
        };
        num_list_users?: number;
    };
};

export type tokenResponse = {
    token_type: ""Bearer"";
    expires_in: number;
    access_token: string;
    refresh_token: string;
};

export type Picture = {
    medium: string;
    large: string;
};

export type Genre = {
    id: number;
    name: string;
};

export type ListStatus = {
    status: ""watching"" | ""completed"" | ""on_hold"" | ""dropped"" | ""plan_to_watch"";
    score: number;
    num_episodes_watched: number;
    is_rewatching: boolean;
    updated_at: string;
};

export type ListPagination<T> = {
    data: T[];
    paging: {
        next: string;
        previous?: string | undefined;
    };
};

export type RequestResponse<T> = {
    response:
        | {
              response: T;
              tokens: tokenResponse;
          }
        | ErrorResponse;
};

export type MediaNode = {
    node: Media;
};

export type Season = {
    year: number;
    season: string;
};

export type Studio = {
    id: number;
    name: string;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isTokenResponse(obj): obj is tokenResponse {
    return ""tokenType"" in obj;
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isErrResp(obj): obj is ErrorResponse {
    return ""error"" in obj;
}
<fim_middle>",correct,4426
26,Function,Function,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn: <fim_suffix>, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",correct,838
27,G,G,cc966119a9d0804aa81737f900326caade60f340,"<fim_prefix>interface ErrorOption {
  cause?: Error;
  status?: number;
}

interface Convertable {
  [key: string]: string | number;
}

type ConvertString<T extends Convertable, Group extends string> = {
  [P in keyof T]: P extends string
    ? T[P] extends number
      ? `${Uppercase<Group>}_${T[P]}`
      : never
    : never;
};

const codeGroup = new Set();

/**
 * Register error group and code, return the standard ErrorCode
 * @param errorGroup
 * @param errorCodeMapping
 */
export function registerErrorCode<T extends Convertable, G extends string>(
  errorGroup: <fim_suffix>,
  errorCodeMapping
) {
  if (codeGroup.has(errorGroup)) {
    throw new MidwayError(
      `Error group ${errorGroup} is duplicated, please check before adding.`
    );
  } else {
    codeGroup.add(errorGroup);
  }
  const newCodeEnum = {} as Convertable;
  // ERROR => GROUP_10000
  for (const errKey in errorCodeMapping) {
    newCodeEnum[errKey as string] =
      errorGroup.toUpperCase() +
      '_' +
      String(errorCodeMapping[errKey]).toUpperCase();
  }
  return newCodeEnum as ConvertString<T, G>;
}

export class MidwayError extends Error {
  code: number | string;
  cause: Error;

  constructor(message, options?);
  constructor(message, code, options?);
  constructor(message, code, options?) {
    super(message);
    if (!code || typeof code === 'object') {
      options = code;
      code = 'MIDWAY_10000';
    }
    this.name = this.constructor.name;
    this.code = code;
    this.cause = options?.cause;
  }
}

export type ResOrMessage = string | { message: string };

export class MidwayHttpError extends MidwayError {
  status: number;

  constructor(resOrMessage, status);
  constructor(
    resOrMessage,
    status,
    code,
    options?
  );
  constructor(
    resOrMessage,
    status,
    code?,
    options?
  ) {
    super(
      typeof resOrMessage === 'string' ? resOrMessage : resOrMessage.message,
      code ?? String(status),
      options
    );
    this.status = status;
  }
}
<fim_middle>",correct,2537
28,GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState) {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState, numberOfRounds): <fim_suffix> {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2132
29,HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error): <fim_suffix> {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1145
30,I,I,e0adc0a947e9e83b8bc03219033fde3d085cbfad,"<fim_prefix>
/**
 * The **bulk function** receives and array of atomic inputs and returns and array of outputs processed in bulk mode.
 * It is essential that this function works more effeciently with an array of items than doing the same operation individually.
 * The response of this function is an array where the items must be placed in the same position than the input items.
 * ```typescript
 * //bulk operation
 * mongodb.insertMany([obj1, obj2, obj3])
 * //atomic operation
 * Promise.all([
 *  mongodb.insertOne(obj1),
 *  mongodb.insertOne(obj2),
 *  mongodb.insertOne(obj3)
 * ])
 * ```
 * 
 * @typeParam Input The input item type.
 * @typeParam Output The output response type.
 */
export type ExecuteBulkFn<Input,Output> = (items) => Promise<Output[]>

class PromiseBulkSingle<I,O> {
    private _executionItemsPromise: Promise<O[]> = Promise.resolve([])
    private _pendingItems = []
    private _free = true


    constructor(private readonly _executeBulk) {}

    async execute(item: <fim_suffix>) {
        const newSize = this._pendingItems.push(item)
        const myIndex = newSize - 1

        if (this._free) {
            this._free = false
            const itemsToExecute = this._pendingItems
            this._pendingItems = []
            this._executionItemsPromise = this.executeBulk(itemsToExecute)
    
            const executedItems = await this._executionItemsPromise
            this._free = true
    
            return executedItems[myIndex]
    
        } else {
            await this._executionItemsPromise
    
            if (this._free) {
                this._free = false
                const itemsToExecute = this._pendingItems
                this._pendingItems = []
                this._executionItemsPromise = this.executeBulk(itemsToExecute)
    
                const executionItems = await this._executionItemsPromise
                this._free = true
                return executionItems[myIndex]
            } else {
                const executedItems = await this._executionItemsPromise
                return executedItems[myIndex]
            }
        }
    }

    executeBulk(items) {
        if (!this._executeBulk) {
            throw new Error('Execute bulk not implemented')
        }
        return this._executeBulk(items)
    }



}

/**
 * This is the main `promise-bulk` feature.
 * This class allows to instantiate bulk processes.
 * 
 * A bulk function is the only required constructor parameter.
 * 
 * @typeParam Input The type of the input items to be processed by the bulk function.
 * 
 * @typeParam Output The type of the response items of the bulk function.
 */
export class PromiseBulk<Input = unknown, Output = unknown> {
    private _index = 0
    private readonly _bulks: PromiseBulkSingle<Input,Output>[]

    /**
     * 
     * @param bulkFn Bulk function. Receives an array of imputs and returns an array of outputs.
     * @param _concurrency Limit of concurrent calls to the bulk function.
     */
    constructor(bulkFn, private readonly _concurrency = 1) {
        this._index = 0
        this._bulks = Array.from({length: _concurrency}, () => new PromiseBulkSingle(bulkFn))
    }

    /**
     * Execute
     * 
     * This function adds one item to the bulk process and waits for its response in a bulk operation.
     * @param item Atomic input that will be included in a bulk process
     * @returns The associated response to the input (will be returned from a bulk process)
     */
    async execute(item) {
        const index = this._index
        this._index = (this._index+1) % this._concurrency
        return this._bulks[index].execute(item)
    }
}<fim_middle>",correct,4342
31,Id,Id,32fad88cf989fe13e31b63cb2ea82544e40b70b9,"<fim_prefix>type Id = string | number;
type Owner = { Id: string }

export enum NFTAction {
  SEND='SEND',
  CONSUME='CONSUME',
  FREEZE='FREEZE',
  DELEGATE='DELEGATE',
  THAW='THAW',
  REVOKE='REVOKE',
  NONE='',
}

export const actionResolver: Record<NFTAction, [string, string]> = {
  SEND: ['uniques','transfer'],
  CONSUME: ['uniques','burn'],
  DELEGATE: ['uniques','approveTransfer'],
  FREEZE: ['uniques','freeze'],
  THAW: ['uniques','thaw'],
  REVOKE: ['uniques','cancelApproval'],
  '': ['',''],
}

export const basicUpdateFunction = (name, index) => `${name} #${index + 1}`

class NFTUtils {
  static createCollection(id, admin) {
    return [String(id), { Id: admin }]
  }


  static createNFT(classId, id, owner) {
    return [String(classId), String(id), { Id: owner }]
  }

  static getActionParams(selectedAction, classId: <fim_suffix>, id, meta) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.CONSUME:
    case NFTAction.DELEGATE:
    case NFTAction.REVOKE:
      return [classId, id, meta]
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return [classId, id]
    default:
      throw new Error('Action not found')
    }
  }

  static apiCall(selectedAction) {
    return actionResolver[selectedAction] || new Error('Action not found')

  }

  static correctMeta(selectedAction, meta, currentOwner, delegate) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.DELEGATE:
      return meta
    case NFTAction.CONSUME:
      return currentOwner
    case NFTAction.REVOKE:
      return delegate
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return ''
    default:
      throw new Error('Action not found')
    }
  }
}



export default NFTUtils
<fim_middle>",correct,2625
32,Instruction,Instruction,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input) : <fim_suffix> {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,292
33,Job,Job,2c31ac9149f16e030306749f32588668642a2f12,"<fim_prefix>export default function parseJob({ skills, seniorityLevels }) {
  return ({
    id,
    title,
    description,
    seniorities: seniorityIds,
    mainSkills: mainSkillIds,
    completeSkills: completeSkillIds,
    location,
    remote,
    startingDate,
  }: <fim_suffix>) => {
    const seniorities = findAll(seniorityLevels, seniorityIds) as Seniority[];
    const mainSkills = findAll(skills, mainSkillIds) as Skill[];
    const completeSkills = findAll(skills, completeSkillIds) as Skill[];
    return {
      id,
      title,
      description,
      location,
      remote,
      startingDate,
      experience: getExperienceRange(seniorities),
      salary: getSalaryRange(seniorities),
      mainSkills: getSkills(mainSkills),
      completeSkills: getSkills(completeSkills),
    };
  };
}

function find(items, id) {
  return items.find((item) => item.id === id);
}

function findAll(items, ids = []) {
  return ids.map((id) => find(items, id));
}

function getSkills(skills) {
  return skills.map((skill) => skill.name);
}

function getExperienceRange(seniorities) {
  return seniorities
    .reduce(
      (acc, seniority) => [
        Math.min(seniority.experience.min, acc[0]),
        Math.max(seniority.experience.max || seniority.experience.min, acc[1]),
      ],
      [Infinity, 0]
    )
    .join("" - "");
}

function getSalaryRange(seniorities) {
  return seniorities
    .reduce(
      (acc, seniority) => [
        Math.round(Math.min(seniority.salary.base, acc[0])),
        Math.round(Math.max(seniority.salary.base, acc[1])),
      ],
      [Infinity, 0]
    )
    .join("" - "");
}

type Skill = { id: string; name: string };

type Seniority = {
  id: string;
  experience: { max: number; min: number };
  salary: { base: number };
};

export type Job = {
  id: string;
  title: string;
  description: string;
  seniorities: string[];
  mainSkills: string[];
  completeSkills: string[];
  location: string;
  remote: boolean;
  startingDate: number;
};
<fim_middle>",correct,3117
34,JsonValue,JsonValue,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue: <fim_suffix>, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,525
35,K,K,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min(): <fim_suffix> {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1741
36,Key,Key,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use() {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key: <fim_suffix>,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query) {
  return new StrictQuery(query)
}
<fim_middle>",correct,535
37,Lab,Lab,dc235984d999ebb87408d4cd3dbfcb29be357945,"<fim_prefix>const { abs, atan2, cos, exp, hypot, PI, sin, sqrt } = Math

type XYZ = [X: number, Y: number, Z: number]
type Lab = [L: number, a: number, b: number]

/**
 * Scale byte to 0...1.
 */
const unscaleByte = (x) => x / 255

/**
 * Invert sRGB gamma function.
 */
const invertGamma = (u) =>
  u <= 0.04045 ? u / 12.92 : ((u + 0.055) / 1.055) ** 2.4

const f = (w) =>
  w > 216 / 24389 ? w ** (1 / 3) : (841 / 108) * w + 4 / 29

/**
 * White point used in sRGB.
 */
const whiteD65: XYZ = [0.9505, 1, 1.089]

/**
 * Convert sRGB to Lab color.
 */
const rgbToLab = (white) => ([R, G, B]): <fim_suffix> => {
  R = invertGamma(unscaleByte(R))
  G = invertGamma(unscaleByte(G))
  B = invertGamma(unscaleByte(B))
  const X = 0.4124564 * R + 0.3575761 * G + 0.1804375 * B
  const Y = 0.2126729 * R + 0.7151522 * G + 0.072175 * B
  const Z = 0.0193339 * R + 0.119192 * G + 0.9503041 * B
  const l = f(Y / white[1])
  const L = 116 * l - 16
  const a = 500 * (f(X / white[0]) - l)
  const b = 200 * (l - f(Z / white[2]))
  return [L, a, b]
}

const degrees = (radians) => radians * (180 / PI)
const radians = (degrees) => degrees * (PI / 180)

/**
 * Returns a mod b
 */
const mod = (b) => (a) => ((a % b) + b) % b

const mod360 = mod(360)

const h = (b, a) => mod360(degrees(atan2(b, a)))

const sc7 = (c) => sqrt(c ** 7 / (c ** 7 + 25 ** 7))

const cosRad = (x) => cos(radians(x))

/**
 * Return CIEDE2000 color difference between two sRGB colors which components
 * are expected in the range 0 to 255.
 */
export const distanceRgb = (rgb1, rgb2) => {
  let [l1, a1, b1] = rgbToLab(whiteD65)(rgb1)
  let [l2, a2, b2] = rgbToLab(whiteD65)(rgb2)
  let c1 = hypot(a1, b1)
  let c2 = hypot(a2, b2)
  const fc7 = (1 - sc7((c1 + c2) / 2)) / 2
  a1 += a1 * fc7
  a2 += a2 * fc7
  const h1 = h(b1, a1)
  const h2 = h(b2, a2)
  let hd = 0
  let hs = h1 + h2
  if (c1 * c2 !== 0) {
    hd = h2 - h1
    if (hd > 180) {
      hd -= 360
    } else if (hd < -180) {
      hd += 360
    }
    const dh = abs(h1 - h2)
    if (dh <= 180) {
      hs /= 2
    } else if (dh > 180 && hs < 360) {
      hs = (hs + 360) / 2
    } else if (dh > 180 && hs >= 360) {
      hs = (hs - 360) / 2
    }
  }
  c1 = hypot(a1, b1)
  c2 = hypot(a2, b2)
  const ml = (l1 + l2) / 2
  const mc = (c1 + c2) / 2
  const t =
    1 -
    0.17 * cosRad(hs - 30) +
    0.24 * cosRad(2 * hs) +
    0.32 * cosRad(3 * hs + 6) -
    0.2 * cosRad(4 * hs - 63)
  const sl = 1 + (0.015 * (ml - 50) ** 2) / sqrt(20 + (ml - 50) ** 2)
  const sc = 1 + 0.045 * mc
  const sh = 1 + 0.015 * mc * t
  const rt = -2 * sc7(mc) * sin(radians(60 * exp(-(((hs - 275) / 25) ** 2))))
  const dl = (l2 - l1) / sl
  const dc = (c2 - c1) / sc
  const dh = (2 * sqrt(c1 * c2) * sin(radians(hd) / 2)) / sh
  return sqrt(dl ** 2 + dc ** 2 + dh ** 2 + rt * dc * dh)
}
<fim_middle>",correct,4770
38,Language,Language,76a884ba965e8d7964d8852a0c0f228c1ae1d7ad,"<fim_prefix>type Language = 'en' | 'zh';

type Terms = {
  selfPick: string;
  noFlowers: string;
  flowers: string;
  commonHand: string;
  fullyConcealedHand: string;
  seatWind: string;
  roundWind: string;
  dragons: string;
  mixedOrphans: string;
  winByLastCatch: string;
  robbingKong: string;
  oneCompleteSetOfFlowers: string;
  twoCompleteSetOfFlowers: string;
  winByKong: string;
  mixedOneSuit: string;
  allInTriplets: string;
  flowerHand: string;
  smallDragon: string;
  allOneSuit: string;
  smallWind: string;
  greatDragon: string;
  greatWind: string;
  allHonors: string;
  orphans: string;
  thirteenOrphans: string;
  kaanKaanHand: string;
  winByDoubleKong: string;
  eightImmortalsCrossingTheSea: string;
  allKongs: string;
  nineGates: string;
  earthlyHand: string;
  heavenlyHand: string;
};

export default class Glossary {
  private static readonly CHINESE_MAP: Terms = {
    selfPick: '自摸',
    noFlowers: '無花',
    flowers: '正花',
    commonHand: '平糊',
    fullyConcealedHand: '門前清',
    seatWind: '門風',
    roundWind: '圈風',
    dragons: '中/發/白',
    mixedOrphans: '花幺',
    winByLastCatch: '海底撈月',
    robbingKong: '搶槓',
    oneCompleteSetOfFlowers: '一台花',
    twoCompleteSetOfFlowers: '兩台花',
    winByKong: '槓上自摸',
    mixedOneSuit: '混一色',
    allInTriplets: '對對糊',
    flowerHand: '花糊',
    smallDragon: '小三元',
    allOneSuit: '清一色',
    smallWind: '小四喜',
    greatDragon: '大三元',
    greatWind: '大四喜',
    allHonors: '字一色',
    orphans: '全幺九',
    thirteenOrphans: '十三幺',
    kaanKaanHand: '坎坎糊',
    winByDoubleKong: '槓上槓自摸',
    eightImmortalsCrossingTheSea: '八仙過海',
    allKongs: '十八羅漢',
    nineGates: '九子連環',
    earthlyHand: '地糊',
    heavenlyHand: '天糊',
  };

  private static readonly ENGLISH_MAP: Terms = {
    selfPick: 'self-pick',
    noFlowers: 'no flowers',
    flowers: 'flowers matching seat position',
    commonHand: 'common hand',
    fullyConcealedHand: 'fully concealed hand',
    seatWind: 'seat wind',
    roundWind: 'round wind',
    dragons: 'dragons',
    mixedOrphans: 'mixed orphans',
    winByLastCatch: 'win by last catch',
    robbingKong: 'robbing kong',
    oneCompleteSetOfFlowers: 'one complete set of flowers',
    twoCompleteSetOfFlowers: 'two complete set of flowers',
    winByKong: 'win by Kong',
    mixedOneSuit: 'mixed one suit',
    allInTriplets: 'all in triplets',
    flowerHand: 'flower hand',
    smallDragon: 'small dragon',
    allOneSuit: 'all one suit',
    smallWind: 'small wind',
    greatDragon: 'great dragon',
    greatWind: 'great wind',
    allHonors: 'all honors',
    orphans: 'orphans',
    thirteenOrphans: 'thirteen orphans',
    kaanKaanHand: 'kaan kaan hand',
    winByDoubleKong: 'win by double Kong',
    eightImmortalsCrossingTheSea: 'eight immortals crossing the sea',
    allKongs: 'all Kongs',
    nineGates: 'nine gates',
    earthlyHand: 'earthly hand',
    heavenlyHand: 'heavenly hand',
  };

  private static language: Language = 'en';

  public static get() {
    if (this.language === 'en') {
      return this.ENGLISH_MAP;
    } else if (this.language === 'zh') {
      return this.CHINESE_MAP;
    } else {
      throw new Error('Language setting has not been configured appropriately.');
    }
  }

  public static setLanguage(languageInput: <fim_suffix>) {
    if (languageInput === 'zh' || languageInput === 'en') {
      this.language = languageInput;
    } else {
      throw new Error('Invalid input of language setting.');
    }
  }
}
<fim_middle>",correct,2148
39,License,License,39850647fe41aa810255752b914cdd87b3e420dc,"<fim_prefix>export const Kind = 'Core#License';

export interface ILicense {
  kind: typeof Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;
}

export class License {
  kind = Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;

  static fromUrl(url, name?) {
    return new License({
      kind: Kind,
      url,
      name,
    });
  }

  static fromContent(content, name?): <fim_suffix> {
    return new License({
      kind: Kind,
      content,
      name,
    });
  }

  /**
   * @param input The license definition used to restore the state.
   */
  constructor(input?) {
    let init: ILicense;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new license clearing anything that is so far defined.
   * 
   * Note, this throws an error when the license is not a license object.
   */
  new(init) {
    if (!License.isLicense(init)) {
      throw new Error(`Not a license.`);
    }
    const { url, content, name } = init;
    this.kind = Kind;
    this.name = name;
    this.content = content;
    this.url = url;
  }

  /**
   * Checks whether the input is a definition of a license.
   */
  static isLicense(input) {
    const typed = input as ILicense;
    if (typed && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: ILicense = {
      kind: Kind,
    };
    if (this.name) {
      result.name = this.name;
    }
    if (this.url) {
      result.url = this.url;
    }
    if (this.content) {
      result.content = this.content;
    }
    return result;
  }
}
<fim_middle>",correct,1627
40,MinMax,MinMax,ac730fc696dbdeb02598746fef516744d766ee52,"<fim_prefix>interface MinMax {
  min: number
  max: number
}

export class RelativeScale {
  static scale (data, tickCount, maxFactor) {
    const {
      min,
      max
    }: MinMax = RelativeScale.calculateBounds(data)

    let factor = 1

    while (true) {
      const scale = Math.pow(10, factor)

      const scaledMin = min - (min % scale)
      let scaledMax = max + (max % scale === 0 ? 0 : scale - (max % scale))

      // Prevent min/max from being equal (and generating 0 ticks)
      // This happens when all data points are products of scale value
      if (scaledMin === scaledMax) {
        scaledMax += scale
      }

      const ticks = (scaledMax - scaledMin) / scale

      if (ticks <= tickCount || (typeof maxFactor === 'number' && factor === maxFactor)) {
        return {
          scaledMin,
          scaledMax,
          scale
        }
      } else {
        // Too many steps between min/max, increase factor and try again
        factor++
      }
    }
  }

  static scaleMatrix (data, tickCount, maxFactor) {
    const nonNullData = data.flat().filter((val) => val !== null)

    // when used with the spread operator large nonNullData/data arrays can reach the max call stack size
    // use reduce calls to safely determine min/max values for any size of array
    // https://stackoverflow.com/questions/63705432/maximum-call-stack-size-exceeded-when-using-the-dots-operator/63706516#63706516
    const max = nonNullData.reduce((a, b) => {
      return Math.max(a, b)
    }, Number.NEGATIVE_INFINITY)

    return RelativeScale.scale(
      [0, RelativeScale.isFiniteOrZero(max)],
      tickCount,
      maxFactor
    )
  }

  static generateTicks (min, max, step) {
    const ticks = []
    for (let i = min; i <= max; i += step) {
      ticks.push(i)
    }
    return ticks
  }

  static calculateBounds (data): <fim_suffix> {
    if (data.length === 0) {
      return {
        min: 0,
        max: 0
      }
    } else {
      const nonNullData = data.filter((val) => val !== null)

      // when used with the spread operator large nonNullData/data arrays can reach the max call stack size
      // use reduce calls to safely determine min/max values for any size of array
      // https://stackoverflow.com/questions/63705432/maximum-call-stack-size-exceeded-when-using-the-dots-operator/63706516#63706516
      const min = nonNullData.reduce((a, b) => {
        return Math.min(a, b)
      }, Number.POSITIVE_INFINITY)
      const max = nonNullData.reduce((a, b) => {
        return Math.max(a, b)
      }, Number.NEGATIVE_INFINITY)

      return {
        min: RelativeScale.isFiniteOrZero(min),
        max: RelativeScale.isFiniteOrZero(max)
      }
    }
  }

  static isFiniteOrZero (val) {
    return Number.isFinite(val) ? val : 0
  }
}
<fim_middle>",correct,1057
41,Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source: <fim_suffix>, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3864
42,Number,Number,b1ab8c4be427c0afaf3d2a41ca821482dd787a9e,"<fim_prefix>type DotNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per dot (36)
type BamNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per bam (36)
type CrakNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per crak (36)
type WindNumber = ""East"" | ""West"" | ""South"" | ""North""; // 4 tiles per wind (16)
type DragonNumber = ""White"" | ""Green"" | ""Red""; // 4 tiles per wind (12)
type FlowerNumber = ""Rose"" | ""Lily"" | ""Tulip"" | ""Juniper""; // 2 tiles per flower (8)

export type Number = DotNumber | BamNumber | CrakNumber | WindNumber | DragonNumber | FlowerNumber;

export enum Suit {
  Dot = ""DOT"",
  Bam = ""BAM"",
  Crak = ""CRAK"",
  Wind = ""WIND"",
  Dragon = ""DRAGON"",
  Flower = ""FLOWER"",
}

export default class Tile {
  x: number;
  y: number;
  z: number;
  number: Number;
  suit: Suit;
  static dotNumbers: DotNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static bamNumbers: BamNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static crakNumbers: CrakNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static windNumbers: WindNumber[] = [""East"", ""West"", ""South"", ""North""];
  static dragonNumbers: DragonNumber[] = [""White"", ""Green"", ""Red""];
  static flowerNumbers: FlowerNumber[] = [""Rose"", ""Lily"", ""Tulip"", ""Juniper""];

  constructor(number: <fim_suffix>, suit) {
    this.number = number;
    this.suit = suit;
    this.x = -10
    this.y = -10
    this.z = -10
  }

  place({ z, x, y }) {
    this.z = z
    this.x = x
    this.y = y
  }

  get tileCells() {
    return [
      {
        z: this.z,
        x: this.x,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x,
        y: this.y + 1,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y + 1,
      },
    ];
  }

  get id() {
    return `${this.suit}_${this.number}_${this.x}_${this.y}_${this.z}`;
  }

  tileIsAdjacent(tile) {
    const t1Cells = this.tileCells;
    const t2Cells = tile.tileCells;

    let isAdjacent = false;

    t1Cells.forEach((t1) => {
      t2Cells.forEach((t2) => {
        // tile is above or below
        if ((t1.z === t2.z - 1 || t1.z === t2.z + 1) && t1.x === t2.x && t1.y === t2.y) {
          isAdjacent = true;
        }

        // tile is to the left or the right
        if (t1.z === t2.z && t1.y === t2.y && (t1.x === t2.x - 1 || t1.x === t2.x + 1)) {
          isAdjacent = true;
        }
      });
    });

    return isAdjacent;
  }
}
<fim_middle>",correct,1120
43,Options,Options,7c6b66273a2e2ae0cf4af96fca68877ec089846c,"<fim_prefix>type Placeholder = undefined | string | Function
interface Options {
  placeholder?: Placeholder
  freeze?: boolean
}

type Result = string | number | Function
type TextObject = Record<string, Result | object>
type TextPath = string
type Texts = TextObject[] | []
type TextFnArguments = string[] | number[]

const ALLOWED_TYPES = ['string', 'number']
const ERROR_TEXTS = Object.freeze({
  not_set: '[t-getter.js] There is no texts objects'
})

export default function GetText(
  texts,
  { placeholder = undefined, freeze = true }: <fim_suffix> = {}
) {
  if (!texts?.length) throw new Error(ERROR_TEXTS.not_set)
  texts = texts.map((o) => (freeze ? Object.freeze(o) : o))
  let placeholderOpt: any = placeholder

  function placeholderFn(options) {
    return typeof placeholderOpt == 'function'
      ? placeholderOpt(options)
      : placeholderOpt
  }

  function checkAllowedTypes(val) {
    return ALLOWED_TYPES.includes(typeof val)
  }

  function getTextValue({
    index,
    prop,
    args
  }) {
    const path = prop.split('.')
    let textObject: any = texts[index]

    let i = 0
    while (i < path.length) {
      let value: TextObject | Result = textObject[path[i]]
      if (value == null) break
      if (typeof value == 'function') value = value(...args)
      textObject = value
      i++
    }
    return textObject
  }

  function t(prop, ...args) {
    if (!texts.length) throw new Error(ERROR_TEXTS.not_set)

    let result: any = undefined
    let index = 0
    while (index < texts.length) {
      const value = getTextValue({ index, prop, args })
      if (checkAllowedTypes(value)) {
        result = value
        break
      }
      index++
    }

    if (!checkAllowedTypes(result)) return placeholderFn({ prop, args })

    return result
  }

  return t
}
<fim_middle>",correct,715
44,Order,Order,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order): <fim_suffix> {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,68
45,Organization,Organization,d85172f11ad96056d5a23d70826940b9d72011d4,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IOrganization {
    description?: string;
    id?: string;
    image?: string;
    name?: string;
    website?: string;
}

export default class Organization {
    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _image: string | undefined;

    get image() {
        return this._image;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _website: string | undefined;

    get website() {
        return this._website;
    }

    constructor(props) {
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.image === 'string') {
            this._image = props.image.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.website === 'string') {
            this._website = props.website.trim();
        }
    }

    serialize() {
        const data: IOrganization = {};
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._image !== 'undefined') {
            data.image = this._image;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._website !== 'undefined') {
            data.website = this._website;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            image: !this._image
                ? true
                : typeof this._image === 'string' && !this._image
                ? true
                : this._image,
            website: !this._website
                ? true
                : typeof this._website === 'string' && !this._website
                ? true
                : this._website,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Organization({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,3100
46,Params,Params,55cd248251ed1b4cc30e54f7fe9cbb0002b63241,"<fim_prefix>interface Params {
  page?: number;
  size?: number;
  message?: string;
  [key: string]: any;
}

interface Result<T> {
  code: number;
  data: {
    list: T[];
    total: number;
  };
  message?: number;
}

type FetchFun<T> = (params) => Promise<Result<T>>;

/**
 * 将分页接口转换为获取所有的接口
 * @param fetch
 */
export default function createFetchAll<T = any>(fetch) {
  return async function (params: <fim_suffix> = {}) {
    // 总数
    let allTotal = 0;
    let fetchTotal = 0;
    // 存储列表数据
    let fetchList: T[] = [];

    return new Promise(async (resolve, reject) => {
      const { page = 1, size = 1000, ...rest } = params;

      // 通过第一次分页请求
      const {
        code,
        data: { list, total },
        message
      } = await fetch({ page, size, ...rest });
      allTotal = total;
      fetchTotal += list.length;
      fetchList = fetchList.concat(list);

      // 从第二页开始
      const allPromise: Promise<Result<T>>[] = [];
      const pageSize = parseInt(total / size + 1 + '');

      for (let i = 2; i <= pageSize; ++i) {
        allPromise.push(
          fetch({
            page: i,
            size: i === pageSize ? total % size : size,
            ...rest
          })
        );
      }

      const allResult = await Promise.all(allPromise);
      for (let i = 0; i < allResult.length; ++i) {
        const {
          data: { list }
        } = allResult[i];
        fetchTotal += list.length;
        fetchList = fetchList.concat(list);
      }

      if (fetchTotal === total) {
        resolve({
          code: code,
          message: message,
          data: {
            list: fetchList,
            total: fetchTotal
          }
        });
      } else {
        reject({
          code: 500,
          message: '数据请求出错',
          data: {
            list: [],
            total: 0
          }
        });
      }
    });
  };
}
<fim_middle>",correct,2240
47,Permission,Permission,b9e827c9b65a470da78b1369ea3f446284d6b91c,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IPermission {
    description?: string;
    id?: string;
    is_internal?: boolean;
    name?: string;
    xml?: string;
}

export default class Permission {
    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _is_internal: boolean | undefined;

    get isInternal() {
        return this._is_internal;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _xml: string | undefined;

    get xml() {
        return this._xml;
    }

    constructor(props) {
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.is_internal === 'boolean') {
            this._is_internal = props.is_internal;
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.xml === 'string') {
            this._xml = props.xml.trim();
        }
    }

    serialize() {
        const data: IPermission = {};
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._is_internal !== 'undefined') {
            data.is_internal = this._is_internal;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._xml !== 'undefined') {
            data.xml = this._xml;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            is_internal: !this._is_internal
                ? true
                : typeof this._is_internal === 'boolean',
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            xml: !this._xml
                ? true
                : typeof this._xml === 'string' && !this._xml
                ? true
                : this._xml,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Permission({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,384
48,Person,Person,9e9c118238962afa94fa08ff3f99466bbd1b84bf,"<fim_prefix>/* tslint:disable */

declare var Object: any;
export interface PersonInterface {
  id?: string;
  name: string;
  realm?: string;
  username?: string;
  password: string;
  email: string;
  emailVerified?: boolean;
  verificationToken?: string;
  created_at: Date;
  updated_at: Date;
  accessTokens?: Array<any>;
}

export class Person implements PersonInterface {
  id: string;
  name: string;
  realm: string;
  username: string;
  password: string;
  email: string;
  emailVerified: boolean;
  verificationToken: string;
  created_at: Date;
  updated_at: Date;
  accessTokens: Array<any>;
  constructor(data?) {
    Object.assign(this, data);
  }
  /**
   * The name of the model represented by this $resource,
   * i.e. `Person`.
   */
  public static getModelName() {
    return ""Person"";
  }
  /**
  * @method factory
  * @author Jonathan Casarrubias
  * @license MIT
  * This method creates an instance of Person for dynamic purposes.
  **/
  public static factory(data): <fim_suffix>{
    return new Person(data);
  }  
  /**
  * @method getModelDefinition
  * @author Julien Ledun
  * @license MIT
  * This method returns an object that represents some of the model
  * definitions.
  **/
  public static getModelDefinition() {
    return {
      name: 'Person',
      plural: 'Persons',
      properties: {
        id: {
          name: 'id',
          type: 'string'
        },
        name: {
          name: 'name',
          type: 'string'
        },
        realm: {
          name: 'realm',
          type: 'string'
        },
        username: {
          name: 'username',
          type: 'string'
        },
        password: {
          name: 'password',
          type: 'string'
        },
        email: {
          name: 'email',
          type: 'string'
        },
        emailVerified: {
          name: 'emailVerified',
          type: 'boolean'
        },
        verificationToken: {
          name: 'verificationToken',
          type: 'string'
        },
        created_at: {
          name: 'created_at',
          type: 'Date'
        },
        updated_at: {
          name: 'updated_at',
          type: 'Date'
        },
      },
      relations: {
        accessTokens: {
          name: 'accessTokens',
          type: 'Array<any>',
          model: ''
        },
      }
    }
  }
}
<fim_middle>",correct,2049
49,Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner(): <fim_suffix> {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4540
50,Point,Point,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2: <fim_suffix>)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,486
51,Polygon,Polygon,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
): <fim_suffix> {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3380
52,Position,Position,d5ff2fa2b6826801f70c82d95dcdfcf780c62790,"<fim_prefix>const OCCUPIED_SEAT = '#';
const EMPTY_SEAT = 'L';
const FLOOR = '.';

interface Position {
  x: number,
  y: number
}

interface Vector {
  x: number,
  y: number
}

type AdjacentSeatFinder = (input, position, direction) => string;

export function getAdjacentSeat(input, position: <fim_suffix>, direction) {
  const adjacentLineIndex = position.y + direction.y;
  const adjacentColumnIndex = position.x + direction.x;
  
  const newPosition = { 
    x: position.x + direction.x,
    y: position.y + direction.y
  }

  if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length){
    return FLOOR;
  }

  return input[adjacentLineIndex][adjacentColumnIndex];
}


export function getFirstSeatAtDirection(input, position, direction) {
  let seat: string = FLOOR;

  let newPosition = position;
  while(true) {
    newPosition = { 
      x: newPosition.x + direction.x,
      y: newPosition.y + direction.y
    }

    if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length) break;

    const place = input[newPosition.y][newPosition.x];

    if (place !== FLOOR) {
      seat = place;
      break;
    }
  }

  return seat;
}

export function computeRound(input, adjacentSeatFinder, maximumAdjacentOccupiedSeats) {
  return input.map((line, lineIndex) => {
    return line
      .split('')
      .map((seat, seatIndex) => {
        if (seat === FLOOR) {
          return seat;
        }

        let numberOfAdjacentOccupiedSeat = 0;
        for (let iLine = -1; iLine <= 1; iLine++) {
          for (let iColumn = -1; iColumn <= 1; iColumn ++) {
            if(iLine === 0 && iColumn === 0) continue;

            const position = { x: seatIndex, y: lineIndex};
            const direction = { x: iColumn, y: iLine }
            const adjacentSeat = adjacentSeatFinder(input, position, direction);

            if (adjacentSeat === OCCUPIED_SEAT) {
              numberOfAdjacentOccupiedSeat++;
            }
          }
        }

        if (numberOfAdjacentOccupiedSeat === 0) {
          return OCCUPIED_SEAT;
        } else if (numberOfAdjacentOccupiedSeat >= maximumAdjacentOccupiedSeats) {
          return EMPTY_SEAT;
        } else {
          return seat;
        }
      })
      .join('');
  })
}

export function countNumberOfOccupiedSeatsAfterStabilization(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getAdjacentSeat, 4);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}

export function countNumberOfOccupiedSeatsAfterStabilizationWithRayCast(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getFirstSeatAtDirection, 5);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}
<fim_middle>",correct,4862
53,RegExp,RegExp,d7180447147db133f246707f18b8bdb014643e7a,"<fim_prefix>// Get balanced parentheses
// Ported from: https://github.com/juliangruber/balanced-match/blob/master/index.js

export interface Output {
	/**
	 * The index of the first match of a
	 */
	start: number;
	/**
	 * The index of the matching b
	 */
	end: number;
	/**
	 * The preamble, a and b not included
	 */
	pre: string;
	/**
	 * The match, a and b not included
	 */
	body: string;
	/**
	 * The postscript, a and b not included
	 */
	post: string;
}

function maybeMatch(reg: <fim_suffix>, str) {
	const m = str.match(reg);
	return m ? m[0] : null;
}

/**
 * For the first non-nested matching pair of a and b in str, return an object with those keys:
 * start the index of the first match of
 * `end` the index of the matching b
 * `pre` the preamble, a and b not included
 * `body` the match, a and b not included
 * `post` the postscript, a and b not included
 * If there's no match, `undefined` will be returned.
 * If the `str` contains more a than b / there are unmatched pairs,
 * the first match that was closed will be used.
 * For example, `{{a}` will match `['{', 'a', '']` and `{a}}` will match `['', 'a', '}']`
 */
export function balanced(
	a,
	b,
	str,
) {
	if (a instanceof RegExp) a = maybeMatch(a, str)!;
	if (b instanceof RegExp) b = maybeMatch(b, str)!;

	const r = range(a, b, str);

	return (
		r && {
			start: r[0] ?? 0,
			end: r[1] ?? 0,
			pre: str.slice(0, r[0]),
			body: str.slice(r[0]! + (a as string).length, r[1]),
			post: str.slice(r[1]! + (b as string).length),
		}
	);
}

/**
 * For the first non-nested matching pair of `a` and `b` in `str`,
 * return an array with indexes: `[ <a index>, <b index> ]`.
 */
export function range(a, b, str) {
	let begs, beg, left, right, result;
	let ai = str.indexOf(a);
	let bi = str.indexOf(b, ai + 1);
	let i = ai;

	if (ai >= 0 && bi > 0) {
		if (a === b) {
			return [ai, bi];
		}
		begs = [];
		left = str.length;

		while (i >= 0 && !result) {
			if (i === ai) {
				begs.push(i);
				ai = str.indexOf(a, i + 1);
			} else if (begs.length === 1) {
				result = [begs.pop(), bi];
			} else {
				beg = begs.pop();
				if (beg! < left!) {
					left = beg;
					right = bi;
				}

				bi = str.indexOf(b, i + 1);
			}

			i = ai < bi && ai >= 0 ? ai : bi;
		}

		if (begs.length) {
			result = [left, right];
		}
	}

	return result;
}

// Ported from: https://github.com/mugendi/balanced-match-all/blob/master/index.js
export function balancedAll(
	pre,
	post,
	str,
	includeInside = false,
	includeOutside = true,
	level = 0,
	arr = [],
) {
	const o = balanced(pre, post, str);

	if (o) {
		arr.push(o);
		const idx = arr.length - 1;

		if (idx > 0) {
			o.start += arr[idx - 1].start + pre.length;
			o.end += arr[idx - 1].start + post.length;
		}

		// loop till all are called
		if (includeInside) {
			arr = balancedAll(
				pre,
				post,
				o.body,
				includeInside,
				includeOutside,
				level++,
				arr,
			);
		}
		if (includeOutside && arr[idx].end < (str.length - 1)) {
			arr = balancedAll(
				pre,
				post,
				str.slice(arr[idx].end - 1),
				includeInside,
				true,
				0,
				arr,
			);
		}
	}

	return arr;
}
<fim_middle>",correct,1143
54,Rgb,Rgb,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l): <fim_suffix> => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,775
55,Role,Role,7f13942c6e9e03b58ec207e726168e13dd86cef1,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IRole {
    id?: string;
    name?: string;
    oauth_client_id?: string;
}

export default class Role {
    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _oauth_client_id: string | undefined;

    get oauthClientId() {
        return this._oauth_client_id;
    }

    constructor(props) {
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.oauth_client_id === 'string') {
            this._oauth_client_id = props.oauth_client_id.trim();
        }
    }

    serialize() {
        const data: IRole = {};
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._oauth_client_id !== 'undefined') {
            data.oauth_client_id = this._oauth_client_id;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            oauth_client_id: !this._oauth_client_id
                ? true
                : typeof this._oauth_client_id === 'string' &&
                  !this._oauth_client_id
                ? true
                : this._oauth_client_id,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Role({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,4821
56,Rule,Rule,326d9d855454c3462da30894d82c92685bff1b6e,"<fim_prefix>export interface Rule {
    calculateNewValue(cellValue, neighbourValues)
}

export function normalizeToOneOrZero(values) {
    return values.map(v => {
        if (v > 0) return 1
        else return 0
    })
}

function countLivingNeighbours(neighbourValues) {
    const normalizedValues = normalizeToOneOrZero(neighbourValues)
    return normalizedValues.reduce((sum, current) => sum + current, 0)
}

export class BSRule implements Rule {
    readonly born: Array<number>
    readonly stay: Array<number>

    constructor(born, stayAlive) {
        this.born = born
        this.stay = stayAlive
    }

    calculateNewValue(cellValue, neighbourValues) {
        const livingNeighbours = countLivingNeighbours(neighbourValues)
        if(cellValue > 0 && this.stay.indexOf(livingNeighbours) >= 0) {
            return cellValue
        }
        else if(cellValue == 0 && this.born.indexOf(livingNeighbours) >= 0) {
            return 1
        }
        return 0
    }

    static convert(rule: <fim_suffix>) {
        if(rule instanceof EEFFRule) {
            const eeffRule = rule as EEFFRule
            var born = Array<number>();
            for(var i = eeffRule.fl; i <= eeffRule.fu; i++) {
                born.push(i)
            }
            var stay = Array<number>();
            for(var i = eeffRule.el; i <= eeffRule.eu; i++) {
                stay.push(i)
            }
            return new BSRule(born, stay)
        }
        else if(rule instanceof BSRule) {
            return rule as BSRule
        }
        throw new Error(`can not convert rule: ${rule}`)
    }
}

export class EEFFRule implements Rule {
    readonly el: number
    readonly eu: number
    readonly fl: number
    readonly fu: number

    constructor(el, eu, fl, fu) {
        this.el = el
        this.eu = eu
        this.fl = fl
        this.fu = fu
    }
    
    calculateNewValue(cellValue, neighbourValues) {
        const livingNeighbours = countLivingNeighbours(neighbourValues)
        if(cellValue > 0 && (livingNeighbours < this.el || livingNeighbours > this.eu)) {
            return 0
        }
        else if(cellValue == 0 && (livingNeighbours >= this.fl && livingNeighbours <= this.fu)) {
            return 1
        }
        return cellValue
    }
}
<fim_middle>",correct,2598
57,Schema,Schema,181ec44034d7ff44d9293788b657b1a2036d874b,"<fim_prefix>type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema: <fim_suffix>) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance) {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance, schema, location) {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance) {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
<fim_middle>",correct,235
58,SearchResult,SearchResult,2f9ed4c5926a0fcede392151f980e017c0c93acb,"<fim_prefix>interface WordCoord {
  start: number[]
  end: number[]
}

interface SearchResult {
  [k: string]: WordCoord | undefined
}

export default class WordSearch {
  // For searching in all 8 directions
  static directions: { row: number; col: number }[] = [
    { row: 0, col: 1 }, // left to right
    { row: 0, col: -1 }, // right to left
    { row: 1, col: 0 }, // top to bottom
    { row: -1, col: 0 }, // bottom to top
    { row: 1, col: 1 }, // top left to bottom right
    { row: 1, col: -1 }, // top right to bottom left
    { row: -1, col: 1 }, // bottom left to top right
    { row: -1, col: -1 }, // bottom right to top left
  ]

  private rowLen: number
  private colLen: number

  constructor(private grid = []) {
    this.rowLen = this.grid.length
    this.colLen = this.grid[0]?.length || 0
  }

  find(words): <fim_suffix> {
    const result: SearchResult = {}

    for (const word of words) {
      for (let row = 0; row < this.rowLen; row++) {
        for (let col = 0; col < this.colLen; col++) {
          if (!result[word]) {
            result[word] = this.findWord(word, row, col)
          }
        }
      }
    }

    return result
  }

  findWord(word, row, col) {
    // Word is not found if the first letter doesn't match.
    if (this.grid[row][col] !== word[0]) {
      return
    }

    // Search in all directions starting from (row, col).
    for (const direction of WordSearch.directions) {
      let rowDir = row + direction.row
      let colDir = col + direction.col
      let i = 0

      // First letter is already checked, start searching from the second letter.
      for (i = 1; i < word.length; i++) {
        // Stop if out of bound.
        if (rowDir >= this.rowLen || rowDir < 0 || colDir >= this.colLen || colDir < 0) {
          break
        }

        // Stop if letter doesn't match.
        if (this.grid[rowDir][colDir] !== word[i]) {
          break
        }

        // Move in particular direction.
        rowDir += direction.row
        colDir += direction.col
      }

      // If all letters matched then value of i is equal to the length of the word.
      if (i === word.length) {
        // Result should be in math indexes which start from (1, 1).
        // So we need to add 1 to indexes but it depends on direction in which word was found.
        const rowAdd = 1 - direction.row
        const colAdd = 1 - direction.col

        return {
          start: [row + 1, col + 1],
          end: [rowDir + rowAdd, colDir + colAdd],
        }
      }
    }
  }
}
<fim_middle>",correct,643
59,Section,Section,4ab9eed9cbc53ed6e544dca10cf2f6417c2bdcd7,"<fim_prefix>export type Section = [number, number];

export function getPreviousTitleLine(lines, lineIndex) {
  do {
    const line = lines[lineIndex];

    if (line.match(/#+ /) !== null) {
      return lineIndex;
    }

    lineIndex--;
  } while (lineIndex >= 0);

  throw Error(""cannot find previous title"");
}

export function getEndOfSectionLine(lines, lineIndex, sectionDepth) {
  const nextHeaderRe = new RegExp(`^(\\#){1,${sectionDepth}} `);

  let cursor = lineIndex + 1;

  while (lines[cursor] !== undefined) {
    const line = lines[cursor];

    if (line.match(nextHeaderRe) && cursor !== 0) {
      return cursor - 1;
    }

    cursor++;
  }

  return lines.length - 1;
}

/**
 * @returns index of started / ended line index
 */
export function getSection(lines, lineIndex): <fim_suffix> {
  const titleLine = getPreviousTitleLine(lines, lineIndex);
  const sectionDeep = lines[titleLine].split("" "")[0].length;

  const lastLine = getEndOfSectionLine(lines, lineIndex, sectionDeep);

  return [titleLine, lastLine];
}

export function promote(lines, lineIndex) {
  const section = getSection(lines, lineIndex);
  const newLines = [...lines];

  for (let i = section[0]; i <= section[1]; i++) {
    const line = newLines[i];

    if (line.match(/^(\#){2,6} +/) !== null) {
      newLines[i] = line.substring(1);
    }
  }

  return newLines;
}

export function demote(lines, lineIndex) {
  const section = getSection(lines, lineIndex);
  const newLines = [...lines];

  for (let i = section[0]; i <= section[1]; i++) {
    const line = newLines[i];

    if (line.match(/^(\#){1,5} +/) !== null) {
      newLines[i] = ""#"".concat(line);
    }
  }

  return newLines;
}
<fim_middle>",correct,2156
60,Settings,Settings,7f5712ec06dabff06003ba15417bd3dcb2d15f53,"<fim_prefix>export type Settings = {
  parserName: string;
  typeHints: boolean;
  mainContents: string;
  mainName: string;
  cliName: string;
  argsName: string;
};

export const defaultSettings = () => {
  return {
    parserName: 'parser',
    typeHints: true,
    mainContents: '# Contents of main',
    mainName: 'main',
    cliName: 'cli',
    argsName: 'args',
  };
};

export type Argument = {
  name: string;
  type: string;
  variableName: string;
  default: string;
  required: boolean;
};

export const newArgument = (
  name,
  type,
  variableName = '',
  defaultValue = '',
  required = false,
) => {
  if (variableName === '') {
    variableName = name.replace(/-/g, '');
  }
  return { name, type, variableName, default: defaultValue, required };
};

function argumentToText(argument, parserName) {
  switch (argument.type) {
    case 'bool':
      return `${parserName}.add_argument(""${argument.name}"", action=""store_${argument.default}"")`;
    default:
      let defaultDisplay;

      if (argument.type === 'str') {
        defaultDisplay = `""${argument.default}""`;
      } else {
        defaultDisplay = argument.default;
      }

      if (argument.default === '') {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type})`;
      } else {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type}, default=${defaultDisplay})`;
      }
  }
}

const argumentToMainParams = (argument, typeHints) => {
  if (typeHints) {
    return `${argument.variableName}: ${argument.type}`;
  } else {
    return `${argument.variableName}`;
  }
};

export const argparseCode = (args, settings: <fim_suffix> = defaultSettings()) => {
  const parserName: string = settings.parserName;
  const argsName: string = settings.argsName;
  const mainParameters: string[] = args.map((arg) => argumentToMainParams(arg, settings.typeHints));
  const argumentsText: string[] = args.map((arg) => argumentToText(arg, parserName));
  const returnText: string[] = args.map((x) => {
    if (x.type === 'str') {
      return `""${x.variableName}"": ${argsName}.${x.variableName},`;
    } else {
      return `""${x.variableName}"": ${x.type}(${argsName}.${x.variableName}),`;
    }
  });

  const mainReturnType = settings.typeHints ? ' -> None' : '';
  const cliReturnType = settings.typeHints ? ' -> Dict[str, Any]' : '';
  const typeImports = settings.typeHints ? '\nfrom typing import Dict, Any' : '';

  const output = `import argparse${typeImports}


def ${settings.mainName}(${mainParameters.join(', ')})${mainReturnType}:
    ${settings.mainContents}
    return


def ${settings.cliName}()${cliReturnType}:
    formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ${parserName} = argparse.ArgumentParser(formatter_class=formatter_class)

    ${argumentsText.join('\n    ')}

    ${argsName} = ${parserName}.parse_args()

    return {${returnText.join('\n            ').slice(0, -1)}}


if __name__ == '__main__':
    ${argsName} = ${settings.cliName}()
    ${settings.mainName}(${args.map((x) => `${x.variableName}=${argsName}[""${x.variableName}""]`).join(',\n         ')})
`;
  return output;
};
<fim_middle>",correct,4829
61,Solution,Solution,782540af99146e3e07fdd0219b9a1b8603c98c86,"<fim_prefix>// Super fast physics simulations for JavaScript
// Copyright 2014 Ralph Thomas
// Licensed under the Apache License, Version 2.0
// https://github.com/iamralpht/gravitas.js

// Adapted to TypeScript and customized by Tanner Linsley (@tannerlinsley)

type Solution = {
  x: (num) => number
  dx: (num) => number
}

const epsilon = 0.001

function almostEqual(a, b) {
  if (Number.isNaN(a) && Number.isNaN(b)) {
    return true
  }
  return a > b - epsilon && a < b + epsilon
}

function almostZero(a) {
  return almostEqual(a, 0)
}

export class Spring {
  private _m: number
  private _k: number
  private _c: number
  private _solution: null | Solution
  private _startTime: number
  endPosition: number

  constructor(
    init,
    mass,
    springConstant,
    damping
  ) {
    this._m = mass
    this._k = springConstant
    this._c = damping
    this._solution = null
    this.endPosition = init
    this._startTime = 0
  }

  x(dt?) {
    if (dt === undefined) {
      dt = (new Date().getTime() - this._startTime) / 1000.0
    }
    return this._solution
      ? this.endPosition + this._solution.x(dt)
      : this.endPosition
  }

  private dx(dt?) {
    if (dt === undefined) {
      dt = (new Date().getTime() - this._startTime) / 1000.0
    }
    return this._solution ? this._solution.dx(dt) : 0
  }

  setEnd(x) {
    const t = new Date().getTime()

    let velocity = 0
    let position = this.endPosition
    if (this._solution) {
      // Don't whack incoming velocity.
      if (almostZero(velocity))
        velocity = this._solution.dx((t - this._startTime) / 1000.0)
      position = this._solution.x((t - this._startTime) / 1000.0)
      if (almostZero(velocity)) velocity = 0
      if (almostZero(position)) position = 0
      position += this.endPosition
    }
    if (this._solution && almostZero(position - x) && almostZero(velocity)) {
      return
    }
    this.endPosition = x
    this._solution = this._solve(position - this.endPosition, velocity)
    this._startTime = t
  }

  snap(x) {
    this._startTime = new Date().getTime()
    this.endPosition = x
    this._solution = {
      x() {
        return 0
      },
      dx() {
        return 0
      },
    }
  }

  done() {
    return almostEqual(this.x(), this.endPosition) && almostZero(this.dx())
  }

  // reconfigure(mass: number, springConstant: number, damping: number) {
  //   this._m = mass
  //   this._k = springConstant
  //   this._c = damping

  //   if (this.done()) {
  //     return
  //   }
  //   this._solution = this._solve(this.x() - this.endPosition, this.dx())
  //   this._startTime = new Date().getTime()
  // }

  // springConstant() {
  //   return this._k
  // }

  // damping() {
  //   return this._c
  // }

  private _solve(initial, velocity): <fim_suffix> {
    const c = this._c
    const m = this._m
    const k = this._k
    // Solve the quadratic equation; root = (-c +/- sqrt(c^2 - 4mk)) / 2m.
    const cmk = c * c - 4 * m * k
    if (cmk === 0) {
      // The spring is critically damped.
      // x = (c1 + c2*t) * e ^(-c/2m)*t
      const r = -c / (2 * m)
      const c1 = initial
      const c2 = velocity / (r * initial)
      return {
        x(t) {
          return (c1 + c2 * t) * Math.pow(Math.E, r * t)
        },
        dx(t) {
          const pow = Math.pow(Math.E, r * t)
          return r * (c1 + c2 * t) * pow + c2 * pow
        },
      }
    } else if (cmk > 0) {
      // The spring is overdamped; no bounces.
      // x = c1*e^(r1*t) + c2*e^(r2t)
      // Need to find r1 and r2, the roots, then solve c1 and c2.
      const r1 = (-c - Math.sqrt(cmk)) / (2 * m)
      const r2 = (-c + Math.sqrt(cmk)) / (2 * m)
      const c2 = (velocity - r1 * initial) / (r2 - r1)
      const c1 = initial - c2

      return {
        x(t) {
          return c1 * Math.pow(Math.E, r1 * t) + c2 * Math.pow(Math.E, r2 * t)
        },
        dx(t) {
          return (
            c1 * r1 * Math.pow(Math.E, r1 * t) +
            c2 * r2 * Math.pow(Math.E, r2 * t)
          )
        },
      }
    } else {
      // The spring is underdamped, it has imaginary roots.
      // r = -(c / 2*m) +- w*i
      // w = sqrt(4mk - c^2) / 2m
      // x = (e^-(c/2m)t) * (c1 * cos(wt) + c2 * sin(wt))
      const w = Math.sqrt(4 * m * k - c * c) / (2 * m)
      const r = -((c / 2) * m)
      const c1 = initial
      const c2 = (velocity - r * initial) / w

      return {
        x(t) {
          return (
            Math.pow(Math.E, r * t) *
            (c1 * Math.cos(w * t) + c2 * Math.sin(w * t))
          )
        },
        dx(t) {
          const power = Math.pow(Math.E, r * t)
          const cos = Math.cos(w * t)
          const sin = Math.sin(w * t)
          return (
            power * (c2 * w * cos - c1 * w * sin) +
            r * power * (c2 * sin + c1 * cos)
          )
        },
      }
    }
  }
}
<fim_middle>",correct,2754
62,Source,Source,de53b444284e879ad933dd4404a7e3f697c8dfe0,"<fim_prefix>export type Mapping<Source, Target> = {
  [P in keyof Target]:
    | keyof PickByType<Source, Target[P]>
    | ((source) => Target[P]);
};

export type KeysOfType<Base, Condition> = {
  [Key in keyof Base]: Base[Key] extends Condition ? Key : never;
}[keyof Base];

export type OmitByType<Base, Condition> = Omit<
  Base,
  KeysOfType<Base, Condition>
>;

export type PickByType<Base, Condition> = Pick<
  Base,
  KeysOfType<Base, Condition>
>;

export type MapTarget<Source> = {
  using: <Target>(mapping) => Target;
};
export type MapSource<Source> = (from) => MapTarget<Source>;

export const map = <Source>(source) => ({
  using: <S, Target>(mapping) => {
    const target = {} as Target;
    for (const targetKey of Object.keys(mapping)) {
      const value = mapping[targetKey];
      if (typeof value === 'string') {
        const sourceKey = value;
        target[targetKey] = source[sourceKey];
      } else if (typeof value === 'function') {
        const fn = value;
        target[targetKey] = fn(source);
      }
    }

    return target;
  },
});

export const using =
  <Source, Target>(mapping) =>
  (source: <fim_suffix>) =>
    map(source).using(mapping);

export function parsePage(
  defaultCount,
  page,
) {
  if (typeof page.first === 'number' || typeof page.after === 'string') {
    const count = page.first || defaultCount;
    return {
      count,
      uniqueId: page.after,
      limit: page.after ? count + 2 : count + 1,
      direction: 'forward',
    };
  } else if (typeof page.last === 'number' || typeof page.before === 'string') {
    const count = page.last || defaultCount;
    return {
      count,
      uniqueId: page.before,
      limit: page.before ? count + 2 : count + 1,
      direction: 'backward',
    };
  }

  return {
    count: defaultCount,
    limit: defaultCount + 1,
    direction: 'forward',
  };
}

export function buildPage<T>(
  items,
  count,
  usedCursor,
  direction,
  getUniqueId,
) {
  const previous = usedCursor ? items[0] : undefined;
  const next: T | undefined = usedCursor ? items[count + 1] : items[count];
  const data = usedCursor ? items.slice(1, count + 1) : items.slice(0, count);

  const first: T | undefined = data[0];
  const last: T | undefined = data[data.length - 1];

  if (direction === 'forward') {
    return {
      items: data,
      hasNextPage: !!next,
      hasPreviousPage: !!previous,
      startCursor: getUniqueId(first),
      endCursor: getUniqueId(last),
    };
  } else {
    return {
      items: data.reverse(),
      hasNextPage: !!previous,
      hasPreviousPage: !!next,
      startCursor: getUniqueId(first),
      endCursor: getUniqueId(last),
    };
  }
}

export function buildInClause<T>(
  items,
  startingAt = 1,
) {
  return {
    in: items.map((_, i) => `$${i + startingAt}`).join(', '),
    values: items,
  };
}
<fim_middle>",correct,5113
63,State,State,6fe76b5aaf422ac45ea3f391258b2aeb7c5ddf67,"<fim_prefix>export type State = {
	room_id: string,
	room_name: string,
	room_icon: string,
	owner_data: {
		client_id: string,
		client_name: string,
		client_profile: string
	}
	active_clients: {
		client_id: string,
		client_name: string,
		client_profile: string
	}[]
}

const roomDefault: State = {
	room_id: '',
	room_name: '',
	room_icon: '',
	owner_data: {
		client_id: '',
		client_name: '',
		client_profile: ''		
	},
	active_clients: [],
}

type ActionType = ""LOAD_ROOM_DATA"" | ""ROOM_BAN_ADD"" | ""ROOM_BAN_REMOVE"" | ""ROOM_MEMBER_UPDATE"" | ""ROOM_MEMBER_REMOVE"" | ""NEW_OWNER""| ""CHANGE_ROOM"" | ""SET_ONLINE_MEMBERS""
type ActionPayload = {
	ip?: string,
	client_id?: string,
	client_name?: string,
	client_profile?: string
	room_name?: string,
	room_icon?: string,
	room_id?: string
	active_clients: {
		client_id: string,
		client_name: string,
		client_profile: string
	}[],
	owner_data: {
		client_id: string,
		client_name: string,
		client_profile: string
	}
}

type Action = {
	type: ActionType,
	payload: ActionPayload
}



export const roomInfo = (state = roomDefault, action): <fim_suffix> => {
	switch(action.type){
		//LOAD ROOM DATA
		case ""LOAD_ROOM_DATA"": {
			const {room_icon, room_id, room_name, owner_data, active_clients} = action.payload
			
			return {
				room_id: room_id!,
				room_name: room_name!,
				room_icon: room_icon!,
				owner_data: owner_data,
				active_clients: active_clients,
			}
		}
		//WHEN OWNER GIVES NEW MEMBER OWNERHOST
		case ""NEW_OWNER"" : {
			const {client_id, client_name, client_profile} = action.payload
			
			return {
				...state,
				owner_data: {
					client_id: client_id!,
					client_name: client_name!,
					client_profile: client_profile!		
				},
			}
		}
		//MEMBER LEAVES ROOM
		case ""ROOM_MEMBER_REMOVE"": {
			const {client_id} = action.payload

			const memberLeft = state.active_clients.filter(e => e.client_id !== client_id)
			
			return {
				...state,
				active_clients: memberLeft
			}
		}
		case ""SET_ONLINE_MEMBERS"": {
			const {active_clients} = action.payload

			return {
				...state,
				active_clients: active_clients
			}
		}
		//MEMBER JOINS ROOM	
		case ""ROOM_MEMBER_UPDATE"": {
			const {client_id, client_name, client_profile} = action.payload
			const duplicateUser = state.active_clients.some(e => e.client_id === client_id)

			if(duplicateUser) return state

			return {
				...state,
				active_clients: [
					...state.active_clients,
					{
						client_id: client_id!,
						client_name: client_name!,
						client_profile: client_profile!
					}
				]
			}
		}
		case ""CHANGE_ROOM"": {
			return {
				...state,
				room_name: action.payload.room_name!,
				room_icon: action.payload.room_icon!
			}
		}
		default: return state
	}
}<fim_middle>",correct,2001
64,StateMachine,StateMachine,4090fc569ef5576bf3bdce304e81cf32fca2f089,"<fim_prefix>export type StateMachineDefinition = {
    states: {
        [key: string]: {
            onEnter?: (subject) => void;
            onEntered?: (subject) => void;
            onExit?: (subject) => void;
            transitions: {
                [key: string]: {
                    to: keyof StateMachineDefinition['states'];
                    action?: (subject) => void;
                };
            };
        };
    };
};

export type StateMachine = {
    subject: any;
    transition: (transitionName) => void;
    canTransit: (transitionName) => boolean;
};
export function createStateMachine(
    subject,
    stateProperty,
    definition,
): <fim_suffix> {
    const { states } = definition;

    const actionInfos = (transitionName) => {
        const currentState = subject[stateProperty];
        const currentStateDefinition = states[currentState as keyof typeof states];
        const destinationTransition =
            currentStateDefinition.transitions[transitionName as keyof typeof currentStateDefinition.transitions];
        if (!destinationTransition) {
            throw new TransitionError(
                `Cannot find the transition '${transitionName}' on subject with state '${currentState}'.`,
            );
        }
        const destinationState = destinationTransition.to;
        const destinationStateDefinition = states[destinationState as keyof typeof states];
        if (!destinationStateDefinition) {
            throw new TransitionError(
                `Cannot transition to '${destinationState}' from '${currentState}'. It does not exist.`,
            );
        }

        return {
            currentStateDefinition,
            destinationTransition,
            destinationStateDefinition,
            destinationState,
        };
    };

    return {
        subject,
        transition(transitionName) {
            const { currentStateDefinition, destinationTransition, destinationStateDefinition, destinationState } =
                actionInfos(transitionName);

            if (destinationTransition.action) {
                destinationTransition.action(subject);
            }
            if (currentStateDefinition.onExit) {
                currentStateDefinition.onExit(subject);
            }
            if (destinationStateDefinition.onEnter) {
                destinationStateDefinition.onEnter(subject);
            }
            subject[stateProperty] = destinationState;
            if (destinationStateDefinition.onEntered) {
                destinationStateDefinition.onEntered(subject);
            }
        },
        canTransit(transitionName) {
            try {
                actionInfos(transitionName);
                return true;
            } catch (exception) {
                return false;
            }
        },
    };
}

export class TransitionError extends Error {
    code: number;
    constructor(message) {
        super(message);
        this.name = 'TransitionError';
        this.code = 400;
    }
}
<fim_middle>",correct,5083
65,Student,Student,861ae1a426b6f731e00a301bff6f6c52ce26d4d9,"<fim_prefix>/* Defines the license entity */
export interface Student {
    adminNotes: string;
    appNum: string;
    appTitle: string;
    appURL: string;     
    applicationFee: number | null;
    authority: string;   
 //   authorityId: number;
    authURL: string;
    authEmail: string;
    authExt: string | null;
    authPhone: string;
    busCoordNotes: string;
    certification: string | null;   
    continuingedu: string | null;  
    coordURL: string;
    coordEmail: string;
    coordExt: string;
    coordPhone: string;
    criminal: string | null;
    duration: string;
    education: string | null;  
    exam: string | null;
    exemptions: string;
    experience: string | null;   
    id: number;
    inactive: string| null;
    keywords: string | null;
    licAuth: string;   
    licAuthId: string;   
    licDesc: string;   
    licNum: number;
    licNumType: string;   
    licTitle: string;   
    licenseId: string;   
    licenseType: string;   
    licenseUpdated: string; 
    licenseURL: string;
    markForAuthXfer: boolean;
    markForDelete: boolean;
    markForDeleteBLNC: boolean;  
    markForDeleteLEAD: boolean;
    miscFee: number;
    newLicFee: number;
    otherReq: string; 
    physical: string;  
    reasonForDelete: string;   
    reciprocity: string;   
    recipStates;
    renewalFee: number;
    ricipFee: number;
    socCode: string;   
    socDesc: string;   
    socTitle: string;
    updatedBy: string;   
    veteran: string;

    tagList: any;
    coordId: string;
    department: string;
    division: string;
    board: string;
    address1: string;
    address2: string;
    city: string;
    st: string;
    zip: string;
    multipleLocation: boolean;
    authphone: string;
    fax: string;
    contact: string;
    url: string;
    officeHours: string;
    coordName: string;
    hasOccProfile: boolean; 
  }
  
  export interface StudentResolved {
    student: any;
    error?: any;
  }

  export function newStudent() : <fim_suffix> {
    const l:Student = {
      adminNotes: '',     
      appNum: '',
      appTitle: '',
      appURL: '',    
      applicationFee: null,
      authority: '',  
      authEmail: '',
      authExt: '',
      authPhone: '',
      authURL: '',
      busCoordNotes: '',   
      certification: null,
      continuingedu: null,
      coordEmail: '',
      coordExt: '',
      coordPhone: '',
      coordURL: '',
      criminal: null, 
      duration: '',
      education: null, 
      exam: null,
      exemptions: '',   
      experience: null,
      id: 0,
      inactive: null,
      keywords: '',
      licAuth: '',   
      licAuthId: null,   
      licDesc: '',   
      licNum: null,
      licNumType: '',   
      licTitle: '',   
      licenseId: null, 
      licenseType: null, 
      licenseUpdated: '',
      licenseURL: '',
      markForAuthXfer: false,
      markForDelete: false,
      markForDeleteBLNC: false, 
      markForDeleteLEAD: false,
      miscFee: null,
      newLicFee: null,
      otherReq: '',
      physical: null,   
      reasonForDelete: '',  
      reciprocity: '',   
      recipStates: [],
      renewalFee: null,
      ricipFee: null,
      socCode: null,  
      socDesc: null,   
      socTitle: '',
      updatedBy: null,
      veteran: null,
      tagList: null,
      coordId: '',
      department: '',
      division: '',
      board: '',
      address1: '',
      address2: '',
      city: '',
      st: '',
      zip: '',
      multipleLocation: false,
      authphone: '',
      fax: '',
      contact: '',
      url: '',
      officeHours: '',
      coordName: '',
      hasOccProfile: false,        
    };
    return l;
  }

  export const enumFields=[
    {name: 'edu', col: 'education', label: 'Education:', sel: '--Please select'},
    {name: 'cert', col: 'certification', label: 'Certification:', sel: '--Please select'},
    {name: 'cedu', col: 'continuingedu', label: 'Continuing education:', sel: '--Please select'},
    {name: 'exp', col: 'experience', label: 'Experience:', sel: '--Please select'},
    {name: 'exam', col: 'exam', label: 'Exam:', sel: '--Please select'},
    {name: 'crim', col: 'criminal', label: 'Criminal:', sel: '--Please select'},
    {name: 'phy', col: 'physical', label: 'Physical requirements:', sel: '--Please select'},
    {name: 'vet', col: 'veteran', label: 'Veteran:', sel: '--Please select'},
    {name: 'active', col: 'inactive', label: 'Active status:', sel: '--Please select'},
    {name: 'types', col: 'licenseType', label: 'License Type:', sel: '--Please select'},
   ];  <fim_middle>",correct,3574
66,T,T,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB: <fim_suffix>
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,222
67,TKey,TKey,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type: <fim_suffix>,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",correct,1707
68,TTT,TTT,ad15d5503f15235dd06d2738702575eb4dfe04e9,"<fim_prefix>export type XO = 'X' | 'O' | '';

export type Board = [[XO, XO, XO], [XO, XO, XO], [XO, XO, XO]];

export type Coordinate = {
  x: number;
  y: number;
};

export type TTT = {
  board: Board;
  lastPlay?: XO;
  winner?: XO;
  draw?: boolean;
};

export const isBoardFull = (x) => x.every((y) => y.every((z) => z));

export const newBoard = () =>
  [...Array(3)].map(() => Array(3).fill('')) as Board;

export const newTtt = (): <fim_suffix> => ({
  board: newBoard(),
});

export const getWinner = (x) => {
  const winners = new Set<XO>();

  for (let i = 0; i < 3; ++i) {
    if (x[0][i] && new Set([x[0][i], x[1][i], x[2][i]]).size === 1) {
      winners.add(x[0][i]);
    }
  }

  for (let i = 0; i < 3; ++i) {
    if (x[i][0] && new Set(x[i]).size === 1) {
      winners.add(x[i][0]);
    }
  }

  if (
    x[1][1] &&
    (new Set([x[0][0], x[1][1], x[2][2]]).size === 1 ||
      new Set([x[0][2], x[1][1], x[2][0]]).size === 1)
  ) {
    winners.add(x[1][1]);
  }

  if (!winners.size) {
    // completion check

    return isBoardFull(x) ? 'DRAW' : 'INCOMPLETE';
  }

  return winners.values().next().value as Exclude<XO, undefined>;
};

export const insertPlay = (x, c) => {
  if (x.board[c[0]][c[1]] || c[0] > 2 || c[1] > 2) return x;

  const winner = getWinner(x.board);
  if (['X', 'O', 'DRAW'].includes(winner.toUpperCase())) {
    if (winner === 'DRAW') {
      x.draw = true;
      return x;
    } else if (winner !== 'INCOMPLETE') {
      x.winner = winner;
      return x;
    }
  }

  x.lastPlay = x.lastPlay === 'X' ? 'O' : 'X';
  x.board[c[0]][c[1]] = x.lastPlay;

  const postWinner = getWinner(x.board);
  if (['X', 'O', 'DRAW'].includes(postWinner.toUpperCase())) {
    if (postWinner === 'DRAW') {
      x.draw = true;
      return x;
    } else if (postWinner !== 'INCOMPLETE') {
      x.winner = postWinner;
      return x;
    }
  }

  return x;
};
<fim_middle>",correct,2072
69,Thing,Thing,c638aa7811a23127f92dc64cfed37e179ef1cc7f,"<fim_prefix>export const Kind = 'Core#Thing';

/**
 * An interface describing a base metadata of a thing.
 */
export declare interface IThing {
  /**
   * The data kind. The application ignores the input with an unknown `kind`, unless it can be determined from the context.
   */
  kind?: typeof Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;
}

export class Thing {
  kind = Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;

  /**
   * Returns one in this order:
   * - displayName
   * - name
   * - 'Unnamed object'
   */
  get renderLabel() {
    return this.displayName || this.name || 'Unnamed object';
  }

  /**
   * Creates a basic description from a name.
   */
  static fromName(name): <fim_suffix> {
    const thing = new Thing({
      name,
      kind: Kind,
    });
    return thing;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IThing;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not a thing.
   */
  new(init) {
    if (!Thing.isThing(init)) {
      throw new Error(`Not a thing.`);
    }
    const { description, name, version, displayName } = init;
    this.kind = Kind;
    this.name = name;
    this.displayName = displayName;
    this.description = description;
    this.version = version;
  }

  /**
   * Checks whether the input is a definition of a server.
   */
  static isThing(input) {
    const typed = input as IThing;
    if (input && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IThing = {
      kind: Kind,
    };
    if (typeof this.name === 'string') {
      result.name = this.name;
    }
    if (typeof this.displayName === 'string') {
      result.displayName = this.displayName;
    }
    if (this.description) {
      result.description = this.description;
    }
    if (this.version) {
      result.version = this.version;
    }
    return result;
  }
}
<fim_middle>",correct,1812
70,Time,Time,c6f7caaa0590e6613ea1d397ac2df028f848091b,"<fim_prefix>interface Time {
  hours: number
  minutes: number
}

export const parseTime = (time) => {
  const values = (time || '').split(':')
  if (values.length >= 2) {
    let hours = Number.parseInt(values[0], 10)
    const minutes = Number.parseInt(values[1], 10)
    const timeUpper = time.toUpperCase()
    if (timeUpper.includes('AM') && hours === 12) {
      hours = 0
    } else if (timeUpper.includes('PM') && hours !== 12) {
      hours += 12
    }
    return {
      hours,
      minutes,
    }
  }

  return null
}

export const compareTime = (time1, time2) => {
  const value1 = parseTime(time1)
  if (!value1) return -1
  const value2 = parseTime(time2)
  if (!value2) return -1
  const minutes1 = value1.minutes + value1.hours * 60
  const minutes2 = value2.minutes + value2.hours * 60
  if (minutes1 === minutes2) {
    return 0
  }
  return minutes1 > minutes2 ? 1 : -1
}

export const padTime = (time) => {
  return `${time}`.padStart(2, '0')
}
export const formatTime = (time: <fim_suffix>) => {
  return `${padTime(time.hours)}:${padTime(time.minutes)}`
}

export const nextTime = (time, step) => {
  const timeValue = parseTime(time)
  if (!timeValue) return ''

  const stepValue = parseTime(step)
  if (!stepValue) return ''

  const next = {
    hours: timeValue.hours,
    minutes: timeValue.minutes,
  }
  next.minutes += stepValue.minutes
  next.hours += stepValue.hours
  next.hours += Math.floor(next.minutes / 60)
  next.minutes = next.minutes % 60
  return formatTime(next)
}
<fim_middle>",correct,1940
71,Triangle,Triangle,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle: <fim_suffix>,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3644
72,Type,Type,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing): <fim_suffix> {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4925
73,TypeDef,TypeDef,8dd4eba467cc4f8c283713bdfc23d3b71e87f31d,"<fim_prefix>export type BasePostMessageCallbackProps<T> = {
  onMessage?: (message) => void
  onInvalidMessageError?: (message, error) => void
}

// This is an internal error. Thrown when we are decoding a post message's
// metadata and we encourntered a missing field or an invalid value. This
// likely means there has been a change to the definition of a post message
// that we do not know about.
export class PostMessageFieldDecodeError extends Error {
  public messageType: string
  public field: string
  public expectedType: TypeDef
  public gotValue: unknown

  constructor(messageType, field, expectedType: <fim_suffix>, gotValue) {
    super(`Unable to decode '${field}' from '${messageType}'`)

    this.messageType = messageType
    this.field = field
    this.expectedType = expectedType
    this.gotValue = gotValue

    Object.setPrototypeOf(this, PostMessageFieldDecodeError.prototype)
  }
}

// This is an internal error. Thrown when we get a post message we don't konw
// about. This likely means there is a new post message that this package needs
// to define.
export class PostMessageUnknownTypeError extends Error {
  public postMessageType: string

  constructor(postMessageType) {
    super(`Unknown post message: ${postMessageType}`)

    this.postMessageType = postMessageType

    Object.setPrototypeOf(this, PostMessageUnknownTypeError.prototype)
  }
}

export type MessageEventData = {
  mx?: boolean
  metadata?: Metadata
  type?: string
}

export type Value = string | number
export type NestedValue = Record<string, Value>
export type TypeDef = string | Array<string> | Record<string, string>
export type Metadata = Record<string, Value | NestedValue>

export function assertMessageProp(
  container,
  postMessageType,
  field,
  expectedType,
) {
  const value = container[field]

  const valueIsDefined = typeof value !== ""undefined""
  const valueIsString = typeof value === ""string""
  const valueIsNumber = typeof value === ""number""
  const valueIsObject = typeof value === ""object"" && !Array.isArray(value)

  const typeIsString = expectedType === ""string""
  const typeIsNumber = expectedType === ""number""
  const typeIsArray = expectedType instanceof Array
  const typeIsObject = typeof expectedType === ""object"" && !Array.isArray(expectedType)

  if (!valueIsDefined) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsString && !valueIsString) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsNumber && !valueIsNumber) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsArray && !(valueIsString && expectedType.includes(value))) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && !valueIsObject) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && valueIsObject) {
    Object.keys(expectedType).forEach((field) => {
      assertMessageProp(value, postMessageType, field, expectedType[field])
    })
  }
}
<fim_middle>",correct,2991
74,U,U,a3c87e22c30072055cfbcdaba851bef6a0244dc3,"<fim_prefix>// /**
//  * DTOs must extends this class
//  */
export class DTOMapper {
  dtoMapperProfile () {
    return undefined;
  };
}

/**
 * DTO Mapper Option Type
 * @param T - Type of class
 */
export interface IDtoMapperOption<T> {
  mapToClass?: IDtoMapperToClass<T>;
  mapToPath?: IDtoMapperToPath;
}

// Mapping to class type
export interface IDtoMapperToClass<T> {
  mapFromKey: string;
  dtoClass: new () => T;
}
// mapping to path type
export interface IDtoMapperToPath {
  mapFromKey: string;
  valueFromPath: string;
}

/**
 * 
 * Map source object to destination class
 * 
 * @param {T} source - Source object to map from
 * @param {U} destination - Destination class to map to
 * @returns {U} An object of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);
/**
 * 
 * Map source object to destination class
 * 
 * @param {T[]} source  - Source array of objects to map from
 * @param {U} destination - Destination class to which map each object from the source
 * @returns {U[]} An array of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);

export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
) {
  if ( Array.isArray( source ) ) {
    return source.map( s => {
      return mapper( s, new destination() );
    } );
  }
  return mapper( source, new destination() );
}

// Mapper to map source to destination
function mapper<T, U extends DTOMapper> ( source, destination ): <fim_suffix> {
  Object.keys( destination ).forEach( key => {
    destination[ key as keyof U ] = <any>source[ key as keyof T ];
    if ( destination.dtoMapperProfile()?.length ) {
      destination.dtoMapperProfile()?.forEach( option => {
        // To class mapping (recursively)
        if ( option.mapToClass?.mapFromKey === key ) {
          if ( source[ key as keyof T ] ) {
            if ( Array.isArray( source[ key as keyof T ] ) ) {
              const result = Array.from( source[ key as keyof T ] as any ).map( el => {
                return mapper( el, new option.mapToClass!.dtoClass() );
              } );
              destination[ key as keyof U ] = result as any;
            } else {
              const result = mapper( source[ key as keyof T ], new option.mapToClass.dtoClass() );
              destination[ key as keyof U ] = result as any;
            }
          }
          // To value mapping
        } else if ( option.mapToPath?.mapFromKey === key ) {
          let sourceVal: any;
          if ( Array.isArray( option.mapToPath.valueFromPath.split( '.' ) ) ) {
            const paths = option.mapToPath.valueFromPath.split( '.' );
            paths.forEach( p => {
              if ( !sourceVal ) {
                sourceVal = source[ p as keyof T ];
              } else {
                sourceVal = sourceVal[ p ];
              }
            } );
          } else {
            sourceVal = <any>source[ option.mapToPath.valueFromPath as keyof T ];
          }

          destination[ key as keyof U ] = sourceVal;
        }
      } );
    }
  } );
  return destination;
}<fim_middle>",correct,2928
75,User,User,bb8faf8f1fabd1682a5c59c52cae3e16456eff95,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IUser {
    admin?: boolean;
    date_password?: string;
    email?: string;
    enabled?: boolean;
    id?: string;
    username?: string;
}

export default class User {
    readonly _admin: boolean | undefined;

    get admin() {
        return this._admin;
    }

    readonly _date_password: string | undefined;

    get datePassword() {
        return this._date_password;
    }

    readonly _email: string | undefined;

    get email() {
        return this._email;
    }

    readonly _enabled: boolean | undefined;

    get enabled() {
        return this._enabled;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _username: string | undefined;

    get username() {
        return this._username;
    }

    constructor(props) {
        if (typeof props.admin === 'boolean') {
            this._admin = props.admin;
        }
        if (typeof props.date_password === 'string') {
            this._date_password = props.date_password.trim();
        }
        if (typeof props.email === 'string') {
            this._email = props.email.trim();
        }
        if (typeof props.enabled === 'boolean') {
            this._enabled = props.enabled;
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.username === 'string') {
            this._username = props.username.trim();
        }
    }

    serialize() {
        const data: IUser = {};
        if (typeof this._admin !== 'undefined') {
            data.admin = this._admin;
        }
        if (typeof this._date_password !== 'undefined') {
            data.date_password = this._date_password;
        }
        if (typeof this._email !== 'undefined') {
            data.email = this._email;
        }
        if (typeof this._enabled !== 'undefined') {
            data.enabled = this._enabled;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._username !== 'undefined') {
            data.username = this._username;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            username: !this._username
                ? true
                : typeof this._username === 'string' && !this._username
                ? true
                : this._username,
            email: !this._email
                ? true
                : typeof this._email === 'string' && !this._email
                ? true
                : this._email,
            date_password: !this._date_password
                ? true
                : typeof this._date_password === 'string' &&
                  !this._date_password
                ? true
                : this._date_password,
            enabled: !this._enabled ? true : typeof this._enabled === 'boolean',
            admin: !this._admin ? true : typeof this._admin === 'boolean',
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new User({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,841
76,V,V,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value): <fim_suffix> {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1776
77,Value,Value,3b28605856ba363437dc8c991572f8f009158f06,"<fim_prefix>interface NestedRecord<V = any> {
  [k: string | number]: NestedRecord<V> | V
}

export function assignNestedKeys<Object = NestedRecord, Value = any>(
  obj,
  keys,
  value: <fim_suffix>,
) {
  let temp: Record<string, any> = obj
  keys.forEach((k, index) => {
    if (index === keys.length - 1) {
      if (temp && typeof temp === ""object"") {
        temp[k] = value
      }
    } else if (temp && typeof temp === ""object"") {
      if (!temp[k]) {
        temp[k] = {}
      }
      temp = temp[k]
    }
  })
}

export function walkObjectDeep<Value, T = Record<string, any>>(
  obj,
  callback,
  shouldSkipPaths?,
) {
  function recurse(object, parentKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (
        (!shouldSkipPaths ||
          (shouldSkipPaths && !shouldSkipPaths([...parentKeys, key]))) &&
        value !== undefined &&
        value !== null
      ) {
        if (typeof value === ""object"" && Object.keys(value).length > 0) {
          recurse(value, [...parentKeys, key])
        } else {
          callback([...parentKeys, key], value, object)
        }
      }
    })
  }
  recurse(obj)
}

function getCssValue(keys, value) {
  if (typeof value === ""number"") {
    if (
      [""lineHeight"", ""fontWeight"", ""opacity"", ""zIndex""].some((prop) =>
        keys.includes(prop),
      )
    ) {
      // CSS property that are unitless
      return value
    }
    const lastKey = keys[keys.length - 1]
    if (lastKey.toLowerCase().includes(""opacity"")) {
      // opacity values are unitless
      return value
    }
    return `${value}px`
  }
  return value
}

export function cssVarsParser<T extends Record<string, any>>(
  theme,
  options?,
) {
  const { prefix, basePrefix = """", shouldSkipGeneratingVar } = options || {}
  const css = {} as NestedRecord<string>
  const vars = {} as NestedRecord<string>
  const parsedTheme = {} as T

  walkObjectDeep(
    theme,
    (keys, value) => {
      if (typeof value === ""string"" || typeof value === ""number"") {
        if (typeof value === ""string"" && /var\(\s*--/.test(value)) {
          // for CSS variable, apply prefix or remove basePrefix from the variable
          if (!basePrefix && prefix) {
            // eslint-disable-next-line no-param-reassign
            value = value.replace(/var\(\s*--/g, `var(--${prefix}-`)
          } else {
            // eslint-disable-next-line no-param-reassign
            value = prefix
              ? value.replace(
                  new RegExp(`var\\(\\s*--${basePrefix}`, ""g""),
                  `var(--${prefix}`,
                ) // removing spaces
              : value.replace(
                  new RegExp(`var\\(\\s*--${basePrefix}-`, ""g""),
                  ""var(--"",
                )
          }
        }

        if (
          shouldSkipGeneratingVar == null ||
          shouldSkipGeneratingVar(keys, value)
        ) {
          // only create css & var if `shouldSkipGeneratingVar` return false
          const cssVar = `--${prefix ? `${prefix}-` : """"}${keys.join(""-"")}`
          Object.assign(css, { [cssVar]: getCssValue(keys, value) })

          assignNestedKeys(vars, keys, `var(${cssVar})`)
        }
      }
      assignNestedKeys(parsedTheme, keys, value)
    },
    (keys) => keys[0] === ""vars"", // skip 'vars/*' paths
  )

  return { css, vars, parsedTheme }
}
<fim_middle>",correct,589
78,ValueType,ValueType,251dc8a6bd0853f15cfeabfb12becc4052d3fe54,"<fim_prefix>type ValueType = string | number;

const isE = (number) => {
  const str = String(number);

  return !Number.isNaN(Number(str)) && str.includes('e');
};

export const trimNumber = (numStr) => {
  let str = numStr.trim();

  if (str === '' || str === '0') {
    return {
      negative: false,
      negativeStr: '',
      trimStr: '',
      integerStr: '0',
      decimalStr: '',
      fullStr: str,
    };
  }

  let negative = str.startsWith('-');

  if (negative) {
    str = str.slice(1);
  }

  str = str
    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
    .replace(/(\.\d*[^0])0*$/, '$1')
    // Remove useless decimal. `1.` => `1`
    .replace(/\.0*$/, '')
    // Remove integer 0. `0001` => `1`, 000.1' => `.1`
    .replace(/^0+/, '');

  if (str.startsWith('.')) {
    str = `0${str}`;
  }

  const trimStr = str || '0';
  const splitNumber = trimStr.split('.');

  const integerStr = splitNumber[0] || '0';
  const decimalStr = splitNumber[1] || '0';

  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }

  const negativeStr = negative ? '-' : '';

  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`,
  };
};

const validateNumber = (num) => {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }

  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
};

const getNumberPrecision = (number) => {
  const numStr = String(number);

  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));

    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch?.[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }

  return numStr.includes('.') && validateNumber(numStr)
    ? numStr.length - numStr.indexOf('.') - 1
    : 0;
};

const maxPrecision = (pre, cur: <fim_suffix>) =>
  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));

const add = (pre, cur) => {
  const preValue = Number(pre);
  const curValue = Number(cur);

  const totalValue = preValue + curValue;
  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {
    return bigIntDecimalAdd(pre, cur);
  }
  return totalValue.toFixed(maxPrecision(pre, cur));
};

const makeBigIntDecimal = (value) => {
  // We need convert back to Number since it require `toFixed` to handle this
  if (isE(value)) {
    value = Number(value);
  }

  value = typeof value === 'string' ? value : num2str(value);

  if (validateNumber(value)) {
    const trimRet = trimNumber(value);
    const numbers = trimRet.trimStr.split('.');
    const decimalStr = numbers[1] || '0';

    return {
      value: value,
      negative: trimRet.negative,
      integer: BigInt(numbers[0]),
      decimal: BigInt(decimalStr),
      decimalLen: decimalStr.length,
    };
  }
  return null;
};

type BigIntDecimalType = {
  value: string;
  negative: boolean;
  integer: BigInt;
  decimal: BigInt;
  decimalLen: number;
};

const bigIntDecimalAdd = (pre, cur) => {
  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;
  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;

  if (!preValue || !curValue) return '';

  const maxDecimalLength = Math.max(
    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,
    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,
  );
  const preDecimal = BigInt(
    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal
      .toString()
      .padStart(preValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );
  const curDecimal = BigInt(
    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal
      .toString()
      .padStart(curValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );

  const valueStr = (preDecimal + curDecimal).toString();

  // We need fill string length back to `maxDecimalLength` to avoid parser failed
  const { negativeStr, trimStr } = trimNumber(valueStr);
  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;

  return trimNumber(
    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,
  ).fullStr;
};

export const num2str = (value) => {
  let numIn = value.toString();
  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;
  let sign = ''; // To remember the number sign
  if (numIn.charAt(0) === '-') {
    numIn = numIn.substring(1);
    sign = '-';
  }
  let str = numIn.split(/[eE]/g); // Split numberic string at e or E

  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back

  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)
  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one

  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator
  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point

  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else """"
  let baseLH = str[0]; // LH base part.

  if (power > 0) {
    // ------- Positive Exponents (Process the RH Base Part)
    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with ""0"" at RH
    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base
    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it
  } else {
    // ------- Negative Exponents (Process the LH Base Part)
    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's
    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with ""0"" at LH
    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert ""."" at the correct place into LH base
    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add ""0""
  }
  return sign + baseLH + baseRH; // Return the long number (with sign)
};

export default add;
<fim_middle>",correct,4638
79,Variable,Variable,b6c4e1fb10e5beed8368e9e86826f11e965be6f5,"<fim_prefix>const DFG_VERSION = '0.18.1';

export enum QueryDetail {
  LABEL = 'LABEL',
  SKELETON = 'SKELETON',
  SUMMARY = 'SUMMARY',
  FULL = 'FULL',
}

export enum VariableType {
  POINT2 = 'RoME.Point2',
  POSE2 = 'RoME.Pose2',
}

export type Variable = {
  label: string;
  dataEntry: string;
  nstime: string;
  variableType: string;
  dataEntryType: string;
  ppeDict: string;
  solverDataDict: string;
  smallData: string;
  solvable: number;
  tags: string;
  timestamp: string;
  _version: string;
};

export function Variable(
  label,
  type,
  tags = ['VARIABLE'],
  timestamp = new Date().toISOString(),
): <fim_suffix> {
  const solverDataDict = {
    default: {
      vecval: [
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      ],
      dimval: 3,
      vecbw: [0.0, 0.0, 0.0],
      dimbw: 3,
      BayesNetOutVertIDs: [],
      dimIDs: [0, 1, 2],
      dims: 3,
      eliminated: false,
      BayesNetVertID: '_null',
      separator: [],
      variableType: type,
      initialized: false,
      infoPerCoord: [0.0, 0.0, 0.0],
      ismargin: false,
      dontmargin: false,
      solveInProgress: 0,
      solvedCount: 0,
      solveKey: 'default',
    },
  };
  const result: Variable = {
    label,
    dataEntry: '{}',
    nstime: '0',
    variableType: type,
    dataEntryType: '{}',
    ppeDict: '{}',
    solverDataDict: JSON.stringify(solverDataDict),
    smallData: '{}',
    solvable: 1,
    tags: JSON.stringify(tags),
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",correct,1023
80,Vertex,Vertex,eaa92966cbe116f28e1b5c9c0f4b724a32bab041,"<fim_prefix>type Vertex = string;
type Weight = number;
type Graph = Record<string, Record<string, Weight>>;

/**
 * If a target is not provided, finds the single-source shortest path distance from the source vertex with positive or negative edge weights
 * (but with no negative weight cycles).
 * Else, it returns the shortest path as well as its distance from source vertex to target vertex.
 * In the case of negative weight cycles, if target is defined, then negative infinity and empty array path will be returned,
 * else, all distances from A will be returned with negative infinity.
 *
 * @param {Graph} graph Vertex with its fields being the neighboring vertices and value being the weight from vertex to neighboring vertices
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target Ending vertex in graph
 * @return {Record<string, number> | [number, Array<Vertex>]} An object mapping of the distance from the source vertex or an array containing the distance
 * and an array containing the path from source to target vertex
 */
function bellmanFord(
  graph,
  source,
  target?,
) {
  const vertices = Object.keys(graph);
  // if graph is empty, immediately return
  if (vertices.length === 0) {
    return target ? [0, []] : {};
  }

  if (!vertices.includes(source) || (target && !vertices.includes(target))) {
    return target ? [-Infinity, []] : {};
  }

  const distances = getDistances(vertices, source);
  const predecessor = getPredecessor(vertices);

  // requires only n - 1 iteration
  for (let i = 0; i < vertices.length - 1; i++) {
    for (let startVertex of vertices) {
      const neighbors = graph[startVertex];
      for (let endVertex in neighbors) {
        const weight = graph[startVertex][endVertex];
        // relaxation
        if (distances[startVertex] + weight < distances[endVertex]) {
          distances[endVertex] = distances[startVertex] + weight;
          predecessor[endVertex] = startVertex;
        }
      }
    }
  }

  // checks for any negative weight cycles. If true returns all distances as -Infinity as a sign negative weight cycles
  for (let startVertex of vertices) {
    const neighbors = graph[startVertex];
    for (let endVertex in neighbors) {
      const weight = graph[startVertex][endVertex];
      // if relaxation occurs here, negative weight cycles detected
      if (distances[startVertex] + weight < distances[endVertex]) {
        return target ? [-Infinity, []] : negativeWeightCycles(vertices);
      }
    }
  }

  if (!target) {
    return distances;
  }

  const shortestDistance = distances[target];
  const path = getPath(predecessor, source, target);
  return [shortestDistance, path];
}

/**
 * Returns an Object mapping of nodes to distance with values all being negative infinity to represent a negative weight cycle being present.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, number>} An object mapping of nodes with values being negative infinity
 */
function negativeWeightCycles(vertices) {
  return vertices.reduce((acc, curr) => {
    acc[curr] = -Infinity;
    return acc;
  }, {} as Record<string, number>);
}

/**
 * Initializes the distance mapping from source to rest of the vertices.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @param {Vertex} source Starting vertex in graph
 * @return {Record<string, number>} An object mapping of source to rest of vertices
 */
function getDistances(
  vertices,
  source,
) {
  const distances = vertices.reduce((acc, curr) => {
    acc[curr] = Infinity;
    return acc;
  }, {} as Record<string, number>);
  distances[source] = 0;
  return distances;
}

/**
 * Returns an array denoting the path from start vertex to end vertex.
 *
 * @param {Object} predecessor Mapping of child vertex pointing to parent vertex
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target End vertex in graph
 * @return {Array<String>} An array containing the path from source to target vertex
 */
function getPath(
  predecessor,
  source,
  target: <fim_suffix>,
) {
  const path = [target];
  while (target && target !== source) {
    const next = predecessor[target];
    target = next ?? source; // if next is undefined, it reaches source
    path.push(target);
  }
  return path.reverse();
}

/**
 * Generates a default object mapping of child vertex pointing to parent vertex which will be defaulted to undefined initially.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, Vertex | undefined>} An object mapping of child vertex pointing to parent vertex
 */
function getPredecessor(
  vertices,
) {
  const predecessor = {} as Record<string, Vertex | undefined>;
  for (let vertex of vertices) {
    predecessor[vertex] = undefined;
  }
  return predecessor;
}

export default bellmanFord;
<fim_middle>",correct,4126
81,WebApi,WebApi,784e0b27e79a2fe98c745e477d0f8c518b8f59ac,"<fim_prefix>export const Kind = 'Core#WebApi';

/**
 * @deprecated This was used in the old version of ARC.
 */
export interface ILegacyRestApi {
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   */
  data: string;
  /**
   * The AMF parser version used to parse this document.
   */
  amfVersion?: string;
}

export interface IWebApi {
  kind: typeof Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path: string;
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;
}

export class WebApi {
  kind = Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId = '';
  /**
   * Version name of the API
   */
  version = '';
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path = '';
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;

  /**
   * Checks whether the object represents a legacy way of storing the web API data.
   */
  get isLegacy() {
    return !!this.data;
  }

  /**
   * Checks whether the object is the legacy schema for web API (formally known as RestAPI)
   */
  static isLegacy(api) {
    const legacy = api as ILegacyRestApi;
    if (legacy.data) {
      return true;
    }
    return false;
  }

  static fromLegacy(api): <fim_suffix> {
    const { version, amfVersion, data, indexId } = api;
    const init: IWebApi = {
      kind: Kind,
      version,
      path: '',
      indexId,
    };
    if (amfVersion) {
      init.amfVersion = amfVersion;
    }
    if (data) {
      init.data = data;
    }
    return new WebApi(init);
  }

  /**
   * Creates an identifier of this web API object.
   * @param indexId The id of the corresponding index item. This is usually the base URI of the API.
   * @param version The version name of this web API.
   * @returns The unique and reversible identifier of this web API.
   */
  static createId(indexId, version) {
    return `${indexId}|${version}`;
  }

  constructor(input?) {
    let init: IWebApi;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        version: '',
        path: '',
        indexId: '',
      };
    }
    this.new(init);
  }

  new(init) {
    const { version, data, amfVersion, path, main, mime, vendor, indexId } = init;
    if (indexId) {
      this.indexId = indexId;
    } else {
      this.indexId = '';
    }
    if (version) {
      this.version = version;
    } else {
      this.version = '';
    }
    if (data) {
      this.data = data;
    } else {
      this.data = undefined;
    }
    if (amfVersion) {
      this.amfVersion = amfVersion;
    } else {
      this.amfVersion = undefined;
    }
    if (path) {
      this.path = path;
    } else {
      this.path = '';
    }
    if (main) {
      this.main = main;
    } else {
      this.main = undefined
    }
    if (mime) {
      this.mime = mime;
    } else {
      this.mime = mime;
    }
    if (vendor) {
      this.vendor = vendor;
    } else {
      this.vendor = undefined;
    }
  }

  toJSON() {
    const result: IWebApi = {
      kind: Kind,
      version: this.version,
      path: this.path,
      indexId: this.indexId,
    };
    if (this.data) {
      result.data = this.data;
    }
    if (this.amfVersion) {
      result.amfVersion = this.amfVersion;
    }
    if (this.main) {
      result.main = this.main;
    }
    if (this.mime) {
      result.mime = this.mime;
    }
    if (this.vendor) {
      result.vendor = this.vendor;
    }
    return result;
  }
}
<fim_middle>",correct,2777
82,any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional: <fim_suffix>) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,81
83,bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration(): <fim_suffix> {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,615
84,boolean,boolean,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit: <fim_suffix>
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,6
85,never,never,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1107
86,number,number,d136cbb659cd7f40984bcec5a5dcf88567bffb4d,"<fim_prefix>export type BookTitle = string;

const booksToChaptersMap: { [name: string]: number } = {
  Genesis: 50,
  Exodus: 40,
  Leviticus: 27,
  Numbers: 36,
  Deuteronomy: 34,
  Joshua: 24,
  Judges: 21,
  Ruth: 4,
  '1 Samuel': 31,
  '2 Samuel': 24,
  '1 Kings': 22,
  '2 Kings': 25,
  '1 Chronicles': 29,
  '2 Chronicles': 36,
  Ezra: 10,
  Nehemiah: 13,
  Esther: 10,
  Job: 42,
  Psalms: 150,
  Proverbs: 31,
  Ecclesiastes: 12,
  'Song of Solomon': 8,
  Isaiah: 66,
  Jeremiah: 52,
  Lamentations: 5,
  Ezekial: 48,
  Daniel: 12,
  Hosea: 14,
  Joel: 3,
  Amos: 9,
  Obadiah: 1,
  Jonah: 4,
  Micah: 7,
  Nahum: 3,
  Habakkuk: 3,
  Zephaniah: 3,
  Haggai: 2,
  Zechariah: 14,
  Malachi: 4,
  Matthew: 28,
  Mark: 16,
  Luke: 24,
  John: 21,
  Acts: 28,
  Romans: 16,
  '1 Corinthians': 16,
  '2 Corinthians': 13,
  Galatians: 6,
  Ephesians: 6,
  Philippians: 4,
  Colossians: 4,
  '1 Thessalonians': 5,
  '2 Thessalonians': 3,
  '1 Timothy': 6,
  '2 Timothy': 4,
  Titus: 3,
  Philemon: 1,
  Hebrews: 13,
  James: 5,
  '1 Peter': 5,
  '2 Peter': 3,
  '1 John': 5,
  '2 John': 1,
  '3 John': 1,
  Jude: 1,
  Revelation: 22,
};

const possibleTitles: string[] = Array.from(Object.keys(booksToChaptersMap));

let i = 0;
export const hebrewScriptures: BookInfo[] = possibleTitles
  .slice(0, 39)
  .map((x) => {
    i++;
    return { id: i, title: x, chapters: booksToChaptersMap[x] };
  });

export const newTestament: BookInfo[] = possibleTitles.slice(39).map((x) => {
  i++;
  return { id: i, title: x, chapters: booksToChaptersMap[x] };
});

export const getBookTitleFromSlug = (
  bookTitle,
) => {
  if (typeof bookTitle !== 'string') {
    throw new Error(`Booktitle ${bookTitle} is not even string`);
  }

  const found = possibleTitles.find(
    (x) => bookTitle === x.replace(' ', '-').toLowerCase(),
  );

  if (found === undefined) {
    throw new Error('There is not such book title:${bookParam}');
  }

  return found;
};

export const getChapterFromSlug = (
  chapter,
  book,
): <fim_suffix> => {
  if (isNaN(Number(chapter))) {
    throw new Error(`Chapter ""${chapter}"" is not a number`);
  }
  if (!Number.isInteger(Number(chapter))) {
    throw new Error(`Chapter ""${chapter}"" is not integer`);
  }
  if (Number(chapter) > booksToChaptersMap[book]) {
    throw new Error(`Chapter ""${chapter}"" is too hight`);
  }
  if (Number(chapter) < 1) {
    throw new Error(`Chapter ""${chapter}"" is too low`);
  }
  return Number(chapter);
};

export interface BookInfo {
  id: number;
  title: string;
  chapters: number;
}
<fim_middle>",correct,34
87,offsets,offsets,bf991cf13e41beda6a1e948184ea7f39b759886d,"<fim_prefix>interface offsets {
  vertical: number
  horizontal: number
}
export function measureOffsets (
  text,
  fontFamily,
  fontSize,
  createCanvas
): <fim_suffix> {
  const canvas = createCanvas()
  const ctx = canvas.getContext('2d')
  ctx.font = `${fontSize}px ${fontFamily}`

  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize
  ctx.font = `${fontSize}px ${fontFamily}`
  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize

  ctx.font = `${fontSize}px ${fontFamily}`
  ctx.textBaseline = 'alphabetic'
  ctx.textAlign = 'center'
  ctx.fillStyle = 'white'
  ctx.fillText(text, canvas.width / 2, canvas.height / 2)

  const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data

  let textTop = 0
  let textBottom = 0
  for (let y = 0; y <= canvas.height; y++) {
    for (let x = 0; x <= canvas.width; x++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]
      if (rValue === 255) {
        if (textTop === 0) {
          textTop = y
        }
        textBottom = y
        break
      }
    }
  }
  const canvasHorizontalCenterLine = canvas.height / 2
  const textHorizontalCenterLine = (textBottom - textTop) / 2 + textTop

  let textLeft = 0
  let textRight = 0
  for (let x = 0; x <= canvas.width; x++) {
    for (let y = 0; y <= canvas.height; y++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]

      if (rValue === 255) {
        if (textLeft === 0) {
          textLeft = x
        }
        textRight = x
        break
      }
    }
  }

  const canvasVerticalCenterLine = canvas.width / 2
  const textVerticalCenterLine = (textRight - textLeft) / 2 + textLeft

  return {
    vertical: canvasHorizontalCenterLine - textHorizontalCenterLine,
    horizontal: canvasVerticalCenterLine - textVerticalCenterLine
  }
}
<fim_middle>",correct,4433
88,string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name: <fim_suffix>) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,22
89,unknown,unknown,9df566c660a96ca1ea9c774ead4166eff4ea2801,"<fim_prefix>export interface AsyncPushCallbacks<T> {
  next: (value) => void;
  done: () => void;
  error: (err: <fim_suffix>) => void;
}

export function createAsyncIterable<T = unknown>(
  listener
) {
  let done = false;
  let error: unknown | null = null;

  const pushQueue: T[] = [];
  const pullQueue: Array<
    [
      (x) => void,
      (err) => void
    ]
  > = [];

  return {
    [Symbol.asyncIterator]() {
      listener({
        next: (value) => {
          if (done || error) return;
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[0]({ value, done: false });
          } else {
            pushQueue.push(value);
          }
        },
        error: (err) => {
          if (done || error) return;
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[1](err);
          }
          error = err;
        },
        done: () => {
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[0]({ value: undefined, done: true });
          }
          done = true;
        },
      });

      return {
        next() {
          return new Promise<{ value: T | undefined; done: boolean }>(
            (resolve, reject) => {
              if (pushQueue.length > 0) {
                resolve({ value: pushQueue.shift(), done: false });
              } else if (done) {
                resolve({ value: undefined, done: true });
              } else if (error) {
                reject(error);
              } else {
                pullQueue.push([resolve, reject]);
              }
            }
          );
        },
      };
    },
  } as AsyncIterable<T>;
}
<fim_middle>",correct,4185
90,void,void,1d39ec473347edb072e37f629ad2a9736fad5a7a,"<fim_prefix>export const Kind = 'Core#ResponseAuthorization';

export interface IResponseAuthorization {
  kind: typeof Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method: string;
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;
}

export class ResponseAuthorization {
  kind = Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method = 'unknown';
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;

  /**
   * @param input The response authorization definition used to restore the state.
   */
  constructor(input?) {
    let init: IResponseAuthorization;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        method: 'unknown',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new response authorization clearing anything that is so far defined.
   * 
   * Note, this throws an error when the object is not a response authorization.
   */
  new(init): <fim_suffix> {
    if (!ResponseAuthorization.isResponseAuthorization(init)) {
      throw new Error(`Not a response authorization.`);
    }
    const { method, state, headers, challengeHeader } = init;
    this.kind = Kind;
    this.method = method;
    this.state = state;
    this.headers = headers;
    this.challengeHeader = challengeHeader;
  }

  /**
   * Checks whether the input is a definition of a response authorization.
   */
  static isResponseAuthorization(input) {
    const typed = input as IResponseAuthorization;
    if (!input || !typed.method) {
      return false;
    }
    return true;
  }

  toJSON() {
    const result: IResponseAuthorization = {
      kind: Kind,
      method: this.method,
    };
    if (typeof this.state === 'number') {
      result.state = this.state;
    }
    if (this.headers) {
      result.headers = this.headers;
    }
    if (this.challengeHeader) {
      result.challengeHeader = this.challengeHeader;
    }
    return result;
  }
}
<fim_middle>",correct,77
