[
    {
        "prompt": "<fim_prefix>type ValueType = string | number;\n\nconst isE = (number) => {\n  const str = String(number);\n\n  return !Number.isNaN(Number(str)) && str.includes('e');\n};\n\nexport const trimNumber = (numStr) => {\n  let str = numStr.trim();\n\n  if (str === '' || str === '0') {\n    return {\n      negative: false,\n      negativeStr: '',\n      trimStr: '',\n      integerStr: '0',\n      decimalStr: '',\n      fullStr: str,\n    };\n  }\n\n  let negative = str.startsWith('-');\n\n  if (negative) {\n    str = str.slice(1);\n  }\n\n  str = str\n    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`\n    .replace(/(\\.\\d*[^0])0*$/, '$1')\n    // Remove useless decimal. `1.` => `1`\n    .replace(/\\.0*$/, '')\n    // Remove integer 0. `0001` => `1`, 000.1' => `.1`\n    .replace(/^0+/, '');\n\n  if (str.startsWith('.')) {\n    str = `0${str}`;\n  }\n\n  const trimStr = str || '0';\n  const splitNumber = trimStr.split('.');\n\n  const integerStr = splitNumber[0] || '0';\n  const decimalStr = splitNumber[1] || '0';\n\n  if (integerStr === '0' && decimalStr === '0') {\n    negative = false;\n  }\n\n  const negativeStr = negative ? '-' : '';\n\n  return {\n    negative,\n    negativeStr,\n    trimStr,\n    integerStr,\n    decimalStr,\n    fullStr: `${negativeStr}${trimStr}`,\n  };\n};\n\nconst validateNumber = (num) => {\n  if (typeof num === 'number') {\n    return !Number.isNaN(num);\n  }\n\n  // Empty\n  if (!num) {\n    return false;\n  }\n\n  return (\n    // Normal type: 11.28\n    /^\\s*-?\\d+(\\.\\d+)?\\s*$/.test(num) ||\n    // Pre-number: 1.\n    /^\\s*-?\\d+\\.\\s*$/.test(num) ||\n    // Post-number: .1\n    /^\\s*-?\\.\\d+\\s*$/.test(num)\n  );\n};\n\nconst getNumberPrecision = (number) => {\n  const numStr = String(number);\n\n  if (isE(number)) {\n    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));\n\n    const decimalMatch = numStr.match(/\\.(\\d+)/);\n    if (decimalMatch?.[1]) {\n      precision += decimalMatch[1].length;\n    }\n    return precision;\n  }\n\n  return numStr.includes('.') && validateNumber(numStr)\n    ? numStr.length - numStr.indexOf('.') - 1\n    : 0;\n};\n\nconst maxPrecision = (pre, cur) =>\n  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));\n\nconst add = (pre, cur) => {\n  const preValue = Number(pre);\n  const curValue = Number(cur);\n\n  const totalValue = preValue + curValue;\n  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {\n    return bigIntDecimalAdd(pre, cur);\n  }\n  return totalValue.toFixed(maxPrecision(pre, cur));\n};\n\nconst makeBigIntDecimal = (value) => {\n  // We need convert back to Number since it require `toFixed` to handle this\n  if (isE(value)) {\n    value = Number(value);\n  }\n\n  value = typeof value === 'string' ? value : num2str(value);\n\n  if (validateNumber(value)) {\n    const trimRet = trimNumber(value);\n    const numbers = trimRet.trimStr.split('.');\n    const decimalStr = numbers[1] || '0';\n\n    return {\n      value: value,\n      negative: trimRet.negative,\n      integer: BigInt(numbers[0]),\n      decimal: BigInt(decimalStr),\n      decimalLen: decimalStr.length,\n    };\n  }\n  return null;\n};\n\ntype BigIntDecimalType = {\n  value: string;\n  negative: boolean;\n  integer: BigInt;\n  decimal: BigInt;\n  decimalLen: number;\n};\n\nconst bigIntDecimalAdd = (pre, cur: <fim_suffix>) => {\n  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;\n  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;\n\n  if (!preValue || !curValue) return '';\n\n  const maxDecimalLength = Math.max(\n    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,\n    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,\n  );\n  const preDecimal = BigInt(\n    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal\n      .toString()\n      .padStart(preValue.decimalLen, '0')\n      .padEnd(maxDecimalLength, '0')}`,\n  );\n  const curDecimal = BigInt(\n    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal\n      .toString()\n      .padStart(curValue.decimalLen, '0')\n      .padEnd(maxDecimalLength, '0')}`,\n  );\n\n  const valueStr = (preDecimal + curDecimal).toString();\n\n  // We need fill string length back to `maxDecimalLength` to avoid parser failed\n  const { negativeStr, trimStr } = trimNumber(valueStr);\n  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;\n\n  return trimNumber(\n    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,\n  ).fullStr;\n};\n\nexport const num2str = (value) => {\n  let numIn = value.toString();\n  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;\n  let sign = ''; // To remember the number sign\n  if (numIn.charAt(0) === '-') {\n    numIn = numIn.substring(1);\n    sign = '-';\n  }\n  let str = numIn.split(/[eE]/g); // Split numberic string at e or E\n\n  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back\n\n  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)\n  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one\n\n  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator\n  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point\n\n  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else \"\"\n  let baseLH = str[0]; // LH base part.\n\n  if (power > 0) {\n    // ------- Positive Exponents (Process the RH Base Part)\n    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with \"0\" at RH\n    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base\n    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it\n  } else {\n    // ------- Negative Exponents (Process the LH Base Part)\n    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's\n    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with \"0\" at LH\n    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert \".\" at the correct place into LH base\n    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add \"0\"\n  }\n  return sign + baseLH + baseRH; // Return the long number (with sign)\n};\n\nexport default add;\n<fim_middle>",
        "label": "ValueType",
        "post_steer_toptok": "number",
        "success": false,
        "generated": "string",
        "id": 4633
    },
    {
        "prompt": "<fim_prefix>export type HttpResponse = {\n  statusCode: number;\n  body: any;\n};\n\nexport function ok<T>(dto?) {\n  return {\n    statusCode: 200,\n    body: dto,\n  };\n}\n\nexport function created(body?) {\n  return {\n    statusCode: 201,\n    body: body !== undefined ? body : undefined,\n  };\n}\n\nexport function noContent(body?) {\n  return {\n    statusCode: 204,\n    body: body !== undefined ? body : undefined,\n  };\n}\n\nexport function clientError(error) {\n  return {\n    statusCode: 400,\n    body: {\n      error: error.message,\n    },\n  };\n}\n\nexport function unauthorized(error) {\n  return {\n    statusCode: 401,\n    body: {\n      error: error.message,\n    },\n  };\n}\n\nexport function forbidden(error) {\n  return {\n    statusCode: 403,\n    body: {\n      error: error.message,\n    },\n  };\n}\n\nexport function notFound(error) {\n  return {\n    statusCode: 404,\n    body: {\n      error: error.message,\n    },\n  };\n}\n\nexport function notAcceptable(error) {\n  return {\n    statusCode: 406,\n    body: {\n      error: error.message,\n    },\n  };\n}\n\nexport function conflict(error) {\n  return {\n    statusCode: 409,\n    body: {\n      error: error.message,\n    },\n  };\n}\n\nexport function tooMany(error) {\n  return {\n    statusCode: 429,\n    body: {\n      error: error.message,\n    },\n  };\n}\n\nexport function fail(error: <fim_suffix>) {\n  return {\n    statusCode: 500,\n    body: {\n      error: error.message,\n    },\n  };\n}\n<fim_middle>",
        "label": "Error",
        "post_steer_toptok": "Error",
        "success": true,
        "generated": "any",
        "id": 1144
    },
    {
        "prompt": "<fim_prefix>export const Kind = 'Core#ResponseAuthorization';\n\nexport interface IResponseAuthorization {\n  kind: typeof Kind;\n  /**\n   * The requested by the authorization server authentication method\n   */\n  method: string;\n  /**\n   * The current state if the authorization process. This is used by NTLM authorization helper.\n   */\n  state?: number;\n  /**\n   * The headers association with the response.\n   */\n  headers?: string;\n  /**\n   * When returned by the server, the value of the challenge.\n   */\n  challengeHeader?: string;\n}\n\nexport class ResponseAuthorization {\n  kind = Kind;\n  /**\n   * The requested by the authorization server authentication method\n   */\n  method = 'unknown';\n  /**\n   * The current state if the authorization process. This is used by NTLM authorization helper.\n   */\n  state?: number;\n  /**\n   * The headers association with the response.\n   */\n  headers?: string;\n  /**\n   * When returned by the server, the value of the challenge.\n   */\n  challengeHeader?: string;\n\n  /**\n   * @param input The response authorization definition used to restore the state.\n   */\n  constructor(input?) {\n    let init: IResponseAuthorization;\n    if (typeof input === 'string') {\n      init = JSON.parse(input);\n    } else if (typeof input === 'object') {\n      init = input;\n    } else {\n      init = {\n        kind: Kind,\n        method: 'unknown',\n      };\n    }\n    this.new(init);\n  }\n\n  /**\n   * Creates a new response authorization clearing anything that is so far defined.\n   * \n   * Note, this throws an error when the object is not a response authorization.\n   */\n  new(init) {\n    if (!ResponseAuthorization.isResponseAuthorization(init)) {\n      throw new Error(`Not a response authorization.`);\n    }\n    const { method, state, headers, challengeHeader } = init;\n    this.kind = Kind;\n    this.method = method;\n    this.state = state;\n    this.headers = headers;\n    this.challengeHeader = challengeHeader;\n  }\n\n  /**\n   * Checks whether the input is a definition of a response authorization.\n   */\n  static isResponseAuthorization(input: <fim_suffix>) {\n    const typed = input as IResponseAuthorization;\n    if (!input || !typed.method) {\n      return false;\n    }\n    return true;\n  }\n\n  toJSON() {\n    const result: IResponseAuthorization = {\n      kind: Kind,\n      method: this.method,\n    };\n    if (typeof this.state === 'number') {\n      result.state = this.state;\n    }\n    if (this.headers) {\n      result.headers = this.headers;\n    }\n    if (this.challengeHeader) {\n      result.challengeHeader = this.challengeHeader;\n    }\n    return result;\n  }\n}\n<fim_middle>",
        "label": "unknown",
        "post_steer_toptok": "I",
        "success": false,
        "generated": "IResponseAuthorization",
        "id": 76
    },
    {
        "prompt": "<fim_prefix>export type Arrow<A extends any[] = any, B = any> = (...args) => B\n\nexport function pipe<A>(a)\nexport function pipe<A, B>(a, ab)\nexport function pipe<A, B, C>(a, ab, bc)\nexport function pipe<A, B, C, D>(a, ab, bc, cd)\nexport function pipe<A, B, C, D, E>(a, ab, bc, cd, de)\nexport function pipe<A, B, C, D, E, F>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef\n)\nexport function pipe<A, B, C, D, E, F, G>(\n  a: <fim_suffix>,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg\n)\nexport function pipe<A, B, C, D, E, F, G, H>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh\n)\nexport function pipe<A, B, C, D, E, F, G, H, I>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi\n)\nexport function pipe<A, B, C, D, E, F, G, H, I, J>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij\n)\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk\n)\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl\n)\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm\n)\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm,\n  mn\n)\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm,\n  mn,\n  no\n)\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm,\n  mn,\n  no,\n  op\n)\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm,\n  mn,\n  no,\n  op,\n  pq\n)\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm,\n  mn,\n  no,\n  op,\n  pq,\n  qr\n)\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm,\n  mn,\n  no,\n  op,\n  pq,\n  qr,\n  rs\n)\n\nexport function pipe<A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T>(\n  a,\n  ab,\n  bc,\n  cd,\n  de,\n  ef,\n  fg,\n  gh,\n  hi,\n  ij,\n  jk,\n  kl,\n  lm,\n  mn,\n  no,\n  op,\n  pq,\n  qr,\n  rs,\n  st\n)\nexport function pipe(\n  a,\n  ab?,\n  bc?,\n  cd?,\n  de?,\n  ef?,\n  fg?,\n  gh?,\n  hi?\n) {\n  switch (arguments.length) {\n    case 1:\n      return a\n    case 2:\n      return ab!(a)\n    case 3:\n      return bc!(ab!(a))\n    case 4:\n      return cd!(bc!(ab!(a)))\n    case 5:\n      return de!(cd!(bc!(ab!(a))))\n    case 6:\n      return ef!(de!(cd!(bc!(ab!(a)))))\n    case 7:\n      return fg!(ef!(de!(cd!(bc!(ab!(a))))))\n    case 8:\n      return gh!(fg!(ef!(de!(cd!(bc!(ab!(a)))))))\n    case 9:\n      return hi!(gh!(fg!(ef!(de!(cd!(bc!(ab!(a))))))))\n    default:\n      // eslint-disable-next-line prefer-rest-params,no-case-declarations\n      let ret = arguments[0]\n      for (let i = 1; i < arguments.length; i++) {\n        // eslint-disable-next-line prefer-rest-params\n        ret = arguments[i](ret)\n      }\n      return ret\n  }\n}\n<fim_middle>",
        "label": "A",
        "post_steer_toptok": "a",
        "success": false,
        "generated": "a",
        "id": 1583
    },
    {
        "prompt": "<fim_prefix>/**\n * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js\n * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE\n * Copyright (c) 2017 Erik Rasmussen\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n * Based on Underscore.js, copyright Jeremy Ashkenas,\n *\n * Structure Tester\n * https://8ypq7n41z0.codesandbox.io/\n */\n\ntype State = any;\n\nconst charCodeOfDot = \".\".charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp(\n    // Match anything that isn't a dot or bracket.\n    \"[^.[\\\\]]+\" +\n        \"|\" +\n        // Or match property names within brackets.\n        \"\\\\[(?:\" +\n        // Match a non-string expression.\n        \"([^\\\"'][^[]*)\" +\n        \"|\" +\n        // Or match strings (supports escaping characters).\n        \"([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2\" +\n        \")\\\\]\" +\n        \"|\" +\n        // Or match \"\" as the space between consecutive dots or empty brackets.\n        \"(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))\",\n    \"g\",\n);\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nconst stringToPath = (string) => {\n    const result = [];\n    if (string.charCodeAt(0) === charCodeOfDot) {\n        result.push(\"\");\n    }\n    string.replace(rePropName, (match, expression, quote, subString) => {\n        let key = match;\n        if (quote) {\n            key = subString.replace(reEscapeChar, \"$1\");\n        } else if (expression) {\n            key = expression.trim();\n        }\n        result.push(key);\n\n        return \"\";\n    });\n    return result;\n};\n\nconst keysCache: { [key: string]: string[] } = {};\n\nconst toPath = (key) => {\n    if (key === null || key === undefined || !key.length) {\n        return [];\n    }\n    if (typeof key !== \"string\") {\n        throw new Error(\"toPath() expects a string\");\n    }\n\n    if (keysCache[key] == null) {\n        keysCache[key] = stringToPath(key);\n    }\n    return keysCache[key]!;\n};\n\nconst setInRecursor = (\n    current,\n    index,\n    path,\n    value,\n    destroyArrays,\n): <fim_suffix> => {\n    if (index >= path.length) {\n        // end of recursion\n        return value;\n    }\n    const key = path[index]!;\n\n    // determine type of key\n    if (isNaN(key as any)) {\n        // object set\n        if (current === undefined || current === null) {\n            // recurse\n            const result = setInRecursor(\n                undefined,\n                index + 1,\n                path,\n                value,\n                destroyArrays,\n            );\n\n            // delete or create an object\n            return result === undefined ? undefined : { [key]: result };\n        }\n        if (Array.isArray(current)) {\n            throw new Error(\"Cannot set a non-numeric property on an array\");\n        }\n        // current exists, so make a copy of all its values, and add/update the new one\n        const result = setInRecursor(\n            current[key],\n            index + 1,\n            path,\n            value,\n            destroyArrays,\n        );\n        if (result === undefined) {\n            const numKeys = Object.keys(current).length;\n            if (current[key] === undefined && numKeys === 0) {\n                // object was already empty\n                return undefined;\n            }\n            if (current[key] !== undefined && numKeys <= 1) {\n                // only key we had was the one we are deleting\n                if (!isNaN(path[index - 1] as any) && !destroyArrays) {\n                    // we are in an array, so return an empty object\n                    return {};\n                } else {\n                    return undefined;\n                }\n            }\n            const { [key]: _removed, ...final } = current;\n            return final;\n        }\n        // set result in key\n        return {\n            ...current,\n            [key]: result,\n        };\n    }\n    // array set\n    const numericKey = Number(key);\n    if (current === undefined || current === null) {\n        // recurse\n        const result = setInRecursor(\n            undefined,\n            index + 1,\n            path,\n            value,\n            destroyArrays,\n        );\n\n        // if nothing returned, delete it\n        if (result === undefined) {\n            return undefined;\n        }\n\n        // create an array\n        const array = [];\n        array[numericKey] = result;\n        return array as any[];\n    }\n    if (!Array.isArray(current)) {\n        throw new Error(\"Cannot set a numeric property on an object\");\n    }\n    // recurse\n    const existingValue = current[numericKey];\n    const result = setInRecursor(\n        existingValue,\n        index + 1,\n        path,\n        value,\n        destroyArrays,\n    );\n\n    // current exists, so make a copy of all its values, and add/update the new one\n    const array = [...current];\n    if (destroyArrays && result === undefined) {\n        array.splice(numericKey, 1);\n        if (array.length === 0) {\n            return undefined;\n        }\n    } else {\n        array[numericKey] = result;\n    }\n    return array;\n};\n\nexport const setIn = (state, key, value) => {\n    if (state === undefined || state === null) {\n        throw new Error(`Cannot call setIn() with ${String(state)} state`);\n    }\n    if (key === undefined || key === null) {\n        throw new Error(`Cannot call setIn() with ${String(key)} key`);\n    }\n    // Recursive function needs to accept and return State, but public API should\n    // only deal with Objects\n    return setInRecursor(state, 0, toPath(key), value, false) as any;\n};\n<fim_middle>",
        "label": "State",
        "post_steer_toptok": "State",
        "success": true,
        "generated": "any",
        "id": 2056
    },
    {
        "prompt": "<fim_prefix>interface CustomDescriptor {\n  [propsname: string]: any;\n}\n\ntype DesType = 'class' | 'method';\n\nfunction getOwnKeys(object) {\n  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>\n    item.toString()\n  );\n\n  return Object.getOwnPropertyNames(object).concat(symbolKeys);\n}\n\nfunction getOwnPropertyDescriptors(obj) {\n  let descs: CustomDescriptor = {};\n\n  getOwnKeys(obj).forEach((key) => {\n    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));\n  });\n\n  return descs;\n}\n\nfunction autoClass(fn, klass, ...rest) {\n  const descs = getOwnPropertyDescriptors(klass.prototype);\n\n  const keys = getOwnKeys(descs);\n\n  keys.forEach((key) => {\n    let desc = descs[key];\n\n    if (typeof desc.value === 'function' && key !== 'constructor') {\n      const descriptor: PropertyDescriptor = fn(\n        klass.prototype,\n        key,\n        desc,\n        ...rest\n      );\n\n      Object.defineProperty(klass.prototype, key, descriptor);\n    }\n  });\n}\n\nfunction handleDescriptor(fn, desType, args) {\n  if (desType === 'class') {\n    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);\n  } else {\n    return fn.apply(undefined, [...args]);\n  }\n}\n\nfunction isDescriptor(desc) {\n  if (!desc || !desc.hasOwnProperty) {\n    return false;\n  }\n\n  const keys = ['value', 'initializer', 'get', 'set'];\n\n  for (let i = 0, l = keys.length; i < l; i++) {\n    if (desc.hasOwnProperty(keys[i])) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction hasParameters(target) {\n  return typeof target !== 'function' && !isDescriptor(target);\n}\n\nexport default function adaption(fn: <fim_suffix>) {\n  if (typeof fn !== 'function') {\n    new TypeError('params has function');\n  }\n\n  return function (...args) {\n    if (!hasParameters(args[args.length - 1])) {\n      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);\n    } else {\n      return function () {\n        const toArgs = Array.prototype.slice.call(arguments);\n\n        return handleDescriptor(\n          fn,\n          toArgs.length === 1 ? 'class' : 'method',\n          toArgs.concat(args)\n        );\n      };\n    }\n  };\n}\n<fim_middle>",
        "label": "Function",
        "post_steer_toptok": "Function",
        "success": true,
        "generated": "(...args: any[]) => any",
        "id": 830
    },
    {
        "prompt": "<fim_prefix>interface ParsedDate {\n\tyear: number,\n\tmonth: number,\n\tday: number,\n\thour: number,\n\tminute: number,\n\tsecond: number,\n\tmillisecond: number,\n}\n\nfunction parseDate(timezone, date) {\n\tlet year = 0;\n\tlet month = 0;\n\tlet day = 1;\n\tlet hour = 0;\n\tlet minute = 0;\n\tlet second = 0;\n\tlet millisecond = 0;\n\n\ttimezone.formatToParts(date).forEach((x) => {\n\t\tswitch (x.type) {\n            case \"year\":\n                year = +x.value;\n                break;\n            case \"month\":\n                month = (+x.value) - 1;\n                break;\n            case \"day\":\n                day = +x.value;\n                break;\n            case \"hour\":\n                hour = +x.value;\n                break;\n            case \"minute\":\n                minute = +x.value;\n                break;\n            case \"second\":\n                second = +x.value;\n                break;\n            case \"fractionalSecond\" as any:\n                millisecond = +x.value;\n                break;\n\t\t}\n\t});\n\n\tif (hour === 24) {\n\t\thour = 0;\n\t}\n\n\treturn { year, month, day, hour, minute, second, millisecond };\n}\n\n\nfunction toUTCDate(timezone, date) {\n\tconst { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);\n\treturn Date.UTC(year, month, day, hour, minute, second, millisecond);\n}\n\n\nexport class Timezone {\n\tprivate _utc: Intl.DateTimeFormat;\n\tprivate _dtf: Intl.DateTimeFormat;\n\n\tpublic readonly name: string | undefined;\n\n    /**\n     * Use this method to create an instance of this class.\n     *\n     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info\n     * @param   timezone  IANA timezone\n     * @return            Instantiated object\n     */\n\tstatic new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {\n\t\treturn (new this(timezone, true)) as T;\n\t}\n\n\tconstructor(timezone, isReal) {\n\t\tif (!isReal) {\n\t\t\tthrow new Error(\"You cannot use `new Class()`, instead use `Class.new()`\");\n\t\t}\n\n\t\tthis.name = timezone;\n\n\t\tthis._utc = new Intl.DateTimeFormat(\"UTC\", {\n\t\t\thour12: false,\n\t\t\ttimeZone: \"UTC\",\n\t\t\tyear: \"numeric\",\n\t\t\tmonth: \"2-digit\",\n\t\t\tday: \"2-digit\",\n\t\t\thour: \"2-digit\",\n\t\t\tminute: \"2-digit\",\n\t\t\tsecond: \"2-digit\",\n\t\t\tfractionalSecondDigits: 3,\n\t\t} as any);\n\n\t\tthis._dtf = new Intl.DateTimeFormat(\"UTC\", {\n\t\t\thour12: false,\n\t\t\ttimeZone: timezone,\n\t\t\tyear: \"numeric\",\n\t\t\tmonth: \"2-digit\",\n\t\t\tday: \"2-digit\",\n\t\t\thour: \"2-digit\",\n\t\t\tminute: \"2-digit\",\n\t\t\tsecond: \"2-digit\",\n\t\t\tfractionalSecondDigits: 3,\n\t\t} as any);\n\t}\n\n\tconvertLocal(date) {\n\t\tconst offset = this.offsetUTC(date);\n\t\tconst userOffset = date.getTimezoneOffset();\n\t\tconst output = new Date(date);\n\t\toutput.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));\n\t\treturn output;\n\t}\n\n\toffsetUTC(date) {\n\t\tconst utc = toUTCDate(this._utc, date);\n\t\tconst dtf = toUTCDate(this._dtf, date);\n\t\treturn (utc - dtf) / 60000;\n\t}\n\n    parseDate(date: <fim_suffix>) {\n        return parseDate(this._dtf, date)\n    }\n}\n<fim_middle>",
        "label": "Date",
        "post_steer_toptok": "string",
        "success": false,
        "generated": "string) {\n        return parseDate(this._utc, date)\n    }",
        "id": 690
    },
    {
        "prompt": "<fim_prefix>export type Constructor<T = any> = { new (...args): T };\nexport type ServiceRegistry = WeakMap<Constructor, any[]>;\n\nexport class Container {\n  private registry: ServiceRegistry;\n  private instances: WeakMap<Constructor, any>;\n\n  constructor() {\n    this.registry = new WeakMap();\n    this.instances = new WeakMap();\n  }\n\n  /**\n   * Adds a class and its constructor arguments to the container. Each time `get()` is called,\n   * a new instance of the class will be returned.\n   * @param newClass The class to add to the container.\n   * @param args The arguments to pass to the class's constructor. Can be a primitive or\n   * another class. If a class is used, the container will create an instance of it and\n   * pass it to the constructor.\n   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.\n   */\n  add<T extends Constructor>(newClass, ...args) {\n    this.registry.set(newClass, args);\n    return this;\n  }\n\n  /**\n   * Adds a static instance of a class to the container. Instead of creating a new instance\n   * each time `get()` is called, that single instance will be returned instead.\n   * @param className The class to add to the container.\n   * @param args The arguments to pass to the class's constructor. Can be a primitive or\n   * another class. If a class is used, the container will create an instance of it and\n   * pass it to the constructor.\n   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.\n   */\n  addStatic<T extends Constructor>(className: <fim_suffix>, ...args) {\n    const instance = new className(...args);\n    this.instances.set(className, instance);\n    return this;\n  }\n\n  /**\n   * Appends arguments to a class's existing arguments array.\n   * @param className The class to modify.\n   * @param newArgs The new arguments to append to the existing arguments array.\n   */\n  appendArgs(className, ...newArgs) {\n    if (!this.has(className)) {\n      throw new ContainerError(\n        `${className.name} is not registered in container.`\n      );\n    }\n\n    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`\n    args.push(...newArgs);\n    this.registry.set(className, args);\n  }\n\n  /**\n   * Reurns an instance of a class from the container. If the class was registered using\n   * `addStatic()`, a singleton instance will be returned with each call to `get()`.\n   *\n   * If a class depends on another class added to the container, it will build an instance\n   * of it using the stored arguments and inject it as a dependency. If a class was registered\n   * using `addStatic()`, the container will inject a singleton instance of that class.\n   * @param className The class to retrieve.\n   * @returns An instance of the provided `className`.\n   */\n  get<T>(className) {\n    // Check for an existing static instance and return it.\n    const existing = this.instances.get(className) as T;\n    if (existing) {\n      return existing;\n    }\n\n    // Otherwise, build a brand new instance.\n    const args = this.registry.get(className);\n    if (!args) {\n      throw new ContainerError(\n        `${className.name} is not registered in container.`\n      );\n    }\n\n    const preparedArgs = args.map((arg) => {\n      if (typeof arg != \"function\") {\n        return arg;\n      }\n\n      // Try: is the function a constructor? If not, a TypeError will be thrown.\n      try {\n        new arg();\n      } catch (error) {\n        // In that case, return it as a callback argument.\n        return arg;\n      }\n\n      // Otherwise, try to retrieve it from the container.\n      const maybeConstructor = arg as Constructor;\n      const registered = this.get(maybeConstructor);\n      return registered;\n    });\n\n    return new className(...preparedArgs);\n  }\n\n  /**\n   * Removes a class from the container.\n   * @param className The class to remove.\n   */\n  delete(className) {\n    if (!this.has(className)) {\n      throw new ContainerError(\n        `${className.name} is not registered in container.`\n      );\n    }\n    this.registry.delete(className);\n  }\n\n  /**\n   * Removes a static instance from the container.\n   * @param className The class to remove.\n   */\n  deleteStatic(className) {\n    if (!this.hasStatic(className)) {\n      throw new ContainerError(\n        `${className.name} is not registered in container.`\n      );\n    }\n    this.instances.delete(className);\n  }\n\n  /**\n   * Checks for the presence of a class in the registry.\n   * @param className The class to look for.\n   * @returns `true` if found, `false` if not.\n   */\n  has(className) {\n    return this.registry.has(className);\n  }\n\n  /**\n   * Checks for the presence of a static instance in the container.\n   * @param className The class to look for.\n   * @returns `true` if found, `false` if not.\n   */\n  hasStatic(className) {\n    return this.instances.has(className);\n  }\n}\n\nexport class ContainerError extends Error {\n  name = \"ContainerError\";\n\n  constructor(public message) {\n    super();\n  }\n}\n<fim_middle>",
        "label": "T",
        "post_steer_toptok": "Constructor",
        "success": false,
        "generated": "Constructor, args) {\n    this.add(className, args);\n    this",
        "id": 996
    },
    {
        "prompt": "<fim_prefix>const INDEX_BIT_COUNT = 12;\nconst LENGTH_BIT_COUNT = 4;\nconst RAW_LOOK_AHEAD_SIZE = 1 << LENGTH_BIT_COUNT;\nconst MAX_OFFSET = (1 << INDEX_BIT_COUNT) + 1;\nconst TREE_ROOT = MAX_OFFSET;\nconst UNUSED = -1;\n\nenum Child {\n  Smaller = 0,\n  Larger = 1,\n}\n\ninterface DefTree {\n  parent: number;\n  children: [number, number];\n  which_child: number;\n}\n\nconst tree: DefTree[] = (() => {\n  const t = new Array<DefTree>(MAX_OFFSET + 2);\n  for (let i = 0; i < t.length; i++) {\n    t[i] = { parent: 0, children: [0, 0], which_child: 0 };\n  }\n  return t;\n})();\n\nfunction initTree() {\n  tree[0].parent = 0;\n  tree[0].children[0] = 0;\n  tree[0].children[1] = 0;\n  tree[0].which_child = 0;\n  for (let i = 1; i < tree.length; i++) {\n    tree[i].parent = UNUSED;\n    tree[i].children[0] = UNUSED;\n    tree[i].children[1] = UNUSED;\n    tree[i].which_child = UNUSED;\n  }\n}\n\nfunction copyNode(src, tgt) {\n  tree[tgt].parent = tree[src].parent;\n  tree[tgt].children[0] = tree[src].children[0];\n  tree[tgt].children[1] = tree[src].children[1];\n  tree[tgt].which_child = tree[src].which_child;\n}\n\nfunction replaceParents(node) {\n  tree[tree[node + 1].children[Child.Smaller] + 1].parent = node;\n  tree[tree[node + 1].children[Child.Larger] + 1].parent = node;\n}\n\nfunction replace_node(old_node, new_node) {\n  copyNode(old_node + 1, new_node + 1);\n\n  replaceParents(new_node);\n\n  tree[tree[old_node + 1].parent + 1].children[tree[old_node + 1].which_child] =\n    new_node;\n}\n\nfunction updateParent(node, parent, which_child) {\n  tree[node + 1].parent = parent;\n  tree[node + 1].which_child = which_child;\n}\n\nfunction findNextNode(node) {\n  let next = tree[node + 1].children[Child.Smaller];\n\n  if (tree[next + 1].children[Child.Larger] === UNUSED)\n    tree[node + 1].children[Child.Smaller] =\n      tree[next + 1].children[Child.Smaller];\n  else {\n    while (tree[next + 1].children[Child.Larger] !== UNUSED)\n      next = tree[next + 1].children[Child.Larger];\n    tree[tree[next + 1].parent + 1].children[Child.Larger] =\n      tree[next + 1].children[Child.Smaller];\n  }\n\n  return next;\n}\n\nfunction updateChild(src_tree, which_child) {\n  if (tree[src_tree + 1].children[which_child] !== UNUSED)\n    updateParent(\n      tree[src_tree + 1].children[which_child],\n      tree[src_tree + 1].parent,\n      tree[src_tree + 1].which_child\n    );\n\n  tree[tree[src_tree + 1].parent + 1].children[tree[src_tree + 1].which_child] =\n    tree[src_tree + 1].children[which_child];\n}\n\n// Adapted from:\n// https://github.com/OBattler/lbatools-c/blob/master/compress/lzmit.c\nexport function compressLZSS_LBA_type_2(data): <fim_suffix> {\n  let val = 0;\n  let src_off = 0;\n  let out_len = 1;\n  let offset_off = 0;\n  let flag_bit = 0;\n  let best_match = 1;\n  let best_node = 0;\n\n  const length = data.byteLength;\n\n  if (length <= RAW_LOOK_AHEAD_SIZE) {\n    return data;\n  }\n\n  const input = new Uint8Array(data);\n  const output = new Uint8Array(length);\n\n  initTree();\n\n  while (best_match + src_off - 1 < length) {\n    let i = best_match;\n    while (i > 0) {\n      const src_tree = src_off % MAX_OFFSET;\n\n      if (tree[src_tree + 1].parent !== UNUSED) {\n        if (\n          tree[src_tree + 1].children[Child.Smaller] !== UNUSED &&\n          tree[src_tree + 1].children[Child.Larger] !== UNUSED\n        ) {\n          const replacement = findNextNode(src_tree);\n          updateParent(\n            tree[replacement + 1].children[Child.Smaller],\n            tree[replacement + 1].parent,\n            tree[replacement + 1].which_child\n          );\n          replace_node(src_tree, replacement);\n        } else {\n          updateChild(\n            src_tree,\n            tree[src_tree + 1].children[Child.Smaller] === UNUSED\n              ? Child.Larger\n              : Child.Smaller\n          );\n        }\n      }\n\n      tree[src_tree + 1].children[Child.Larger] = UNUSED;\n      tree[src_tree + 1].children[Child.Smaller] = UNUSED;\n\n      let cur_node = tree[TREE_ROOT + 1].children[Child.Smaller];\n\n      if (cur_node < 0) {\n        best_match = 0;\n        best_node = 0;\n\n        updateParent(src_tree, TREE_ROOT, 0);\n        tree[TREE_ROOT + 1].children[Child.Smaller] = src_tree;\n      } else {\n        best_match = 2;\n\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n          let cur_string = src_off;\n          let cmp_string =\n            cur_string - ((src_tree - cur_node + MAX_OFFSET) % MAX_OFFSET);\n          const node = cur_node;\n          let j = RAW_LOOK_AHEAD_SIZE + 2;\n          cur_node = j - 1;\n\n          let diff: number;\n          do diff = input[cur_string++] - input[cmp_string++];\n          while (--j !== 0 && diff === 0);\n\n          if (j !== 0 || diff !== 0) {\n            cur_node -= j;\n            if (cur_node > best_match) {\n              best_match = cur_node;\n              best_node = node;\n            }\n\n            j = diff >= 0 ? 1 : 0;\n            cur_node = tree[node + 1].children[j];\n\n            if (cur_node < 0) {\n              updateParent(src_tree, node, j);\n              tree[node + 1].children[j] = src_tree;\n              break;\n            }\n          } else {\n            replace_node(node, src_tree);\n            tree[node + 1].parent = UNUSED;\n            best_match = RAW_LOOK_AHEAD_SIZE + 2;\n            best_node = node;\n            break;\n          }\n        }\n      }\n\n      if (--i > 0) src_off++;\n    }\n\n    if (out_len >= length - RAW_LOOK_AHEAD_SIZE - 1) {\n      return data;\n    }\n\n    val >>= 1;\n\n    if (best_match > 2 && src_off + best_match <= length) {\n      const temp =\n        (best_match - 3) |\n        ((src_off - best_node - 1 + MAX_OFFSET) % MAX_OFFSET <<\n          LENGTH_BIT_COUNT);\n      output[out_len] = temp & 0xff;\n      output[out_len + 1] = temp >> 8;\n      out_len += 2;\n    } else {\n      output[out_len++] = input[src_off];\n      val |= 0x80;\n      best_match = 1;\n    }\n\n    flag_bit++;\n    if (flag_bit >= 8) {\n      flag_bit = 0;\n      output[offset_off] = val & 0xff;\n      offset_off = out_len;\n      out_len++;\n    }\n\n    src_off++;\n  }\n\n  if (flag_bit === 0) out_len--;\n  else if (flag_bit < 8) output[offset_off] = val >> (8 - flag_bit);\n\n  return output.buffer.slice(0, out_len);\n}\n<fim_middle>",
        "label": "ArrayBuffer",
        "post_steer_toptok": "Uint",
        "success": false,
        "generated": "Uint8Array",
        "id": 3712
    },
    {
        "prompt": "<fim_prefix>type TimeCalculatorPropsType = {\n  createdAt: Date\n}\n\nconst TimeCalculator = ({ createdAt }): <fim_suffix> => {\n  const createdDate: Date = new Date(createdAt)\n  const nowDate: Date = new Date()\n\n  const months = [\n    'January',\n    'February',\n    'March',\n    'April',\n    'May',\n    'June',\n    'July',\n    'August',\n    'September',\n    'October',\n    'November',\n    'December'\n  ]\n\n  const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\n\n  const milisecond: number = nowDate.valueOf() - createdDate.valueOf()\n  const second = milisecond / 1000\n  const minute = second / 60\n  const hour = minute / 60\n  const day = hour / 24\n\n  if (second < 1) {\n    return 'now'\n  }\n\n  if (\n    Math.floor(minute) === 0 &&\n    Math.floor(hour) === 0 &&\n    Math.floor(day) === 0\n  ) {\n    return Math.round(second) === 1\n      ? `${Math.round(second)} second ago`\n      : `${Math.round(second)} seconds ago`\n  }\n\n  if (Math.floor(day) === 0 && Math.floor(hour) === 0) {\n    return Math.round(minute) === 1\n      ? `${Math.round(minute)} minute ago`\n      : `${Math.round(minute)} minutes ago`\n  }\n\n  if (Math.floor(day) === 0) {\n    return Math.round(hour) === 1\n      ? `${Math.round(hour)} hour ago`\n      : `${Math.round(hour)} hours ago`\n  }\n\n  if (Math.round(day) < 7) {\n    return Math.round(day) === 1\n      ? `${Math.round(day)} day ago`\n      : `${Math.round(day)} days ago`\n  }\n\n  const dayName = days[createdDate.getDay()]\n  const date = createdDate.getDate()\n  const monthName = months[createdDate.getMonth()]\n  const createdYear =\n    createdDate.getFullYear() === nowDate.getFullYear()\n      ? ''\n      : createdDate.getFullYear()\n  const createdTime = createdDate.toLocaleTimeString([], {\n    hour: '2-digit',\n    minute: '2-digit',\n    hour12: false\n  })\n\n  return `${createdTime} \u00b7 ${dayName}, ${date} ${monthName} ${createdYear}`\n}\n\nexport default TimeCalculator\n<fim_middle>",
        "label": "string",
        "post_steer_toptok": "Time",
        "success": false,
        "generated": "JSX.Element",
        "id": 48
    },
    {
        "prompt": "<fim_prefix>export enum LongOption {\n  NUMBER = 'number',\n  LONG = 'long',\n  STRING = 'string',\n}\n\nexport enum DateOption {\n  DATE = 'date',\n  STRING = 'string',\n  TIMESTAMP = 'timestamp',\n}\n\nexport enum EnvOption {\n  NODE = 'node',\n  BROWSER = 'browser',\n  BOTH = 'both',\n}\n\nexport enum OneofOption {\n  PROPERTIES = 'properties',\n  UNIONS = 'unions',\n}\n\nexport enum ServiceOption {\n  GRPC = 'grpc-js',\n  GENERIC = 'generic-definitions',\n  DEFAULT = 'default',\n  NONE = 'none',\n}\n\nexport type Options = {\n  context: boolean;\n  snakeToCamel: Array<'json' | 'keys'>;\n  forceLong: LongOption;\n  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated\n  useDate: DateOption;\n  oneof: OneofOption;\n  esModuleInterop: boolean;\n  fileSuffix: string;\n  outputEncodeMethods: boolean;\n  outputJsonMethods: boolean;\n  outputPartialMethods: boolean;\n  outputTypeRegistry: boolean;\n  stringEnums: boolean;\n  constEnums: boolean;\n  enumsAsLiterals: boolean;\n  outputClientImpl: boolean | 'grpc-web';\n  outputServices: ServiceOption;\n  addGrpcMetadata: boolean;\n  addNestjsRestParameter: boolean;\n  returnObservable: boolean;\n  lowerCaseServiceMethods: boolean;\n  nestJs: boolean;\n  env: EnvOption;\n  unrecognizedEnum: boolean;\n  exportCommonSymbols: boolean;\n  outputSchema: boolean;\n  // An alias of !output\n  onlyTypes: boolean;\n  emitImportedFiles: boolean;\n  useExactTypes: boolean;\n  delimitedMethods: boolean;\n};\n\nexport function defaultOptions() {\n  return {\n    context: false,\n    snakeToCamel: ['json', 'keys'],\n    forceLong: LongOption.NUMBER,\n    useOptionals: 'none',\n    useDate: DateOption.DATE,\n    oneof: OneofOption.PROPERTIES,\n    esModuleInterop: false,\n    fileSuffix: '',\n    lowerCaseServiceMethods: false,\n    outputEncodeMethods: true,\n    outputJsonMethods: true,\n    outputPartialMethods: true,\n    outputTypeRegistry: false,\n    stringEnums: false,\n    constEnums: false,\n    enumsAsLiterals: false,\n    outputClientImpl: true,\n    outputServices: ServiceOption.DEFAULT,\n    returnObservable: false,\n    addGrpcMetadata: false,\n    addNestjsRestParameter: false,\n    nestJs: false,\n    env: EnvOption.BOTH,\n    unrecognizedEnum: true,\n    exportCommonSymbols: true,\n    outputSchema: false,\n    onlyTypes: false,\n    emitImportedFiles: true,\n    useExactTypes: true,\n    delimitedMethods: false,\n  };\n}\n\nconst nestJsOptions: Partial<Options> = {\n  lowerCaseServiceMethods: true,\n  outputEncodeMethods: false,\n  outputJsonMethods: false,\n  outputPartialMethods: false,\n  outputClientImpl: false,\n  useDate: DateOption.TIMESTAMP,\n};\n\nexport function optionsFromParameter(parameter) {\n  const options = defaultOptions();\n  if (parameter) {\n    const parsed = parseParameter(parameter);\n    if (parsed.nestJs) {\n      Object.assign(options, nestJsOptions);\n    }\n    Object.assign(options, parsed);\n  }\n  // We should promote onlyTypes to its own documented flag, but just an alias for now\n  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {\n    options.onlyTypes = true;\n  }\n\n  // Treat forceLong=true as LONG\n  if ((options.forceLong as any) === true) {\n    options.forceLong = LongOption.LONG;\n  }\n\n  // Treat outputServices=false as NONE\n  if ((options.outputServices as any) === false) {\n    options.outputServices = ServiceOption.NONE;\n  }\n\n  if ((options.useDate as any) === true) {\n    // Treat useDate=true as DATE\n    options.useDate = DateOption.DATE;\n  } else if ((options.useDate as any) === false) {\n    // Treat useDate=false as TIMESTAMP\n    options.useDate = DateOption.TIMESTAMP;\n  }\n\n  if ((options.snakeToCamel as any) === false) {\n    options.snakeToCamel = [];\n  } else if ((options.snakeToCamel as any) === true) {\n    options.snakeToCamel = ['keys', 'json'];\n  }\n\n  return options;\n}\n\n// A very naive parse function, eventually could/should use iots/runtypes\nfunction parseParameter(parameter): <fim_suffix> {\n  const options = {} as any;\n  const pairs = parameter.split(',').map((s) => s.split('='));\n  pairs.forEach(([key, value]) => {\n    options[key] = value === 'true' ? true : value === 'false' ? false : value;\n  });\n  return options;\n}\n\nexport function getTsPoetOpts(options) {\n  if (options.esModuleInterop) {\n    return { forceDefaultImport: ['protobufjs/minimal'] };\n  } else {\n    return {};\n  }\n}\n<fim_middle>",
        "label": "Options",
        "post_steer_toptok": "Options",
        "success": true,
        "generated": "any",
        "id": 3849
    },
    {
        "prompt": "<fim_prefix>/*\n * @Author: your name\n * @Date: 2022-04-24 10:11:23\n * @LastEditTime: 2022-04-24 16:14:52\n * @LastEditors: Please set LastEditors\n * @Description: \u6253\u5f00koroFileHeader\u67e5\u770b\u914d\u7f6e \u8fdb\u884c\u8bbe\u7f6e: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE\n * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts\n */\n//  props \u5929\nexport interface dayProps {\n    year: number;\n    month: number;\n    active: number;\n    change: Function;\n    visible: boolean;\n    monthRef: any;\n    show: boolean;\n    limit: boolean;\n}\n//  props \u6708\nexport interface monthProps {\n    visible: boolean;\n    active: number;\n    change: Function;\n    year: number;\n    plateChange: Function;\n    limit: boolean;\n}\n//  props \u5e74\nexport interface yearProps {\n    visible: boolean;\n    active: number;\n    change: Function;\n    plateChange: Function;\n    limit: boolean;\n}\n\n// pageday-item type\nexport type dayItem = {\n    label: string;\n    value: number;\n    disabled: boolean; //\u7981\u7528\n    prev: boolean; // \u662f\u5426\u5c5e\u4e8e\u4e0a\u4e00\u6708\u4efd\n    next: boolean; // \u662f\u5426\u5c5e\u4e8e\u4e0a\u4e00\u6708\u4efd\n    week: number; // \u661f\u671f\u4e0b\u6807\n    weekLabel: string; // \u661f\u671f\u660e\u6587\n};\n\n// pageMonth-item type\nexport type monthItem = {\n    value: number;\n    label: string;\n    disabled: boolean;\n};\n\n// \u5e74\u4efd\nexport function getYearList(year, limit) {\n    let list: Array<monthItem> = [];\n\n    let newYear = new Date().getFullYear();\n    let maxYear = year + 9;\n    for (let i = year - 3; i < maxYear; i++) {\n        list.push({\n            value: i,\n            label: `${i}`,\n            disabled: i < newYear && limit,\n        });\n    }\n    return list;\n}\n\n// \u6708\u4efd\nexport function getMonthList(year, limit) {\n    let list: Array<monthItem> = [];\n    for (let i = 1; i < 13; i++) {\n        list.push({\n            value: i,\n            label: `${i}\u6708`,\n            disabled: checkDisabledMonth(year, i) && limit,\n        });\n    }\n    return list;\n}\n// \u6708-\u7981\u7528\u5224\u5b9a\nfunction checkDisabledMonth(prevYear, prevMonth) {\n    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();\n    const newDate = new Date();\n    const year: number = newDate.getFullYear();\n    let month: number = newDate.getMonth() + 1;\n    const newTime = new Date(`${year}/${month}/01`).getTime();\n    return prevTime < newTime;\n}\n\n// \u65e5\u671f\u5bf9\u7167\u6708\u4efd\u8868\nconst monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //\u6708\u4efd\n\n// \u661f\u671f\u5217\u8868\nexport const weekList = [\"\u4e00\", \"\u4e8c\", \"\u4e09\", \"\u56db\", \"\u4e94\", \"\u516d\", \"\u65e5\"];\n\n// \u65e5-\u6570\u636e\u5217\u8868\u751f\u6210type:0\u5f53\u524d\u6708\u4efd\uff0c1\u4e0a\u4e00\u6708\uff0c2\u4e0b\u4e00\u6708\nexport function getDayList(\n    year,\n    month,\n    type: <fim_suffix>,\n    limit\n) {\n    let list: Array<dayItem> = [];\n    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // \u95f0\u5e74\u5224\u5b9a\n    max = monthAsDay[month - 1] + max; // \u5b9a\u4f4d\u6708\u4efd\n\n    for (let i = 0; i < max; i++) {\n        let value = i + 1;\n        let weekParam = checkWeek(year, month, value);\n        list.push({\n            label: value.toString(),\n            value: value,\n            disabled: checkDisabled(year, month, value) && limit,\n            prev: type === 1,\n            next: type === 2,\n            week: weekParam.value,\n            weekLabel: weekParam.label,\n        });\n    }\n    if (type !== 0) {\n        return list;\n    } else {\n        return dayListSupply(list, year, month, limit);\n    }\n}\n// \u65e5-\u6570\u636e\u6309\u5468\u8865\u5145\nfunction dayListSupply(\n    arr,\n    year,\n    month,\n    limit\n) {\n    let prevList = getDayList(\n        month === 1 ? year - 1 : year,\n        month === 1 ? 12 : month - 1,\n        1,\n        limit\n    );\n    let nextList = getDayList(\n        month === 12 ? year + 1 : year,\n        month === 12 ? 1 : month + 1,\n        2,\n        limit\n    );\n    // \u4e0a\u6708\n    for (let i = prevList.length - 1; i > 0; i--) {\n        if (prevList[i].week === 7) {\n            break;\n        }\n        arr.unshift(prevList[i]);\n    }\n    // \u4e0b\u6708\n    for (let i = 0; i < nextList.length - 1; i++) {\n        if (arr.length === 42) {\n            break;\n        }\n        arr.push(nextList[i]);\n    }\n    return arr;\n}\n\n// \u65e5-\u7981\u7528\u5224\u5b9a\nexport function checkDisabled(\n    prevYear,\n    prevMonth,\n    prevDay\n) {\n    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();\n    const newDate = new Date();\n    const year: number = newDate.getFullYear();\n    let month: number = newDate.getMonth() + 1;\n    let day: number = newDate.getDate();\n    const newTime = new Date(`${year}/${month}/${day}`).getTime();\n    return prevTime < newTime;\n}\n\n// \u5468\u671f-\u5224\u5b9a\u661f\u671f\u51e0\nfunction checkWeek(year, month, day) {\n    let weekday = [\n        \"\u661f\u671f\u65e5\",\n        \"\u661f\u671f\u4e00\",\n        \"\u661f\u671f\u4e8c\",\n        \"\u661f\u671f\u4e09\",\n        \"\u661f\u671f\u56db\",\n        \"\u661f\u671f\u4e94\",\n        \"\u661f\u671f\u516d\",\n    ];\n    let newDate = new Date(`${year}/${month}/${day}`);\n    let mark = newDate.getDay();\n\n    return {\n        value: mark === 0 ? 7 : mark,\n        label: weekday[mark],\n    };\n}\n<fim_middle>",
        "label": "number",
        "post_steer_toptok": "0",
        "success": false,
        "generated": "0 | 1 | 2,\n    limit\n) {\n    let list",
        "id": 11
    },
    {
        "prompt": "<fim_prefix>export interface ElementUltraResolverOptions {\n  /**\n   * use commonjs lib & source css or scss for ssr\n   */\n  ssr?: boolean\n\n  /**\n   * auto import for directives\n   *\n   * @default true\n   */\n  directives?: boolean\n\n  /**\n   * exclude component name, if match do not resolve the name\n   */\n  exclude?: RegExp\n}\n\ntype ElementUltraResolverOptionsResolved = Required<\n  Omit<ElementUltraResolverOptions, 'exclude'>\n> &\n  Pick<ElementUltraResolverOptions, 'exclude'>\n\nfunction getSideEffects(dirName): <fim_suffix> {\n  const esComponentsFolder = '@element-ultra/components'\n  return `${esComponentsFolder}/${dirName}/style/index`\n}\n\nfunction kebabCase(key) {\n  const result = key.replace(/([A-Z])/g, ' $1').trim()\n  return result.split(' ').join('-').toLowerCase()\n}\n\nfunction resolveComponent(name) {\n  if (!name.match(/^El[A-Z]/)) return\n\n  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column\n\n  return {\n    importName: name,\n    path: `element-ultra`,\n    sideEffects: getSideEffects(partialName),\n  }\n}\n\nfunction resolveDirective(\n  name,\n  options\n) {\n  if (!options.directives) return\n\n  const directives: Record<string, { importName: string; styleName: string }> =\n    {\n      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },\n      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },\n      InfiniteScroll: {\n        importName: 'ElInfiniteScroll',\n        styleName: 'infinite-scroll',\n      },\n    }\n\n  const directive = directives[name]\n  if (!directive) return\n\n  return {\n    importName: directive.importName,\n    path: `element-ultra`,\n    sideEffects: getSideEffects(directive.styleName),\n  }\n}\n\nexport function ElementUltraResolver(\n  options = {}\n) {\n  let optionsResolved: ElementUltraResolverOptionsResolved\n\n  async function resolveOptions() {\n    if (optionsResolved) return optionsResolved\n    optionsResolved = {\n      ssr: false,\n      directives: true,\n      exclude: undefined,\n      ...options,\n    }\n    return optionsResolved\n  }\n\n  return [\n    {\n      type: 'component',\n      resolve: async (name) => {\n        return resolveComponent(name)\n      },\n    },\n    {\n      type: 'directive',\n      resolve: async (name) => {\n        return resolveDirective(name, await resolveOptions())\n      },\n    },\n  ]\n}\n<fim_middle>",
        "label": "any",
        "post_steer_toptok": "string",
        "success": false,
        "generated": "string[] {\n  const esComponentsFolder = '@element-ultra/components",
        "id": 32
    },
    {
        "prompt": "<fim_prefix>// \u2714\ufe0f Define types (or interfaces, os structs... or even classes)\ntype Currency = 'EUR' | 'USD';\n\ntype Money = { amount: number; currency: Currency };\n\ntype SavingsCondition = { principal: Money; rate: number; years: number };\n\nexport function calculateInterest() {\n  // \u2714\ufe0f object literal\n  const mySavingsConditionsLit: SavingsCondition = {\n    principal: { amount: 1000, currency: 'EUR' },\n    rate: 3.5,\n    years: 1,\n  };\n  // \u2714\ufe0f object factory\n  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);\n\n  // \u2714\ufe0f single parameter\n  const interest = getSimpleInterest(mySavingsConditions);\n  return interest;\n}\n\nfunction moneyFactory(amount, currency: <fim_suffix> = 'EUR') {\n  // \u2714\ufe0f parameter validation, and default value\n  assertAmountPositive(amount);\n  return {\n    amount,\n    currency,\n  };\n}\n\nfunction conditionsFactory(\n  amount,\n  rate,\n  years = 1,\n  currency = 'EUR'\n) {\n  // \u2714\ufe0f parameter validation\n  assertAmountPositive(amount);\n  assertRateRange(rate);\n  assertYearsRange(years);\n\n  const conditions: SavingsCondition = {\n    principal: moneyFactory(amount, currency),\n    rate: rate,\n    years: years,\n  };\n  return conditions;\n}\n\nfunction assertYearsRange(years) {\n  const MIN_YEARS = 0;\n  const MAX_YEARS = 100;\n  if (years < MIN_YEARS || years > MAX_YEARS)\n    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);\n}\n\nfunction assertRateRange(rate) {\n  const MIN_RATE = 1;\n  const MAX_RATE = 10;\n  if (rate < MIN_RATE || rate > MAX_RATE)\n    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);\n}\n\nfunction assertAmountPositive(amount) {\n  if (amount < 0) throw new Error(`Amount must be positive`);\n}\n\nfunction getSimpleInterest(conditions) {\n  const PER_CENT = 100;\n  const interestAmount =\n    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;\n  return moneyFactory(interestAmount, conditions.principal.currency);\n}\n<fim_middle>",
        "label": "Currency",
        "post_steer_toptok": "'",
        "success": false,
        "generated": "'EUR') {\n  // \u2714\ufe0f parameter validation, and default value\n  assert",
        "id": 2975
    },
    {
        "prompt": "<fim_prefix>export type Type = string | number | symbol;\n\nexport type Constructor<T> = new (...args) => T;\n\nexport type Factory<T> = (...args) => T;\n\nexport enum BindingType {\n    value = 'value',\n    constructor = 'constructor',\n    factory = 'factory',\n}\n\nexport type ConstructorBinding<T> = {\n    type: BindingType.constructor | `${BindingType.constructor}`;\n    value: Constructor<T>;\n    singleton?: boolean;\n};\n\nexport type FactoryBinding<T> = {\n    type: BindingType.factory | `${BindingType.factory}`;\n    value: Factory<T>;\n    singleton?: boolean;\n};\n\nexport type ValueBinding<T> = {\n    type?: BindingType.value | `${BindingType.value}`;\n    value: T;\n};\n\nexport type InjectionBinding<T> =\n    | ConstructorBinding<T>\n    | FactoryBinding<T>\n    | ValueBinding<T>;\n\nexport type InjectionType<T> = T extends ConstructorBinding<infer U>\n    ? U\n    : T extends FactoryBinding<infer U>\n    ? U\n    : T extends ValueBinding<infer U>\n    ? U\n    : never;\n\nexport type InjectionParams<T extends InjectionBinding<any>> =\n    T extends ConstructorBinding<any>\n        ? ConstructorParameters<T['value']>\n        : T extends FactoryBinding<any>\n        ? Parameters<T['value']>\n        : T extends ValueBinding<any>\n        ? never\n        : never;\n\nexport type InjectionValue<T extends InjectionBinding<any>> = T['value'];\n\nexport interface DefaultBindings {\n    [index: string]: InjectionBinding<any>;\n}\n\n/**\n * An Inversion of Control Container.\n *\n * Values, constructors, and factories can be bound to a Type.\n *\n * Then, given a Type, they can be retrieved later.\n */\nexport class Container<\n    T extends {\n        [index: string]: InjectionBinding<any>;\n    } = {\n        [index: string]: InjectionBinding<any>;\n    },\n> {\n    bindings: T = {} as any;\n    protected instances: Record<keyof T, any> = {} as any;\n\n    constructor(bindings = {} as any) {\n        this.bindings = bindings;\n    }\n\n    /**\n     * Binds a value to a Type\n     * @param type - a Type to bind\n     * @param value - a value to bind\n     */\n    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(\n        type,\n        value,\n    ) {\n        this.bindings[type] = {\n            type: BindingType.value,\n            value,\n        } as any;\n    }\n\n    /**\n     * Binds a constructor to a Type\n     * @param type - a Type to bind\n     * @param constructor - a constructor to bind\n     */\n    bindConstructor<\n        TKey extends keyof T,\n        TConstructor extends Constructor<InjectionType<T[TKey]>>,\n    >(type, constructor, singleton?) {\n        this.bindings[type] = {\n            type: BindingType.constructor,\n            value: constructor,\n            singleton,\n        } as any;\n    }\n\n    /**\n     * Binds a factory to a Type\n     * @param type - a Type to bind\n     * @param factory - a factory to bind\n     */\n    bindFactory<\n        TKey extends keyof T,\n        TFactory extends Factory<InjectionType<T[TKey]>>,\n    >(type: <fim_suffix>, factory, singleton?) {\n        this.bindings[type] = {\n            type: BindingType.factory,\n            value: factory,\n            singleton,\n        } as any;\n    }\n\n    /**\n     * Gets a value for a given Type.\n     *\n     * If the value is a value, it is returned.\n     * If the value is a constructor, a new object is created.\n     * If the value is a factory, the factory is run.\n     *\n     * Args are passed to constructors and factories.\n     *\n     * This can be used as a default parameter value for other functions.\n     *\n     * @param type - a bound Type\n     * @param args - zero or more args to pass if the bound value is a function or constructor\n     */\n    get<TKey extends keyof T>(\n        type,\n        ...args\n    ) {\n        let binding = this.bindings[type];\n        if (!binding) {\n            throw `No binding associated with: ${type.toString()}`;\n        }\n        const value: InjectionValue<T[TKey]> = binding.value;\n        switch (binding.type) {\n            case BindingType.constructor:\n            case 'constructor':\n                if (binding.singleton) {\n                    const instance = this.instances[type];\n                    if (instance) {\n                        return instance;\n                    } else {\n                        // @ts-ignore TODO: Fix this\n                        const instance = new value(...args);\n                        this.instances[type] = instance;\n                        return instance;\n                    }\n                } else {\n                    // @ts-ignore TODO: Fix this\n                    return new value(...args);\n                }\n            case BindingType.factory:\n            case 'factory':\n                if (binding.singleton) {\n                    const instance = this.instances[type];\n                    if (instance) {\n                        return instance;\n                    } else {\n                        // @ts-ignore TODO: Fix this\n                        const instance = value(...args);\n                        this.instances[type] = instance;\n                        return instance;\n                    }\n                } else {\n                    // @ts-ignore TODO: Fix this\n                    return value(...args);\n                }\n            case BindingType.value:\n            case 'value':\n            default:\n                return binding.value;\n        }\n    }\n\n    private static default: Container<DefaultBindings> | undefined;\n\n    /**\n     * Gets the default Container\n     */\n    static getDefault() {\n        let container = this.default;\n        if (!container) {\n            container = new Container();\n            this.default = container;\n        }\n        return container;\n    }\n\n    /**\n     * Sets the default Container\n     * @param container - a Container object\n     */\n    static setDefault<TContainer extends Container<DefaultBindings>>(\n        container,\n    ) {\n        Container.default = container;\n    }\n}\n\n/**\n * Gets a value fron a specified Container by Type\n *\n * This can be used as a default parameter value for other functions.\n *\n * @param type - a bound Type\n * @param container - a Container to use\n * @param args - zero or more args to pass if the bound value is a function or constructor\n */\nexport function inject<\n    TContainer extends Container,\n    TKey extends keyof TContainer['bindings'],\n>(\n    container,\n    type,\n    ...args\n);\n\n/**\n * Gets a value fron the default Container by Type\n *\n * This can be used as a default parameter value for other functions.\n *\n * @param type - a bound Type\n * @param [args] - zero or more args to pass if the bound value is a function or constructor\n */\nexport function inject<TKey extends keyof DefaultBindings>(\n    type,\n    ...args\n);\n\nexport function inject<T>(a, b, ...args) {\n    if (a instanceof Container) {\n        // @ts-ignore TODO: Fix this\n        return a.get(b, ...args);\n    } else {\n        const container = Container.getDefault();\n        return container.get(a, ...[b, ...args]);\n    }\n}\n<fim_middle>",
        "label": "TKey",
        "post_steer_toptok": "type",
        "success": false,
        "generated": "type",
        "id": 1718
    },
    {
        "prompt": "<fim_prefix>type Id = string | number;\ntype Owner = { Id: string }\n\nexport enum NFTAction {\n  SEND='SEND',\n  CONSUME='CONSUME',\n  FREEZE='FREEZE',\n  DELEGATE='DELEGATE',\n  THAW='THAW',\n  REVOKE='REVOKE',\n  NONE='',\n}\n\nexport const actionResolver: Record<NFTAction, [string, string]> = {\n  SEND: ['uniques','transfer'],\n  CONSUME: ['uniques','burn'],\n  DELEGATE: ['uniques','approveTransfer'],\n  FREEZE: ['uniques','freeze'],\n  THAW: ['uniques','thaw'],\n  REVOKE: ['uniques','cancelApproval'],\n  '': ['',''],\n}\n\nexport const basicUpdateFunction = (name, index) => `${name} #${index + 1}`\n\nclass NFTUtils {\n  static createCollection(id, admin) {\n    return [String(id), { Id: admin }]\n  }\n\n\n  static createNFT(classId: <fim_suffix>, id, owner) {\n    return [String(classId), String(id), { Id: owner }]\n  }\n\n  static getActionParams(selectedAction, classId, id, meta) {\n    switch (selectedAction) {\n    case NFTAction.SEND:\n    case NFTAction.CONSUME:\n    case NFTAction.DELEGATE:\n    case NFTAction.REVOKE:\n      return [classId, id, meta]\n    case NFTAction.FREEZE:\n    case NFTAction.THAW:\n      return [classId, id]\n    default:\n      throw new Error('Action not found')\n    }\n  }\n\n  static apiCall(selectedAction) {\n    return actionResolver[selectedAction] || new Error('Action not found')\n\n  }\n\n  static correctMeta(selectedAction, meta, currentOwner, delegate) {\n    switch (selectedAction) {\n    case NFTAction.SEND:\n    case NFTAction.DELEGATE:\n      return meta\n    case NFTAction.CONSUME:\n      return currentOwner\n    case NFTAction.REVOKE:\n      return delegate\n    case NFTAction.FREEZE:\n    case NFTAction.THAW:\n      return ''\n    default:\n      throw new Error('Action not found')\n    }\n  }\n}\n\n\n\nexport default NFTUtils\n<fim_middle>",
        "label": "Id",
        "post_steer_toptok": "string",
        "success": false,
        "generated": "string",
        "id": 2630
    },
    {
        "prompt": "<fim_prefix>/* eslint-disable max-len */\n// Send, Receive, Deposit, Withdrawal, Income\nexport interface Transaction {\n    id: string;\n    timestamp: Date;\n    type: string;\n    baseCurrency: string;\n    baseQuantity: number;\n    baseUsdPrice: number;\n    feeCurrency: string;\n    feeQuantity: number;\n    feeUsdPrice: number;\n    feeTotal: number;\n    subTotal: number;\n    total: number;\n}\n\n// Buy, Sell, Swap\nexport interface Order {\n    id: string;\n    timestamp: Date;\n    type: string;\n    baseCurrency: string;\n    baseQuantity: number;\n    baseUsdPrice: number;\n    quoteCurrency: string;\n    quoteQuantity: number;\n    quotePrice: number;\n    quoteUsdPrice: number;\n    feeCurrency: string;\n    feeQuantity: number;\n    feeUsdPrice: number;\n    feeTotal: number;\n    subTotal: number;\n    total: number;\n}\n\n/**\n * A base class to support general connection operations\n */\nexport default class BaseConnection {\n    name: string;\n    type: string;\n    connection: any;\n    credentials?: any;\n    balances: any;\n    symbols: Array<any>;\n    initialized: boolean;\n    requireSymbols: boolean;\n    requireUsdValuation: boolean;\n    stableCoins: Array<string> = [\"USDC\", \"USDT\"];\n    fiatCurrencies: Array<string> = [\"USD\"];\n    stableCurrencies: Array<string> = [\"USD\", \"USDC\", \"USDT\"];\n\n    /**\n     * Create BaseConnection instance\n     * @param {string} name - Name of connection (Ex: coinbase)\n     * @param {string} type - Type of connection (Ex: api)\n     * @param {any} params - (Optional) Additional paramaters\n     */\n    constructor(name, type, params = {}) {\n        this.name = name;\n        this.type = type;\n        this.connection = null;\n        this.initialized = false;\n        this.symbols = [];\n        this.requireSymbols = params.requireSymbols\n            ? params.requireSymbols\n            : false;\n        this.requireUsdValuation = params.requireUsdValuation\n            ? params.requireUsdValuation\n            : true;\n    }\n\n    /**\n     * JSON object representing connection\n     * @return {any}\n     */\n    toJSON() {\n        const baseJSON = {\n            name: this.name,\n            type: this.type,\n            params: {},\n        };\n        if (this.credentials) {\n            const updatedParams: any = baseJSON.params;\n            updatedParams.credentials = this.credentials;\n            baseJSON.params = updatedParams;\n        }\n        return baseJSON;\n    }\n\n    /**\n     * HELPER: Convert buy/sell to swap if no fiat is involved in order\n     *\n     * @param {any} order - Order instance\n     * @return {Order} Reformatted Order\n     */\n    _attemptedSwapConversion(order) {\n        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {\n            if (order.type === \"sell\") {\n                const tempBC = order.baseCurrency;\n                const tempBQ = order.baseQuantity;\n                const tempBP = order.baseUsdPrice;\n                order.baseCurrency = order.quoteCurrency;\n                order.baseQuantity = order.quoteQuantity;\n                order.baseUsdPrice = order.quoteUsdPrice;\n                order.quoteCurrency = tempBC;\n                order.quoteQuantity = tempBQ;\n                order.quoteUsdPrice = tempBP;\n                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;\n            }\n            order.type = \"swap\";\n        }\n        return order;\n    }\n\n    /**\n     * Initialize exchange by fetching balances and loading markets\n     * @return {void}\n     */\n    initialize() {\n        throw Error(\n            `NotImplementedError: ${this.name}.initialize() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch Account Balances\n     * @return {void}\n     */\n    getBalances() {\n        throw Error(\n            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch Account Withdrawals\n     * @return {void}\n     */\n    getWithdrawals() {\n        throw Error(\n            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch Account Deposits\n     * @return {void}\n     */\n    getDeposits() {\n        throw Error(\n            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch Account Orders\n     * @return {void}\n     */\n    getOrders() {\n        throw Error(\n            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch all account ledger (withdrawals, deposits, and orders)\n     * @return {void}\n     */\n    getLedger() {\n        throw Error(\n            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch account transactions (withdrawals, deposits, and orders)\n     * @return {void}\n     */\n    getTransactions() {\n        throw Error(\n            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch all account transactions (withdrawals, deposits, and orders)\n     * @return {void}\n     */\n    getAllTransactions() {\n        throw Error(\n            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`\n        );\n    }\n\n    /**\n     * Fetch all account transactions (withdrawals, deposits, and orders)\n     * @return {void}\n     */\n    getTxUsdVal(): <fim_suffix> {\n        throw Error(\n            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`\n        );\n    }\n}\n<fim_middle>",
        "label": "void",
        "post_steer_toptok": "Promise",
        "success": false,
        "generated": "Promise<any>",
        "id": 59
    },
    {
        "prompt": "<fim_prefix>type Vertex = string;\ntype Weight = number;\ntype Graph = Record<string, Record<string, Weight>>;\n\n/**\n * If a target is not provided, finds the single-source shortest path distance from the source vertex with positive or negative edge weights\n * (but with no negative weight cycles).\n * Else, it returns the shortest path as well as its distance from source vertex to target vertex.\n * In the case of negative weight cycles, if target is defined, then negative infinity and empty array path will be returned,\n * else, all distances from A will be returned with negative infinity.\n *\n * @param {Graph} graph Vertex with its fields being the neighboring vertices and value being the weight from vertex to neighboring vertices\n * @param {Vertex} source Starting vertex in graph\n * @param {Vertex} target Ending vertex in graph\n * @return {Record<string, number> | [number, Array<Vertex>]} An object mapping of the distance from the source vertex or an array containing the distance\n * and an array containing the path from source to target vertex\n */\nfunction bellmanFord(\n  graph,\n  source,\n  target?,\n) {\n  const vertices = Object.keys(graph);\n  // if graph is empty, immediately return\n  if (vertices.length === 0) {\n    return target ? [0, []] : {};\n  }\n\n  if (!vertices.includes(source) || (target && !vertices.includes(target))) {\n    return target ? [-Infinity, []] : {};\n  }\n\n  const distances = getDistances(vertices, source);\n  const predecessor = getPredecessor(vertices);\n\n  // requires only n - 1 iteration\n  for (let i = 0; i < vertices.length - 1; i++) {\n    for (let startVertex of vertices) {\n      const neighbors = graph[startVertex];\n      for (let endVertex in neighbors) {\n        const weight = graph[startVertex][endVertex];\n        // relaxation\n        if (distances[startVertex] + weight < distances[endVertex]) {\n          distances[endVertex] = distances[startVertex] + weight;\n          predecessor[endVertex] = startVertex;\n        }\n      }\n    }\n  }\n\n  // checks for any negative weight cycles. If true returns all distances as -Infinity as a sign negative weight cycles\n  for (let startVertex of vertices) {\n    const neighbors = graph[startVertex];\n    for (let endVertex in neighbors) {\n      const weight = graph[startVertex][endVertex];\n      // if relaxation occurs here, negative weight cycles detected\n      if (distances[startVertex] + weight < distances[endVertex]) {\n        return target ? [-Infinity, []] : negativeWeightCycles(vertices);\n      }\n    }\n  }\n\n  if (!target) {\n    return distances;\n  }\n\n  const shortestDistance = distances[target];\n  const path = getPath(predecessor, source, target);\n  return [shortestDistance, path];\n}\n\n/**\n * Returns an Object mapping of nodes to distance with values all being negative infinity to represent a negative weight cycle being present.\n *\n * @param {Array<Vertex>} vertices An array of all vertices in the graph\n * @return {Record<string, number>} An object mapping of nodes with values being negative infinity\n */\nfunction negativeWeightCycles(vertices) {\n  return vertices.reduce((acc, curr) => {\n    acc[curr] = -Infinity;\n    return acc;\n  }, {} as Record<string, number>);\n}\n\n/**\n * Initializes the distance mapping from source to rest of the vertices.\n *\n * @param {Array<Vertex>} vertices An array of all vertices in the graph\n * @param {Vertex} source Starting vertex in graph\n * @return {Record<string, number>} An object mapping of source to rest of vertices\n */\nfunction getDistances(\n  vertices,\n  source: <fim_suffix>,\n) {\n  const distances = vertices.reduce((acc, curr) => {\n    acc[curr] = Infinity;\n    return acc;\n  }, {} as Record<string, number>);\n  distances[source] = 0;\n  return distances;\n}\n\n/**\n * Returns an array denoting the path from start vertex to end vertex.\n *\n * @param {Object} predecessor Mapping of child vertex pointing to parent vertex\n * @param {Vertex} source Starting vertex in graph\n * @param {Vertex} target End vertex in graph\n * @return {Array<String>} An array containing the path from source to target vertex\n */\nfunction getPath(\n  predecessor,\n  source,\n  target,\n) {\n  const path = [target];\n  while (target && target !== source) {\n    const next = predecessor[target];\n    target = next ?? source; // if next is undefined, it reaches source\n    path.push(target);\n  }\n  return path.reverse();\n}\n\n/**\n * Generates a default object mapping of child vertex pointing to parent vertex which will be defaulted to undefined initially.\n *\n * @param {Array<Vertex>} vertices An array of all vertices in the graph\n * @return {Record<string, Vertex | undefined>} An object mapping of child vertex pointing to parent vertex\n */\nfunction getPredecessor(\n  vertices,\n) {\n  const predecessor = {} as Record<string, Vertex | undefined>;\n  for (let vertex of vertices) {\n    predecessor[vertex] = undefined;\n  }\n  return predecessor;\n}\n\nexport default bellmanFord;\n<fim_middle>",
        "label": "Vertex",
        "post_steer_toptok": "string",
        "success": false,
        "generated": "string,\n) {\n  const distances = vertices.reduce((acc, curr",
        "id": 4130
    },
    {
        "prompt": "<fim_prefix>const isNull =\n\t(val): val is null =>\n\t\tval === null\n\nconst isString =\n\t(val): val is string =>\n\t\ttypeof val === \"string\"\n\nconst isBoolean =\n\t(val): val is boolean =>\n\t\ttypeof val === \"boolean\"\n\nconst isUndefined =\n\t(val): val is undefined =>\n\t\tval === undefined\n\nconst isUpperCase =\n\t(x): <fim_suffix> =>\n\t\tx === x.toUpperCase()\n\nconst isEmpty =\n\t(val) =>\n\t\tval.length === 0\n\nconst normalizeInput =\n\t(classNames) =>\n\t\tclassNames\n\t\t\t.map(\n\t\t\t\tclassName => {\n\t\t\t\t\tif (isBoolean(className) || isNull(className) || isUndefined(className)) {\n\t\t\t\t\t\treturn { className: \"\", remove: true }\n\t\t\t\t\t} else if (isString(className)) {\n\t\t\t\t\t\tif (isEmpty(className)) {\n\t\t\t\t\t\t\treturn { className }\n\t\t\t\t\t\t} else if (isUpperCase(className.charAt(0))) {\n\t\t\t\t\t\t\treturn { className, ignore: true }\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn { className }\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn className\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t)\n\nconst filterRemove =\n\t(classNames) =>\n\t\tclassNames.filter(({ remove }) => !remove)\n\nconst mapBEMValues =\n\t(classNames, componentName) =>\n\t\tclassNames.map(\n\t\t\t({ ignore, className }) => {\n\t\t\t\tif (ignore) {\n\t\t\t\t\treturn className\n\t\t\t\t} else if (isEmpty(componentName)) {\n\t\t\t\t\treturn className\n\t\t\t\t} else if (isEmpty(className)) {\n\t\t\t\t\treturn componentName\n\t\t\t\t} else {\n\t\t\t\t\treturn `${componentName}__${className}`\n\t\t\t\t}\n\t\t\t},\n\t\t)\n\nconst joinToString =\n\t(classNames) => (\n\t\tisEmpty(classNames) ?\n\t\t\tundefined :\n\t\t\tclassNames.join(\" \")\n\t)\n\nexport const createBEM =\n\t(componentName) =>\n\t\t(...classNames) =>\n\t\t\tjoinToString(\n\t\t\t\tmapBEMValues(\n\t\t\t\t\tfilterRemove(\n\t\t\t\t\t\tnormalizeInput(classNames),\n\t\t\t\t\t),\n\t\t\t\t\tcomponentName,\n\t\t\t\t),\n\t\t\t)\n\nexport interface BEMClassType {\n\tremove?: boolean,\n\tignore?: boolean,\n\tclassName: string,\n}\n\nexport type BEMInput =\n\tBEMClassType | string | boolean | undefined | null<fim_middle>",
        "label": "boolean",
        "post_steer_toptok": "x",
        "success": false,
        "generated": "x is string",
        "id": 726
    },
    {
        "prompt": "<fim_prefix>export default class Day2 {\n    public static calculatePart1(input)  {\n        const reducer = (state, i)  =>\n        {\n            switch (i.direction) {\n                case Direction.Forward:\n                    return { horizontal: state.horizontal + i.distance, depth: state.depth };\n                case Direction.Down:\n                    return { horizontal: state.horizontal, depth: state.depth + i.distance };\n                case Direction.Up:\n                    return { horizontal: state.horizontal, depth: state.depth - i.distance };\n            }\n        };\n        \n        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });\n    }\n\n    public static calculatePart2(input)  {\n        const reducer = (state, i)  =>\n        {\n            const aim = state.aim ?? 0;\n\n            switch (i.direction) {\n                case Direction.Forward:\n                    return { horizontal: state.horizontal + i.distance, \n                             depth: state.depth + (aim * i.distance), \n                             aim: aim };\n                case Direction.Down:\n                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };\n                case Direction.Up:\n                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };\n            }\n        };\n        \n        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });\n    }\n\n    private static calculate(\n        input, \n        reducertialState: <fim_suffix>)  {\n        const position = input\n            .map(Day2.parse)\n            .reduce(reducer, initialState);\n\n        return position.horizontal * position.depth;\n    }\n\n    private static parse(input)  {\n        const parts = input.split(' ');\n        return {\n            direction: parts[0] as Direction,\n            distance: parseInt(parts[1], 10)\n        };\n    }\n}\n\nenum Direction {\n    Forward = \"forward\",\n    Down = \"down\",\n    Up = \"up\"\n}\n\ninterface Instruction {\n    direction: Direction;\n    distance: number;\n}\n\ninterface Position {\n    horizontal: number;\n    depth: number;\n    aim?: number;\n}<fim_middle>",
        "label": "Position",
        "post_steer_toptok": "(",
        "success": false,
        "generated": "(state: Position, instruction: Instruction) => Position,\n        initialState: Position",
        "id": 295
    }
]