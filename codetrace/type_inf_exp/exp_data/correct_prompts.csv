generated,solution,hexsha,prompt,correctness,id
A,A,c6809d0badc6c8f808466d7d4c6fca23ae804536,"<fim_prefix>type Err<T> = {
  kind: 'Err'
  value: T
}

type Ok<T> = {
  kind: 'Ok'
  value: T
}

export type Result<A, B> = Ok<A> | Err<B>

export const Err = <B>(value) => {
  return {
    kind: 'Err',
    value,
  }
}

export const Ok = <A>(value: <fim_suffix>) => {
  return {
    kind: 'Ok',
    value,
  }
}

export type ParserStateHooks = {
  getSource: () => string
  getOffset: () => number
  setOffset: (offset) => void
  getError: () => string
  setError: (message) => void
}

let currentSource = ''
let currentOffset = 0
let currentMessage = ''

const hooks: ParserStateHooks = {
  getSource: () => {
    return currentSource
  },
  getOffset: () => {
    return currentOffset
  },
  setOffset: (newOffset) => {
    currentOffset = newOffset
  },
  getError: () => {
    return currentMessage
  },
  setError: (newMessage) => {
    currentMessage = newMessage
  },
}

export type Parser<T = any> = () => Result<T, string>

const { getSource, getOffset, setOffset, getError, setError } = hooks

export const runParser = <P extends Parser>(
  parser,
  source
) => {
  currentSource = source
  currentOffset = 0
  currentMessage = ''

  let result = parser() as ReturnType<P>

  let info = {
    source,
    offset: currentOffset,
    message: currentMessage,
  }

  currentSource = ''
  currentMessage = ''
  currentOffset = 0

  return [result, info]
}

export const inject = <T>(value) => {
  return () => Ok(value)
}

export const map = <A, B>(parser, f) => {
  return () => {
    let result = parser()

    if (result.kind === 'Err') {
      return result
    }

    return Ok(f(result.value))
  }
}

export const ap = <A, B>(
  parserFn,
  parserArg
) => {
  return () => {
    let resultFn = parserFn()

    if (resultFn.kind === 'Err') {
      return resultFn
    }

    let resultArg = parserArg()

    if (resultArg.kind === 'Err') {
      return resultArg
    }

    return Ok(resultFn.value(resultArg.value))
  }
}

export function apply<A, B>(
  parserFn,
  a
)

export function apply<A, B, C>(
  parserFn a,
  b
)

export function apply<A, B, C, D>(
  parserFn
  b,
  c
)

export function apply<A, B, C, D, E>(
  parserFnb,
  c,
  d
)

export function apply<A, B, C, D, E, F>(
  parserFn  c,
  d,
  e
)

export function apply<A, B, C, D, E, F>(
  parserFn  c,
  d,
  e
)

export function apply<A, B, C, D, E, F, G>(
  parserFn,
  a,
  b,
  c,
  d,
  e,
  f
)

export function apply(...args) {
  if (args.length < 2) {
    throw new Error(`Expected receiving at least two arguments`)
  }
  return args.reduce(ap)
}

export const item: Parser<string> = () => {
  let source = getSource()
  let offset = getOffset()

  if (offset >= source.length) {
    return Err('EOF')
  }

  setOffset(offset + 1)

  return Ok(source[offset])
}

export const satisfy = (predicate) => {
  return () => {
    let result = item()

    if (result.kind === 'Err') {
      return result
    }

    if (predicate(result.value)) {
      return result
    } else {
      return Err(`Unmatched char ${result.value}`)
    }
  }
}

export const digit = satisfy((c) => c >= '0' && c <= '9')
export const lower = satisfy((c) => c >= 'a' && c <= 'z')
export const uppper = satisfy((c) => c >= 'A' && c <= 'Z')

export const char = (target) => {
  return satisfy((c) => c === target)
}

export const notChar = (x) => {
  return satisfy((value) => value !== x)
}

export const comma = char(',')

export const semicolon = char(':')

export const either = <A, B>(
  parserA,
  parserB
) => {
  return () => {
    let offset = getOffset()
    let resultA = parserA()

    if (resultA.kind === 'Err') {
      setOffset(offset)
      return parserB()
    }

    return resultA
  }
}

export function oneOf<A>(parserA)

export function oneOf<A, B>(
  parserA,
  parserB
)

export function oneOf<A, B, C>(
  parserA,
  parserB,
  parserC
)

export function oneOf<A, B, C, D>(
  parserA,
  parserB,
  parserC,
  parserD
)

export function oneOf<A, B, C, D, E>(
  parserA,
  parserB,
  parserC,
  parserD,
  parserE
)

export function oneOf<A, B, C, D, E, F>(
  parserA,
  parserB,
  parserC,
  parserD,
  parserE,
  parserF
)

export function oneOf<A, B, C, D, E, F, G>(
  parserA,
  parserB,
  parserC,
  parserD,
  parserE,
  parserF,
  parserG
)

export function oneOf(...parsers) {
  if (parsers.length < 2) {
    throw new Error(
      `Expected received at least two parsers, but got ${parsers.length}`
    )
  }
  return parsers.reduce(either)
}

export const whiteSpace = satisfy((x) => {
  if (x === ' ') return true
  if (x === '\n') return true
  if (x === '\t') return true
  if (x === '\r') return true
  return false
})

export const many = <T>(parser) => {
  return () => {
    let list: T[] = []

    while (true) {
      let offset = getOffset()
      let result = parser()

      if (result.kind === 'Err') {
        setError(result.value)
        setOffset(offset)
        return Ok(list)
      } else {
        list[list.length] = result.value
      }
    }
  }
}

export const many1 = <T>(parser) => {
  let manyParser = many(parser)
  return () => {
    let result = manyParser()

    if (result.kind === 'Err') {
      return result
    }

    if (result.value.length === 0) {
      return Err(getError() || `at least match once`)
    }

    return result
  }
}

export const whiteSpaces = many1(whiteSpace)

// tslint:disable-next-line: variable-name
export const string = (str) => {
  return () => {
    for (let i = 0; i < str.length; i++) {
      let result = item()

      if (result.kind === 'Err') {
        return result
      }

      if (result.value !== str[i]) {
        return Err(`Unmatched string: ${str}`)
      }
    }

    return Ok(str)
  }
}

export const letter = either(lower, uppper)

export const digits = many1(digit)

export const positiveInteger: Parser<number> = () => {
  let result = digits()

  if (result.kind === 'Err') {
    return result
  }

  let value = Number(result.value.join(''))

  return Ok(value)
}

export const negativeInteger: Parser<number> = () => {
  let charResult = char('-')()

  if (charResult.kind === 'Err') {
    return charResult
  }

  let intResult = positiveInteger()

  if (intResult.kind === 'Err') {
    return intResult
  }

  return Ok(-intResult.value)
}

export const integer = either(positiveInteger, negativeInteger)

export const dot = char('.')

export const positiveFloat: Parser<number> = () => {
  let digitsResult0 = digits()

  if (digitsResult0.kind === 'Err') {
    return digitsResult0
  }

  let dotResult = dot()

  if (dotResult.kind === 'Err') {
    return dotResult
  }

  let digitsResult1 = digits()

  if (digitsResult1.kind === 'Err') {
    return digitsResult1
  }

  let value = Number(
    digitsResult0.value.join('') +
      dotResult.value +
      digitsResult1.value.join('')
  )

  return Ok(value)
}

export const negativeFloat: Parser<number> = () => {
  let charResult = char('-')()

  if (charResult.kind === 'Err') {
    return charResult
  }

  let floatResult = positiveFloat()

  if (floatResult.kind === 'Err') {
    return floatResult
  }

  return Ok(-floatResult.value)
}

export const float = either(positiveFloat, negativeFloat)

// tslint:disable-next-line: variable-name
export const number = either(float, integer)

export const separateBy = <A, S>(
  parser,
  separator
) => {
  let pair: Parser<A> = () => {
    let separatorResult = separator()

    if (separatorResult.kind === 'Err') {
      return separatorResult
    }

    return parser()
  }

  let pairs = many(pair)

  return () => {
    let result = parser()

    if (result.kind === 'Err') {
      return result
    }

    let pairsResult = pairs()

    if (pairsResult.kind === 'Err') {
      return pairsResult
    }

    let value = [result.value, ...pairsResult.value]

    return Ok(value)
  }
}

export const bracket = <O, A, C>(
  open,
  parser,
  close
) => () => {
  let openResult = open()

  if (openResult.kind === 'Err') {
    return openResult
  }

  let parserResult = parser()

  if (parserResult.kind === 'Err') {
    return parserResult
  }

  let closeResult = close()

  if (closeResult.kind === 'Err') {
    return closeResult
  }

  return parserResult
}

export const aroundBy = <A, S>(
  parser,
  surround
) => {
  return bracket(many(surround), parser, many(surround))
}

export const aroundBySpace = <A>(parser) => {
  return aroundBy(parser, whiteSpace)
}

export const stringLiteral = map(
  bracket(char('""'), many(notChar('""')), char('""')),
  (list) => list.join('')
)
<fim_middle>",correct,1930
A,A,f3813017e9bb14bf831177d63f99b8ab50b44ad4,"<fim_prefix>export type Empty = {
    readonly _tag: 'Empty';
};
export type BeregnButton = {
    readonly _tag: 'BeregnButton';
};
export type BeregnButtonAndErrorSummary<E> = {
    readonly _tag: 'BeregnButtonAndErrorSummary';
    readonly errors: E;
};
export type NoValidChildrenOrange = {
    readonly _tag: 'NoValidChildrenOrange';
};
export type ResultBox<A> = {
    readonly _tag: 'ResultBox';
    readonly result: A;
};

export type ResultView<E, A> =
    | Empty
    | BeregnButton
    | BeregnButtonAndErrorSummary<E>
    | NoValidChildrenOrange
    | ResultBox<A>;

// constructors
export const empty: ResultView<never, never> = {
    _tag: 'Empty',
};
export const beregnButton: ResultView<never, never> = {
    _tag: 'BeregnButton',
};
export const beregnButtonAndErrorSummary = <E>(errors) => ({
    _tag: 'BeregnButtonAndErrorSummary',
    errors,
});
export const noValidChildrenOrange: ResultView<never, never> = {
    _tag: 'NoValidChildrenOrange',
};
export const resultBox = <A>(result: <fim_suffix>) => ({
    _tag: 'ResultBox',
    result,
});
// filters
export const isEmpty = (data): data is Empty => data._tag === 'Empty';
export const isBeregnButton = (data): data is BeregnButton =>
    data._tag === 'BeregnButton';
export const isBeregnButtonAndErrorSummary = <E>(
    data
): data is BeregnButtonAndErrorSummary<E> => data._tag === 'BeregnButtonAndErrorSummary';
export const isNoValidChildrenOrange = (data): data is NoValidChildrenOrange =>
    data._tag === 'NoValidChildrenOrange';
export const isResultBox = <A>(data): data is ResultBox<A> => data._tag === 'ResultBox';

// fold
export const caseResultViewOf =
    <E, A, B>(
        empty,
        beregnButton,
        beregnButtonAndErrorSummary,
        noValidChildrenOrange,
        resultBox
    ) =>
    (resultView) => {
        switch (resultView._tag) {
            case 'Empty': {
                return empty();
            }
            case 'BeregnButton': {
                return beregnButton();
            }
            case 'BeregnButtonAndErrorSummary': {
                return beregnButtonAndErrorSummary(resultView.errors);
            }
            case 'NoValidChildrenOrange': {
                return noValidChildrenOrange();
            }
            case 'ResultBox': {
                return resultBox(resultView.result);
            }
        }
    };
<fim_middle>",correct,3887
Action,Action,566e0bf1c5e4eafebc876c82fc048623ab53ab35,"<fim_prefix>type Action =
  | { type: 'closeTag', tag: string }
  | { type: 'showInput' }
  | { type: 'confirmInput', tag?: string }
  | { type: 'reset' }
  | { type: 'addIngredient' }
  | { type: 'removeIngredient', id: number }
  | { type: 'addDirection' }
  | { type: 'removeDirection', id: number }

interface State {
  tags: string[]
  inputVisible: boolean
  ingredients: number[]
  directions: number[]
}


let ingredientId = 0
let directionId = 0
export const initialState = {
  tags: [],
  inputVisible: false,
  ingredients: [ingredientId],
  directions: [directionId],
}


const reducer = (state, action: <fim_suffix>) => {
  switch (action.type) {
    case 'closeTag':
      return { ...state, tags: state.tags.filter(tag => tag !== action.tag) }

    case 'reset':
      return initialState

    case 'showInput':
      return { ...state, inputVisible: true }
    case 'confirmInput':
      let tag = action.tag
      if (!tag) return { ...state, inputVisible: false }
      tag = tag.trim()

      const { tags } = state
      let newTags = tags

      if (tag && tags.indexOf(tag) === -1) newTags = [...tags, tag]

      return { ...state, inputVisible: false, tags: newTags }

    case 'addIngredient':
      ingredientId += 1
      return {
        ...state,
        ingredients: [...state.ingredients, ingredientId],
      }
    case 'removeIngredient':
      return {
        ...state,
        ingredients: state.ingredients.filter(index => index !== action.id),
      }

    case 'addDirection':
      directionId += 1
      return {
        ...state,
        directions: [...state.directions, directionId],
      }
    case 'removeDirection':
      return {
        ...state,
        directions: state.directions.filter(index => index !== action.id),
      }

    default:
      throw new Error('Unexpected action.')
  }
}


export default reducer
<fim_middle>",correct,20
Action,Action,9c7b185eb474643e7ed1d3b11566888a9164266a,"<fim_prefix>type Action =
  | { type: 'setTags', tags: string[] }
  | { type: 'closeTag', tag: string }
  | { type: 'showInput' }
  | { type: 'confirmInput', tag?: string }
  | { type: 'reset' }
  | { type: 'setIngredients', length: number }
  | { type: 'addIngredient' }
  | { type: 'removeIngredient', id: number }
  | { type: 'addDirection' }
  | { type: 'setDirections', length: number }
  | { type: 'removeDirection', id: number }

interface State {
  tags: string[]
  inputVisible: boolean
  ingredients: number[]
  directions: number[]
}


let ingredientId = 0
let directionId = 0
export const initialState = {
  tags: [],
  inputVisible: false,
  ingredients: [ingredientId],
  directions: [directionId],
}


const reducer = (state, action: <fim_suffix>) => {
  switch (action.type) {
    case 'setTags':
      return { ...state, tags: action.tags }
    case 'closeTag':
      return { ...state, tags: state.tags.filter(tag => tag !== action.tag) }

    case 'reset':
      return initialState

    case 'showInput':
      return { ...state, inputVisible: true }
    case 'confirmInput':
      let tag = action.tag
      if (!tag) return { ...state, inputVisible: false }
      tag = tag.trim()

      const { tags } = state
      let newTags = tags

      if (tag && tags.indexOf(tag) === -1) newTags = [...tags, tag]

      return { ...state, inputVisible: false, tags: newTags }

    case 'setIngredients':
      const ingredients = [] as number[]
      new Array(action.length).fill(null).forEach(() => {
        ingredientId += 1
        ingredients.push(ingredientId)
      })
      return { ...state, ingredients }
    case 'addIngredient':
      ingredientId += 1
      return {
        ...state,
        ingredients: [...state.ingredients, ingredientId],
      }
    case 'removeIngredient':
      return {
        ...state,
        ingredients: state.ingredients.filter(index => index !== action.id),
      }

    case 'setDirections':
      const directions = [] as number[]
      new Array(action.length).fill(null).forEach(() => {
        directionId += 1
        directions.push(ingredientId)
      })
      return { ...state, directions }
    case 'addDirection':
      directionId += 1
      return {
        ...state,
        directions: [...state.directions, directionId],
      }
    case 'removeDirection':
      return {
        ...state,
        directions: state.directions.filter(index => index !== action.id),
      }

    default:
      throw new Error('Unexpected action.')
  }
}


export default reducer
<fim_middle>",correct,1673
Action,Action,da0ef1973818334ec9af63eb9d4d8f9b49d3597e,"<fim_prefix>export type State = {
	username: string,
	profile_src: string,
	createdAt: string,
	client_id: string
	message: string,
	message_id: string,
	reply?: {
		reply_username: string,
		reply_picture: string,
		reply_message: string,
		reply_message_owner_id: string
	}
}

type Action = {
	type: ""SET_USER"" | ""MESSAGE_INPUT"" | ""CLEAR_MESSAGE_FIELD"" | ""SET_MESSAGE_ID"" | ""SET_REPLY_MESSAGE"" | ""CLEAR_REPLY"",
	payload: {
		username: string,
		profile_src: string,
		createdAt: string,
		client_id: string,
		message: string,
		message_id: string,
		reply_username?: string,
		reply_picture?: string,
		reply_message?: string,
		reply_message_id?: string
	}
}

const clientState: State = {
	username: '',
	profile_src: '',
	createdAt: '',
	client_id: '',
	message: '',
	message_id: ''
}

export const clientReducer = (state = clientState, action: <fim_suffix>) => {
	
	switch(action.type){
		case ""SET_USER"": {
			const {username, message_id, profile_src, createdAt, client_id} = action.payload
			return {
				...state,
				username: username,
				profile_src: profile_src,
				createdAt: createdAt,
				client_id: client_id,
				message_id: message_id
			}
		}case ""MESSAGE_INPUT"": {
			const {message} = action.payload
			return {
				...state,
				message: message
			}
		}
		case ""CLEAR_MESSAGE_FIELD"": {
			return {
				...state,
				message: """"
			}
		}
		case ""SET_MESSAGE_ID"": {
			return {
				...state,
				message_id: action.payload.message_id
			}
		}
		case ""SET_REPLY_MESSAGE"": {
			const {reply_username, reply_picture, reply_message, reply_message_id} = action.payload

			return {
				...state,
				reply: {
					reply_username: reply_username as string,
					reply_picture: reply_picture as string,
					reply_message: reply_message as string,
					reply_message_owner_id: reply_message_id as string
				}
			}
		}
		case ""CLEAR_REPLY"": {
			return {
				...state,
				reply: undefined
			}
		}
		default: return state
	}
}<fim_middle>",correct,3546
Actions,Actions,ebfbabd6e86ee48c24c3828f4ee1b92f6ff39f68,"<fim_prefix>export interface AppSetting {
  shouldSplitMemoWord: boolean;
  shouldHideImageUrl: boolean;
  shouldUseMarkdownParser: boolean;
  useTinyUndoHistoryCache: boolean;
}

export interface State extends AppSetting {
  markMemoId: string;
  editMemoId: string;
  commentMemoId: string;
  isMobileView: boolean;
  showSiderbarInMobileView: boolean;
  changedByMemos: boolean;
}

interface SetMarkMemoIdAction {
  type: 'SET_MARK_MEMO_ID';
  payload: {
    markMemoId: string;
  };
}

interface SetEditMemoIdAction {
  type: 'SET_EDIT_MEMO_ID';
  payload: {
    editMemoId: string;
  };
}

interface SetCommentMemoIdAction {
  type: 'SET_COMMENT_MEMO_ID';
  payload: {
    commentMemoId: string;
  };
}

interface SetMobileViewAction {
  type: 'SET_MOBILE_VIEW';
  payload: {
    isMobileView: boolean;
  };
}

interface SetChangedByMemosAction {
  type: 'SET_CHANGED_BY_MEMOS';
  payload: {
    changedByMemos: boolean;
  };
}

interface SetShowSidebarAction {
  type: 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW';
  payload: {
    showSiderbarInMobileView: boolean;
  };
}

interface SetAppSettingAction {
  type: 'SET_APP_SETTING';
  payload: Partial<AppSetting>;
}

export type Actions =
  | SetMobileViewAction
  | SetShowSidebarAction
  | SetEditMemoIdAction
  | SetCommentMemoIdAction
  | SetMarkMemoIdAction
  | SetChangedByMemosAction
  | SetAppSettingAction;

export function reducer(state, action: <fim_suffix>) {
  switch (action.type) {
    case 'SET_MARK_MEMO_ID': {
      if (action.payload.markMemoId === state.markMemoId) {
        return state;
      }

      return {
        ...state,
        markMemoId: action.payload.markMemoId,
      };
    }
    case 'SET_EDIT_MEMO_ID': {
      if (action.payload.editMemoId === state.editMemoId) {
        return state;
      }

      return {
        ...state,
        editMemoId: action.payload.editMemoId,
      };
    }
    case 'SET_COMMENT_MEMO_ID': {
      if (action.payload.commentMemoId === state.commentMemoId) {
        return state;
      }

      return {
        ...state,
        commentMemoId: action.payload.commentMemoId,
      };
    }
    case 'SET_MOBILE_VIEW': {
      if (action.payload.isMobileView === state.isMobileView) {
        return state;
      }

      return {
        ...state,
        isMobileView: action.payload.isMobileView,
      };
    }
    case 'SET_CHANGED_BY_MEMOS': {
      if (action.payload.changedByMemos === state.changedByMemos) {
        return state;
      }

      return {
        ...state,
        changedByMemos: action.payload.changedByMemos,
      };
    }
    case 'SET_SHOW_SIDEBAR_IN_MOBILE_VIEW': {
      if (action.payload.showSiderbarInMobileView === state.showSiderbarInMobileView) {
        return state;
      }

      return {
        ...state,
        showSiderbarInMobileView: action.payload.showSiderbarInMobileView,
      };
    }
    case 'SET_APP_SETTING': {
      return {
        ...state,
        ...action.payload,
      };
    }
    default: {
      return state;
    }
  }
}

export const defaultState: State = {
  markMemoId: '',
  editMemoId: '',
  commentMemoId: '',
  shouldSplitMemoWord: true,
  shouldHideImageUrl: true,
  shouldUseMarkdownParser: true,
  useTinyUndoHistoryCache: false,
  isMobileView: false,
  showSiderbarInMobileView: false,
  changedByMemos: false,
};
<fim_middle>",correct,236
Application,Application,cae47631c7a90006a8af948c94a65fc0aa8379c0,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IApplication {
    client_type?: string;
    description?: string;
    grant_type?: string;
    id?: string;
    image?: string;
    name?: string;
    redirect_uri?: string;
    response_type?: string;
    url?: string;
}

export default class Application {
    readonly _client_type: string | undefined;

    get clientType() {
        return this._client_type;
    }

    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _grant_type: string | undefined;

    get grantType() {
        return this._grant_type;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _image: string | undefined;

    get image() {
        return this._image;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _redirect_uri: string | undefined;

    get redirectUri() {
        return this._redirect_uri;
    }

    readonly _response_type: string | undefined;

    get responseType() {
        return this._response_type;
    }

    readonly _url: string | undefined;

    get url() {
        return this._url;
    }

    constructor(props) {
        if (typeof props.client_type === 'string') {
            this._client_type = props.client_type.trim();
        }
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.grant_type === 'string') {
            this._grant_type = props.grant_type.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.image === 'string') {
            this._image = props.image.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.redirect_uri === 'string') {
            this._redirect_uri = props.redirect_uri.trim();
        }
        if (typeof props.response_type === 'string') {
            this._response_type = props.response_type.trim();
        }
        if (typeof props.url === 'string') {
            this._url = props.url.trim();
        }
    }

    serialize() {
        const data: IApplication = {};
        if (typeof this._client_type !== 'undefined') {
            data.client_type = this._client_type;
        }
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._grant_type !== 'undefined') {
            data.grant_type = this._grant_type;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._image !== 'undefined') {
            data.image = this._image;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._redirect_uri !== 'undefined') {
            data.redirect_uri = this._redirect_uri;
        }
        if (typeof this._response_type !== 'undefined') {
            data.response_type = this._response_type;
        }
        if (typeof this._url !== 'undefined') {
            data.url = this._url;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            image: !this._image
                ? true
                : typeof this._image === 'string' && !this._image
                ? true
                : this._image,
            url: !this._url
                ? true
                : typeof this._url === 'string' && !this._url
                ? true
                : this._url,
            redirect_uri: !this._redirect_uri
                ? true
                : typeof this._redirect_uri === 'string' && !this._redirect_uri
                ? true
                : this._redirect_uri,
            grant_type: !this._grant_type
                ? true
                : typeof this._grant_type === 'string' && !this._grant_type
                ? true
                : this._grant_type,
            response_type: !this._response_type
                ? true
                : typeof this._response_type === 'string' &&
                  !this._response_type
                ? true
                : this._response_type,
            client_type: !this._client_type
                ? true
                : typeof this._client_type === 'string' && !this._client_type
                ? true
                : this._client_type,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Application({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,2034
Argument,Argument,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x: <fim_suffix>) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3358
Argument,Argument,7f5712ec06dabff06003ba15417bd3dcb2d15f53,"<fim_prefix>export type Settings = {
  parserName: string;
  typeHints: boolean;
  mainContents: string;
  mainName: string;
  cliName: string;
  argsName: string;
};

export const defaultSettings = () => {
  return {
    parserName: 'parser',
    typeHints: true,
    mainContents: '# Contents of main',
    mainName: 'main',
    cliName: 'cli',
    argsName: 'args',
  };
};

export type Argument = {
  name: string;
  type: string;
  variableName: string;
  default: string;
  required: boolean;
};

export const newArgument = (
  name,
  type,
  variableName = '',
  defaultValue = '',
  required = false,
): <fim_suffix> => {
  if (variableName === '') {
    variableName = name.replace(/-/g, '');
  }
  return { name, type, variableName, default: defaultValue, required };
};

function argumentToText(argument, parserName) {
  switch (argument.type) {
    case 'bool':
      return `${parserName}.add_argument(""${argument.name}"", action=""store_${argument.default}"")`;
    default:
      let defaultDisplay;

      if (argument.type === 'str') {
        defaultDisplay = `""${argument.default}""`;
      } else {
        defaultDisplay = argument.default;
      }

      if (argument.default === '') {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type})`;
      } else {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type}, default=${defaultDisplay})`;
      }
  }
}

const argumentToMainParams = (argument, typeHints) => {
  if (typeHints) {
    return `${argument.variableName}: ${argument.type}`;
  } else {
    return `${argument.variableName}`;
  }
};

export const argparseCode = (args, settings = defaultSettings()) => {
  const parserName: string = settings.parserName;
  const argsName: string = settings.argsName;
  const mainParameters: string[] = args.map((arg) => argumentToMainParams(arg, settings.typeHints));
  const argumentsText: string[] = args.map((arg) => argumentToText(arg, parserName));
  const returnText: string[] = args.map((x) => {
    if (x.type === 'str') {
      return `""${x.variableName}"": ${argsName}.${x.variableName},`;
    } else {
      return `""${x.variableName}"": ${x.type}(${argsName}.${x.variableName}),`;
    }
  });

  const mainReturnType = settings.typeHints ? ' -> None' : '';
  const cliReturnType = settings.typeHints ? ' -> Dict[str, Any]' : '';
  const typeImports = settings.typeHints ? '\nfrom typing import Dict, Any' : '';

  const output = `import argparse${typeImports}


def ${settings.mainName}(${mainParameters.join(', ')})${mainReturnType}:
    ${settings.mainContents}
    return


def ${settings.cliName}()${cliReturnType}:
    formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ${parserName} = argparse.ArgumentParser(formatter_class=formatter_class)

    ${argumentsText.join('\n    ')}

    ${argsName} = ${parserName}.parse_args()

    return {${returnText.join('\n            ').slice(0, -1)}}


if __name__ == '__main__':
    ${argsName} = ${settings.cliName}()
    ${settings.mainName}(${args.map((x) => `${x.variableName}=${argsName}[""${x.variableName}""]`).join(',\n         ')})
`;
  return output;
};
<fim_middle>",correct,4835
ArrayBuffer,ArrayBuffer,8942b9bffbeae8bdf02b8ff01a9a7a9bca89f53c,"<fim_prefix>const INDEX_BIT_COUNT = 12;
const LENGTH_BIT_COUNT = 4;
const WINDOW_SIZE = 1 << INDEX_BIT_COUNT;
const RAW_LOOK_AHEAD_SIZE = 1 << LENGTH_BIT_COUNT;
const BREAK_EVEN = Math.floor((1 + INDEX_BIT_COUNT + LENGTH_BIT_COUNT) / 9);
const LOOK_AHEAD_SIZE = RAW_LOOK_AHEAD_SIZE + BREAK_EVEN;
const TREE_ROOT = WINDOW_SIZE;
const UNUSED = -1;
const MOD_WINDOW = (a) => a & (WINDOW_SIZE - 1);

enum Child {
  Smaller = 0,
  Larger = 1,
}

interface DefTree {
  parent: number;
  children: [number, number];
}

let current_pos: number;
let match_pos: number;
const win = new Uint8Array(WINDOW_SIZE * 5);
const tree: DefTree[] = (() => {
  const t = new Array<DefTree>(WINDOW_SIZE + 2);
  for (let i = 0; i < t.length; i++) {
    t[i] = { parent: 0, children: [0, 0] };
  }
  return t;
})();

function initTree(r) {
  for (let i = 0; i <= WINDOW_SIZE; i++) {
    const node = tree[i];
    node.parent = UNUSED;
    node.children[Child.Smaller] = UNUSED;
    node.children[Child.Larger] = UNUSED;
  }
  tree[TREE_ROOT].children[Child.Larger] = r;
  tree[r].parent = TREE_ROOT;
  tree[-1] = tree[WINDOW_SIZE + 1];
}

function contractNode(old_node, new_node) {
  tree[new_node].parent = tree[old_node].parent;
  if (tree[tree[old_node].parent].children[Child.Larger] === old_node)
    tree[tree[old_node].parent].children[Child.Larger] = new_node;
  else tree[tree[old_node].parent].children[Child.Smaller] = new_node;
  tree[old_node].parent = UNUSED;
}

function copyNode(new_node, old_node) {
  tree[new_node].parent = tree[old_node].parent;
  tree[new_node].children[Child.Smaller] =
    tree[old_node].children[Child.Smaller];
  tree[new_node].children[Child.Larger] = tree[old_node].children[Child.Larger];
}

function replaceNode(old_node, new_node) {
  const parent = tree[old_node].parent;
  if (tree[parent].children[Child.Smaller] === old_node)
    tree[parent].children[Child.Smaller] = new_node;
  else tree[parent].children[Child.Larger] = new_node;
  copyNode(new_node, old_node);
  if (tree[new_node].children[Child.Smaller] !== UNUSED)
    tree[tree[new_node].children[Child.Smaller]].parent = new_node;
  if (tree[new_node].children[Child.Larger] !== UNUSED)
    tree[tree[new_node].children[Child.Larger]].parent = new_node;
  tree[old_node].parent = UNUSED;
}

function findNextNode(node) {
  let next = tree[node].children[Child.Smaller];
  while (tree[next].children[Child.Larger] !== UNUSED)
    next = tree[next].children[Child.Larger];
  return next;
}

function deleteString(p) {
  if (tree[p].parent === UNUSED) return;
  if (tree[p].children[Child.Larger] === UNUSED)
    contractNode(p, tree[p].children[Child.Smaller]);
  else if (tree[p].children[Child.Smaller] === UNUSED)
    contractNode(p, tree[p].children[Child.Larger]);
  else {
    const replacement = findNextNode(p);
    deleteString(replacement);
    replaceNode(p, replacement);
  }
}

function addString() {
  let i = 0;
  let delta = 0;
  let test_node = tree[TREE_ROOT].children[Child.Larger];
  let match_length = 0;
  for (;;) {
    for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
      delta = win[MOD_WINDOW(current_pos + i)] - win[MOD_WINDOW(test_node + i)];
      if (delta !== 0) break;
    }
    if (i >= match_length) {
      match_length = i;
      match_pos = test_node;
      if (match_length >= LOOK_AHEAD_SIZE) {
        replaceNode(test_node, current_pos);
        return match_length;
      }
    }
    const child_node = tree[test_node];
    const child_prop = delta >= 0 ? Child.Larger : Child.Smaller;
    if (child_node.children[child_prop] === UNUSED) {
      child_node.children[child_prop] = current_pos;
      tree[current_pos].parent = test_node;
      tree[current_pos].children[Child.Larger] = UNUSED;
      tree[current_pos].children[Child.Smaller] = UNUSED;
      return match_length;
    }
    test_node = child_node.children[child_prop];
  }
}

// Adapted from:
// https://github.com/2point21/lba2-classic/blob/main/SOURCES/LZSS.CPP
export function compressLZSS_LBA_type_1(data: <fim_suffix>) {
  let i: number;
  let read = 0;
  let write = 0;
  let info: number;
  let look_ahead_bytes: number;
  let replace_count: number;
  let match_length: number;
  let count_bits = 0;
  let mask = 1;
  let len = 0;
  let length = data.byteLength;

  const input = new Uint8Array(data);
  const output = new Uint8Array(length);

  const save_length = length;
  current_pos = 0;

  for (i = 0; i < LOOK_AHEAD_SIZE; i++) {
    if (length === 0) break;
    win[current_pos + i] = input[read++];
    length--;
  }

  look_ahead_bytes = i;
  initTree(current_pos);
  match_length = 0;
  match_pos = 0;
  info = write++;

  if (++len >= save_length) return data;

  output[info] = 0;

  while (look_ahead_bytes > 0) {
    if (match_length > look_ahead_bytes) match_length = look_ahead_bytes;

    if (match_length <= BREAK_EVEN) {
      replace_count = 1;
      output[info] |= mask;
      output[write++] = win[current_pos];
      if (++len >= save_length) return data;
    } else {
      if ((len = len + 2) >= save_length) return data;

      const value =
        (MOD_WINDOW(current_pos - match_pos - 1) << LENGTH_BIT_COUNT) |
        (match_length - BREAK_EVEN - 1);
      const low = (value & 0xff00) >> 8;
      const high = value & 0xff;
      output[write] = high;
      output[write + 1] = low;

      write += 2;
      replace_count = match_length;
    }

    if (++count_bits === 8) {
      if (++len >= save_length) return data;
      info = write++;
      output[info] = 0;
      count_bits = 0;
      mask = 1;
    } else {
      mask = (mask << 1) & 0xff;
    }

    for (i = 0; i < replace_count; i++) {
      deleteString(MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE));
      if (length === 0) look_ahead_bytes--;
      else {
        win[MOD_WINDOW(current_pos + LOOK_AHEAD_SIZE)] = input[read++];
        length--;
      }

      current_pos = MOD_WINDOW(current_pos + 1);
      if (look_ahead_bytes) match_length = addString();
    }
  }

  if (count_bits === 0) len--;
  return output.buffer.slice(0, len);
}
<fim_middle>",correct,4258
B,B,f3813017e9bb14bf831177d63f99b8ab50b44ad4,"<fim_prefix>export type Empty = {
    readonly _tag: 'Empty';
};
export type BeregnButton = {
    readonly _tag: 'BeregnButton';
};
export type BeregnButtonAndErrorSummary<E> = {
    readonly _tag: 'BeregnButtonAndErrorSummary';
    readonly errors: E;
};
export type NoValidChildrenOrange = {
    readonly _tag: 'NoValidChildrenOrange';
};
export type ResultBox<A> = {
    readonly _tag: 'ResultBox';
    readonly result: A;
};

export type ResultView<E, A> =
    | Empty
    | BeregnButton
    | BeregnButtonAndErrorSummary<E>
    | NoValidChildrenOrange
    | ResultBox<A>;

// constructors
export const empty: ResultView<never, never> = {
    _tag: 'Empty',
};
export const beregnButton: ResultView<never, never> = {
    _tag: 'BeregnButton',
};
export const beregnButtonAndErrorSummary = <E>(errors) => ({
    _tag: 'BeregnButtonAndErrorSummary',
    errors,
});
export const noValidChildrenOrange: ResultView<never, never> = {
    _tag: 'NoValidChildrenOrange',
};
export const resultBox = <A>(result) => ({
    _tag: 'ResultBox',
    result,
});
// filters
export const isEmpty = (data): data is Empty => data._tag === 'Empty';
export const isBeregnButton = (data): data is BeregnButton =>
    data._tag === 'BeregnButton';
export const isBeregnButtonAndErrorSummary = <E>(
    data
): data is BeregnButtonAndErrorSummary<E> => data._tag === 'BeregnButtonAndErrorSummary';
export const isNoValidChildrenOrange = (data): data is NoValidChildrenOrange =>
    data._tag === 'NoValidChildrenOrange';
export const isResultBox = <A>(data): data is ResultBox<A> => data._tag === 'ResultBox';

// fold
export const caseResultViewOf =
    <E, A, B>(
        empty,
        beregnButton,
        beregnButtonAndErrorSummary,
        noValidChildrenOrange,
        resultBox
    ) =>
    (resultView): <fim_suffix> => {
        switch (resultView._tag) {
            case 'Empty': {
                return empty();
            }
            case 'BeregnButton': {
                return beregnButton();
            }
            case 'BeregnButtonAndErrorSummary': {
                return beregnButtonAndErrorSummary(resultView.errors);
            }
            case 'NoValidChildrenOrange': {
                return noValidChildrenOrange();
            }
            case 'ResultBox': {
                return resultBox(resultView.result);
            }
        }
    };
<fim_middle>",correct,3874
Binding,Binding,4b26b14a08d5cdfff6183540cb79049b3ed5038a,"<fim_prefix>/* eslint-disable no-constant-condition */

const EOF = '~EOF~'

class Parser {
  private pos = 0

  constructor(private input) {}

  next() {
    if (this.pos >= this.input.length) {
      return EOF
    }
    return this.input[this.pos++]
  }

  backup() {
    this.pos--
  }

  parseTemplate(): <fim_suffix> {
    if (this.next() != '/') {
      throw new Error('binding URL should start with a slash')
    }
    
    return {
      segments: this.parseSegments(),
      verb: this.parseVerb(),
    }
  }

  private parseSegments() {
    let segments: Segment[] = []
    segments.push(this.parseSegment())

    while (true) {
      let r = this.next()
      switch (r) {
        case '/':
          segments.push(this.parseSegment())
          continue

        case ':':
        case '}':
          this.backup()
          return segments

        case EOF:
          return segments

        default:
          throw new Error(`unexpected ${r} in segments`)
      }
    }
  }

  private parseSegment() {
    let content = ''
    while (true) {
      let r = this.next()
      switch (r) {
        case EOF:
          if (!content.length) {
            throw new Error(`unexpected EOF in segment`)
          }
          return { content }

        case '{':
          return { content, variable: this.parseVariable() }

        case ':':
        case '/':
        case '}':
          this.backup()
          if (!content.length) {
            throw new Error(`unexpected ${r} in segment`)
          }
          return { content }

        default:
          content += r
      }
    }
  }

  private parseVariable() {
    let v: Variable = {
      name: '',
    }
    while (true) {
      let r = this.next()
      switch (r) {
        case '}':
          if (!v.name.length) {
            throw new Error(`empty variable name`)
          }
          return v

        case '=':
          v.parts = this.parseSegments().map(segment => {
            if (!segment.content.length) {
              throw new Error(`unexpected empty segment`)
            }
            return segment.content
          })
          break

        case EOF:
          throw new Error(`unexpected EOF in variable ${v.name}`)

        default:
          v.name += r
      }
    }
  }

  private parseVerb() {
    let r = this.next()
    switch (r) {
      case ':':
        break

      case EOF:
        return ''

      default:
        throw new Error(`unexpected ${r} in verb`)
    }

    let verb = ''
    while (true) {
      let r = this.next()
      if (r === EOF) {
        if (!verb.length) {
          throw new Error(`empty verb`)
        }
        return verb
      }
      verb += r
    }
  }
}

interface Binding {
  segments: Segment[]
  verb: string
}

interface Segment {
  content: string
  variable?: Variable
}

interface Variable {
  name: string
  parts?: string[]
}

export function buildURL(template, params) {
  let parser = new Parser(template)
  let binding = parser.parseTemplate()

  let parts = binding.segments.map(segment => {
    if (segment.variable) {
      if (!params[segment.variable.name]) {
        throw new Error(`input parameter ${segment.variable.name} is required`)
      }

      return params[segment.variable.name]
    }
    return segment.content
  })
  let verb = binding.verb ? `:${binding.verb}` : ''
  return '/' + parts.join('/') + verb
}
<fim_middle>",correct,928
Board,Board,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction): <fim_suffix> {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,799
Board,Board,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board): <fim_suffix> {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,802
Board,Board,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board): <fim_suffix> {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,806
Board,Board,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board): <fim_suffix> {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,808
BooleanField,BooleanField,5f2d2febe1a2a566772fc84aa89c133d84d3093b,"<fim_prefix>/**
 * Number
 */
type NumberField = {
  type: 'number';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const number = (options) => {
  return {
    type: 'number',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * BigInt
 */
type BigIntField = {
  type: 'bigint';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const bigInt = (options) => {
  return {
    type: 'bigint',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * String
 */
type StringField = {
  type: 'string';
  maxLength: number;
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const string = (options) => {
  return {
    type: 'string',
    maxLength: options.maxLength,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Boolean
 */
type BooleanField = {
  type: 'boolean';
  canBeNull: boolean;
  default: boolean | null;
  primaryKey: boolean;
};

export const boolean = (options): <fim_suffix> => {
  return {
    type: 'boolean',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Enumerated
 */
type EnumeratedField = {
  type: 'enumerated';
  values: string[];
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const enumerated = (options) => {
  return {
    type: 'enumerated',
    values: options.values,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * DateTime
 */
type DateTimeField = {
  type: 'datetime';
  canBeNull: boolean;
  default: Date | null;
  primaryKey: boolean;
};

export const dateTime = (options) => {
  return {
    type: 'datetime',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Any Field
 */
export type AnyField =
  | NumberField
  | BigIntField
  | StringField
  | BooleanField
  | EnumeratedField
  | DateTimeField;

export type Fields = {
  [key: string]: AnyField;
};
<fim_middle>",correct,4935
ClassType,ClassType,b898174dc9208306ba4726075f110ac026c56fe6,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// This file contains generic TypeScript types, and predicate methods
type VoidReturn = void | undefined;

export type VoidCallback<Args extends unknown[] = []> = Args extends []
	? ((arg?) => VoidReturn)
	: ((...args) => VoidReturn);

export type DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};

export type AsyncVoidCallback<Args extends unknown[] = []> = AsyncCallback<
	VoidReturn,
	Args
>;

export type AsyncCallback<Return, Args extends unknown[] = []> = Args extends []
	? (() => Return | Promise<Return>)
	: ((...args) => Return | Promise<Return>);

export type ErrorCallback<Err extends Error = Error> = (err) => void;

export type MapKey<T> = T extends Map<infer K, unknown> ? K : never;

export type MapValue<T> = T extends Map<unknown, infer V> ? V : never;

export type SetValue<T> = T extends Set<infer V> ? V : never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export type UnionToIntersection<U> = (U extends any ? (k) => void : never) extends ((
	k,
) => void)
	? I
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
type ClassConstructorParams<T> = T extends {
	new (
		...args
	): any;
}
	? R
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export interface Class<T, Args extends any[] = ClassConstructorParams<T>> {
	new (
		...args
	): T;
	prototype: T;
}

export type Dict<T> = Record<string, T>;

export type RequiredProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]-?: NonNullable<Obj[Key]>
};

export type OptionalProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]?: Obj[Key]
};

export type TaggedTemplateFunction<Ret, Sub> = (
	strs,
	...substitutions
) => Ret;

// Turn a type that contains interfaces into regular objects
export type InterfaceToObject<T> = T extends {}
	? {[K in keyof T]: InterfaceToObject<T[K]>}
	: T;

export type UnknownObject = Dict<unknown>;

export type UnknownFunction = (...args) => unknown;

export function isObject(obj): obj is UnknownObject {
	return typeof obj === ""object"" && obj !== null && !Array.isArray(obj);
}

export function isPlainObject(obj): obj is UnknownObject {
	// Weird duck typing for cross-realm objects
	return (
		isObject(obj) &&
		obj.constructor !== undefined &&
		obj.constructor.name === ""Object""
	);
}

export function isIterable(obj): obj is Iterable<unknown> {
	if (typeof obj === ""object"" && obj != null) {
		// @ts-ignore
		return typeof obj[Symbol.iterator] === ""function"";
	} else {
		return false;
	}
}

// TypeScript has awful behaviour where it treats optional properties and undefined values as the same
// eg. https://www.typescriptlang.org/play/index.html?ssl=3&ssc=1&pln=1&pc=1#code/C4TwDgpgBAChBOBnA9gOygXigbwFBQKgDMBLJYAOQEMBbCALikWHhNQHMBufQgGyubU6jZqw7cAvt1wBjNMyhgq8YCSq84SNIzyEo-QbQgB+ESzbsANLgmYcPAgcpHGAV1QATCKVQQP1qVxZeWBFBBRURk0Iu11CUnIhBigAIgBlCAAjAVUqVBTrPSckxhSKdxAqAocoADp6pRU1DXC0AOkAeg79HKSoEkQody8fPyhM11CAFTSoD2QIRFQAclCEeGR4XEgtVFrio0wMLGHvNj9OIA
// https://github.com/microsoft/TypeScript/issues/13195
// This means that places where we expect to receive a value when object spreading in a partial object
// can actually have undefined values!
export function mergeObjects<A extends object>(
	a,
	b,
) {
	if (b === undefined) {
		return a;
	}

	const newObj: A = {
		...a,
		...b,
	};

	// If b contains undefined properties then use the value from A
	for (const key in b) {
		if (b[key] === undefined) {
			// @ts-ignore
			newObj[key] = a[key];
		}
	}

	return newObj;
}

export function equalArray<A extends unknown[], B extends unknown[]>(
	a,
	b,
): a is B {
	if (a.length !== b.length) {
		return false;
	}

	if (a === b) {
		return true;
	}

	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

// Check if a value is instance of a class, disallowing inheritance
// rome-ignore lint/ts/noExplicitAny: Necessary
export function isSafeInstanceof<ClassType extends new (
	...args
) => any>(inst, Class: <fim_suffix>): inst is InstanceType<ClassType> {
	return inst instanceof Class && inst.constructor === Class;
}
<fim_middle>",correct,3213
Color,Color,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random(): <fim_suffix> {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,383
Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?
) => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2,
  color3?: <fim_suffix>
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1987
Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?
) => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2: <fim_suffix>,
  color3?
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1988
Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?
): <fim_suffix> => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2,
  color3?
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1992
Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2,
  rgbColor3?: <fim_suffix>
) => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2,
  color3?
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1993
Color,Color,46db563dd7e7f7a5daf1c6d96ede4b374aba6ef3,"<fim_prefix>interface Color {
  red: number;
  green: number;
  blue: number;
}

export const colorGradient = (
  fadeFraction,
  rgbColor1,
  rgbColor2: <fim_suffix>,
  rgbColor3?
) => {
  let color1 = rgbColor1;
  let color2 = rgbColor2;
  let fade = fadeFraction;

  // Do we have 3 colors for the gradient? Need to adjust the params.
  if (rgbColor3) {
    fade = fade * 2;

    // Find which interval to use and adjust the fade percentage
    if (fade >= 1) {
      fade -= 1;
      color1 = rgbColor2;
      color2 = rgbColor3;
    }
  }

  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;

  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * fade).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * fade).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * fade).toString(), 10),
  };

  // return 'rgb(' + gradient.red + ',' + gradient.green + ',' + gradient.blue + ')';
  return gradient;
};

export const perc2color = (
  perc,
  maxPerc,
  color1,
  color2,
  color3?
) => {
  perc = perc / maxPerc;
  if (color3) {
    perc = perc * 2;
    if (perc >= 1) {
      perc -= 1;
      color1 = color2;
      color2 = color3;
    }
  }
  const diffRed = color2.red - color1.red;
  const diffGreen = color2.green - color1.green;
  const diffBlue = color2.blue - color1.blue;
  const gradient = {
    red: parseInt(Math.floor(color1.red + diffRed * perc).toString(), 10),
    green: parseInt(Math.floor(color1.green + diffGreen * perc).toString(), 10),
    blue: parseInt(Math.floor(color1.blue + diffBlue * perc).toString(), 10),
  };
  const sum = 0x10000 * gradient.red + 0x100 * gradient.green + 0x1 * gradient.blue;
  return '#' + ('000000' + sum.toString(16)).slice(-6);
};
<fim_middle>",correct,1994
Command,Command,c5055e95b1cf23c00d4f8174c39f7e7831a25a28,"<fim_prefix>/*--------------------------------------------------------------------------

MIT License

Copyright (c) smoke-pack 2019 Haydn Paterson (sinclair) <haydn.developer@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the ""Software""), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---------------------------------------------------------------------------*/


export interface InfoCommand   { kind: 'info',   message: string }

export interface ListCommand   { kind: 'list' }
export interface CreateCommand { kind: 'create', name: string, type: string }
export interface AddCommand    { kind: 'add',    name: string, type: string }
export interface RemoveCommand { kind: 'remove', name: string }
export interface LinkCommand   { kind: 'link',   name: string, dependency: string }
export interface UnlinkCommand { kind: 'unlink', name: string, dependency: string }

export interface CleanCommand  { kind: 'clean',  name:  string }
export interface BuildCommand  { kind: 'build',  name:  string }
export interface WatchCommand  { kind: 'watch',  names: string[] }
export interface StartCommand  { kind: 'start',  name:  string }
export interface TestCommand   { kind: 'test',   name:  string }
export interface PackCommand   { kind: 'pack',   name:  string }
export interface RunCommand    { kind: 'run',    name:  string, script: string }

export type Command =
// general
| InfoCommand 

// provision
| ListCommand
| CreateCommand 
| AddCommand 
| RemoveCommand 
| LinkCommand 
| UnlinkCommand

// automation 
| CleanCommand
| BuildCommand
| WatchCommand
| StartCommand 
| TestCommand 
| PackCommand
| RunCommand


/** Parses the given command line arguments. */
export function parse(args): <fim_suffix> {
  const forward = [args.shift()!, args.shift()!]

  if(args.length === 0) {
    const kind = 'info'
    const message = ''
    return { kind, message }
  }
  const commandKind   = args.shift()!
  switch(commandKind) {
    // ---------------------
    // provision
    // ---------------------
    case 'list': {
      const kind = 'list'
      return { kind }
    }
    // ---------------------
    // provision
    // ---------------------
    case 'create': {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <type> arguments.'
        return { kind, message }
      }
      const kind = 'create'
      const name = args.shift()!
      const type = args.shift()!
      return { kind, name, type }
    }
    case 'add': {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <type> arguments.'
        return { kind, message }
      }
      const kind = 'add'
      const name = args.shift()!
      const type = args.shift()!
      return { kind, name, type }
    }
    case 'remove': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'remove'
      const name = args.shift()!
      return { kind, name }
    }
    case ""link"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <dependency> arguments.'
        return { kind, message }
      }
      const kind       = 'link'
      const name       = args.shift()!
      const dependency = args.shift()!
      return { kind, name, dependency }
    }
    case ""unlink"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <dependency> arguments.'
        return { kind, message }
      }
      const kind       = 'unlink'
      const name       = args.shift()!
      const dependency = args.shift()!
      return { kind, name, dependency }
    }
    // ---------------------
    // automation
    // ---------------------
    case 'clean': {
      const kind = 'clean'
      if(args.length !== 1) {
        const name = '*'
        return { kind, name }
      }
      const name = args.shift()!
      return { kind, name }
    }
    case 'build': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'build'
      const name = args.shift()!
      return { kind, name }
    }
    case 'watch': {
      if(args.length < 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind  = 'watch'
      const names = [...args]
      return { kind, names }
    }
    case 'start': {
      if(args.length !== 1) {
        const kind    = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'start'
      const name = args.shift()!
      return { kind, name }
    }
    case 'test': {
      if(args.length !== 1) {
        const kind = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'test'
      const name = args.shift()!
      return { kind, name }
    }
    case 'pack': {
      if(args.length !== 1) {
        const kind = 'info'
        const message = 'Expected <name> argument.'
        return { kind, message }
      }
      const kind = 'pack'
      const name = args.shift()!
      return { kind, name }
    }
    case ""run"": {
      if(args.length !== 2) {
        const kind    = 'info'
        const message = 'Expected <name> <script> arguments.'
        return { kind, message }
      }
      const kind   = 'run'
      const name   = args.shift()!
      const script = args.shift()!
      return { kind, name, script }
    }
    default: {
      const kind    = 'info'
      const message = `Invalid command '${commandKind}'`
      return { kind, message }
    }
  }  
}
<fim_middle>",correct,2104
Command,Command,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x): <fim_suffix> {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3357
Command,Command,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x): <fim_suffix> {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3359
Command,Command,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command: <fim_suffix>) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3366
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space): <fim_suffix>;
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3968
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space): <fim_suffix>;
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3970
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels): <fim_suffix>;
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3982
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent): <fim_suffix>;
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3986
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent): <fim_suffix>;
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3990
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum): <fim_suffix>;
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3994
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius): <fim_suffix>;
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3998
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth): <fim_suffix>;
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,4006
Computer,Computer,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling(): <fim_suffix> {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,4014
Config,Config,3916af040035d5fc03d4a8992d5ecdd8e2401645,"<fim_prefix>export interface Config {
    speedMultMalus: number;
    weaponSpeedMultOneHanderMalus: number;
    weaponSpeedMultTwoHanderMalus: number;
    weaponSpeedMultRangedMalus: number;
    staminaRateMultMalus: number;
    magickaRateMultMalus: number;
    powerAttackStaminaMultMalus: number;
    spellCostMalus: number;

    lightCuirassBase: number; 
    lightGauntletsBase: number; 
    lightBootsBase: number; 
    lightHelmetBase: number; 
    heavyCuirassBase: number; 
    heavyGauntletsBase: number; 
    heavyBootsBase: number; 
    heavyHelmetBase: number; 
    shieldBase: number; 

    enableSkillBonuses: boolean,
    speedMultLightArmorSkillBonus: number;
    speedMultHeavyArmorSkillBonus: number;
    weaponSpeedMultOneHandedSkillBonus: number;
    weaponSpeedMultTwoHandedSkillBonus: number;
    weaponSpeedMultMarksmanSkillBonus: number;
    staminaRateMultLightArmorSkillBonus: number;
    staminaRateMultHeavyArmorSkillBonus: number;
    magickaRateMultMagicSkillBonus: number;
    powerAttackStaminaOneHandedSkillBonus: number;
    powerAttackStaminaTwoHandedSkillBonus: number;
    spellCostSkillBonus: number;

    racialOffsets: Record<string, MalusOffset[]>;
    spellCostArgonianLightArmorRestorationPctOffset: number;
    spellCostArgonianLightArmorAlterationPctOffset: number;
    spellCostDunmerLightArmorFireDamagePctOffset: number;
    spellCostImperialHeavyArmorRestorationPctOffset: number;

    factionalOffsets: Record<string, MalusOffset[]>;
    spellCostThalmorLightArmorPctOffset: number;

    lightArmorPerkFormId: string;
    lightArmorPerkOffsetPct: number;
    heavyArmorPerkFormId: string;
    heavyArmorPerkOffsetPct: number;

    debug: boolean;
    useCloak: boolean;
}

type Types = ""string"" | ""number"" | ""boolean"" | ""object"";
export function asConfig(data): <fim_suffix> {
    const keyValidators: Record<keyof Config, Types> = {
        speedMultMalus: ""number"",
        weaponSpeedMultOneHanderMalus: ""number"",
        weaponSpeedMultTwoHanderMalus: ""number"",
        weaponSpeedMultRangedMalus: ""number"",
        staminaRateMultMalus: ""number"",
        magickaRateMultMalus: ""number"",
        powerAttackStaminaMultMalus: ""number"",
        spellCostMalus: ""number"",

        lightCuirassBase: ""number"", 
        lightGauntletsBase: ""number"", 
        lightBootsBase: ""number"", 
        lightHelmetBase: ""number"", 
        heavyCuirassBase: ""number"", 
        heavyGauntletsBase: ""number"", 
        heavyBootsBase: ""number"", 
        heavyHelmetBase: ""number"", 
        shieldBase: ""number"", 

        enableSkillBonuses: ""boolean"",
        speedMultLightArmorSkillBonus: ""number"",
        speedMultHeavyArmorSkillBonus: ""number"",
        weaponSpeedMultOneHandedSkillBonus: ""number"",
        weaponSpeedMultTwoHandedSkillBonus: ""number"",
        weaponSpeedMultMarksmanSkillBonus: ""number"",
        staminaRateMultLightArmorSkillBonus: ""number"",
        staminaRateMultHeavyArmorSkillBonus: ""number"",
        magickaRateMultMagicSkillBonus: ""number"",
        powerAttackStaminaOneHandedSkillBonus: ""number"",
        powerAttackStaminaTwoHandedSkillBonus: ""number"",
        spellCostSkillBonus: ""number"",

        racialOffsets: ""object"",
        spellCostArgonianLightArmorRestorationPctOffset: ""number"",
        spellCostArgonianLightArmorAlterationPctOffset: ""number"",
        spellCostDunmerLightArmorFireDamagePctOffset: ""number"",
        spellCostImperialHeavyArmorRestorationPctOffset: ""number"",

        factionalOffsets: ""object"",
        spellCostThalmorLightArmorPctOffset: ""number"",
    
        lightArmorPerkFormId: ""string"",
        lightArmorPerkOffsetPct: ""number"",
        heavyArmorPerkFormId: ""string"",
        heavyArmorPerkOffsetPct: ""number"",
    
        debug: ""boolean"",
        useCloak: ""boolean"",
    }

    if (typeof data === 'object' && data !== null) {
        let maybeConfig = data as Config
        for (const key of Object.keys(keyValidators) as Array<keyof Config>) {
            if (typeof maybeConfig[key] !== keyValidators[key]) {
                throw new Error(`data is not a Config: ${key} has type ${typeof maybeConfig[key]}`);
            }
            if (key === ""racialOffsets"") {
                const maybeOffsets = maybeConfig[key];
                Object.keys(maybeOffsets).map(key => maybeOffsets[key].map(maybeOffset => asMalusOffset(maybeOffset)));
            }
        }
        return maybeConfig;
    }

    throw new Error('data is not a Config');
}

type Malus = ""SpeedMult"" | ""WeaponSpeedMult"" | ""StaminaRateMult"" | ""MagickaRateMult"";
type ArmorKeyword = ""ArmorLight"" | ""ArmorHeavy"" | ""Any"";
type WeaponKeyword = ""WeapTypeSword"" | ""WeapTypeDagger"" | ""WeapTypeWarAxe"" | ""WeapTypeMace"" | ""WeapTypeGreatsword"" | ""WeapTypeBattleaxe"" | ""WeapTypeWarhammer"" | ""WeapTypeBow"" | ""WeapTypeCrossbow""  | ""Any"";
export interface MalusOffset {
    malus: Malus;
    armorKeyword: ArmorKeyword;
    weaponKeyword: WeaponKeyword;
    requiresShield: boolean;
    pctOffset: number;
}

export function asMalusOffset(data) {
    const keyValidators: Record<keyof MalusOffset, Types> = {
        malus: ""string"",
        armorKeyword: ""string"",
        weaponKeyword: ""string"",
        requiresShield: ""boolean"",
        pctOffset: ""number"",
    }

    if (typeof data === 'object' && data !== null) {
        let maybeMalusOffset = data as MalusOffset
        for (const key of Object.keys(keyValidators) as Array<keyof MalusOffset>) {
            if (typeof maybeMalusOffset[key] !== keyValidators[key]) {
                throw new Error(`data is not a MalusOffset: ${key} has type ${typeof maybeMalusOffset[key]}`);
            }
        }
        return maybeMalusOffset;
    }

    throw new Error('data is not a MalusOffset');
}
<fim_middle>",correct,1619
Config,Config,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text): <fim_suffix> {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value) {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text) {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line) {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value) {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4212
Config,Config,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text): <fim_suffix> {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value) {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text) {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line) {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value) {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4214
Config,Config,30d2bb4fdee631da49c7d9cbb94237a68567e65c,"<fim_prefix>//! Copyright (c) 2022 Victorien Elvinger
//! Licensed under Apache License 2.0 (https://apache.org/licenses/LICENSE-2.0)

export class ConfigError extends Error {
    declare readonly name: ""ConfigError""

    constructor(message) {
        super(message)
        this.name = ""ConfigError""
    }
}

export interface Config {
    readonly generator: ""bare"" | ""dts"" | ""js"" | ""ts""
    readonly importConfig: boolean
    readonly importFactory: boolean
    readonly legacy: boolean
    readonly out: string | number
    readonly pedantic: boolean
    readonly schema: string | number
    readonly useClass: boolean
    readonly useFlatUnion: boolean
    readonly useGenericArray: boolean
    readonly useIntEnum: boolean
    readonly useLaxOptional: boolean
    readonly useMutable: boolean
    readonly useQuotedProperty: boolean
    readonly useSafeInt: boolean
    readonly useUndefined: boolean
}

/**
 * @param {Partial<Config>} part
 * @returns {Config} completed config
 * @throws {ConfigError} when the code generator cannot be determinate or
 *  when the schema format is not a supported.
 */
export function Config({
    generator,
    importConfig = false,
    importFactory = false,
    legacy = false,
    out = """",
    pedantic = false,
    schema = """",
    useClass = false,
    useFlatUnion = false,
    useGenericArray = false,
    useIntEnum = false,
    useLaxOptional = false,
    useMutable = false,
    useQuotedProperty = false,
    useSafeInt = false,
    useUndefined = false,
}): <fim_suffix> {
    if (
        typeof schema === ""string"" &&
        schema !== """" &&
        !schema.endsWith("".bare"")
    ) {
        throw new ConfigError(
            ""a file containing a BARE schema must end with extension '.bare'."",
        )
    }
    const inferredGenerator =
        typeof out === ""string"" && out.endsWith("".bare"")
            ? ""bare""
            : typeof out === ""string"" && out.endsWith("".d.ts"")
            ? ""dts""
            : typeof out === ""string"" && out.endsWith("".ts"")
            ? ""ts""
            : typeof out === ""string"" && out.endsWith("".js"")
            ? ""js""
            : (typeof out === ""number"" || out === """") && generator === undefined
            ? ""ts""
            : generator
    if (generator !== undefined && inferredGenerator !== generator) {
        throw new ConfigError(
            `the inferred generator '${inferredGenerator}' from out '${out}' does not match the chosen generator '${generator}'.`,
        )
    }
    if (inferredGenerator === undefined) {
        throw new ConfigError(
            ""the code generator to use cannot be determinate. Please set the option 'generator'."",
        )
    }
    return {
        generator: inferredGenerator,
        importConfig,
        importFactory,
        legacy,
        out,
        pedantic,
        schema,
        useClass,
        useFlatUnion,
        useGenericArray,
        useIntEnum,
        useLaxOptional,
        useMutable,
        useQuotedProperty,
        useSafeInt,
        useUndefined,
    }
}
<fim_middle>",correct,4691
Config,Config,52d6fc301866fccc3a2004222d9a88498840f05e,"<fim_prefix>

interface Config {
    rc: any
    redirect?: string
    rootFile?: string
    /** 过滤文件 */
    filter?: (file) => boolean
    /** 定义组件返回 */
    component: (file) => any
}
/**
 * https://github.com/MrHzq/vue-router-auto
 * rc：require.context 传入的文件
 * redirect：需要将根路由(/)重定向到的路由
 * rootFile：页面级别的.vue存放的文件名称
 * filter：过滤文件
 * component：定义组件返回
 */
export function createRouters(config: <fim_suffix>) {
    // 所生成的所有路由数组
    const Routers: any = []
    const defaultConfig: Config = {
        rc: null,
        redirect: '',
        rootFile: 'pages',
        filter: () => true,
        component: () => ({})
    }
    const { rc, redirect, filter, rootFile, component } = (<any>Object).assign(
        {},
        defaultConfig,
        config
    )
    if (rc === null) return Routers

    // allRouters[object]：存储所有路由的变量：先将所有的路由生成，然后放在该变量里面
    const allRouters: any = {
        len1: []
    }
    // 通过循环RC(传入的文件)
    const routerFileAndLen = rc
        .keys()
        .filter(filter)
        .map((fileName) => {
            // 因为得到的filename格式是: './baseButton.vue', 所以这里我们去掉头和尾，只保留真正的文件名
            const realFileName = fileName
                .replace(/^\.\//, '')
                .replace(/\.\w+$/, '')
            return {
                file: fileName,
                fileName: realFileName,
                // routerName(路由名称)：将 / 转为 - 并去掉 _
                routerName: realFileName.replace(/\//g, '-').replace(/_/g, '').replace(/-index/g, ''),
                // routerComponent(路由异步component的文件路径)：将 ./baseButton.vue 从 . 之后截取
                routerComponent: fileName.substr(1),
                // fileLen(文件的层级深度)：通过 / 的数量来判断当前文件的深度
                fileLen: fileName.match(/\//g).length
            }
        })
        .sort((i, j) => i.fileLen - j.fileLen) // 通过文件深度 升序排序

    // 传入文件中最大深度
    let maxLen = 0
    routerFileAndLen.map((r) => {
        const name = r.routerName
        // 生成一块路由对象，包含：name、fileName(用于后续处理真正path的依据)、path、needDelectName(用于后续处理，判断是否删除name的依据)、component
        const obj = {
            name,
            exact: true,
            fileName: r.fileName,
            // path：只是以name命名的path，还不是真正的路由path
            path: '/' + (name === 'index' ? '' : name),
            // needDelectName: name === 'index',
            needDelectName: false,
            component: component(rc(r.file))//() => import(`~/${rootFile}${r.routerComponent}`)
        }
        maxLen = r.fileLen
        // allRouters的key：以 'len'加当前的文件深度 作为key
        const key = 'len' + maxLen
        if (Array.isArray(allRouters[key])) allRouters[key].push(obj)
        else allRouters[key] = [obj]
    })

    // 将根目录层的路由放入Routers中
    // @ts-ignore
    Routers.push(...allRouters.len1)

    // 截取名称方法：从开始到最后一个'-'之间的字符串
    const substrName = (name) => name.substr(0, name.lastIndexOf('-'))

    /**
     * 正式生成路由：1、将相应的路由放在对应的路由下，形成子路由；2、生成同级路由
     * index：当前文件深度，为maxlen的倒序循环
     * nofindnum：未找到路由的次数
     * newcurr：当前新的深度下的路由数据
     */
    const ceateRouter = (index, nofindnum = 0, newcurr = null) => {
        // 当前深度下的路由数据：优先使用传入的newcurr，其次获取当前深度对应的路由数据
        const curr = newcurr || allRouters['len' + index]
        // 当前深度上一层的路由数据
        const pre = allRouters['len' + (index - 1)]
        // 若 没有上一层的数据了
        if (!pre) {
            // 则表明是属于顶层的路由
            curr.map((c) => {
                let path = '/' + c.fileName.replace('/index', '')
                // if (path.match('_')) path = path.replace('/_', '/:')
                // 将真正的路由path赋值给当前路由
                c.path = path
                // 将当前路由放到Routers里面
                Routers.push(c)
            })
            return
        }

        // 在上一层中 未找到的 当前深度路由数据
        let noFind: any = []

        // 循环当前深度路由数据
        curr?.map((c) => {
            // 在 上一层深度 的路由数据里面查找
            const fobj = pre.find((p) => {
                // 生成 当前深度 当前项 路由的name
                let name = substrName(c.name)
                // 循环nofindnum，当nofindnum>0，则表示已经出现：在上一层中未找到对应的父路由，则需要将 当前深度 当前项 路由的name 再次生成
                for (let i = 0; i < nofindnum; i++) {
                    name = substrName(name)
                }

                return name === p.name
            })
            // 如果 找到了 对应的 父路由数据(fobj)
            if (fobj) {
                // 生成 当前路由的path：1、去掉当前路由中与父路由重复的；2、去掉/；3、将 _ 转为 :；

                let path = c.fileName
                    .replace(fobj.fileName, '')
                    .substr(1)
                    .replace('_', ':')
                if (path.match('/') && !path.match('/:')) {
                    path = path.replace('/index', '')
                }
                if (path === undefined) {
                    throw new Error(
                        `找到了对应的父路由，但是生成子路由的path为【undefined】了`
                    )
                }

                // 将真正的路由path赋值给当前路由
                c.path = path

                // 若：当前路由为 index
                if (path === 'index') {
                    // 1、转为 '' path，''：表明是默认子路由，那父路由就不能存在name属性
                    c.path = ''
                    // 2、将父路由的needDelectName标记为true，表明需要删除它的name
                    fobj.needDelectName = fobj.needDelectName || true
                }
                // 将当前路由放到父路由的children里面
                if (Array.isArray(fobj.children)) fobj.children.push(c)
                else fobj.children = [c]
            } else noFind.push(c) // 表明未找到父路由，则先将当前路由的数据放入noFind中存储起来
        })

        // 若存在：未找到的路由数据，则再次向上一个层级寻找
        if (noFind.length) ceateRouter(index - 1, ++nofindnum, noFind)
    }
    // 倒序循环 最大深度，然后调用生成路由方法
    for (let i = maxLen; i > 1; i--) ceateRouter(i)

    // 路由生成完毕了，应该删除 有默认子路由的父路由的name属性
    const deleteNameFun = (arr) => {
        arr.map((r) => {
            // 删除多余的fileName属性
            delete r.fileName
            // 判断是否需要删除name属性
            if (r.needDelectName) delete r.name
            // 判断完毕了，则要删除needDelectName属性
            delete r.needDelectName
            // 若 存在子路由 则继续调用deleteNameFun，删除name
            if (Array.isArray(r.children)) deleteNameFun(r.children)
        })
    }
    // 调用deleteNameFun，先删除Routers的一级路由的name
    deleteNameFun(Routers)

    // 若存在重定向的路由，则加入重定向
    if (redirect) Routers.unshift({ path: '/', redirect })
    // 返回正儿八经的的路由数据
    return Routers
}<fim_middle>",correct,5015
Container,Container,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args): <fim_suffix> {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,994
Container,Container,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args): <fim_suffix> {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,997
Context,Context,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name
) => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?: <fim_suffix>) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,204
Converter,Converter,447872004859a7953a492bb7f23a814bdf0b3451,"<fim_prefix>const BitLookup = [ 1, 2, 4, 8, 16, 32, 64, 128 ];

export interface Converter
{
  atob?: (s) => string;
  btoa?: (s) => string;
}

// In NodeJS:

// {
//  btoa: (s: string) => { return Buffer.from(s, 'binary').toString('base64') },
//  atob: (s: string) => { return Buffer.from(s, 'base64').toString('binary') },
// }

// In Browser:

// {
//  btoa: window.btoa,
//  atob: window.atob,
// }

export class ListToBitset
{
  list: string[];
  index: { [s: string]: number };
  size: number;
  converter: Converter;

  constructor(list, converter?: <fim_suffix>)
  {
    this.list = list;
    this.converter = converter;
  }

  toBits(l)
  {
    if (! this.index)
    {
      this.size = Math.floor((this.list.length+7)/8);
      this.index = {};
      this.list.forEach((s, i) => { this.index[s] = i });
    }
    let ab = new ArrayBuffer(this.size);
    let u8 = new Uint8Array(ab);
    if (l) l.forEach(s => {
        let n = this.index[s];
        let i = Math.floor(n/8);
        u8[i] |= BitLookup[n % 8];
      });
    return u8;
  }

  toList(u8)
  {
    let list: string[] = [];
    for (let i = 0; i < u8.length; i++)
    {
      let u = u8[i];
      if (u)
      {
        if (u & 1) list.push(this.list[i*8+0]);
        if (u & 2) list.push(this.list[i*8+1]);
        if (u & 4) list.push(this.list[i*8+2]);
        if (u & 8) list.push(this.list[i*8+3]);
        if (u & 16) list.push(this.list[i*8+4]);
        if (u & 32) list.push(this.list[i*8+5]);
        if (u & 64) list.push(this.list[i*8+6]);
        if (u & 128) list.push(this.list[i*8+7]);
      }
    }
    return list;
  }

  base64tou8(base64)
  {
    let raw = this.converter.atob(base64);
    let rawLength = raw.length;
    let u8 = new Uint8Array(new ArrayBuffer(rawLength));
    for (let i = 0; i < rawLength; i++)
      u8[i] = raw.charCodeAt(i);
    return u8;
  }

  u8ToBase64(u8)
  {
    let binary: string[] = [];
    let len = u8.byteLength;
    for (let i = 0; i < len; i++) {
        binary.push(String.fromCharCode(u8[i]));
    }
    return this.converter.btoa(binary.join(''));
}

  fromBitString(base64)
  {
    return this.toList(this.base64tou8(base64));
  }

  toBitString(l)
  {
    // Note: On server, Buffer.from(this.toBits(l)).toString('base64') probably faster
    return this.u8ToBase64(this.toBits(l));
  }
}
<fim_middle>",correct,5135
Currency,Currency,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest() {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency: <fim_suffix> = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions) {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",correct,2971
Cursor,Cursor,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board): <fim_suffix> {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,810
Cursor,Cursor,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board): <fim_suffix> {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,819
Cursor,Cursor,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor): <fim_suffix> {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,821
Cx,Cx,6b2e48994d25dfb77d9f951487af828409217c22,"<fim_prefix>/* Types */

type Tx<T> = () => Promise<T>;
type Cx = () => Promise<unknown>;

export class ReadOnly<T> {
  constructor(public tx) {}
}

export class Mutating<T> {
  constructor(public tx, public cx) {}
}

export class Pivot<T> {
  constructor(public tx) {}
}

type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;

export type Workflow = Generator<Step<any>, void, any>;

/* Constructors */

export const readOnly = <T>(tx) => new ReadOnly<T>(tx);

export const mutating = <T>(tx, cx: <fim_suffix>) =>
  new Mutating<T>(tx, cx);

export const pivot = <T>(tx) => new Pivot<T>(tx);

/* Workflow executor */

export async function run(workflow) {
  // a list of compensating functions
  let cxs: Cx[] = [];
  // a number of pivot operations happened during the workflow
  let nPivots: number = 0;
  // should the workflow be unrolled
  let unrollReason: unknown;

  let next: IteratorResult<Step<unknown>>;
  let res: unknown;

  try {
    next = workflow.next();
  } catch (e) {
    unrollReason = e;
  }

  while (!unrollReason && !next!.done) {
    const flow = next!.value;

    try {
      // execute async operation
      res = await flow.tx();
    } catch (e1) {
      // async exception caught
      try {
        // try rethrowing into workflow -- this acquires a next workflow step;
        // compensating operation is not added, because the atomic forward
        // operation didn't succeed, so nothing to compensate
        next = workflow.throw(e1);
        continue;
      } catch (e2) {
        // rethrowing didn't succeed, unroll
        unrollReason = e2;
        break;
      }
    }

    // async operation succeeds, register its aftereffects
    if (flow instanceof Mutating) {
      cxs.push(flow.cx);
    } else if (flow instanceof Pivot) {
      nPivots++;
    }

    // try acquiring next workflow step
    try {
      next = workflow.next(res);
      continue;
    } catch (e) {
      // caught a sync exception that is not caught inside workflow, unroll
      unrollReason = e;
      break;
    }
  }

  // unroll if error happened
  if (unrollReason) {
    // workflow is not revertible if there were completed pivot operations
    if (nPivots) {
      throw unrollReason;
    }

    for (const cx of cxs.reverse()) {
      // compensating function error means the state is unknown
      // this can only be handled by a caller, so no try-catch
      await cx();
    }
    throw unrollReason;
  }
}
<fim_middle>",correct,3734
Cx,Cx,6b2e48994d25dfb77d9f951487af828409217c22,"<fim_prefix>/* Types */

type Tx<T> = () => Promise<T>;
type Cx = () => Promise<unknown>;

export class ReadOnly<T> {
  constructor(public tx) {}
}

export class Mutating<T> {
  constructor(public tx, public cx: <fim_suffix>) {}
}

export class Pivot<T> {
  constructor(public tx) {}
}

type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;

export type Workflow = Generator<Step<any>, void, any>;

/* Constructors */

export const readOnly = <T>(tx) => new ReadOnly<T>(tx);

export const mutating = <T>(tx, cx) =>
  new Mutating<T>(tx, cx);

export const pivot = <T>(tx) => new Pivot<T>(tx);

/* Workflow executor */

export async function run(workflow) {
  // a list of compensating functions
  let cxs: Cx[] = [];
  // a number of pivot operations happened during the workflow
  let nPivots: number = 0;
  // should the workflow be unrolled
  let unrollReason: unknown;

  let next: IteratorResult<Step<unknown>>;
  let res: unknown;

  try {
    next = workflow.next();
  } catch (e) {
    unrollReason = e;
  }

  while (!unrollReason && !next!.done) {
    const flow = next!.value;

    try {
      // execute async operation
      res = await flow.tx();
    } catch (e1) {
      // async exception caught
      try {
        // try rethrowing into workflow -- this acquires a next workflow step;
        // compensating operation is not added, because the atomic forward
        // operation didn't succeed, so nothing to compensate
        next = workflow.throw(e1);
        continue;
      } catch (e2) {
        // rethrowing didn't succeed, unroll
        unrollReason = e2;
        break;
      }
    }

    // async operation succeeds, register its aftereffects
    if (flow instanceof Mutating) {
      cxs.push(flow.cx);
    } else if (flow instanceof Pivot) {
      nPivots++;
    }

    // try acquiring next workflow step
    try {
      next = workflow.next(res);
      continue;
    } catch (e) {
      // caught a sync exception that is not caught inside workflow, unroll
      unrollReason = e;
      break;
    }
  }

  // unroll if error happened
  if (unrollReason) {
    // workflow is not revertible if there were completed pivot operations
    if (nPivots) {
      throw unrollReason;
    }

    for (const cx of cxs.reverse()) {
      // compensating function error means the state is unknown
      // this can only be handled by a caller, so no try-catch
      await cx();
    }
    throw unrollReason;
  }
}
<fim_middle>",correct,3739
Date,Date,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date): <fim_suffix> {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",correct,693
Date,Date,1cff957f4d2e357142c20a3575489611cf52b52e,"<fim_prefix>export const emailRegex =
  /^(([^<>()\[\]\\.,;:\s@""]+(\.[^<>()\[\]\\.,;:\s@""]+)*)|("".+""))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/

//https://www.twilio.com/docs/glossary/what-e164
const phoneRegex = /^\+[1-9]\d{1,14}$/

export const validateEmpty = (
  value?,
  message?
) => {
  let errorMessage = ''
  if (!value) {
    errorMessage = message || 'Required'
  }
  return errorMessage
}

export const validateMinLength = (
  value,
  minLength,
  fieldName = 'Field'
) =>
  value.length < minLength
    ? `${fieldName} requires at least ${minLength} characters`
    : ''

export const validateEmail = (email, equalTo?) => {
  let validation = ''
  if (equalTo) {
    validation = email === equalTo ? '' : 'Emails must match'
  }
  if (validation) {
    return validation
  }
  return !emailRegex.test(email) ? 'Please enter a valid email address' : ''
}

export const validatePasswords = (password, equalTo) => {
  let validation = ''
  if (equalTo) {
    validation = password === equalTo ? '' : 'Passwords must match'
  }
  if (validation) {
    return validation
  }
  validation = validateEmpty(password)
  if (validation) {
    return validation
  }

  return validateMinLength(password, 6, 'Password')
}

export const validateAge = (
  dateOfBirth: <fim_suffix>,
  minimumAge = 18
) => {
  const today = new Date()
  const age = today.getFullYear() - dateOfBirth.getFullYear()
  return age < minimumAge ? `You must be at least ${minimumAge} years old` : ''
}

interface IValidatePhoneNumber {
  phoneNumber?: string
  customError?: string
}
export const validatePhoneNumber = ({
  phoneNumber,
  customError,
}) => {
  if (!phoneNumber) {
    return customError || 'Please enter a phone number'
  }

  return !phoneRegex.test(`${phoneNumber}`)
    ? customError || 'Please enter a valid phone number'
    : ''
}
<fim_middle>",correct,969
Date,Date,55ca1837cce770e7e7f0bda123564f098fe3a486,"<fim_prefix>export type JalaaliDate = { jy: number; jm: number; jd: number };
export type GregorianDate = { gy: number; gm: number; gd: number };

/**
 * Converts a Gregorian date to Jalaali.
 */
export function toJalaali(date);
export function toJalaali(gy, gm, gd);
export function toJalaali(
  gy,
  gm?,
  gd?,
) {
  if (gy instanceof Date) {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }
  return d2j(g2d(gy, gm!, gd!));
}

/**
 * Converts a Jalaali date to Gregorian.
 */
export function toGregorian(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd));
}

/**
 * Checks whether a Jalaali date is valid or not.
 */
export function isValidJalaaliDate(
  jy,
  jm,
  jd,
) {
  return (
    jy >= minJalaaliYear &&
    jy <= maxJalaaliYear &&
    jm >= 1 &&
    jm <= 12 &&
    jd >= 1 &&
    jd <= jalaaliMonthLength(jy, jm)
  );
}

/**
 * Is this a leap year or not?
 */
export function isLeapJalaaliYear(jy) {
  return jalCalLeap(jy) === 0;
}

/**
 * The number of days in a given month in a Jalaali year.
 */
export function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) {
    return 31;
  }
  if (jm <= 11) {
    return 30;
  }
  if (isLeapJalaaliYear(jy)) {
    return 30;
  }
  return 29;
}

/**
 * This function determines if the Jalaali (Persian) year is
 * leap (366-day long) or is the common year (365 days), and
 * finds the day in March (Gregorian calendar) of the first
 * day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @param withoutLeap when don't need leap (true or false) default is false
 * @returns
 *   leap: number of years since the last leap year (0 to 4)
 *   gy: Gregorian year of the beginning of Jalaali year
 *   march: the March day of Farvardin the 1st (1st day of jy)
 * @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
 * @see: http://www.fourmilab.ch/documents/calendar/
 */
export function jalCal(jy, withoutLeap = false) {
  validateJalaaliYear(jy);

  let jump = 0;
  let leapJ = -14;
  let jp = minJalaaliYear;
  // Find the limiting years for the Jalaali year jy.
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
      leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
    }
  }
  let n = jy - jp;

  // Find the number of leap years from AD 621 to the beginning
  // of the current Jalaali year in the Persian calendar.
  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
  if (mod(jump, 33) === 4 && jump - n === 4) {
    leapJ += 1;
  }

  const gy = jy + 621;

  // And the same in the Gregorian calendar (until the year gy).
  const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

  // Determine the Gregorian date of Farvardin the 1st.
  const march = 20 + leapJ - leapG;

  // return with gy and march when we don't need leap
  if (withoutLeap) {
    return {
      gy,
      march,
    };
  }

  // Find how many years have passed since the last leap year.
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }
  let leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }

  return {
    leap,
    gy,
    march,
  };
}

/**
 * Converts a date of the Jalaali calendar to the Julian Day number.
 *
 * @param jy Jalaali year (1 to 3100)
 * @param jm Jalaali month (1 to 12)
 * @param jd Jalaali day (1 to 29/31)
 * @returns Julian Day number
 */
export function j2d(jy, jm, jd) {
  const { gy, march } = jalCal(jy, true);
  return g2d(gy, 3, march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
}

/**
 * Converts the Julian Day number to a date in the Jalaali calendar.
 *
 * @param jdn Julian Day number
 * @returns
 *   jy: Jalaali year (1 to 3100)
 *   jm: Jalaali month (1 to 12)
 *   jd: Jalaali day (1 to 29/31)
 */
export function d2j(jdn) {
  const gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
  let jy = gy - 621;
  const r = jalCal(jy, false);
  const jdn1f = g2d(gy, 3, r.march);
  let jd;
  let jm;
  let k;

  // Find number of days that passed since 1 Farvardin.
  k = jdn - jdn1f;
  if (k >= 0) {
    if (k <= 185) {
      // The first 6 months.
      jm = 1 + div(k, 31);
      jd = mod(k, 31) + 1;
      return { jy: jy, jm: jm, jd: jd };
    } else {
      // The remaining months.
      k -= 186;
    }
  } else {
    // Previous Jalaali year.
    jy -= 1;
    k += 179;
    if (r.leap === 1) k += 1;
  }
  jm = 7 + div(k, 30);
  jd = mod(k, 30) + 1;
  return { jy: jy, jm: jm, jd: jd };
}

/**
 * Calculates the Julian Day number from Gregorian or Julian
 * calendar dates. This integer number corresponds to the noon of
 * the date (i.e. 12 hours of Universal Time).
 * The procedure was tested to be good since 1 March, -100100 (of both
 * calendars) up to a few million years into the future.
 *
 * @param gy Calendar year (years BC numbered 0, -1, -2, ...)
 * @param gm Calendar month (1 to 12)
 * @param gd Calendar day of the month (1 to 28/29/30/31)
 * @returns Julian Day number
 */
export function g2d(gy, gm, gd) {
  let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) +
    div(153 * mod(gm + 9, 12) + 2, 5) +
    gd -
    34840408;
  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
  return d;
}

/**
 * Calculates Gregorian and Julian calendar dates from the Julian Day number
 * (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
 * calendars) to some millions of years ahead of the present.
 *
 * @param jdn Julian Day number
 * @returns
 *   gy: Calendar year (years BC numbered 0, -1, -2, ...)
 *   gm: Calendar month (1 to 12)
 *   gd: Calendar day of the month M (1 to 28/29/30/31)
 */
export function d2g(jdn) {
  let j = 4 * jdn + 139361631;
  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  const i = div(mod(j, 1461), 4) * 5 + 308;
  const gd = div(mod(i, 153), 5) + 1;
  const gm = mod(div(i, 153), 12) + 1;
  const gy = div(j, 1461) - 100100 + div(8 - gm, 6);
  return { gy, gm, gd };
}

/**
 * Returns Saturday and Friday day of the current week
 * (week starts on Saturday)
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @returns Saturday and Friday of the current week
 */
export function jalaaliWeek(jy, jm, jd) {
  const dayOfWeek = jalaaliToDateObject(jy, jm, jd).getDay();

  const startDayDifference = dayOfWeek == 6 ? 0 : -(dayOfWeek + 1);
  const endDayDifference = 6 + startDayDifference;

  return {
    saturday: d2j(j2d(jy, jm, jd + startDayDifference)),
    friday: d2j(j2d(jy, jm, jd + endDayDifference)),
  };
}

/**
 * Convert Jalaali calendar dates to javascript Date object
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @param [h] hours
 * @param [m] minutes
 * @param [s] seconds
 * @param [ms] milliseconds
 * @returns Date object of the jalaali calendar dates
 */
export function jalaaliToDateObject(
  jy,
  jm,
  jd,
  h = 0,
  m = 0,
  s = 0,
  ms = 0,
): <fim_suffix> {
  const { gy, gm, gd } = toGregorian(jy, jm, jd);

  return new Date(gy, gm - 1, gd, h, m, s, ms);
}

/**
 * Checks wether the jalaali year is between min and max
 */
function validateJalaaliYear(jy) {
  if (jy < minJalaaliYear || jy > maxJalaaliYear) {
    throw new Error(`Invalid Jalaali year ${jy}`);
  }
}

/**
 * This function determines if the Jalaali (Persian) year is a leap
 * (366-day long) or is the common year (365 days), and finds the day in March
 * (Gregorian calendar) of the first day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @returns number of years since the last leap year (0 to 4)
 */
function jalCalLeap(jy) {
  validateJalaaliYear(jy);

  let jump = 0;
  let jp = minJalaaliYear;
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
    }
  }

  let n = jy - jp;
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }

  const leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    return 4;
  }
  return leap;
}

/**
 * Utility helper functions.
 */
function div(a, b) {
  return ~~(a / b);
}
function mod(a, b) {
  return a - ~~(a / b) * b;
}

/**
 * Jalaali years starting the 33-year rule.
 */
const breaks: number[] = [
  -61,
  9,
  38,
  199,
  426,
  686,
  756,
  818,
  1111,
  1181,
  1210,
  1635,
  2060,
  2097,
  2192,
  2262,
  2324,
  2394,
  2456,
  3178,
];

const minJalaaliYear = breaks[0];
const maxJalaaliYear = breaks[breaks.length - 1] - 1;
<fim_middle>",correct,2195
Date,Date,22df358673565dcee46071280b05b031077329af,"<fim_prefix>export type MonthAndYearType = {
  string: string
  date: Date
}

const monthStrings = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'Novemeber',
  'Decemeber',
]

export const getMonthAndYearOptions = () => {
  const date = new Date()
  const year = date.getFullYear()
  const startMonth = date.getMonth()
  const months: MonthAndYearType[] = []

  for (let i = 0; i < 12; i++) {
    if (startMonth + i > 11) {
      months.push({
        string: `${monthStrings[startMonth + i - 12]} ${year + 1}`,
        date: new Date(year + 1, startMonth + i - 12, 1),
      })
    } else {
      months.push({
        string: `${monthStrings[startMonth + i]} ${year}`,
        date: new Date(year, startMonth + i, 1),
      })
    }
  }

  return months
}

export const sameMonthAndYear = (dateA, dateB) => {
  return (
    dateA.getMonth() === dateB.getMonth() &&
    dateA.getFullYear() === dateB.getFullYear()
  )
}

export const getNextMonth = (date) => {
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 11) {
    return new Date(year + 1, 0, 1)
  }

  return new Date(year, month + 1, 1)
}

export const getPreviousMonth = (date) => {
  const today = new Date()
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 0) {
    if (today.getFullYear() === year - 1 && today.getMonth() === 11) {
      return new Date(year - 1, 11, today.getDate())
    }
    return new Date(year - 1, 11, 1)
  }

  if (today.getFullYear() === year && today.getMonth() === month - 1) {
    return new Date(year, month - 1, today.getDate())
  }
  return new Date(year, month - 1, 1)
}

const getDateString = (year, month, day) => {
  return new Date(year, month, day).toDateString()
}

const isLeapYear = (date) => {
  const year = date.getFullYear()

  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
}

const getDaysInMonth = (date) => {
  const leapYear = isLeapYear(date)
  const month = date.getMonth()

  // getMonth() returns zero indexed month, so each month is the normal month number - 1
  // I.E. January is 0, February is 1, March is 2, etc.
  switch (month) {
    case 1:
      if (leapYear) {
        return 29
      }
      return 28
    case 3:
    case 5:
    case 8:
    case 10:
      return 30
    default:
      return 31
  }
}

export const generateDays = (date: <fim_suffix>) => {
  const year = date.getFullYear()
  const month = date.getMonth()
  const daysInMonth = getDaysInMonth(date)
  const today = new Date()
  const days = []

  for (let i = 1; i < daysInMonth + 1; i++) {
    if (
      i < today.getDate() &&
      month <= today.getMonth() &&
      year <= today.getFullYear()
    ) {
      days.push({
        date: i,
        disabled: true,
        dateString: getDateString(year, month, i),
      })
    } else {
      days.push({
        date: i,
        disabled: false,
        dateString: getDateString(year, month, i),
      })
    }
  }

  return days
}

// Generates an array of ""skip days"" to place the first day of the month
// on the right day of the week
export const getSkipDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  const firstDay = new Date(year, month, 1).getDay()
  const skipppedDays = []
  for (let i = 0; i < firstDay; i++) {
    skipppedDays.push(i)
  }

  return skipppedDays
}

export const getMonthAndYearString = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  return `${monthStrings[month]} ${year}`
}
<fim_middle>",correct,3178
Date,Date,22df358673565dcee46071280b05b031077329af,"<fim_prefix>export type MonthAndYearType = {
  string: string
  date: Date
}

const monthStrings = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'Novemeber',
  'Decemeber',
]

export const getMonthAndYearOptions = () => {
  const date = new Date()
  const year = date.getFullYear()
  const startMonth = date.getMonth()
  const months: MonthAndYearType[] = []

  for (let i = 0; i < 12; i++) {
    if (startMonth + i > 11) {
      months.push({
        string: `${monthStrings[startMonth + i - 12]} ${year + 1}`,
        date: new Date(year + 1, startMonth + i - 12, 1),
      })
    } else {
      months.push({
        string: `${monthStrings[startMonth + i]} ${year}`,
        date: new Date(year, startMonth + i, 1),
      })
    }
  }

  return months
}

export const sameMonthAndYear = (dateA, dateB) => {
  return (
    dateA.getMonth() === dateB.getMonth() &&
    dateA.getFullYear() === dateB.getFullYear()
  )
}

export const getNextMonth = (date: <fim_suffix>) => {
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 11) {
    return new Date(year + 1, 0, 1)
  }

  return new Date(year, month + 1, 1)
}

export const getPreviousMonth = (date) => {
  const today = new Date()
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 0) {
    if (today.getFullYear() === year - 1 && today.getMonth() === 11) {
      return new Date(year - 1, 11, today.getDate())
    }
    return new Date(year - 1, 11, 1)
  }

  if (today.getFullYear() === year && today.getMonth() === month - 1) {
    return new Date(year, month - 1, today.getDate())
  }
  return new Date(year, month - 1, 1)
}

const getDateString = (year, month, day) => {
  return new Date(year, month, day).toDateString()
}

const isLeapYear = (date) => {
  const year = date.getFullYear()

  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
}

const getDaysInMonth = (date) => {
  const leapYear = isLeapYear(date)
  const month = date.getMonth()

  // getMonth() returns zero indexed month, so each month is the normal month number - 1
  // I.E. January is 0, February is 1, March is 2, etc.
  switch (month) {
    case 1:
      if (leapYear) {
        return 29
      }
      return 28
    case 3:
    case 5:
    case 8:
    case 10:
      return 30
    default:
      return 31
  }
}

export const generateDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()
  const daysInMonth = getDaysInMonth(date)
  const today = new Date()
  const days = []

  for (let i = 1; i < daysInMonth + 1; i++) {
    if (
      i < today.getDate() &&
      month <= today.getMonth() &&
      year <= today.getFullYear()
    ) {
      days.push({
        date: i,
        disabled: true,
        dateString: getDateString(year, month, i),
      })
    } else {
      days.push({
        date: i,
        disabled: false,
        dateString: getDateString(year, month, i),
      })
    }
  }

  return days
}

// Generates an array of ""skip days"" to place the first day of the month
// on the right day of the week
export const getSkipDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  const firstDay = new Date(year, month, 1).getDay()
  const skipppedDays = []
  for (let i = 0; i < firstDay; i++) {
    skipppedDays.push(i)
  }

  return skipppedDays
}

export const getMonthAndYearString = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  return `${monthStrings[month]} ${year}`
}
<fim_middle>",correct,3185
Date,Date,22df358673565dcee46071280b05b031077329af,"<fim_prefix>export type MonthAndYearType = {
  string: string
  date: Date
}

const monthStrings = [
  'January',
  'February',
  'March',
  'April',
  'May',
  'June',
  'July',
  'August',
  'September',
  'October',
  'Novemeber',
  'Decemeber',
]

export const getMonthAndYearOptions = () => {
  const date = new Date()
  const year = date.getFullYear()
  const startMonth = date.getMonth()
  const months: MonthAndYearType[] = []

  for (let i = 0; i < 12; i++) {
    if (startMonth + i > 11) {
      months.push({
        string: `${monthStrings[startMonth + i - 12]} ${year + 1}`,
        date: new Date(year + 1, startMonth + i - 12, 1),
      })
    } else {
      months.push({
        string: `${monthStrings[startMonth + i]} ${year}`,
        date: new Date(year, startMonth + i, 1),
      })
    }
  }

  return months
}

export const sameMonthAndYear = (dateA, dateB: <fim_suffix>) => {
  return (
    dateA.getMonth() === dateB.getMonth() &&
    dateA.getFullYear() === dateB.getFullYear()
  )
}

export const getNextMonth = (date) => {
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 11) {
    return new Date(year + 1, 0, 1)
  }

  return new Date(year, month + 1, 1)
}

export const getPreviousMonth = (date) => {
  const today = new Date()
  const month = date.getMonth()
  const year = date.getFullYear()

  if (month === 0) {
    if (today.getFullYear() === year - 1 && today.getMonth() === 11) {
      return new Date(year - 1, 11, today.getDate())
    }
    return new Date(year - 1, 11, 1)
  }

  if (today.getFullYear() === year && today.getMonth() === month - 1) {
    return new Date(year, month - 1, today.getDate())
  }
  return new Date(year, month - 1, 1)
}

const getDateString = (year, month, day) => {
  return new Date(year, month, day).toDateString()
}

const isLeapYear = (date) => {
  const year = date.getFullYear()

  return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
}

const getDaysInMonth = (date) => {
  const leapYear = isLeapYear(date)
  const month = date.getMonth()

  // getMonth() returns zero indexed month, so each month is the normal month number - 1
  // I.E. January is 0, February is 1, March is 2, etc.
  switch (month) {
    case 1:
      if (leapYear) {
        return 29
      }
      return 28
    case 3:
    case 5:
    case 8:
    case 10:
      return 30
    default:
      return 31
  }
}

export const generateDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()
  const daysInMonth = getDaysInMonth(date)
  const today = new Date()
  const days = []

  for (let i = 1; i < daysInMonth + 1; i++) {
    if (
      i < today.getDate() &&
      month <= today.getMonth() &&
      year <= today.getFullYear()
    ) {
      days.push({
        date: i,
        disabled: true,
        dateString: getDateString(year, month, i),
      })
    } else {
      days.push({
        date: i,
        disabled: false,
        dateString: getDateString(year, month, i),
      })
    }
  }

  return days
}

// Generates an array of ""skip days"" to place the first day of the month
// on the right day of the week
export const getSkipDays = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  const firstDay = new Date(year, month, 1).getDay()
  const skipppedDays = []
  for (let i = 0; i < firstDay; i++) {
    skipppedDays.push(i)
  }

  return skipppedDays
}

export const getMonthAndYearString = (date) => {
  const year = date.getFullYear()
  const month = date.getMonth()

  return `${monthStrings[month]} ${year}`
}
<fim_middle>",correct,3186
Date,Date,88616d2acf8d66a97538d1bb1d1d2e0761bd2463,"<fim_prefix>export interface TimeDelta {
  sign: '' | '+',
  years: number,
  months: number,
  days: number,
  hours: number,
  minutes: number,
  seconds: number,
}

export interface AgeOptions {
  /**
   * Comparison date
   */
  now?: Date;

  /**
   * Precision
   */
  levels?: number;
}

/**
 * Get the ymdhms differences between two dates
 *
 * @param left  + date value
 * @param right - date value
 * @returns     difference between the two dates
 */
export function getTimeDelta(
  left,
  right,
) {
  const {
    secondsPerSecond: secondsPerSecond,
    secondsPerMinute: secondsPerMinute,
    secondsPerHour: secondsPerHour,
    secondsPerDay: secondsPerDay,
    secondsPerMonth: secondsPerMonth,
    secondsPerYear: secondsPerYear,
  } = getAge.defaults;

  const leftMs = left.valueOf();
  const rightMs = right.valueOf();
  let delta = Math.abs(leftMs - rightMs) / 1000;

  const years = Math.floor(delta / secondsPerYear);
  delta -= years * secondsPerYear;

  const months = Math.floor(delta / secondsPerMonth);
  delta -= months * secondsPerMonth;

  const days = Math.floor(delta / secondsPerDay);
  delta -= days * secondsPerDay;

  const hours = Math.floor(delta / secondsPerHour);
  delta -= hours * secondsPerHour;

  const minutes = Math.floor(delta / secondsPerMinute);
  delta -= minutes * secondsPerMinute;

  const seconds = Math.floor(delta / secondsPerSecond);
  delta -= seconds * secondsPerSecond;

  const timeDelta: TimeDelta = {
    sign: leftMs < rightMs ? '+' : '',
    years,
    months,
    days,
    hours,
    minutes,
    seconds,
  };

  return timeDelta;
}


/**
 * Get the approximate age of the given date from now
 *
 * @param birth     date to find the age of
 * @param options
 * @returns         approximate age of the date
 *
 * @example
 * ```ts
 * '2y3m4d'
 * '2y4d1h'
 * '3y2m1s'
 * '17s'
 * ```
 */
export function getAge(
  birth: <fim_suffix>,
  options?
) {
  const now = options?.now ?? getAge.defaults.NOW();
  const levels = options?.levels ?? getAge.defaults.LEVELS;
  const delta = getTimeDelta(now, birth);
  let str = delta.sign;
  let cnt = 0;

  if (levels < 0) {
    throw new TypeError(`getAge(): ""levels"" must be >= 0. Given: ${levels}.`);
  }

  // years

  if (delta.years) {
    str += `${delta.years}y`;
    cnt += 1;
  }

  // months

  if (cnt >= levels) return str;

  if (delta.months) {
    str += `${delta.months}m`;
    cnt += 1;
  }

  // days

  if (cnt >= levels) return str;

  if (delta.days) {
    str += `${delta.days}d`;
    cnt += 1;
  }

  // hours

  if (cnt >= levels) return str;

  if (delta.hours) {
    str += `${delta.hours}h`;
    cnt += 1;
  }

  // minutes

  if (cnt >= levels) return str;

  if (delta.minutes) {
    str += `${delta.minutes}m`;
    cnt += 1;
  }

  // seconds

  if (cnt >= levels) return str;

  if (delta.seconds) {
    str += `${delta.seconds}s`;
    cnt += 1;
  }

  // if there is no difference, show zero seconds...

  if (cnt === 0) {
    str += '0s';
  }

  return str;
}

/**
 * defaults for usage with `@nkp/age` functions
 */
getAge.defaults = {
  secondsPerSecond: 1,
  secondsPerMinute: 1 * 60,
  secondsPerHour  : 1 * 60 * 60,
  secondsPerDay   : 1 * 60 * 60 * 24,
  // on average 30.437 days in a month
  secondsPerMonth : 1 * 60 * 60 * 24 * 30.437,
  // SECONDS_PER_MONTH : 1 * 60 * 60 * 24 * 30,
  // on average 365.24 days in a year
  secondsPerYear  : 1 * 60 * 60 * 24 * 365.24,
  // SECONDS_PER_YEAR  : 1 * 60 * 60 * 24 * 365,

  NOW: () => new Date(),
  LEVELS: 3,
};
<fim_middle>",correct,3429
Date,Date,88616d2acf8d66a97538d1bb1d1d2e0761bd2463,"<fim_prefix>export interface TimeDelta {
  sign: '' | '+',
  years: number,
  months: number,
  days: number,
  hours: number,
  minutes: number,
  seconds: number,
}

export interface AgeOptions {
  /**
   * Comparison date
   */
  now?: Date;

  /**
   * Precision
   */
  levels?: number;
}

/**
 * Get the ymdhms differences between two dates
 *
 * @param left  + date value
 * @param right - date value
 * @returns     difference between the two dates
 */
export function getTimeDelta(
  left,
  right: <fim_suffix>,
) {
  const {
    secondsPerSecond: secondsPerSecond,
    secondsPerMinute: secondsPerMinute,
    secondsPerHour: secondsPerHour,
    secondsPerDay: secondsPerDay,
    secondsPerMonth: secondsPerMonth,
    secondsPerYear: secondsPerYear,
  } = getAge.defaults;

  const leftMs = left.valueOf();
  const rightMs = right.valueOf();
  let delta = Math.abs(leftMs - rightMs) / 1000;

  const years = Math.floor(delta / secondsPerYear);
  delta -= years * secondsPerYear;

  const months = Math.floor(delta / secondsPerMonth);
  delta -= months * secondsPerMonth;

  const days = Math.floor(delta / secondsPerDay);
  delta -= days * secondsPerDay;

  const hours = Math.floor(delta / secondsPerHour);
  delta -= hours * secondsPerHour;

  const minutes = Math.floor(delta / secondsPerMinute);
  delta -= minutes * secondsPerMinute;

  const seconds = Math.floor(delta / secondsPerSecond);
  delta -= seconds * secondsPerSecond;

  const timeDelta: TimeDelta = {
    sign: leftMs < rightMs ? '+' : '',
    years,
    months,
    days,
    hours,
    minutes,
    seconds,
  };

  return timeDelta;
}


/**
 * Get the approximate age of the given date from now
 *
 * @param birth     date to find the age of
 * @param options
 * @returns         approximate age of the date
 *
 * @example
 * ```ts
 * '2y3m4d'
 * '2y4d1h'
 * '3y2m1s'
 * '17s'
 * ```
 */
export function getAge(
  birth,
  options?
) {
  const now = options?.now ?? getAge.defaults.NOW();
  const levels = options?.levels ?? getAge.defaults.LEVELS;
  const delta = getTimeDelta(now, birth);
  let str = delta.sign;
  let cnt = 0;

  if (levels < 0) {
    throw new TypeError(`getAge(): ""levels"" must be >= 0. Given: ${levels}.`);
  }

  // years

  if (delta.years) {
    str += `${delta.years}y`;
    cnt += 1;
  }

  // months

  if (cnt >= levels) return str;

  if (delta.months) {
    str += `${delta.months}m`;
    cnt += 1;
  }

  // days

  if (cnt >= levels) return str;

  if (delta.days) {
    str += `${delta.days}d`;
    cnt += 1;
  }

  // hours

  if (cnt >= levels) return str;

  if (delta.hours) {
    str += `${delta.hours}h`;
    cnt += 1;
  }

  // minutes

  if (cnt >= levels) return str;

  if (delta.minutes) {
    str += `${delta.minutes}m`;
    cnt += 1;
  }

  // seconds

  if (cnt >= levels) return str;

  if (delta.seconds) {
    str += `${delta.seconds}s`;
    cnt += 1;
  }

  // if there is no difference, show zero seconds...

  if (cnt === 0) {
    str += '0s';
  }

  return str;
}

/**
 * defaults for usage with `@nkp/age` functions
 */
getAge.defaults = {
  secondsPerSecond: 1,
  secondsPerMinute: 1 * 60,
  secondsPerHour  : 1 * 60 * 60,
  secondsPerDay   : 1 * 60 * 60 * 24,
  // on average 30.437 days in a month
  secondsPerMonth : 1 * 60 * 60 * 24 * 30.437,
  // SECONDS_PER_MONTH : 1 * 60 * 60 * 24 * 30,
  // on average 365.24 days in a year
  secondsPerYear  : 1 * 60 * 60 * 24 * 365.24,
  // SECONDS_PER_YEAR  : 1 * 60 * 60 * 24 * 365,

  NOW: () => new Date(),
  LEVELS: 3,
};
<fim_middle>",correct,3431
Date,Date,dadf55286f28793ab229a3f259e1af36d5c7836a,"<fim_prefix>interface Embed {
	title: string
	description: string
	url: string
	timestamp: Date
	color: number
	footer: {
		text: string
		icon_url: string
	}
	thumbnail: {
		url: string
	}
	image: {
		url: string
	}
	fields: {
		name: string
		value: string
		inline: boolean
	}[]
	author: {
		name: string
		url: string
		icon_url: string
	}
}
class Embed {
	constructor() {
		this.title = ''
		this.description = ''
		this.url = ''
		this.color = 0
		this.timestamp = new Date()
		this.footer = {
			text: '',
			icon_url: ''
		}
		this.image = {
			url: ''
		}
		this.thumbnail = {
			url: ''
		}
		this.author = {
			name: '',
			url: '',
			icon_url: ''
		}
		this.fields = []
	}
	setTitle(title) {
		this.title = title
		return this
	}
	setDescription(description) {
		this.description = description
		return this
	}
	setURL(url) {
		this.url = url
		return this
	}
	setTimestamp(timestamp: <fim_suffix>) {
		this.timestamp = timestamp
		return this
	}
	setColor(color) {
		this.color = color
		return this
	}
	setFooter(text, icon) {
		this.footer.text = text
		this.footer.icon_url = icon
		return this
	}
	setThumbnail(url) {
		this.thumbnail.url = url
		return this
	}
	setImage(url) {
		this.image.url = url
		return this
	}
	setAuthor(name, url, icon) {
		this.author.name = name
		this.author.url = url
		this.author.icon_url = icon
		return this
	}
	addField(name, value, inline = false) {
		this.fields.push({
			name,
			value,
			inline
		})
		return this
	}
	toJSON() {
		return {
			title: this.title,
			description: this.description,
			url: this.url,
			timestamp: this.timestamp,
			color: this.color,
			footer: this.footer,
			thumbnail: this.thumbnail,
			image: this.image,
			fields: this.fields,
			author: this.author
		}
	}
}
<fim_middle>",correct,3570
Date,Date,09d130eaf6fa6284f1fb610e8f53944921615073,"<fim_prefix>
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;

export function range(start = 0, stop, step = 1) {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}

/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {number} year
 * @returns {boolean}
 */
export function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}

export function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}

/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {number} year
 * @param {number} month
 * @returns {number[]}
 */
export function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error(""Invalid month specified"");
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}

export interface ICalendarDate {
    date: Date;
    isCurrentMonth: boolean;
    isPrevMonth: boolean;
    isNextMonth: boolean;
}

export enum WEEKDAYS {
    SUNDAY = 0,
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6
}

export class Calendar {

    private _firstWeekDay: number | WEEKDAYS;

    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }

    public get firstWeekDay() {
        return this._firstWeekDay % 7;
    }

    public set firstWeekDay(value) {
        this._firstWeekDay = value;
    }

    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns {number[]}
     *
     * @memberof Calendar
     */
    public weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }

    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param {number} year
     * @param {number} month
     * @param {extraWeek} boolean
     * @returns {ICalendarDate[]}
     *
     * @memberof Calendar
     */
    public monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1, 12, 0, 0, 0);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, ""day"", -days);
        const res = [];
        let value: ICalendarDate;

        while (true) {

            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, ""day"", 1);

            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const i of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, ""day"", 1);
                    }
                }
                break;
            }
        }
        return res;
    }

    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param {number} year
     * @param {number} month
     * @returns {ICalendarDate[][]}
     *
     * @memberof Calendar
     */
    public monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }

    public timedelta(date, interval, units): <fim_suffix> {
        const ret = new Date(date);

        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };

        switch (interval.toLowerCase()) {
            case ""year"":
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case ""quarter"":
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case ""month"":
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case ""week"":
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case ""day"":
                ret.setDate(ret.getDate() + units);
                break;
            case ""hour"":
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case ""minute"":
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case ""second"":
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error(""Invalid interval specifier"");
        }
        return ret;
    }

    private generateICalendarDate(date, year, month) {
            return {
                date,
                isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
                isNextMonth: this.isNextMonth(date, year, month),
                isPrevMonth: this.isPreviousMonth(date, year, month)
            };
        }
    private isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }

    private isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
<fim_middle>",correct,4098
Date,Date,87c45d173a88a8085fea7c65e036d9547bec5542,"<fim_prefix>/* eslint-disable @typescript-eslint/no-explicit-any,no-cond-assign,no-restricted-syntax,no-continue */
type EqualFn = (a, b) => boolean;

export const compareDates = (a, b: <fim_suffix>) => a.getTime() === b.getTime();

export const compareRegexps = (a, b) =>
  a.source === b.source && a.flags === b.flags;

export const compareArrays = (a, b, equal) => {
  let l = a.length;
  if (l !== b.length) return false;

  while (l-- && equal(a[l], b[l]));

  return l === -1;
};

export const compareMaps = (a, b, equal) => {
  if (a.size !== b.size) return false;
  const it = a.entries();
  let i: any;

  while (!(i = it.next()).done) {
    if (!b.has(i.value[0]) || !equal(i.value[1], b.get(i.value[0]))) return false;
  }

  return true;
};

export const compareSets = (a, b) => {
  if (a.size !== b.size) return false;
  const it = a.values();
  let i: any;

  while (!(i = it.next()).done) {
    if (!b.has(i.value)) return false;
  }

  return true;
};

export const compareDataViews = (a, b) => {
  let l = a.byteLength;
  if (l !== b.byteLength) return false;

  while (l-- && a.getInt8(l) === b.getInt8(l));

  return l === -1;
};

export const compareArrayBuffers = (a, b) => {
  let l = a.length;
  if (l !== b.length) return false;

  while (l-- && a[l] === b[l]);

  return l === -1;
};

const { hasOwnProperty } = Object.prototype;
const oKeys = Object.keys;

export const compareObjects = (
  a,
  b,
  equal
) => {
  let i;
  let len = 0;

  for (i in a) {
    if (hasOwnProperty.call(a, i)) {
      len++;

      if (!hasOwnProperty.call(b, i)) return false;

      if (!equal(a[i], b[i])) return false;
    }
  }

  return oKeys(b).length === len;
};

export const compareObjectsReact = (
  a,
  b,
  equal
) => {
  let i;
  let len = 0;

  for (i in a) {
    if (hasOwnProperty.call(a, i)) {
      len++;
      if (a.$$typeof && (i === '_owner' || i === '__v' || i === '__o')) {
        // in React and Preact these properties contain circular references
        // .$$typeof is just reasonable marker of element

        continue;
      }

      if (!hasOwnProperty.call(b, i)) return false;

      if (!equal(a[i], b[i])) return false;
    }
  }

  return oKeys(b).length === len;
};
<fim_middle>",correct,4325
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date): <fim_suffix> => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5248
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date): <fim_suffix> => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5250
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end: <fim_suffix>, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5256
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start: <fim_suffix>, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5257
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date: <fim_suffix>, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5258
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date: <fim_suffix>, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5261
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b: <fim_suffix>) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5263
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b: <fim_suffix>) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5266
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0) => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a: <fim_suffix>, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5267
Date,Date,818a2300376cab79a024aa225b6f0e82d422faf1,"<fim_prefix>/**
 * 获取传入月份的上个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getLastMonth = (year, month) => {
  if (month === 0) {
    return {
      year: year - 1,
      month: 11,
    };
  }
  return {
    year,
    month: month - 1,
  };
};

/**
 * 获取传入月的下个月
 * @param year number
 * @param month number
 * @returns { year: number; month: number }
 */
export const getNextMonth = (year, month) => {
  if (month === 11) {
    return {
      year: year + 1,
      month: 0,
    };
  }
  return {
    year,
    month: month + 1,
  };
};

/**
 * 判断传入的年份是否是闰年
 * @param year number
 * @returns boolean
 */
const isLeap = (year) => {
  return (year % 4 === 0 && year % 100 === 0) || year % 400 === 0;
};

/**
 * 获取传入年所在月的最大天数
 * @param year number
 * @param month number
 * @returns number
 */
export const getMaxDayNumOfYearMonth = (year, month) => {
  switch (month) {
    case 0:
    case 2:
    case 4:
    case 6:
    case 7:
    case 9:
    case 11:
      return 31;
    case 1:
      return isLeap(year) ? 29 : 28;
    default:
      return 30;
  }
};

/**
 * 获取指定年所在月的第一天是星期几
 * 返回一个0到6之间的整数值，代表星期几： 0 代表星期日
 * @param year number
 * @param month number
 * @returns number
 */
export const getFirstDayOfYearMonth = (year, month) => {
  const date = new Date(year, month, 1);
  return date.getDay();
};

const PER_DAY_MILLISECONDS = 86400000; // 24 * 60 * 60 * 1000

/**
 * 获取指定年所在月的第一天
 * @param year number
 * @param month number
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns Date
 */
export const getStartDateOfCalendar = (year, month, startOfWeek = 0): <fim_suffix> => {
  const date = new Date(year, month, 1);
  const day = date.getDay();
  date.setTime(date.getTime() - PER_DAY_MILLISECONDS * ((day - startOfWeek + 7) % 7));
  return date;
};

export interface MonthItem {
  year: number;
  month: number;
}

/**
 * 比较两个月的大小
 * @param a MonthItem
 * @param b MonthItem
 * @returns number
 */
export const compareMonth = (a, b) => {
  if (a.year === b.year) {
    if (a.month === b.month) {
      return 0;
    }

    return a.month > b.month ? 1 : -1;
  }

  return a.year > b.year ? 1 : -1;
};

/**
 * 比较两个日期大小
 * @param a Date
 * @param b Date
 * @returns number 0 means same date, 1 means a > b
 */
export const compareDate = (a, b) => {
  const aYear = a.getFullYear();
  const aMonth = a.getMonth();
  const aDate = a.getDate();
  const bYear = b.getFullYear();
  const bMonth = b.getMonth();
  const bDate = b.getDate();

  if (aYear === bYear) {
    if (aMonth === bMonth) {
      if (aDate === bDate) {
        return 0;
      }

      return aDate > bDate ? 1 : -1;
    }

    return aMonth > bMonth ? 1 : -1;
  }

  return aYear > bYear ? 1 : -1;
};

/**
 * 判断是否是同一天
 * @param a Date
 * @param b Date
 * @returns boolean
 */
export const isSameDay = (a, b) => {
  if (!a || !b) {
    return false;
  }
  return compareDate(a, b) === 0;
};

/**
 * 判断日期是否在所给的列表中
 * @param date Date
 * @param days Date[]
 * @returns boolean
 */
export const isInRange = (date, days) => {
  if (!date || !days) {
    return false;
  }

  return days.some((day) => isSameDay(day, date));
};

/**
 * 判断给定的日期是否在两个日期之间
 * @param date Date
 * @param start Date
 * @param end Date
 * @param include boolean 是否包含等于
 * @returns boolean
 */
export const isInRange2 = (date, start, end, include = false) => {
  if (!date || !start || !end) {
    return false;
  }

  let startDate = start;
  let endDate = end;
  if (start > end) {
    startDate = end;
    endDate = start;
  }

  return include
    ? compareDate(date, startDate) >= 0 && compareDate(date, endDate) <= 0
    : compareDate(date, startDate) > 0 && compareDate(date, endDate) < 0;
};

export interface YearRange {
  start: number;
  end: number;
}

/**
 * 获取指定年的10年间起始的年，如2021 => [2020, 2029]
 * @param year number
 * @returns YearRange
 */
export const getYearRange = (year?) => {
  const y = year || new Date().getFullYear();
  const start = Math.floor(y / 10) * 10;
  const end = start + 9;
  return { start, end };
};

/**
 * 获取给定日期的起始时间
 * @param date Date
 * @returns Date
 */
export const getStartOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(0);
  d.setMinutes(0);
  d.setSeconds(0);
  d.setMilliseconds(0);
  return d;
};

/**
 * 获取指定日期的结束时间
 * @param date Date
 * @returns Date
 */
export const getEndOfDate = (date) => {
  const d = new Date(date.getTime());
  d.setHours(23);
  d.setMinutes(59);
  d.setSeconds(59);
  d.setMilliseconds(999);
  return d;
};

/**
 * 获取指定日期所在周的起始和结束日期
 * @param date Date
 * @param startOfWeek number 一周是从周几开始，传值0~6，0表示周日
 * @returns [startDate, endDate]
 */
export const getWeekRange = (date, startOfWeek = 0) => {
  // 获取当前日期偏离当前周第一天的天数
  // 如：startOfWeek = 0，周四 => 4; startOfWeek=1，周四 => 3
  const day = (7 - (startOfWeek - date.getDay())) % 7;
  const start = new Date(date.getTime() - PER_DAY_MILLISECONDS * day);
  const end = new Date(start.getTime() + PER_DAY_MILLISECONDS * 6);
  return [getStartOfDate(start), getEndOfDate(end)];
};
<fim_middle>",correct,5271
DateTimeField,DateTimeField,5f2d2febe1a2a566772fc84aa89c133d84d3093b,"<fim_prefix>/**
 * Number
 */
type NumberField = {
  type: 'number';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const number = (options) => {
  return {
    type: 'number',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * BigInt
 */
type BigIntField = {
  type: 'bigint';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const bigInt = (options) => {
  return {
    type: 'bigint',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * String
 */
type StringField = {
  type: 'string';
  maxLength: number;
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const string = (options) => {
  return {
    type: 'string',
    maxLength: options.maxLength,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Boolean
 */
type BooleanField = {
  type: 'boolean';
  canBeNull: boolean;
  default: boolean | null;
  primaryKey: boolean;
};

export const boolean = (options) => {
  return {
    type: 'boolean',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Enumerated
 */
type EnumeratedField = {
  type: 'enumerated';
  values: string[];
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const enumerated = (options) => {
  return {
    type: 'enumerated',
    values: options.values,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * DateTime
 */
type DateTimeField = {
  type: 'datetime';
  canBeNull: boolean;
  default: Date | null;
  primaryKey: boolean;
};

export const dateTime = (options): <fim_suffix> => {
  return {
    type: 'datetime',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Any Field
 */
export type AnyField =
  | NumberField
  | BigIntField
  | StringField
  | BooleanField
  | EnumeratedField
  | DateTimeField;

export type Fields = {
  [key: string]: AnyField;
};
<fim_middle>",correct,4931
Deps,Deps,4ecebdfe2a83e32ca2665144d05b64c53181178a,"<fim_prefix>/**
 *
 *
 * Copied direcly from: https://github.com/pmndrs/jotai/blob/main/src/utils/weakCache.ts
 *
 * Eventually just import it from Jotai if it's exported.
 *
 *
 *
 */
export type WeakCache<T> = WeakMap<object, [WeakCache<T>] | [WeakCache<T>, T]>;

const getWeakCacheItem = <T>(
  cache,
  deps
) => {
  while (true) {
    const [dep, ...rest] = deps;
    const entry = cache.get(dep as object);
    if (!entry) {
      return;
    }
    if (!rest.length) {
      return entry[1];
    }
    cache = entry[0];
    deps = rest;
  }
};

const setWeakCacheItem = <T>(
  cache,
  deps,
  item
) => {
  while (true) {
    const [dep, ...rest] = deps;
    let entry = cache.get(dep as object);
    if (!entry) {
      entry = [new WeakMap()];
      cache.set(dep as object, entry);
    }
    if (!rest.length) {
      entry[1] = item;
      return;
    }
    cache = entry[0];
    deps = rest;
  }
};

export const createMemoizeAtom = () => {
  const cache: WeakCache<{}> = new WeakMap();
  const memoizeAtom = <T extends {}, Deps extends readonly object[]>(
    createAtom,
    deps: <fim_suffix>
  ) => {
    const cachedAtom = getWeakCacheItem(cache, deps);
    if (cachedAtom) {
      return cachedAtom as T;
    }
    const createdAtom = createAtom();
    setWeakCacheItem(cache, deps, createdAtom);
    return createdAtom;
  };
  return memoizeAtom;
};
<fim_middle>",correct,3786
Difficulty,Difficulty,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty: <fim_suffix>) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty) => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",correct,4729
Dim,Dim,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by: <fim_suffix>)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1215
Dim,Dim,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over: <fim_suffix>, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1224
Directions,Directions,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction: <fim_suffix>) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,800
Directions,Directions,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction: <fim_suffix>) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,813
E,E,f3813017e9bb14bf831177d63f99b8ab50b44ad4,"<fim_prefix>export type Empty = {
    readonly _tag: 'Empty';
};
export type BeregnButton = {
    readonly _tag: 'BeregnButton';
};
export type BeregnButtonAndErrorSummary<E> = {
    readonly _tag: 'BeregnButtonAndErrorSummary';
    readonly errors: E;
};
export type NoValidChildrenOrange = {
    readonly _tag: 'NoValidChildrenOrange';
};
export type ResultBox<A> = {
    readonly _tag: 'ResultBox';
    readonly result: A;
};

export type ResultView<E, A> =
    | Empty
    | BeregnButton
    | BeregnButtonAndErrorSummary<E>
    | NoValidChildrenOrange
    | ResultBox<A>;

// constructors
export const empty: ResultView<never, never> = {
    _tag: 'Empty',
};
export const beregnButton: ResultView<never, never> = {
    _tag: 'BeregnButton',
};
export const beregnButtonAndErrorSummary = <E>(errors: <fim_suffix>) => ({
    _tag: 'BeregnButtonAndErrorSummary',
    errors,
});
export const noValidChildrenOrange: ResultView<never, never> = {
    _tag: 'NoValidChildrenOrange',
};
export const resultBox = <A>(result) => ({
    _tag: 'ResultBox',
    result,
});
// filters
export const isEmpty = (data): data is Empty => data._tag === 'Empty';
export const isBeregnButton = (data): data is BeregnButton =>
    data._tag === 'BeregnButton';
export const isBeregnButtonAndErrorSummary = <E>(
    data
): data is BeregnButtonAndErrorSummary<E> => data._tag === 'BeregnButtonAndErrorSummary';
export const isNoValidChildrenOrange = (data): data is NoValidChildrenOrange =>
    data._tag === 'NoValidChildrenOrange';
export const isResultBox = <A>(data): data is ResultBox<A> => data._tag === 'ResultBox';

// fold
export const caseResultViewOf =
    <E, A, B>(
        empty,
        beregnButton,
        beregnButtonAndErrorSummary,
        noValidChildrenOrange,
        resultBox
    ) =>
    (resultView) => {
        switch (resultView._tag) {
            case 'Empty': {
                return empty();
            }
            case 'BeregnButton': {
                return beregnButton();
            }
            case 'BeregnButtonAndErrorSummary': {
                return beregnButtonAndErrorSummary(resultView.errors);
            }
            case 'NoValidChildrenOrange': {
                return noValidChildrenOrange();
            }
            case 'ResultBox': {
                return resultBox(resultView.result);
            }
        }
    };
<fim_middle>",correct,3889
ElementType,ElementType,8ab616f33f5bd10a91c24a82c6b27b64f543e801,"<fim_prefix>
export interface SelectionElement {
  get selected();
  set selected(val);
  get value();

  addOnChange: (callback) => (() => void);
};

export class SelectionState<T = any, ElementType extends SelectionElement = SelectionElement> {
  elements: { el: ElementType, listener: () => void }[] = [];
  value: T | T[];
  any: boolean;
  all: boolean;
  onChange: (val, all, any) => void;
  onUpdate: (state) => void;

  constructor(
    public readonly allowMultiple,
    public readonly initialValue,
  ) {
    this.value = initialValue || (allowMultiple ? [] : undefined);
    if (this.allowMultiple && !Array.isArray(this.value)) this.value = [this.value];
  }

  private changed(sender?) {
    if (this.allowMultiple) {
      let all = true;
      let any = false;
      const res = [];
      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el.selected) {
          res.push(element.el.value);
          any = true;
        }
        else all = false;
      }
      this.value = res;
      this.all = all;
      this.any = any;
      return;
    } else {
      this.all = false;
      let firstChecked = sender;

      if (!firstChecked) {
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (element.el.selected) {
            firstChecked = element.el;
            break;
          }
        }
      }

      if (!firstChecked) {
        this.value = undefined;
        this.any = false;
        return;
      }

      if (!firstChecked.selected) firstChecked.selected = true;

      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el !== firstChecked) element.el.selected = false;
      }

      this.value = firstChecked.value;
      this.any = true;
    }
  }

  triggerChange() {
    this.onChange?.(this.value, this.all, this.any);
  }

  triggerUpdate() {
    this.onUpdate?.(this);
  }

  register(el) {
    const listener = el.addOnChange(() => {
      this.changed(el);
      this.triggerChange();
      this.triggerUpdate();
    });

    this.elements.push({ el, listener });

    if (this.allowMultiple && Array.isArray(this.value)) el.selected = this.value.includes(el.value);
    else el.selected = this.value === el.value;

    if (this.allowMultiple) {
      if (this.all && !el.selected) {
        this.all = false;
        this.triggerChange();
      }

      if (!this.any && el.selected) {
        this.any = true;
        this.triggerChange();
      }
    }

    this.triggerUpdate();
  }

  unregister(el: <fim_suffix>) {
    const ind = this.elements.findIndex(x => x.el === el);
    if (ind >= 0) {
      const item = this.elements[ind];
      this.elements.splice(ind, 1);
      if (item.listener) item.listener();
    }

    this.triggerUpdate();
  }

  setAll(checked?) {
    if (!this.allowMultiple && checked) throw new Error('Multiple values cannot be selected for radio groups');
    checked = !!checked;

    this.all = checked;
    this.any = checked;

    const values = [];
    for (let index = 0; index < this.elements.length; index++) {
      const element = this.elements[index];
      element.el.selected = checked;
    }

    this.value = this.allowMultiple ? values : undefined;
    this.all = checked;
    this.any = checked;
    this.triggerChange();
    this.triggerUpdate();
  }

  getSelectedElements() {
    const res: ElementType[] = [];
    for (let index = 0; index < this.elements.length; index++) {
      const { el } = this.elements[index];

      const isSelected = this.allowMultiple && Array.isArray(this.value) ? this.value.includes(el.value) : this.value === el.value;
      if (isSelected) res.push(el);
    }

    return res;
  }
}
<fim_middle>",correct,4457
ElementType,ElementType,8ab616f33f5bd10a91c24a82c6b27b64f543e801,"<fim_prefix>
export interface SelectionElement {
  get selected();
  set selected(val);
  get value();

  addOnChange: (callback) => (() => void);
};

export class SelectionState<T = any, ElementType extends SelectionElement = SelectionElement> {
  elements: { el: ElementType, listener: () => void }[] = [];
  value: T | T[];
  any: boolean;
  all: boolean;
  onChange: (val, all, any) => void;
  onUpdate: (state) => void;

  constructor(
    public readonly allowMultiple,
    public readonly initialValue,
  ) {
    this.value = initialValue || (allowMultiple ? [] : undefined);
    if (this.allowMultiple && !Array.isArray(this.value)) this.value = [this.value];
  }

  private changed(sender?) {
    if (this.allowMultiple) {
      let all = true;
      let any = false;
      const res = [];
      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el.selected) {
          res.push(element.el.value);
          any = true;
        }
        else all = false;
      }
      this.value = res;
      this.all = all;
      this.any = any;
      return;
    } else {
      this.all = false;
      let firstChecked = sender;

      if (!firstChecked) {
        for (let index = 0; index < this.elements.length; index++) {
          const element = this.elements[index];
          if (element.el.selected) {
            firstChecked = element.el;
            break;
          }
        }
      }

      if (!firstChecked) {
        this.value = undefined;
        this.any = false;
        return;
      }

      if (!firstChecked.selected) firstChecked.selected = true;

      for (let index = 0; index < this.elements.length; index++) {
        const element = this.elements[index];
        if (element.el !== firstChecked) element.el.selected = false;
      }

      this.value = firstChecked.value;
      this.any = true;
    }
  }

  triggerChange() {
    this.onChange?.(this.value, this.all, this.any);
  }

  triggerUpdate() {
    this.onUpdate?.(this);
  }

  register(el: <fim_suffix>) {
    const listener = el.addOnChange(() => {
      this.changed(el);
      this.triggerChange();
      this.triggerUpdate();
    });

    this.elements.push({ el, listener });

    if (this.allowMultiple && Array.isArray(this.value)) el.selected = this.value.includes(el.value);
    else el.selected = this.value === el.value;

    if (this.allowMultiple) {
      if (this.all && !el.selected) {
        this.all = false;
        this.triggerChange();
      }

      if (!this.any && el.selected) {
        this.any = true;
        this.triggerChange();
      }
    }

    this.triggerUpdate();
  }

  unregister(el) {
    const ind = this.elements.findIndex(x => x.el === el);
    if (ind >= 0) {
      const item = this.elements[ind];
      this.elements.splice(ind, 1);
      if (item.listener) item.listener();
    }

    this.triggerUpdate();
  }

  setAll(checked?) {
    if (!this.allowMultiple && checked) throw new Error('Multiple values cannot be selected for radio groups');
    checked = !!checked;

    this.all = checked;
    this.any = checked;

    const values = [];
    for (let index = 0; index < this.elements.length; index++) {
      const element = this.elements[index];
      element.el.selected = checked;
    }

    this.value = this.allowMultiple ? values : undefined;
    this.all = checked;
    this.any = checked;
    this.triggerChange();
    this.triggerUpdate();
  }

  getSelectedElements() {
    const res: ElementType[] = [];
    for (let index = 0; index < this.elements.length; index++) {
      const { el } = this.elements[index];

      const isSelected = this.allowMultiple && Array.isArray(this.value) ? this.value.includes(el.value) : this.value === el.value;
      if (isSelected) res.push(el);
    }

    return res;
  }
}
<fim_middle>",correct,4458
Error,Error,4626f86ebac17685496987c0b44d830041d92194,"<fim_prefix>export interface Part {
  name: string;
  group: PartGroupType;
  path: string;
  pathToSmallImage: string;
}

export interface PartsState {
  isLoading: boolean;
  error?: Error;
  backParts: Record<string, Part>;
  frontParts: Record<string, Part>;
  wordParts: Record<string, Part>;
}

export enum PartGroupType {
  BACK_NORMAL = 'BACK_NORMAL',
  BACK_SPECIAL = 'BACK_SPECIAL',
  FRONT_NORMAL = 'FRONT_NORMAL',
  FRONT_ANIMALS = 'FRONT_ANIMALS',
  FRONT_CODENAMES = 'FRONT_CODENAMES',
  FRONT_SPECIAL = 'FRONT_SPECIAL',
  WORD_NORMAL = 'WORD_NORMAL',
  WORD_PHONETIC = 'WORD_PHONETIC',
  WORD_CODENAMES = 'WORD_CODENAMES',
  WORD_NUMBER = 'WORD_NUMBER',
  WORD_LETTER = 'WORD_LETTER',
}

export const groupTypeDisplayNames = new Map([
  [PartGroupType.BACK_NORMAL, 'Normal'],
  [PartGroupType.BACK_SPECIAL, 'Special'],
  [PartGroupType.FRONT_NORMAL, 'Normal'],
  [PartGroupType.FRONT_SPECIAL, 'Special'],
  [PartGroupType.FRONT_ANIMALS, 'Animals'],
  [PartGroupType.FRONT_CODENAMES, 'Codenames'],
  [PartGroupType.WORD_NORMAL, 'Normal'],
  [PartGroupType.WORD_NUMBER, 'Numbers'],
  [PartGroupType.WORD_LETTER, 'Letter'],
  [PartGroupType.WORD_PHONETIC, 'Phonetic'],
  [PartGroupType.WORD_CODENAMES, 'Codenames'],
]);

export const backGroupTypes = new Set([
  PartGroupType.BACK_NORMAL,
  PartGroupType.BACK_SPECIAL,
]);

export const frontGroupTypes = new Set([
  PartGroupType.FRONT_NORMAL,
  PartGroupType.FRONT_ANIMALS,
  PartGroupType.FRONT_CODENAMES,
  PartGroupType.FRONT_SPECIAL,
]);

export const wordGroupTypes = new Set([
  PartGroupType.WORD_NORMAL,
  PartGroupType.WORD_PHONETIC,
  PartGroupType.WORD_CODENAMES,
  PartGroupType.WORD_NUMBER,
  PartGroupType.WORD_LETTER,
]);

export function loadingPartsState() {
  return {
    isLoading: true,
    backParts: {},
    frontParts: {},
    wordParts: {},
  };
}

export function successPartsState(json) {
  const backParts: Record<string, Part> = {};
  const frontParts: Record<string, Part> = {};
  const wordParts: Record<string, Part> = {};

  for (const id of Object.keys(json)) {
    const part = json[id];
    part.path = `/assets/images/${part.path}`;

    if (backGroupTypes.has(part.group)) {
      backParts[id] = part;
    } else if (frontGroupTypes.has(part.group)) {
      frontParts[id] = part;
    } else if (wordGroupTypes.has(part.group)) {
      wordParts[id] = part;
    }
  }

  return {
    isLoading: false,
    backParts,
    frontParts,
    wordParts,
  };
}

export function errorPartsState(error: <fim_suffix>) {
  return {
    isLoading: false,
    error,
    backParts: {},
    frontParts: {},
    wordParts: {},
  };
}
<fim_middle>",correct,1982
ErrorResponse,ErrorResponse,009999bb6cc1b9b148abc178a6579d671236e29a,"<fim_prefix>interface APIError {
	number: number
	field?: string
	message?: string
	object?: string
	value?: string
}

export type ErrorResponse =
	| { errors: APIError[] }
	| { code: string; message: string }

export default class APIClientError extends Error {
	name: string

	message: string

	code?: string

	errors?: APIError[]

	constructor(
		name,
		message,
		code?,
		errors?
	) {
		super()
		this.name = name
		this.message = message
		this.code = code
		this.errors = errors
	}
}

export const isErrorResponse = ({
	error,
	error_type: errorType,
	response,
}) => error || errorType || response.errors

export const transformErrorResponse = (errorResponse): <fim_suffix> => {
	const {
		response,
		error,
		error_description: errorDescription,
		error_type: errorType,
		message,
	} = errorResponse

	// singular error e.g., as returned by APIClient.users.me()
	if (error && errorDescription) {
		return {
			code: error,
			message: errorDescription,
		}
	}

	// not_found error
	if (errorType && message) {
		return {
			code: errorType,
			message,
		}
	}

	// general error supplied by valid endpoint
	return {
		errors: response.errors.map(
			({
				errno: number,
				field,
				message: msg,
				object,
				value,
			}) => ({
				number,
				field,
				message: msg,
				object,
				value,
			})
		),
	}
}
<fim_middle>",correct,3900
EventEmitter,EventEmitter,4fa4cc3b188c443e4bf9fce3c1d94ca87897d5c9,"<fim_prefix>interface Listener {
    callback: Function;
    once: boolean;
}

interface Listeners {
    [key: string]: Listener[];
}

interface ListenersRegex {
    [key: string]: RegExp;
}

interface EventObject {
    event: string;
    stack?: {
        typeName: string,
        methodName: string,
        function: Function,
        functionName: string,
        fileName: string,
        lineNumber: number,
    }[]
}

interface EventEmitterOptions {
    mode?: 'wildcard' | 'regex' | 'simple';
    includeStack?: boolean;
    delimiter?: string;
}

export default class EventEmitter {
    private _listeners: Listeners = {};
    private _wildcardsRegex: ListenersRegex = {};
    private _listenerRegex: ListenersRegex = {};

    mode = ""wildcard"";
    includeStack = false;
    delimiter = ""."";

    constructor({mode = ""wildcard"", includeStack = false, delimiter = "".""} = {}) {
        if (mode) {
            this.mode = mode;
        }
        if (includeStack !== undefined) {
            this.includeStack = includeStack;
        }
        if (delimiter) {
            this.delimiter = delimiter;
        }
    }

    addListener = (event, cb, options = {}) => {
        if (Array.isArray(event)) {
            event.forEach((e) => this._addListener(e, cb, options))
        } else {
            this._addListener(event, cb, options)
        }
        return this;
    }

    private _addListener = (event, cb, options = {}) => {
        if (!hasOwnProperty(this._listeners, event)) {
            defineProperty(this._listeners, event, []);
        }
        this.emit(""newListener"", event, cb);

        if (!hasOwnProperty(this._wildcardsRegex, event)) {
            const parts = event.split(this.delimiter).map((p) => (p === ""*"" ? ""\\w*"" : p.replace(/[.*+?^${}()|[\]\\]/g, ""\\$&"")));
            const regex = new RegExp(`^${parts.join(""\\"" + this.delimiter)}$`);
            defineProperty(this._wildcardsRegex, event, regex);
        }

        if (!hasOwnProperty(this._listenerRegex, event)) {
            defineProperty(this._listenerRegex, event, new RegExp(event));
        }

        this._listeners[event].push({callback: cb, once: !!options?.once});
    };

    on = this.addListener;

    once = (event, cb, options = {}) => {
        return this.addListener(event, cb, {...options, once: true});
    };

    private _removeListener = (event, listener) => {
        if (this.listenerCount(event)) {
            let listenerIndex = this._listeners[event].findIndex((l) => l?.callback === listener);
            if (listenerIndex > -1) {
                this._listeners[event].splice(listenerIndex, 1);
                return true;
            }
        }
        return false;
    };

    removeListener = (event, listener): <fim_suffix> => {
        if (this._removeListener(event, listener)) {
            this.emit(""removeListener"", event, listener);
        }
        return this;
    };

    off = this.removeListener;

    removeAllListeners = (event) => {
        if (event && this.listeners(event).length) {
            const callbacks = this.listeners(event);
            delete this._listeners[event];

            for (const callback of callbacks) {
                this.emit(""removeListener"", event, callback);
            }
        }
        return this;
    };

    eventNames = () => Object.keys(this._listeners);

    listenerCount = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].length;
        }
        return 0;
    };

    listeners = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].map(l => l.callback);
        }
        return [];
    };

    private _getStack = () => {
        // @ts-ignore
        const prepareStackTraceOrg = Error.prepareStackTrace;
        const err = new Error();
        // @ts-ignore
        Error.prepareStackTrace = (_, stack) => stack;
        const stacks = err.stack;
        // @ts-ignore
        Error.prepareStackTrace = prepareStackTraceOrg;
        return stacks?.slice(2) || [];
    };

    private _callListeners = (e, eventObject, params) => {
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                callback?.callback?.(eventObject, ...params);
            }
        }
    };

    private _callAsyncListeners = (e, eventObject, params) => {
        const promises: Promise<any>[] = [];
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                promises.push(callback?.callback?.(eventObject, ...params));
            }
        }
        return promises;
    };

    emit = (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let listenerFound = false;
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            this._callListeners(event, eventObject, params);
            listenerFound = true;
        }
        return listenerFound;
    };

    emitAsync = async (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let promises: Promise<any>[] = [];
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            promises = this._callAsyncListeners(event, eventObject, params);
        }

        if (promises?.length) {
            await Promise.allSettled(promises);
            return true;
        }
        return false;
    };
}

function defineProperty(source, key, value) {
    return Object.defineProperty(source, key, {value, configurable: true, writable: true, enumerable: true});
}

function hasOwnProperty(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
<fim_middle>",correct,5179
Expression,Expression,4e0101374b9ed16a03bd794fbb67ac927c7f589a,"<fim_prefix>function buildParenthesizedExpression(token) {
    if (!Array.isArray(token)) {
        throw Error(""accident token type"");
    }
    const inner_expression = buildExpression(token);
    if (!inner_expression) {
        throw Error(""empty expression"");
    }
    const current_expression: Expression = {
        type: ""ParenthesizedExpression"",
        expression: inner_expression,
    };
    return current_expression;
}
function buildNumericLiteralExpression(token) {
    if (typeof token !== ""number"") {
        throw Error(""accident token type"");
    }
    const current_expression: Expression = {
        type: ""NumericLiteral"",
        value: token,
    };
    return current_expression;
}
export default function calculate(s) {
    const tokens = tokenize(s);

    const ast = buildExpression(tokens);

    return evaluate(ast);
}
export function evaluate(ast) {
    if (ast.type === ""NumericLiteral"") {
        return ast.value;
    }
    if (ast.type === ""UnaryExpression"") {
        if (ast.operator === ""-"") {
            return -1 * evaluate(ast.argument);
        }
    }
    if (ast.type === ""BinaryExpression"") {
        if (ast.operator === ""-"") {
            return evaluate(ast.left) - evaluate(ast.right);
        }
        if (ast.operator === ""*"") {
            return evaluate(ast.left) * evaluate(ast.right);
        }
        if (ast.operator === ""+"") {
            return evaluate(ast.left) + evaluate(ast.right);
        }

        if (ast.operator === ""/"") {
            const num1 = evaluate(ast.left);
            const num2 = evaluate(ast.right);
            const sign = Math.sign(num2) * Math.sign(num1);
            return sign * Math.floor(Math.abs(num1) / Math.abs(num2));
            //整数除法
        }
    }
    if (ast.type === ""ParenthesizedExpression"") {
        return evaluate(ast.expression);
    }
    throw Error(""not support expression"");
}
type Token = Tokens extends (infer P)[] ? P : never;

type Tokens = Array<string | number | Tokens>;
function getTokenType(token) {
    const tokentype: TokenType = typeof token === ""number""
        ? TokenType[""number""]
        : typeof token === ""string""
        ? TokenType[""operator""]
        : Array.isArray(token)
        ? TokenType[""parentheses""]
        : TokenType[""unknown""];
    return tokentype;
}
export function tokenize(s) {
    const tokens: Tokens = [];
    const stack: Tokens[] = [tokens];
    for (let i = 0; i < s.length; i++) {
        const value = s[i];
        if (/\d/.test(value)) {
            //只处理整数
            const digits: string[] = [value];

            while (/\d/.test(s[i + 1])) {
                digits.push(s[i + 1]);
                i++;
            }

            const num = Number(digits.join(""""));
            stack[stack.length - 1].push(num);
        }
        if ([""+"", ""-"", ""/"", ""*""].includes(value)) {
            stack[stack.length - 1].push(value);
        }
        if (value === ""("") {
            stack.push([]);
        }
        if (value === "")"") {
            if (stack.length <= 0) throw Error(""parentheses mismatch"");
            const last = stack[stack.length - 1];
            stack.pop();
            stack[stack.length - 1].push(last);
        }
    }
    if (stack.length !== 1) throw Error(""parentheses mismatch"");
    return tokens;
}
export function buildExpression(tokens): <fim_suffix> {
    if (tokens.length === 0) {
        throw Error(""empty expression"");
    }
    let state = State.initial;
    const pendingtype: ExpressionType[] = [];
    const pendingoperator: ExpressionOperator[] = [];

    const pendingleft: Expression[] = [];
    for (const token of tokens) {
        const tokentype: TokenType = getTokenType(token);
        if (tokentype === TokenType.unknown) throw Error(""unknown token"");
        state = transform[state][tokentype] ?? State.unknown;
        if (state === State.unknown) throw Error(""unknown state"");
        if (state === State.unary) {
            pendingtype.push(""UnaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
        if ([State.parentheses, State.number].includes(state)) {
            const current_expression: Expression = State.number === state
                ? buildNumericLiteralExpression(token)
                : buildParenthesizedExpression(token);
            if (pendingtype.length === 0 && pendingoperator.length === 0) {
                pendingleft.push(current_expression);
            } else {
                const type = pendingtype[pendingtype.length - 1];
                pendingtype.pop();
                const operator = pendingoperator[pendingoperator.length - 1];
                pendingoperator.pop();
                if (type === ""BinaryExpression"") {
                    //优先级更高

                    const left = pendingleft[pendingleft.length - 1];

                    if (
                        left.type === ""BinaryExpression"" &&
                        [""*"", ""/""].includes(operator) &&
                        [""+"", ""-""].includes(left.operator)
                    ) {
                        left.right = {
                            type: ""BinaryExpression"",
                            operator: operator as BinaryExpression[""operator""],
                            left: left.right,
                            right: current_expression,
                        };
                    } else {
                        pendingleft.pop();
                        pendingleft.push({
                            operator: operator as BinaryExpression[""operator""],
                            type: ""BinaryExpression"",
                            left,
                            right: current_expression,
                        });
                    }
                }
                if (type === ""UnaryExpression"") {
                    pendingleft.push({
                        operator: operator as UnaryExpression[""operator""],
                        type: ""UnaryExpression"",
                        argument: current_expression,
                    });
                }
            }
        }

        if (state === State.binary) {
            pendingtype.push(""BinaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
    }
    if (valid_end_states.includes(state) && pendingleft.length) {
        return pendingleft[0];
    } else {
        throw new Error(""unexpected end state or empty expression"");
    }
}
const enum State {
    ""initial"",
    ""unary"",
    ""parentheses"",
    ""number"",
    ""binary"",
    ""unknown"",
}
const valid_end_states = [State[""parentheses""], State[""number""]];
const enum TokenType {
    ""number"",
    ""operator"",
    ""parentheses"",
    ""unknown"",
}
const transform: Record<State, Record<TokenType, State>> = {
    [State.initial]: {
        [TokenType.operator]: State.unary,
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.unary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.binary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.parentheses]: {
        [TokenType.operator]: State.binary,
    },
    [State.number]: {
        [TokenType.operator]: State.binary,
    },
} as Record<State, Record<TokenType, State>>;
type ExpressionType = Expression[""type""];

type ExpressionOperator =
    | UnaryExpression[""operator""]
    | BinaryExpression[""operator""];
type Expression =
    | BinaryExpression
    | NumericLiteral
    | UnaryExpression
    | ParenthesizedExpression;
interface ParenthesizedExpression {
    type: ""ParenthesizedExpression"";
    expression: Expression;
}
interface NumericLiteral {
    type: ""NumericLiteral"";
    value: number;
}
interface UnaryExpression {
    type: ""UnaryExpression"";
    operator: ""void"" | ""throw"" | ""delete"" | ""!"" | ""+"" | ""-"" | ""~"" | ""typeof"";
    argument: Expression;
}
interface BinaryExpression {
    type: ""BinaryExpression"";
    operator:
        | ""+""
        | ""-""
        | ""/""
        | ""%""
        | ""*""
        | ""**""
        | ""&""
        | ""|""
        | "">>""
        | "">>>""
        | ""<<""
        | ""^""
        | ""==""
        | ""===""
        | ""!=""
        | ""!==""
        | ""in""
        | ""instanceof""
        | "">""
        | ""<""
        | "">=""
        | ""<=""
        | ""|>"";
    left: Expression;
    right: Expression;
}
<fim_middle>",correct,3742
Expression,Expression,4e0101374b9ed16a03bd794fbb67ac927c7f589a,"<fim_prefix>function buildParenthesizedExpression(token) {
    if (!Array.isArray(token)) {
        throw Error(""accident token type"");
    }
    const inner_expression = buildExpression(token);
    if (!inner_expression) {
        throw Error(""empty expression"");
    }
    const current_expression: Expression = {
        type: ""ParenthesizedExpression"",
        expression: inner_expression,
    };
    return current_expression;
}
function buildNumericLiteralExpression(token) {
    if (typeof token !== ""number"") {
        throw Error(""accident token type"");
    }
    const current_expression: Expression = {
        type: ""NumericLiteral"",
        value: token,
    };
    return current_expression;
}
export default function calculate(s) {
    const tokens = tokenize(s);

    const ast = buildExpression(tokens);

    return evaluate(ast);
}
export function evaluate(ast: <fim_suffix>) {
    if (ast.type === ""NumericLiteral"") {
        return ast.value;
    }
    if (ast.type === ""UnaryExpression"") {
        if (ast.operator === ""-"") {
            return -1 * evaluate(ast.argument);
        }
    }
    if (ast.type === ""BinaryExpression"") {
        if (ast.operator === ""-"") {
            return evaluate(ast.left) - evaluate(ast.right);
        }
        if (ast.operator === ""*"") {
            return evaluate(ast.left) * evaluate(ast.right);
        }
        if (ast.operator === ""+"") {
            return evaluate(ast.left) + evaluate(ast.right);
        }

        if (ast.operator === ""/"") {
            const num1 = evaluate(ast.left);
            const num2 = evaluate(ast.right);
            const sign = Math.sign(num2) * Math.sign(num1);
            return sign * Math.floor(Math.abs(num1) / Math.abs(num2));
            //整数除法
        }
    }
    if (ast.type === ""ParenthesizedExpression"") {
        return evaluate(ast.expression);
    }
    throw Error(""not support expression"");
}
type Token = Tokens extends (infer P)[] ? P : never;

type Tokens = Array<string | number | Tokens>;
function getTokenType(token) {
    const tokentype: TokenType = typeof token === ""number""
        ? TokenType[""number""]
        : typeof token === ""string""
        ? TokenType[""operator""]
        : Array.isArray(token)
        ? TokenType[""parentheses""]
        : TokenType[""unknown""];
    return tokentype;
}
export function tokenize(s) {
    const tokens: Tokens = [];
    const stack: Tokens[] = [tokens];
    for (let i = 0; i < s.length; i++) {
        const value = s[i];
        if (/\d/.test(value)) {
            //只处理整数
            const digits: string[] = [value];

            while (/\d/.test(s[i + 1])) {
                digits.push(s[i + 1]);
                i++;
            }

            const num = Number(digits.join(""""));
            stack[stack.length - 1].push(num);
        }
        if ([""+"", ""-"", ""/"", ""*""].includes(value)) {
            stack[stack.length - 1].push(value);
        }
        if (value === ""("") {
            stack.push([]);
        }
        if (value === "")"") {
            if (stack.length <= 0) throw Error(""parentheses mismatch"");
            const last = stack[stack.length - 1];
            stack.pop();
            stack[stack.length - 1].push(last);
        }
    }
    if (stack.length !== 1) throw Error(""parentheses mismatch"");
    return tokens;
}
export function buildExpression(tokens) {
    if (tokens.length === 0) {
        throw Error(""empty expression"");
    }
    let state = State.initial;
    const pendingtype: ExpressionType[] = [];
    const pendingoperator: ExpressionOperator[] = [];

    const pendingleft: Expression[] = [];
    for (const token of tokens) {
        const tokentype: TokenType = getTokenType(token);
        if (tokentype === TokenType.unknown) throw Error(""unknown token"");
        state = transform[state][tokentype] ?? State.unknown;
        if (state === State.unknown) throw Error(""unknown state"");
        if (state === State.unary) {
            pendingtype.push(""UnaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
        if ([State.parentheses, State.number].includes(state)) {
            const current_expression: Expression = State.number === state
                ? buildNumericLiteralExpression(token)
                : buildParenthesizedExpression(token);
            if (pendingtype.length === 0 && pendingoperator.length === 0) {
                pendingleft.push(current_expression);
            } else {
                const type = pendingtype[pendingtype.length - 1];
                pendingtype.pop();
                const operator = pendingoperator[pendingoperator.length - 1];
                pendingoperator.pop();
                if (type === ""BinaryExpression"") {
                    //优先级更高

                    const left = pendingleft[pendingleft.length - 1];

                    if (
                        left.type === ""BinaryExpression"" &&
                        [""*"", ""/""].includes(operator) &&
                        [""+"", ""-""].includes(left.operator)
                    ) {
                        left.right = {
                            type: ""BinaryExpression"",
                            operator: operator as BinaryExpression[""operator""],
                            left: left.right,
                            right: current_expression,
                        };
                    } else {
                        pendingleft.pop();
                        pendingleft.push({
                            operator: operator as BinaryExpression[""operator""],
                            type: ""BinaryExpression"",
                            left,
                            right: current_expression,
                        });
                    }
                }
                if (type === ""UnaryExpression"") {
                    pendingleft.push({
                        operator: operator as UnaryExpression[""operator""],
                        type: ""UnaryExpression"",
                        argument: current_expression,
                    });
                }
            }
        }

        if (state === State.binary) {
            pendingtype.push(""BinaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
    }
    if (valid_end_states.includes(state) && pendingleft.length) {
        return pendingleft[0];
    } else {
        throw new Error(""unexpected end state or empty expression"");
    }
}
const enum State {
    ""initial"",
    ""unary"",
    ""parentheses"",
    ""number"",
    ""binary"",
    ""unknown"",
}
const valid_end_states = [State[""parentheses""], State[""number""]];
const enum TokenType {
    ""number"",
    ""operator"",
    ""parentheses"",
    ""unknown"",
}
const transform: Record<State, Record<TokenType, State>> = {
    [State.initial]: {
        [TokenType.operator]: State.unary,
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.unary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.binary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.parentheses]: {
        [TokenType.operator]: State.binary,
    },
    [State.number]: {
        [TokenType.operator]: State.binary,
    },
} as Record<State, Record<TokenType, State>>;
type ExpressionType = Expression[""type""];

type ExpressionOperator =
    | UnaryExpression[""operator""]
    | BinaryExpression[""operator""];
type Expression =
    | BinaryExpression
    | NumericLiteral
    | UnaryExpression
    | ParenthesizedExpression;
interface ParenthesizedExpression {
    type: ""ParenthesizedExpression"";
    expression: Expression;
}
interface NumericLiteral {
    type: ""NumericLiteral"";
    value: number;
}
interface UnaryExpression {
    type: ""UnaryExpression"";
    operator: ""void"" | ""throw"" | ""delete"" | ""!"" | ""+"" | ""-"" | ""~"" | ""typeof"";
    argument: Expression;
}
interface BinaryExpression {
    type: ""BinaryExpression"";
    operator:
        | ""+""
        | ""-""
        | ""/""
        | ""%""
        | ""*""
        | ""**""
        | ""&""
        | ""|""
        | "">>""
        | "">>>""
        | ""<<""
        | ""^""
        | ""==""
        | ""===""
        | ""!=""
        | ""!==""
        | ""in""
        | ""instanceof""
        | "">""
        | ""<""
        | "">=""
        | ""<=""
        | ""|>"";
    left: Expression;
    right: Expression;
}
<fim_middle>",correct,3748
Factor,Factor,5854bf3dea0d67d8667446aaccf3a64dd1f826ee,"<fim_prefix>const DFG_VERSION = '0.18.1';
const PI = 3.14159;

export enum FactorType {
  PRIORPOSE2 = 'PriorPose2',
  POSE2POSE2 = 'Pose2Pose2',
  POSE2APRILTAG4CORNERS = 'Pose2AprilTag4Corners',
}

type FactorData = {
  eliminated: boolean;
  potentialused: boolean;
  edgeIDs: string[];
  fnc: any;
  multihypo: number[];
  certainhypo: number[];
  nullhypo: number;
  solveInProgress: number;
  inflation: number;
};

export type Factor = {
  label: string;
  nstime: string;
  fnctype: string;
  _variableOrderSymbols: string[];
  data: FactorData;
  solvable: number;
  tags: string[];
  timestamp: string;
  _version: string;
};

function InitializeFactorData() {
  return {
    eliminated: false,
    potentialused: false,
    edgeIDs: [],
    fnc: {},
    multihypo: [],
    certainhypo: [],
    nullhypo: 0.0,
    solveInProgress: 0,
    inflation: 3.0,
  };
}

export function PriorPose2Data(xythetaPrior = [0.0, 0.0, 0.0], xythetaCovars = [0.01, 0.01, 0.01]) {
  const fnc = {
    Z: {
      _type: 'IncrementalInference.PackedFullNormal',
      mu: xythetaPrior,
      cov: [xythetaCovars[0], 0.0, 0.0, 0.0, xythetaCovars[1], 0.0, 0.0, 0.0, xythetaCovars[2]],
    },
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1];
  return data;
}

export function Pose2Pose2Data(mus = [1, 0, 0.3333 * PI], sigmas = [0.01, 0.01, 0.01]) {
  const fnc = {
    Z: {
      _type: 'IncrementalInference.PackedFullNormal',
      mu: mus,
      cov: [sigmas[0], 0.0, 0.0, 0.0, sigmas[1], 0.0, 0.0, 0.0, sigmas[2]],
    },
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1, 2];
  return data;
}

export function Pose2AprilTag4CornersData(
  id,
  corners,
  homography,
  K = [300.0, 0.0, 0.0, 0.0, 300.0, 0.0, 180.0, 120.0, 1.0],
  taglength = 0.25,
) {
  const fnc = {
    _type: '/application/JuliaLang/PackedPose2AprilTag4Corners',
    corners,
    homography,
    K,
    taglength,
    id,
  };
  const data = InitializeFactorData();
  data.fnc = fnc;
  data.certainhypo = [1, 2];
  return data;
}

export function Factor(
  label,
  fncType,
  variableOrderSymbols,
  data,
  tags = ['FACTOR'],
  timestamp = new Date().toISOString(),
): <fim_suffix> {
  data.certainhypo = variableOrderSymbols.map((x, idx) => idx + 1);

  const result: Factor = {
    label,
    nstime: '0',
    fnctype: fncType,
    _variableOrderSymbols: variableOrderSymbols,
    data,
    solvable: 1,
    tags,
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",correct,2815
Fields,Fields,bf712f9fe76a6eeeb69b15794f6333cb9c774f5e,"<fim_prefix>/* eslint-disable @typescript-eslint/naming-convention */
export type ResponseMessage = {
    status: string;
    message: any;
};

export type ErrorResponse = {
    error: string;
    message?: string;
};

export type Fields = {
    id?: boolean;
    title?: boolean;
    main_picture?: boolean;
    alternative_titles?: boolean;
    start_date?: boolean;
    end_date?: boolean;
    synopsis?: boolean;
    mean?: boolean;
    rank?: boolean;
    popularity?: boolean;
    num_list_users?: boolean;
    num_scoring_users?: boolean;
    nsfw?: boolean;
    created_at?: boolean;
    updated_at?: boolean;
    media_type?: boolean;
    status?: boolean;
    genres?: boolean;
    my_list_status?: boolean | Fields; // different possible fields
    num_episodes?: boolean;
    start_season?: boolean;
    broadcast?: boolean;
    source?: boolean;
    average_episode_duration?: boolean;
    rating?: boolean;
    pictures?: boolean;
    background?: boolean;
    related_anime?: boolean | Fields;
    related_manga?: boolean | Fields;
    recommendations?: boolean | Fields;
    studios?: boolean;
    statistics?: boolean;
    videos?: boolean;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function fieldsToString(fields) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
    const entries = Object.entries(fields);
    let str = """";

    for (const entry of entries) {
        if (str.length > 0) {
            str += "","";
        }
        str += entry[0];
        if (entry[1] !== true && entry[1] !== false) {
            str += `{${fieldsToString(entry[1] as any)}}`;
        }
    }
    return str;
}

export function extractFields(str) {
    let subject = str;

    if (subject[0] === ""{"") {
        subject = subject.substr(1, subject.length);
    }

    let currentObject = """";
    const createdObj: any = {};

    function addObject(stri, val) {
        if (stri === """") return;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access
        createdObj[currentObject] = val;
        currentObject = """";
    }

    function skipSubject() {
        subject = subject.substr(1, subject.length);
    }

    while (subject.length > 0) {
        const subjZero = subject[0];

        if (subjZero === "" "") {
            skipSubject();
            if (subject.length === 0) {
                addObject(currentObject, true);
            }
            continue;
        }

        if (subjZero === ""{"") {
            const res = extractFields(subject);
            addObject(currentObject, res.fields);
            subject = res.remaining;
            continue;
        }
        if (subjZero === ""}"") {
            addObject(currentObject, true);

            skipSubject();
            if (subject[0] === "","") skipSubject();

            return {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
                fields: createdObj,
                remaining: subject,
            };
        }
        if (subjZero === "","") {
            addObject(currentObject, true);
            skipSubject();
            continue;
        }

        currentObject += subjZero;
        skipSubject();

        if (subject.length === 0) {
            addObject(currentObject, true);
        }
    }

    return {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        fields: createdObj,
        remaining: """",
    };
}

export function allFields(): <fim_suffix> {
    return {
        alternative_titles: true,
        average_episode_duration: true,
        background: true,
        broadcast: true,
        created_at: true,
        end_date: true,
        genres: true,
        id: true,
        main_picture: true,
        mean: true,
        media_type: true,
        my_list_status: true,
        nsfw: true,
        num_episodes: true,
        num_list_users: true,
        num_scoring_users: true,
        pictures: true,
        popularity: true,
        rank: true,
        rating: true,
        recommendations: true,
        related_anime: true,
        related_manga: true,
        source: true,
        start_date: true,
        start_season: true,
        statistics: true,
        status: true,
        studios: true,
        synopsis: true,
        title: true,
        updated_at: true,
    };
}

type Relation = MediaNode & {
    relation_type: string;
    relation_type_formatted: string;
};

export type StatusNode = MediaNode & {
    list_status: ListStatus;
};

export type Media = {
    id: number;
    title: string;
    main_picture: Picture;
    alternative_titles?: {
        synonyms?: string[];
        en?: string;
        ja?: string;
    };
    start_date?: string;
    end_date?: string;
    synopsis?: string;
    mean?: number;
    rank?: number;
    popularity?: number;
    num_list_users?: number;
    num_scoring_users?: number;
    nsfw?: string;
    created_at?: string;
    updated_at?: string;
    media_type?: string;
    status?: string;
    genres?: Genre[];
    my_list_status?: ListStatus;
    num_episodes?: number;
    start_season?: Season;
    broadcast?: {
        day_of_the_week?: string;
        start_time?: string;
    };
    source?: string;
    average_episode_duration?: number;
    rating?: string;
    pictures?: Picture[];
    background?: string;
    related_anime?: Relation[];
    related_manga?: Relation[];
    recommendations?: (MediaNode & {
        num_recommendations?: number;
    })[];
    studios?: Studio[];
    statistics?: {
        status?: {
            watching?: string;
            completed?: string;
            on_hold?: string;
            dropped?: string;
            plan_to_watch?: string;
        };
        num_list_users?: number;
    };
};

export type tokenResponse = {
    token_type: ""Bearer"";
    expires_in: number;
    access_token: string;
    refresh_token: string;
};

export type Picture = {
    medium: string;
    large: string;
};

export type Genre = {
    id: number;
    name: string;
};

export type ListStatus = {
    status: ""watching"" | ""completed"" | ""on_hold"" | ""dropped"" | ""plan_to_watch"";
    score: number;
    num_episodes_watched: number;
    is_rewatching: boolean;
    updated_at: string;
};

export type ListPagination<T> = {
    data: T[];
    paging: {
        next: string;
        previous?: string | undefined;
    };
};

export type RequestResponse<T> = {
    response:
        | {
              response: T;
              tokens: tokenResponse;
          }
        | ErrorResponse;
};

export type MediaNode = {
    node: Media;
};

export type Season = {
    year: number;
    season: string;
};

export type Studio = {
    id: number;
    name: string;
};

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isTokenResponse(obj): obj is tokenResponse {
    return ""tokenType"" in obj;
}

// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isErrResp(obj): obj is ErrorResponse {
    return ""error"" in obj;
}
<fim_middle>",correct,4426
Function,Function,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn: <fim_suffix>, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",correct,838
Function,Function,27a493ada994b85fc1ed438e2a30a8ce7eab7c21,"<fim_prefix>/**
 * EventType
 */
interface EventType {
	readonly callback: Function;
	readonly once: boolean;
}

type EventsType = Record<string, EventType[]>;

const WILDCARD = '*';

/* event-emitter */
export default class EventEmitter {
	private _events: EventsType = {};

	/**
	 * 监听一个事件
	 * @param evt
	 * @param callback
	 * @param once
	 */
	on(evt, callback: <fim_suffix>, once?) {
		if (!this._events[evt]) {
			this._events[evt] = [];
		}
		this._events[evt].push({
			callback,
			once: !!once,
		});
		return this;
	}

	/**
	 * 监听一个事件一次
	 * @param evt
	 * @param callback
	 */
	once(evt, callback) {
		return this.on(evt, callback, true);
	}

	/**
	 * 触发一个事件
	 * @param evt
	 * @param args
	 */
	emit(evt, ...args) {
		const events = this._events[evt] || [];
		const wildcardEvents = this._events[WILDCARD] || [];

		// 实际的处理 emit 方法
		const doEmit = (es) => {
			let length = es.length;
			for (let i = 0; i < length; i++) {
				if (!es[i]) {
					continue;
				}
				const { callback, once } = es[i];

				if (once) {
					es.splice(i, 1);

					if (es.length === 0) {
						delete this._events[evt];
					}

					length--;
					i--;
				}

				callback.apply(this, args);
			}
		};

		doEmit(events);
		doEmit(wildcardEvents);
	}

	/**
	 * 取消监听一个事件，或者一个channel
	 * @param evt
	 * @param callback
	 */
	off(evt?, callback?) {
		if (!evt) {
			// evt 为空全部清除
			this._events = {};
		} else {
			if (!callback) {
				// evt 存在，callback 为空，清除事件所有方法
				delete this._events[evt];
			} else {
				// evt 存在，callback 存在，清除匹配的
				const events = this._events[evt] || [];

				let length = events.length;
				for (let i = 0; i < length; i++) {
					if (events[i].callback === callback) {
						events.splice(i, 1);
						length--;
						i--;
					}
				}

				if (events.length === 0) {
					delete this._events[evt];
				}
			}
		}

		return this;
	}

	/* 当前所有的事件 */
	getEvents() {
		return this._events;
	}
}
<fim_middle>",correct,2297
Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn: <fim_suffix>, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2321
Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?: <fim_suffix>)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2329
Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?: <fim_suffix>)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2332
Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?: <fim_suffix>)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2335
Function,Function,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback: <fim_suffix>)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2338
Function,Function,4fa4cc3b188c443e4bf9fce3c1d94ca87897d5c9,"<fim_prefix>interface Listener {
    callback: Function;
    once: boolean;
}

interface Listeners {
    [key: string]: Listener[];
}

interface ListenersRegex {
    [key: string]: RegExp;
}

interface EventObject {
    event: string;
    stack?: {
        typeName: string,
        methodName: string,
        function: Function,
        functionName: string,
        fileName: string,
        lineNumber: number,
    }[]
}

interface EventEmitterOptions {
    mode?: 'wildcard' | 'regex' | 'simple';
    includeStack?: boolean;
    delimiter?: string;
}

export default class EventEmitter {
    private _listeners: Listeners = {};
    private _wildcardsRegex: ListenersRegex = {};
    private _listenerRegex: ListenersRegex = {};

    mode = ""wildcard"";
    includeStack = false;
    delimiter = ""."";

    constructor({mode = ""wildcard"", includeStack = false, delimiter = "".""} = {}) {
        if (mode) {
            this.mode = mode;
        }
        if (includeStack !== undefined) {
            this.includeStack = includeStack;
        }
        if (delimiter) {
            this.delimiter = delimiter;
        }
    }

    addListener = (event, cb, options = {}) => {
        if (Array.isArray(event)) {
            event.forEach((e) => this._addListener(e, cb, options))
        } else {
            this._addListener(event, cb, options)
        }
        return this;
    }

    private _addListener = (event, cb, options = {}) => {
        if (!hasOwnProperty(this._listeners, event)) {
            defineProperty(this._listeners, event, []);
        }
        this.emit(""newListener"", event, cb);

        if (!hasOwnProperty(this._wildcardsRegex, event)) {
            const parts = event.split(this.delimiter).map((p) => (p === ""*"" ? ""\\w*"" : p.replace(/[.*+?^${}()|[\]\\]/g, ""\\$&"")));
            const regex = new RegExp(`^${parts.join(""\\"" + this.delimiter)}$`);
            defineProperty(this._wildcardsRegex, event, regex);
        }

        if (!hasOwnProperty(this._listenerRegex, event)) {
            defineProperty(this._listenerRegex, event, new RegExp(event));
        }

        this._listeners[event].push({callback: cb, once: !!options?.once});
    };

    on = this.addListener;

    once = (event, cb, options = {}) => {
        return this.addListener(event, cb, {...options, once: true});
    };

    private _removeListener = (event, listener) => {
        if (this.listenerCount(event)) {
            let listenerIndex = this._listeners[event].findIndex((l) => l?.callback === listener);
            if (listenerIndex > -1) {
                this._listeners[event].splice(listenerIndex, 1);
                return true;
            }
        }
        return false;
    };

    removeListener = (event, listener: <fim_suffix>) => {
        if (this._removeListener(event, listener)) {
            this.emit(""removeListener"", event, listener);
        }
        return this;
    };

    off = this.removeListener;

    removeAllListeners = (event) => {
        if (event && this.listeners(event).length) {
            const callbacks = this.listeners(event);
            delete this._listeners[event];

            for (const callback of callbacks) {
                this.emit(""removeListener"", event, callback);
            }
        }
        return this;
    };

    eventNames = () => Object.keys(this._listeners);

    listenerCount = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].length;
        }
        return 0;
    };

    listeners = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].map(l => l.callback);
        }
        return [];
    };

    private _getStack = () => {
        // @ts-ignore
        const prepareStackTraceOrg = Error.prepareStackTrace;
        const err = new Error();
        // @ts-ignore
        Error.prepareStackTrace = (_, stack) => stack;
        const stacks = err.stack;
        // @ts-ignore
        Error.prepareStackTrace = prepareStackTraceOrg;
        return stacks?.slice(2) || [];
    };

    private _callListeners = (e, eventObject, params) => {
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                callback?.callback?.(eventObject, ...params);
            }
        }
    };

    private _callAsyncListeners = (e, eventObject, params) => {
        const promises: Promise<any>[] = [];
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                promises.push(callback?.callback?.(eventObject, ...params));
            }
        }
        return promises;
    };

    emit = (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let listenerFound = false;
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            this._callListeners(event, eventObject, params);
            listenerFound = true;
        }
        return listenerFound;
    };

    emitAsync = async (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let promises: Promise<any>[] = [];
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            promises = this._callAsyncListeners(event, eventObject, params);
        }

        if (promises?.length) {
            await Promise.allSettled(promises);
            return true;
        }
        return false;
    };
}

function defineProperty(source, key, value) {
    return Object.defineProperty(source, key, {value, configurable: true, writable: true, enumerable: true});
}

function hasOwnProperty(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
<fim_middle>",correct,5180
Function,Function,4fa4cc3b188c443e4bf9fce3c1d94ca87897d5c9,"<fim_prefix>interface Listener {
    callback: Function;
    once: boolean;
}

interface Listeners {
    [key: string]: Listener[];
}

interface ListenersRegex {
    [key: string]: RegExp;
}

interface EventObject {
    event: string;
    stack?: {
        typeName: string,
        methodName: string,
        function: Function,
        functionName: string,
        fileName: string,
        lineNumber: number,
    }[]
}

interface EventEmitterOptions {
    mode?: 'wildcard' | 'regex' | 'simple';
    includeStack?: boolean;
    delimiter?: string;
}

export default class EventEmitter {
    private _listeners: Listeners = {};
    private _wildcardsRegex: ListenersRegex = {};
    private _listenerRegex: ListenersRegex = {};

    mode = ""wildcard"";
    includeStack = false;
    delimiter = ""."";

    constructor({mode = ""wildcard"", includeStack = false, delimiter = "".""} = {}) {
        if (mode) {
            this.mode = mode;
        }
        if (includeStack !== undefined) {
            this.includeStack = includeStack;
        }
        if (delimiter) {
            this.delimiter = delimiter;
        }
    }

    addListener = (event, cb: <fim_suffix>, options = {}) => {
        if (Array.isArray(event)) {
            event.forEach((e) => this._addListener(e, cb, options))
        } else {
            this._addListener(event, cb, options)
        }
        return this;
    }

    private _addListener = (event, cb, options = {}) => {
        if (!hasOwnProperty(this._listeners, event)) {
            defineProperty(this._listeners, event, []);
        }
        this.emit(""newListener"", event, cb);

        if (!hasOwnProperty(this._wildcardsRegex, event)) {
            const parts = event.split(this.delimiter).map((p) => (p === ""*"" ? ""\\w*"" : p.replace(/[.*+?^${}()|[\]\\]/g, ""\\$&"")));
            const regex = new RegExp(`^${parts.join(""\\"" + this.delimiter)}$`);
            defineProperty(this._wildcardsRegex, event, regex);
        }

        if (!hasOwnProperty(this._listenerRegex, event)) {
            defineProperty(this._listenerRegex, event, new RegExp(event));
        }

        this._listeners[event].push({callback: cb, once: !!options?.once});
    };

    on = this.addListener;

    once = (event, cb, options = {}) => {
        return this.addListener(event, cb, {...options, once: true});
    };

    private _removeListener = (event, listener) => {
        if (this.listenerCount(event)) {
            let listenerIndex = this._listeners[event].findIndex((l) => l?.callback === listener);
            if (listenerIndex > -1) {
                this._listeners[event].splice(listenerIndex, 1);
                return true;
            }
        }
        return false;
    };

    removeListener = (event, listener) => {
        if (this._removeListener(event, listener)) {
            this.emit(""removeListener"", event, listener);
        }
        return this;
    };

    off = this.removeListener;

    removeAllListeners = (event) => {
        if (event && this.listeners(event).length) {
            const callbacks = this.listeners(event);
            delete this._listeners[event];

            for (const callback of callbacks) {
                this.emit(""removeListener"", event, callback);
            }
        }
        return this;
    };

    eventNames = () => Object.keys(this._listeners);

    listenerCount = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].length;
        }
        return 0;
    };

    listeners = (event) => {
        if (event && hasOwnProperty(this._listeners, event)) {
            return this._listeners[event].map(l => l.callback);
        }
        return [];
    };

    private _getStack = () => {
        // @ts-ignore
        const prepareStackTraceOrg = Error.prepareStackTrace;
        const err = new Error();
        // @ts-ignore
        Error.prepareStackTrace = (_, stack) => stack;
        const stacks = err.stack;
        // @ts-ignore
        Error.prepareStackTrace = prepareStackTraceOrg;
        return stacks?.slice(2) || [];
    };

    private _callListeners = (e, eventObject, params) => {
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                callback?.callback?.(eventObject, ...params);
            }
        }
    };

    private _callAsyncListeners = (e, eventObject, params) => {
        const promises: Promise<any>[] = [];
        if (e && hasOwnProperty(this._listeners, e)) {
            for (const callback of this._listeners[e]) {
                if (callback.once) {
                    this._removeListener(e, callback?.callback);
                }
                promises.push(callback?.callback?.(eventObject, ...params));
            }
        }
        return promises;
    };

    emit = (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let listenerFound = false;
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    this._callListeners(ev, eventObject, params);
                    listenerFound = true;
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            this._callListeners(event, eventObject, params);
            listenerFound = true;
        }
        return listenerFound;
    };

    emitAsync = async (event, ...params) => {
        const eventObject: EventObject = {
            event: event,
        };

        if (this.includeStack) {
            // @ts-ignore
            eventObject.stack = this._getStack().map((stack) => ({
                typeName: stack.getTypeName(),
                methodName: stack.getMethodName(),
                function: stack.getFunction(),
                functionName: stack.getFunctionName(),
                fileName: stack.getFileName(),
                lineNumber: stack.getLineNumber(),
            }));
        }

        let promises: Promise<any>[] = [];
        if (this.mode === ""wildcard"") {
            for (const ev in this._listeners) {
                if (this._wildcardsRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (this.mode === ""regex"") {
            for (const ev in this._listeners) {
                if (this._listenerRegex[ev]?.test?.(event)) {
                    promises.push(...this._callAsyncListeners(ev, eventObject, params));
                }
            }
        } else if (hasOwnProperty(this._listeners, event)) {
            promises = this._callAsyncListeners(event, eventObject, params);
        }

        if (promises?.length) {
            await Promise.allSettled(promises);
            return true;
        }
        return false;
    };
}

function defineProperty(source, key, value) {
    return Object.defineProperty(source, key, {value, configurable: true, writable: true, enumerable: true});
}

function hasOwnProperty(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
<fim_middle>",correct,5191
G,G,cc966119a9d0804aa81737f900326caade60f340,"<fim_prefix>interface ErrorOption {
  cause?: Error;
  status?: number;
}

interface Convertable {
  [key: string]: string | number;
}

type ConvertString<T extends Convertable, Group extends string> = {
  [P in keyof T]: P extends string
    ? T[P] extends number
      ? `${Uppercase<Group>}_${T[P]}`
      : never
    : never;
};

const codeGroup = new Set();

/**
 * Register error group and code, return the standard ErrorCode
 * @param errorGroup
 * @param errorCodeMapping
 */
export function registerErrorCode<T extends Convertable, G extends string>(
  errorGroup: <fim_suffix>,
  errorCodeMapping
) {
  if (codeGroup.has(errorGroup)) {
    throw new MidwayError(
      `Error group ${errorGroup} is duplicated, please check before adding.`
    );
  } else {
    codeGroup.add(errorGroup);
  }
  const newCodeEnum = {} as Convertable;
  // ERROR => GROUP_10000
  for (const errKey in errorCodeMapping) {
    newCodeEnum[errKey as string] =
      errorGroup.toUpperCase() +
      '_' +
      String(errorCodeMapping[errKey]).toUpperCase();
  }
  return newCodeEnum as ConvertString<T, G>;
}

export class MidwayError extends Error {
  code: number | string;
  cause: Error;

  constructor(message, options?);
  constructor(message, code, options?);
  constructor(message, code, options?) {
    super(message);
    if (!code || typeof code === 'object') {
      options = code;
      code = 'MIDWAY_10000';
    }
    this.name = this.constructor.name;
    this.code = code;
    this.cause = options?.cause;
  }
}

export type ResOrMessage = string | { message: string };

export class MidwayHttpError extends MidwayError {
  status: number;

  constructor(resOrMessage, status);
  constructor(
    resOrMessage,
    status,
    code,
    options?
  );
  constructor(
    resOrMessage,
    status,
    code?,
    options?
  ) {
    super(
      typeof resOrMessage === 'string' ? resOrMessage : resOrMessage.message,
      code ?? String(status),
      options
    );
    this.status = status;
  }
}
<fim_middle>",correct,2537
GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState) {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState, numberOfRounds): <fim_suffix> {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2132
GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState) {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState: <fim_suffix>, numberOfRounds) {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2134
GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState): <fim_suffix> {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState, numberOfRounds) {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2135
GameState,GameState,c5cbef909f0917171ef87f6f627d749ffbf01b40,"<fim_prefix>interface GameState {
  cups: number[],
  currentCupIndex: number
}

export function playRound(gameState: <fim_suffix>) {
  const localCups = [...gameState.cups];
  
  const currentIndex = gameState.currentCupIndex;

  const tail = localCups.splice(0, currentIndex);
  localCups.push(...tail);

  const currentCup = localCups[0];

  const nextThreeCups = localCups.splice(1, 3);

  let destinationCup = currentCup - 1;
  if (destinationCup === 0) {
    destinationCup = Math.max(...gameState.cups);
  }
  while (nextThreeCups.includes(destinationCup)) {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = Math.max(...gameState.cups);
    }
  }

  const destinationIndex = localCups.indexOf(destinationCup) + 1;

  localCups.splice(destinationIndex, 0, ...nextThreeCups);

  const head = localCups.splice(localCups.length - currentIndex, currentIndex);
  localCups.unshift(...head);

  return {
    cups: localCups,
    currentCupIndex: (currentIndex + 1) % localCups.length
  };
}

export function playXRound(gameState, numberOfRounds) {
  let currentGameState = gameState;
  for (let i = 0; i < numberOfRounds; i++) {
    currentGameState = playRound(currentGameState);
  }

  return currentGameState;
}

export function getCupsLabeling(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?

  const gameState = {
    cups,
    currentCupIndex: 0
  }
  
  const result = playXRound(gameState, numberOfRounds);

  const indexOf1 = result.cups.indexOf(1);
  
  const tail = result.cups.splice(0, indexOf1);
  result.cups.push(...tail);

  result.cups.shift()

  return result.cups
    .join('');
}





export interface GameStateLinkedArray {
  cups: number[],
  currentCup: number,
  maxCup: number
}

export function convertToLinkedArray(orderedListOfCups) {
  const linkedArray: number[] = [-1];

  for(let i = 0; i < orderedListOfCups.length; i++) {
    const currentCup = orderedListOfCups[i];
    const nextIndex = (i+1) % orderedListOfCups.length;
    const nextCup = orderedListOfCups[nextIndex];
    linkedArray[currentCup] = nextCup;
  }

  return linkedArray;
}

export function convertToOrderedArray(linkedListOfCups) {
  const orderedArray: number[] = [];

  const firstItem = linkedListOfCups[1]; //?

  orderedArray.push(firstItem);

  let previousIndex = linkedListOfCups.indexOf(firstItem);

  while (previousIndex !== firstItem) {
    orderedArray.unshift(previousIndex);
    previousIndex = linkedListOfCups.indexOf(previousIndex);
  }

  return orderedArray;
}

export function shiftOrderedArray(orderedListOfCups, startingCup) {
  const indexOfStartingCup = orderedListOfCups.indexOf(startingCup);

  const tail = orderedListOfCups.splice(0, indexOfStartingCup);

  orderedListOfCups.push(...tail);
}

export function removeNext(linkedListOfCups, cup) {
  const nextCup = linkedListOfCups[cup];
  const nextNextCup = linkedListOfCups[nextCup];

  linkedListOfCups[cup] = nextNextCup;

  return nextCup;
}

export function removeNextThree(linkedListOfCups, cup) {
  return [
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup),
    removeNext(linkedListOfCups, cup)
  ]
}

export function insertNext (linkedListOfCups, cup, insertedCup) {
  const nextCup = linkedListOfCups[cup];

  linkedListOfCups[cup] = insertedCup;

  linkedListOfCups[insertedCup] = nextCup;
}

export function insertNextThree(linkedListOfCups, cup, insertedCups) {
  insertedCups.reverse().forEach(insertedCup => {
    insertNext(linkedListOfCups, cup, insertedCup)
  })
}

export function playRoundLinkedArray(gameState) {
  const nextThree = removeNextThree(gameState.cups, gameState.currentCup); //?

  let destinationCup = gameState.currentCup;
  do {
    destinationCup -= 1;
    if (destinationCup === 0) {
      destinationCup = gameState.maxCup;
    }
  } while (nextThree.includes(destinationCup))

  insertNextThree(gameState.cups, destinationCup, nextThree);

  gameState.currentCup = gameState.cups[gameState.currentCup];
}

export function playXRoundLinkedArray(gameState, numberOfRounds) {
  for (let i = 0; i < numberOfRounds; i++) {
    playRoundLinkedArray(gameState);
  }
}

export function getStars(input, numberOfRounds) {
  const cups = input.split('').map(i => parseInt(i)); //?
  const linkedCups = convertToLinkedArray(cups); //?.

  const macCups = 1_000_000;
  
  const maxCupsFromFile = Math.max(...cups);
  let lastCup = cups[cups.length - 1];
  for (let i = maxCupsFromFile + 1; i <= macCups; i++) {
    insertNext(linkedCups, lastCup, i);
    lastCup = i;
  }

  const gameState = {
    cups: linkedCups,
    currentCup: cups[0],
    maxCup: macCups
  };

  playXRoundLinkedArray(gameState, numberOfRounds);

  const nextCup1 = gameState.cups[1];
  const nextCup2 = gameState.cups[nextCup1];

  return nextCup1 * nextCup2;
}<fim_middle>",correct,2136
Group,Group,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command): <fim_suffix> {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3365
Group,Group,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group): <fim_suffix> {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3367
Group,Group,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group: <fim_suffix>) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3368
Group,Group,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group: <fim_suffix>, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text)
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3372
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error): <fim_suffix> {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1145
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error): <fim_suffix> {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1147
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error): <fim_suffix> {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1151
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error): <fim_suffix> {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1153
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error): <fim_suffix> {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1155
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error): <fim_suffix> {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1157
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?): <fim_suffix> {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1159
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?): <fim_suffix> {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1161
HttpResponse,HttpResponse,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?): <fim_suffix> {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1163
I,I,e0adc0a947e9e83b8bc03219033fde3d085cbfad,"<fim_prefix>
/**
 * The **bulk function** receives and array of atomic inputs and returns and array of outputs processed in bulk mode.
 * It is essential that this function works more effeciently with an array of items than doing the same operation individually.
 * The response of this function is an array where the items must be placed in the same position than the input items.
 * ```typescript
 * //bulk operation
 * mongodb.insertMany([obj1, obj2, obj3])
 * //atomic operation
 * Promise.all([
 *  mongodb.insertOne(obj1),
 *  mongodb.insertOne(obj2),
 *  mongodb.insertOne(obj3)
 * ])
 * ```
 * 
 * @typeParam Input The input item type.
 * @typeParam Output The output response type.
 */
export type ExecuteBulkFn<Input,Output> = (items) => Promise<Output[]>

class PromiseBulkSingle<I,O> {
    private _executionItemsPromise: Promise<O[]> = Promise.resolve([])
    private _pendingItems = []
    private _free = true


    constructor(private readonly _executeBulk) {}

    async execute(item: <fim_suffix>) {
        const newSize = this._pendingItems.push(item)
        const myIndex = newSize - 1

        if (this._free) {
            this._free = false
            const itemsToExecute = this._pendingItems
            this._pendingItems = []
            this._executionItemsPromise = this.executeBulk(itemsToExecute)
    
            const executedItems = await this._executionItemsPromise
            this._free = true
    
            return executedItems[myIndex]
    
        } else {
            await this._executionItemsPromise
    
            if (this._free) {
                this._free = false
                const itemsToExecute = this._pendingItems
                this._pendingItems = []
                this._executionItemsPromise = this.executeBulk(itemsToExecute)
    
                const executionItems = await this._executionItemsPromise
                this._free = true
                return executionItems[myIndex]
            } else {
                const executedItems = await this._executionItemsPromise
                return executedItems[myIndex]
            }
        }
    }

    executeBulk(items) {
        if (!this._executeBulk) {
            throw new Error('Execute bulk not implemented')
        }
        return this._executeBulk(items)
    }



}

/**
 * This is the main `promise-bulk` feature.
 * This class allows to instantiate bulk processes.
 * 
 * A bulk function is the only required constructor parameter.
 * 
 * @typeParam Input The type of the input items to be processed by the bulk function.
 * 
 * @typeParam Output The type of the response items of the bulk function.
 */
export class PromiseBulk<Input = unknown, Output = unknown> {
    private _index = 0
    private readonly _bulks: PromiseBulkSingle<Input,Output>[]

    /**
     * 
     * @param bulkFn Bulk function. Receives an array of imputs and returns an array of outputs.
     * @param _concurrency Limit of concurrent calls to the bulk function.
     */
    constructor(bulkFn, private readonly _concurrency = 1) {
        this._index = 0
        this._bulks = Array.from({length: _concurrency}, () => new PromiseBulkSingle(bulkFn))
    }

    /**
     * Execute
     * 
     * This function adds one item to the bulk process and waits for its response in a bulk operation.
     * @param item Atomic input that will be included in a bulk process
     * @returns The associated response to the input (will be returned from a bulk process)
     */
    async execute(item) {
        const index = this._index
        this._index = (this._index+1) % this._concurrency
        return this._bulks[index].execute(item)
    }
}<fim_middle>",correct,4342
Id,Id,32fad88cf989fe13e31b63cb2ea82544e40b70b9,"<fim_prefix>type Id = string | number;
type Owner = { Id: string }

export enum NFTAction {
  SEND='SEND',
  CONSUME='CONSUME',
  FREEZE='FREEZE',
  DELEGATE='DELEGATE',
  THAW='THAW',
  REVOKE='REVOKE',
  NONE='',
}

export const actionResolver: Record<NFTAction, [string, string]> = {
  SEND: ['uniques','transfer'],
  CONSUME: ['uniques','burn'],
  DELEGATE: ['uniques','approveTransfer'],
  FREEZE: ['uniques','freeze'],
  THAW: ['uniques','thaw'],
  REVOKE: ['uniques','cancelApproval'],
  '': ['',''],
}

export const basicUpdateFunction = (name, index) => `${name} #${index + 1}`

class NFTUtils {
  static createCollection(id, admin) {
    return [String(id), { Id: admin }]
  }


  static createNFT(classId, id, owner) {
    return [String(classId), String(id), { Id: owner }]
  }

  static getActionParams(selectedAction, classId: <fim_suffix>, id, meta) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.CONSUME:
    case NFTAction.DELEGATE:
    case NFTAction.REVOKE:
      return [classId, id, meta]
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return [classId, id]
    default:
      throw new Error('Action not found')
    }
  }

  static apiCall(selectedAction) {
    return actionResolver[selectedAction] || new Error('Action not found')

  }

  static correctMeta(selectedAction, meta, currentOwner, delegate) {
    switch (selectedAction) {
    case NFTAction.SEND:
    case NFTAction.DELEGATE:
      return meta
    case NFTAction.CONSUME:
      return currentOwner
    case NFTAction.REVOKE:
      return delegate
    case NFTAction.FREEZE:
    case NFTAction.THAW:
      return ''
    default:
      throw new Error('Action not found')
    }
  }
}



export default NFTUtils
<fim_middle>",correct,2625
Index,Index,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select: <fim_suffix>)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1193
Instruction,Instruction,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input) : <fim_suffix> {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,292
Instruction,Instruction,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i: <fim_suffix>)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,299
Instruction,Instruction,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i: <fim_suffix>)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,304
Job,Job,2c31ac9149f16e030306749f32588668642a2f12,"<fim_prefix>export default function parseJob({ skills, seniorityLevels }) {
  return ({
    id,
    title,
    description,
    seniorities: seniorityIds,
    mainSkills: mainSkillIds,
    completeSkills: completeSkillIds,
    location,
    remote,
    startingDate,
  }: <fim_suffix>) => {
    const seniorities = findAll(seniorityLevels, seniorityIds) as Seniority[];
    const mainSkills = findAll(skills, mainSkillIds) as Skill[];
    const completeSkills = findAll(skills, completeSkillIds) as Skill[];
    return {
      id,
      title,
      description,
      location,
      remote,
      startingDate,
      experience: getExperienceRange(seniorities),
      salary: getSalaryRange(seniorities),
      mainSkills: getSkills(mainSkills),
      completeSkills: getSkills(completeSkills),
    };
  };
}

function find(items, id) {
  return items.find((item) => item.id === id);
}

function findAll(items, ids = []) {
  return ids.map((id) => find(items, id));
}

function getSkills(skills) {
  return skills.map((skill) => skill.name);
}

function getExperienceRange(seniorities) {
  return seniorities
    .reduce(
      (acc, seniority) => [
        Math.min(seniority.experience.min, acc[0]),
        Math.max(seniority.experience.max || seniority.experience.min, acc[1]),
      ],
      [Infinity, 0]
    )
    .join("" - "");
}

function getSalaryRange(seniorities) {
  return seniorities
    .reduce(
      (acc, seniority) => [
        Math.round(Math.min(seniority.salary.base, acc[0])),
        Math.round(Math.max(seniority.salary.base, acc[1])),
      ],
      [Infinity, 0]
    )
    .join("" - "");
}

type Skill = { id: string; name: string };

type Seniority = {
  id: string;
  experience: { max: number; min: number };
  salary: { base: number };
};

export type Job = {
  id: string;
  title: string;
  description: string;
  seniorities: string[];
  mainSkills: string[];
  completeSkills: string[];
  location: string;
  remote: boolean;
  startingDate: number;
};
<fim_middle>",correct,3117
JsonValue,JsonValue,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue: <fim_suffix>, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,525
JsonValue,JsonValue,a9791fb0765ba4c24e3bb22e28c8274b007ee1ae,"<fim_prefix>export type JsonValue =
	| null
	| string
	| number
	| boolean
	| JsonValue[]
	| { [key: string]: JsonValue };

type Dict<T> = { [key: string]: T };
const indexableObj = (i): i is Dict<JsonValue> => typeof i === 'object' && !Array.isArray(i);

/**
 * @param path - sringPath.with.dot.separators
 * @param input - A JSON Value
 */
export const getPath = (path, input) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;
	// .map(s=> {const n = Number.parseInt(s) })
	return pathSegments.reduce((p, seg) => {
		if (indexableObj(p)) {
			if (seg in p) {
				return p[seg] as JsonValue | undefined;
			} else {
				return undefined;
			}
		} else if (Array.isArray(p)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < p.length) {
				return p[n];
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}, input as JsonValue | undefined);
};

export const setPath = (
	path,
	replacerValue,
	input,
): <fim_suffix> => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;

	const seg = pathSegments[0];
	if (pathSegments.length === 1) {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	} else {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = setPath(pathSegments.slice(1), replacerValue, input[seg]);
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = setPath(pathSegments.slice(1), replacerValue, input[n]);
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	}
};

export default getPath;
<fim_middle>",correct,1665
JsonValue,JsonValue,a9791fb0765ba4c24e3bb22e28c8274b007ee1ae,"<fim_prefix>export type JsonValue =
	| null
	| string
	| number
	| boolean
	| JsonValue[]
	| { [key: string]: JsonValue };

type Dict<T> = { [key: string]: T };
const indexableObj = (i): i is Dict<JsonValue> => typeof i === 'object' && !Array.isArray(i);

/**
 * @param path - sringPath.with.dot.separators
 * @param input - A JSON Value
 */
export const getPath = (path, input) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;
	// .map(s=> {const n = Number.parseInt(s) })
	return pathSegments.reduce((p, seg) => {
		if (indexableObj(p)) {
			if (seg in p) {
				return p[seg] as JsonValue | undefined;
			} else {
				return undefined;
			}
		} else if (Array.isArray(p)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < p.length) {
				return p[n];
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}, input as JsonValue | undefined);
};

export const setPath = (
	path,
	replacerValue,
	input: <fim_suffix>,
) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;

	const seg = pathSegments[0];
	if (pathSegments.length === 1) {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	} else {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = setPath(pathSegments.slice(1), replacerValue, input[seg]);
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = setPath(pathSegments.slice(1), replacerValue, input[n]);
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	}
};

export default getPath;
<fim_middle>",correct,1666
JsonValue,JsonValue,a9791fb0765ba4c24e3bb22e28c8274b007ee1ae,"<fim_prefix>export type JsonValue =
	| null
	| string
	| number
	| boolean
	| JsonValue[]
	| { [key: string]: JsonValue };

type Dict<T> = { [key: string]: T };
const indexableObj = (i): i is Dict<JsonValue> => typeof i === 'object' && !Array.isArray(i);

/**
 * @param path - sringPath.with.dot.separators
 * @param input - A JSON Value
 */
export const getPath = (path, input: <fim_suffix>) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;
	// .map(s=> {const n = Number.parseInt(s) })
	return pathSegments.reduce((p, seg) => {
		if (indexableObj(p)) {
			if (seg in p) {
				return p[seg] as JsonValue | undefined;
			} else {
				return undefined;
			}
		} else if (Array.isArray(p)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < p.length) {
				return p[n];
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	}, input as JsonValue | undefined);
};

export const setPath = (
	path,
	replacerValue,
	input,
) => {
	const pathSegments = typeof path === 'string' ? path.split('.') : path;

	const seg = pathSegments[0];
	if (pathSegments.length === 1) {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = replacerValue;
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	} else {
		if (indexableObj(input)) {
			if (seg in input) {
				input[seg] = setPath(pathSegments.slice(1), replacerValue, input[seg]);
				return input;
			} else {
				return input;
			}
		} else if (Array.isArray(input)) {
			const n = Number.parseInt(seg);
			if (Number.isSafeInteger(n) && n < input.length) {
				input[n] = setPath(pathSegments.slice(1), replacerValue, input[n]);
				return input;
			} else {
				return input;
			}
		} else {
			return input;
		}
	}
};

export default getPath;
<fim_middle>",correct,1670
K,K,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min(): <fim_suffix> {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1741
K,K,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key: <fim_suffix>, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1778
K,K,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key: <fim_suffix>, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1781
K,K,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key: <fim_suffix>, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1784
K,K,f77b40c49a005709dafda73e190c54efa502710e,"<fim_prefix>// Key type is always a string
type K = string;

// Internal item storage type
type Item<K, V> = [K, V, number];

// Type of a new item passed to the constructor. Level must be passed internally only.
type NewItem<K, V> = [K, V, number?];

/**
 * Immutable flat tree is the tree where position in hierarchy is defined by a delimited string key.
 */
export class ImmutableFlatTree<V> {
    private items: Item<K, V>[]; // Internally we store key, value and level
    private delimiter: K;

    /**
     * Creates the instance of ImmutableFlatTree from an array of [key, value] tuples
     * @param items Array of [key, value] tuples
     */
    constructor(items, delimiter: <fim_suffix> = ""."") {
        this.delimiter = delimiter;
        this.items = new Array<Item<K, V>>()

        const keys = new Set<K>();

        // Fill in the new items calculating level if necessary, skipping duplicates
        items.forEach(([key, value, level]) => {
            if (!keys.has(key)) {
                this.items.push([key, value, level ? level : this.levelOf(key)])
                keys.add(key)
            }
        })
    }

    private levelOf(value) {
        return value.split(this.delimiter).length
    }

    /**
     * Returns the elements of a tree that meet the condition specified in a callback function.
     * @param predicate A function that accepts up to three arguments. The filter method calls the predicate function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the predicate function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(predicateeFlatTree(this.items.filter(predicate), this.delimiter)
    };

    /**
     * Returns item descendants
     * @param parent Parent key (or empty for root)
     * @param depth Depth (1 means children)
     * @returns Map of descendants
     */
    descendants(parentKey?, depth?) {
        let limit = depth

        if ((parentKey == null) && (depth == null)) {
            return this;
        }

        if (parentKey) {
            const parent = this.get(parentKey)
            if (!parent) {
                // Parent not found: return the empty tree
                return new ImmutableFlatTree<V>([]);
            }

            const [, , parentDepth] = parent
            if ((parentDepth) && (depth)) {
                limit = parentDepth + depth
            }
        }

        return this.filter(item => {
            let match: boolean
            const [key, , level] = item

            match = false

            if (parentKey) {
                match = key.startsWith(parentKey+this.delimiter) && key != parentKey
            }

            if (limit) {
                match = match && (level <= limit)
            }

            return match ? item : null
        });
    }

    /**
     * Iterates over tree elements
     * @param callbackfn Callback
     * @param thisArg Value of this
     */
    forEach(callbackfn.forEach(callbackfn);
    }

    /**
     * Gets tree item by key
     * @param key Item key
     * @returns Tree item
     */
    get(key) {
        return this.items.find((value) => value[0] == key ? value : null)
    }

    /**
     * Returns tree length
     */
    get size() {
        return this.items.length;
    }

    /**
     * Returns entries as array
     */
    get entries() {
        return this.items
    }
}
<fim_middle>",correct,2489
Key,Key,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name
): <fim_suffix> => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,206
Key,Key,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use() {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key: <fim_suffix>,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query) {
  return new StrictQuery(query)
}
<fim_middle>",correct,535
Lab,Lab,dc235984d999ebb87408d4cd3dbfcb29be357945,"<fim_prefix>const { abs, atan2, cos, exp, hypot, PI, sin, sqrt } = Math

type XYZ = [X: number, Y: number, Z: number]
type Lab = [L: number, a: number, b: number]

/**
 * Scale byte to 0...1.
 */
const unscaleByte = (x) => x / 255

/**
 * Invert sRGB gamma function.
 */
const invertGamma = (u) =>
  u <= 0.04045 ? u / 12.92 : ((u + 0.055) / 1.055) ** 2.4

const f = (w) =>
  w > 216 / 24389 ? w ** (1 / 3) : (841 / 108) * w + 4 / 29

/**
 * White point used in sRGB.
 */
const whiteD65: XYZ = [0.9505, 1, 1.089]

/**
 * Convert sRGB to Lab color.
 */
const rgbToLab = (white) => ([R, G, B]): <fim_suffix> => {
  R = invertGamma(unscaleByte(R))
  G = invertGamma(unscaleByte(G))
  B = invertGamma(unscaleByte(B))
  const X = 0.4124564 * R + 0.3575761 * G + 0.1804375 * B
  const Y = 0.2126729 * R + 0.7151522 * G + 0.072175 * B
  const Z = 0.0193339 * R + 0.119192 * G + 0.9503041 * B
  const l = f(Y / white[1])
  const L = 116 * l - 16
  const a = 500 * (f(X / white[0]) - l)
  const b = 200 * (l - f(Z / white[2]))
  return [L, a, b]
}

const degrees = (radians) => radians * (180 / PI)
const radians = (degrees) => degrees * (PI / 180)

/**
 * Returns a mod b
 */
const mod = (b) => (a) => ((a % b) + b) % b

const mod360 = mod(360)

const h = (b, a) => mod360(degrees(atan2(b, a)))

const sc7 = (c) => sqrt(c ** 7 / (c ** 7 + 25 ** 7))

const cosRad = (x) => cos(radians(x))

/**
 * Return CIEDE2000 color difference between two sRGB colors which components
 * are expected in the range 0 to 255.
 */
export const distanceRgb = (rgb1, rgb2) => {
  let [l1, a1, b1] = rgbToLab(whiteD65)(rgb1)
  let [l2, a2, b2] = rgbToLab(whiteD65)(rgb2)
  let c1 = hypot(a1, b1)
  let c2 = hypot(a2, b2)
  const fc7 = (1 - sc7((c1 + c2) / 2)) / 2
  a1 += a1 * fc7
  a2 += a2 * fc7
  const h1 = h(b1, a1)
  const h2 = h(b2, a2)
  let hd = 0
  let hs = h1 + h2
  if (c1 * c2 !== 0) {
    hd = h2 - h1
    if (hd > 180) {
      hd -= 360
    } else if (hd < -180) {
      hd += 360
    }
    const dh = abs(h1 - h2)
    if (dh <= 180) {
      hs /= 2
    } else if (dh > 180 && hs < 360) {
      hs = (hs + 360) / 2
    } else if (dh > 180 && hs >= 360) {
      hs = (hs - 360) / 2
    }
  }
  c1 = hypot(a1, b1)
  c2 = hypot(a2, b2)
  const ml = (l1 + l2) / 2
  const mc = (c1 + c2) / 2
  const t =
    1 -
    0.17 * cosRad(hs - 30) +
    0.24 * cosRad(2 * hs) +
    0.32 * cosRad(3 * hs + 6) -
    0.2 * cosRad(4 * hs - 63)
  const sl = 1 + (0.015 * (ml - 50) ** 2) / sqrt(20 + (ml - 50) ** 2)
  const sc = 1 + 0.045 * mc
  const sh = 1 + 0.015 * mc * t
  const rt = -2 * sc7(mc) * sin(radians(60 * exp(-(((hs - 275) / 25) ** 2))))
  const dl = (l2 - l1) / sl
  const dc = (c2 - c1) / sc
  const dh = (2 * sqrt(c1 * c2) * sin(radians(hd) / 2)) / sh
  return sqrt(dl ** 2 + dc ** 2 + dh ** 2 + rt * dc * dh)
}
<fim_middle>",correct,4770
Language,Language,76a884ba965e8d7964d8852a0c0f228c1ae1d7ad,"<fim_prefix>type Language = 'en' | 'zh';

type Terms = {
  selfPick: string;
  noFlowers: string;
  flowers: string;
  commonHand: string;
  fullyConcealedHand: string;
  seatWind: string;
  roundWind: string;
  dragons: string;
  mixedOrphans: string;
  winByLastCatch: string;
  robbingKong: string;
  oneCompleteSetOfFlowers: string;
  twoCompleteSetOfFlowers: string;
  winByKong: string;
  mixedOneSuit: string;
  allInTriplets: string;
  flowerHand: string;
  smallDragon: string;
  allOneSuit: string;
  smallWind: string;
  greatDragon: string;
  greatWind: string;
  allHonors: string;
  orphans: string;
  thirteenOrphans: string;
  kaanKaanHand: string;
  winByDoubleKong: string;
  eightImmortalsCrossingTheSea: string;
  allKongs: string;
  nineGates: string;
  earthlyHand: string;
  heavenlyHand: string;
};

export default class Glossary {
  private static readonly CHINESE_MAP: Terms = {
    selfPick: '自摸',
    noFlowers: '無花',
    flowers: '正花',
    commonHand: '平糊',
    fullyConcealedHand: '門前清',
    seatWind: '門風',
    roundWind: '圈風',
    dragons: '中/發/白',
    mixedOrphans: '花幺',
    winByLastCatch: '海底撈月',
    robbingKong: '搶槓',
    oneCompleteSetOfFlowers: '一台花',
    twoCompleteSetOfFlowers: '兩台花',
    winByKong: '槓上自摸',
    mixedOneSuit: '混一色',
    allInTriplets: '對對糊',
    flowerHand: '花糊',
    smallDragon: '小三元',
    allOneSuit: '清一色',
    smallWind: '小四喜',
    greatDragon: '大三元',
    greatWind: '大四喜',
    allHonors: '字一色',
    orphans: '全幺九',
    thirteenOrphans: '十三幺',
    kaanKaanHand: '坎坎糊',
    winByDoubleKong: '槓上槓自摸',
    eightImmortalsCrossingTheSea: '八仙過海',
    allKongs: '十八羅漢',
    nineGates: '九子連環',
    earthlyHand: '地糊',
    heavenlyHand: '天糊',
  };

  private static readonly ENGLISH_MAP: Terms = {
    selfPick: 'self-pick',
    noFlowers: 'no flowers',
    flowers: 'flowers matching seat position',
    commonHand: 'common hand',
    fullyConcealedHand: 'fully concealed hand',
    seatWind: 'seat wind',
    roundWind: 'round wind',
    dragons: 'dragons',
    mixedOrphans: 'mixed orphans',
    winByLastCatch: 'win by last catch',
    robbingKong: 'robbing kong',
    oneCompleteSetOfFlowers: 'one complete set of flowers',
    twoCompleteSetOfFlowers: 'two complete set of flowers',
    winByKong: 'win by Kong',
    mixedOneSuit: 'mixed one suit',
    allInTriplets: 'all in triplets',
    flowerHand: 'flower hand',
    smallDragon: 'small dragon',
    allOneSuit: 'all one suit',
    smallWind: 'small wind',
    greatDragon: 'great dragon',
    greatWind: 'great wind',
    allHonors: 'all honors',
    orphans: 'orphans',
    thirteenOrphans: 'thirteen orphans',
    kaanKaanHand: 'kaan kaan hand',
    winByDoubleKong: 'win by double Kong',
    eightImmortalsCrossingTheSea: 'eight immortals crossing the sea',
    allKongs: 'all Kongs',
    nineGates: 'nine gates',
    earthlyHand: 'earthly hand',
    heavenlyHand: 'heavenly hand',
  };

  private static language: Language = 'en';

  public static get() {
    if (this.language === 'en') {
      return this.ENGLISH_MAP;
    } else if (this.language === 'zh') {
      return this.CHINESE_MAP;
    } else {
      throw new Error('Language setting has not been configured appropriately.');
    }
  }

  public static setLanguage(languageInput: <fim_suffix>) {
    if (languageInput === 'zh' || languageInput === 'en') {
      this.language = languageInput;
    } else {
      throw new Error('Invalid input of language setting.');
    }
  }
}
<fim_middle>",correct,2148
License,License,39850647fe41aa810255752b914cdd87b3e420dc,"<fim_prefix>export const Kind = 'Core#License';

export interface ILicense {
  kind: typeof Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;
}

export class License {
  kind = Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;

  static fromUrl(url, name?) {
    return new License({
      kind: Kind,
      url,
      name,
    });
  }

  static fromContent(content, name?): <fim_suffix> {
    return new License({
      kind: Kind,
      content,
      name,
    });
  }

  /**
   * @param input The license definition used to restore the state.
   */
  constructor(input?) {
    let init: ILicense;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new license clearing anything that is so far defined.
   * 
   * Note, this throws an error when the license is not a license object.
   */
  new(init) {
    if (!License.isLicense(init)) {
      throw new Error(`Not a license.`);
    }
    const { url, content, name } = init;
    this.kind = Kind;
    this.name = name;
    this.content = content;
    this.url = url;
  }

  /**
   * Checks whether the input is a definition of a license.
   */
  static isLicense(input) {
    const typed = input as ILicense;
    if (typed && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: ILicense = {
      kind: Kind,
    };
    if (this.name) {
      result.name = this.name;
    }
    if (this.url) {
      result.url = this.url;
    }
    if (this.content) {
      result.content = this.content;
    }
    return result;
  }
}
<fim_middle>",correct,1627
License,License,39850647fe41aa810255752b914cdd87b3e420dc,"<fim_prefix>export const Kind = 'Core#License';

export interface ILicense {
  kind: typeof Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;
}

export class License {
  kind = Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;

  static fromUrl(url, name?): <fim_suffix> {
    return new License({
      kind: Kind,
      url,
      name,
    });
  }

  static fromContent(content, name?) {
    return new License({
      kind: Kind,
      content,
      name,
    });
  }

  /**
   * @param input The license definition used to restore the state.
   */
  constructor(input?) {
    let init: ILicense;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new license clearing anything that is so far defined.
   * 
   * Note, this throws an error when the license is not a license object.
   */
  new(init) {
    if (!License.isLicense(init)) {
      throw new Error(`Not a license.`);
    }
    const { url, content, name } = init;
    this.kind = Kind;
    this.name = name;
    this.content = content;
    this.url = url;
  }

  /**
   * Checks whether the input is a definition of a license.
   */
  static isLicense(input) {
    const typed = input as ILicense;
    if (typed && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: ILicense = {
      kind: Kind,
    };
    if (this.name) {
      result.name = this.name;
    }
    if (this.url) {
      result.url = this.url;
    }
    if (this.content) {
      result.content = this.content;
    }
    return result;
  }
}
<fim_middle>",correct,1630
Matrix,Matrix,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols): <fim_suffix>
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1189
Matrix,Matrix,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select): <fim_suffix>
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1192
Matrix,Matrix,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by): <fim_suffix>
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1214
Matrix,Matrix,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b: <fim_suffix>, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1216
Matrix,Matrix,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a): <fim_suffix>
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1226
Matrix,Matrix,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a: <fim_suffix>)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1227
MinMax,MinMax,ac730fc696dbdeb02598746fef516744d766ee52,"<fim_prefix>interface MinMax {
  min: number
  max: number
}

export class RelativeScale {
  static scale (data, tickCount, maxFactor) {
    const {
      min,
      max
    }: MinMax = RelativeScale.calculateBounds(data)

    let factor = 1

    while (true) {
      const scale = Math.pow(10, factor)

      const scaledMin = min - (min % scale)
      let scaledMax = max + (max % scale === 0 ? 0 : scale - (max % scale))

      // Prevent min/max from being equal (and generating 0 ticks)
      // This happens when all data points are products of scale value
      if (scaledMin === scaledMax) {
        scaledMax += scale
      }

      const ticks = (scaledMax - scaledMin) / scale

      if (ticks <= tickCount || (typeof maxFactor === 'number' && factor === maxFactor)) {
        return {
          scaledMin,
          scaledMax,
          scale
        }
      } else {
        // Too many steps between min/max, increase factor and try again
        factor++
      }
    }
  }

  static scaleMatrix (data, tickCount, maxFactor) {
    const nonNullData = data.flat().filter((val) => val !== null)

    // when used with the spread operator large nonNullData/data arrays can reach the max call stack size
    // use reduce calls to safely determine min/max values for any size of array
    // https://stackoverflow.com/questions/63705432/maximum-call-stack-size-exceeded-when-using-the-dots-operator/63706516#63706516
    const max = nonNullData.reduce((a, b) => {
      return Math.max(a, b)
    }, Number.NEGATIVE_INFINITY)

    return RelativeScale.scale(
      [0, RelativeScale.isFiniteOrZero(max)],
      tickCount,
      maxFactor
    )
  }

  static generateTicks (min, max, step) {
    const ticks = []
    for (let i = min; i <= max; i += step) {
      ticks.push(i)
    }
    return ticks
  }

  static calculateBounds (data): <fim_suffix> {
    if (data.length === 0) {
      return {
        min: 0,
        max: 0
      }
    } else {
      const nonNullData = data.filter((val) => val !== null)

      // when used with the spread operator large nonNullData/data arrays can reach the max call stack size
      // use reduce calls to safely determine min/max values for any size of array
      // https://stackoverflow.com/questions/63705432/maximum-call-stack-size-exceeded-when-using-the-dots-operator/63706516#63706516
      const min = nonNullData.reduce((a, b) => {
        return Math.min(a, b)
      }, Number.POSITIVE_INFINITY)
      const max = nonNullData.reduce((a, b) => {
        return Math.max(a, b)
      }, Number.NEGATIVE_INFINITY)

      return {
        min: RelativeScale.isFiniteOrZero(min),
        max: RelativeScale.isFiniteOrZero(max)
      }
    }
  }

  static isFiniteOrZero (val) {
    return Number.isFinite(val) ? val : 0
  }
}
<fim_middle>",correct,1057
Money,Money,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest() {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions): <fim_suffix> {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",correct,2966
Money,Money,57d87d12960f35a593f6da68902f487a24c0f939,"<fim_prefix>// ✔️ Define types (or interfaces, os structs... or even classes)
type Currency = 'EUR' | 'USD';

type Money = { amount: number; currency: Currency };

type SavingsCondition = { principal: Money; rate: number; years: number };

export function calculateInterest(): <fim_suffix> {
  // ✔️ object literal
  const mySavingsConditionsLit: SavingsCondition = {
    principal: { amount: 1000, currency: 'EUR' },
    rate: 3.5,
    years: 1,
  };
  // ✔️ object factory
  const mySavingsConditions: SavingsCondition = conditionsFactory(100, 3.5);

  // ✔️ single parameter
  const interest = getSimpleInterest(mySavingsConditions);
  return interest;
}

function moneyFactory(amount, currency = 'EUR') {
  // ✔️ parameter validation, and default value
  assertAmountPositive(amount);
  return {
    amount,
    currency,
  };
}

function conditionsFactory(
  amount,
  rate,
  years = 1,
  currency = 'EUR'
) {
  // ✔️ parameter validation
  assertAmountPositive(amount);
  assertRateRange(rate);
  assertYearsRange(years);

  const conditions: SavingsCondition = {
    principal: moneyFactory(amount, currency),
    rate: rate,
    years: years,
  };
  return conditions;
}

function assertYearsRange(years) {
  const MIN_YEARS = 0;
  const MAX_YEARS = 100;
  if (years < MIN_YEARS || years > MAX_YEARS)
    throw new Error(`Year must be between ${MIN_YEARS} and ${MAX_YEARS}`);
}

function assertRateRange(rate) {
  const MIN_RATE = 1;
  const MAX_RATE = 10;
  if (rate < MIN_RATE || rate > MAX_RATE)
    throw new Error(`Rate must be between ${MIN_RATE} and ${MAX_RATE}`);
}

function assertAmountPositive(amount) {
  if (amount < 0) throw new Error(`Amount must be positive`);
}

function getSimpleInterest(conditions) {
  const PER_CENT = 100;
  const interestAmount =
    (conditions.principal.amount * conditions.rate * conditions.years) / PER_CENT;
  return moneyFactory(interestAmount, conditions.principal.currency);
}
<fim_middle>",correct,2977
Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source: <fim_suffix>, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3864
Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v: <fim_suffix>) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3865
Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target: <fim_suffix>) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3867
Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source: <fim_suffix>, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3868
Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node: <fim_suffix>) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3869
Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node: <fim_suffix>) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3870
Node,Node,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node: <fim_suffix>) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3872
Node,Node,f6127d3ca25913df8797295ddc538560f5ecbd34,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 任务存放的数据结构
 * 类似小顶堆 将heap中最小的节点放在第一个
 * @flow strict
 */

export type Heap = Array<Node>
export type Node = {
  id: number
  sortIndex: number
}

/**
 * push一个任务
 * 先将任务放在队列末尾
 * 然后进行二分遍历，将最小的任务放在第一个
 */
export function push(heap, node) {
  const index = heap.length

  heap.push(node)
  siftUp(heap, node, index)
}

// 查看小顶堆的第一个任务
export function peek(heap) {
  return heap.length === 0 ? null : heap[0]
}

// 推出第一个任务
export function pop(heap) {
  if (heap.length === 0) {
    return null
  }

  const first = heap[0]
  const last = heap.pop() as Node

  if (last !== first) {
    heap[0] = last
    siftDown(heap, last, 0)
  }

  return first
}

/**
 * 上浮元素
 * 确保队列的第一个始终是sortIndex最小的
 *
 * 之所以不将入队的node直接和head[0]进行比较
 * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历
 */
function siftUp(heap, node, i) {
  let index = i

  while (index > 0) {
    // 获取队列中0到index的二分位置
    const parentIndex = (index - 1) >>> 1
    const parent = heap[parentIndex]

    /**
     * 如果中间位置的node和需要入队的node compare结果为正
     * 则表明需要入队的node需要继续往前移动
     * index为2或者1的时候 parentIndex会为0
     * 这样就比较了需要入队的node和head[0]
     */
    if (compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node
      heap[index] = parent
      index = parentIndex
    } else {
      // The parent is smaller. Exit.
      return
    }
  }
}

/**
 * 通过小顶堆寻找队列中最小的最小的
 * 确保队列的第一个始终是sortIndex最小的
 */
function siftDown(heap, node, i) {
  let index = i

  debugger
  const length = heap.length
  const halfLength = length >>> 1

  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1
    const left = heap[leftIndex]
    const rightIndex = leftIndex + 1
    const right = heap[rightIndex]

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) < 0) {
      // 先找到右子树中最小的
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right
        heap[rightIndex] = node
        index = rightIndex
      } else {
        // 右子树中最小的找到以后 再来比较左子树
        heap[index] = left
        heap[leftIndex] = node
        index = leftIndex
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right
      heap[rightIndex] = node
      index = rightIndex
    } else {
      // Neither child is smaller. Exit.
      return
    }
  }
}

// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id
function compare(a, b: <fim_suffix>) {
  // Compare sort index first, then task id.
  const diff = a.sortIndex - b.sortIndex

  return diff !== 0 ? diff : a.id - b.id
}
<fim_middle>",correct,4776
Node,Node,f6127d3ca25913df8797295ddc538560f5ecbd34,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 任务存放的数据结构
 * 类似小顶堆 将heap中最小的节点放在第一个
 * @flow strict
 */

export type Heap = Array<Node>
export type Node = {
  id: number
  sortIndex: number
}

/**
 * push一个任务
 * 先将任务放在队列末尾
 * 然后进行二分遍历，将最小的任务放在第一个
 */
export function push(heap, node) {
  const index = heap.length

  heap.push(node)
  siftUp(heap, node, index)
}

// 查看小顶堆的第一个任务
export function peek(heap) {
  return heap.length === 0 ? null : heap[0]
}

// 推出第一个任务
export function pop(heap) {
  if (heap.length === 0) {
    return null
  }

  const first = heap[0]
  const last = heap.pop() as Node

  if (last !== first) {
    heap[0] = last
    siftDown(heap, last, 0)
  }

  return first
}

/**
 * 上浮元素
 * 确保队列的第一个始终是sortIndex最小的
 *
 * 之所以不将入队的node直接和head[0]进行比较
 * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历
 */
function siftUp(heap, node, i) {
  let index = i

  while (index > 0) {
    // 获取队列中0到index的二分位置
    const parentIndex = (index - 1) >>> 1
    const parent = heap[parentIndex]

    /**
     * 如果中间位置的node和需要入队的node compare结果为正
     * 则表明需要入队的node需要继续往前移动
     * index为2或者1的时候 parentIndex会为0
     * 这样就比较了需要入队的node和head[0]
     */
    if (compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node
      heap[index] = parent
      index = parentIndex
    } else {
      // The parent is smaller. Exit.
      return
    }
  }
}

/**
 * 通过小顶堆寻找队列中最小的最小的
 * 确保队列的第一个始终是sortIndex最小的
 */
function siftDown(heap, node: <fim_suffix>, i) {
  let index = i

  debugger
  const length = heap.length
  const halfLength = length >>> 1

  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1
    const left = heap[leftIndex]
    const rightIndex = leftIndex + 1
    const right = heap[rightIndex]

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) < 0) {
      // 先找到右子树中最小的
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right
        heap[rightIndex] = node
        index = rightIndex
      } else {
        // 右子树中最小的找到以后 再来比较左子树
        heap[index] = left
        heap[leftIndex] = node
        index = leftIndex
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right
      heap[rightIndex] = node
      index = rightIndex
    } else {
      // Neither child is smaller. Exit.
      return
    }
  }
}

// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id
function compare(a, b) {
  // Compare sort index first, then task id.
  const diff = a.sortIndex - b.sortIndex

  return diff !== 0 ? diff : a.id - b.id
}
<fim_middle>",correct,4779
Node,Node,f6127d3ca25913df8797295ddc538560f5ecbd34,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 任务存放的数据结构
 * 类似小顶堆 将heap中最小的节点放在第一个
 * @flow strict
 */

export type Heap = Array<Node>
export type Node = {
  id: number
  sortIndex: number
}

/**
 * push一个任务
 * 先将任务放在队列末尾
 * 然后进行二分遍历，将最小的任务放在第一个
 */
export function push(heap, node) {
  const index = heap.length

  heap.push(node)
  siftUp(heap, node, index)
}

// 查看小顶堆的第一个任务
export function peek(heap) {
  return heap.length === 0 ? null : heap[0]
}

// 推出第一个任务
export function pop(heap) {
  if (heap.length === 0) {
    return null
  }

  const first = heap[0]
  const last = heap.pop() as Node

  if (last !== first) {
    heap[0] = last
    siftDown(heap, last, 0)
  }

  return first
}

/**
 * 上浮元素
 * 确保队列的第一个始终是sortIndex最小的
 *
 * 之所以不将入队的node直接和head[0]进行比较
 * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历
 */
function siftUp(heap, node: <fim_suffix>, i) {
  let index = i

  while (index > 0) {
    // 获取队列中0到index的二分位置
    const parentIndex = (index - 1) >>> 1
    const parent = heap[parentIndex]

    /**
     * 如果中间位置的node和需要入队的node compare结果为正
     * 则表明需要入队的node需要继续往前移动
     * index为2或者1的时候 parentIndex会为0
     * 这样就比较了需要入队的node和head[0]
     */
    if (compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node
      heap[index] = parent
      index = parentIndex
    } else {
      // The parent is smaller. Exit.
      return
    }
  }
}

/**
 * 通过小顶堆寻找队列中最小的最小的
 * 确保队列的第一个始终是sortIndex最小的
 */
function siftDown(heap, node, i) {
  let index = i

  debugger
  const length = heap.length
  const halfLength = length >>> 1

  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1
    const left = heap[leftIndex]
    const rightIndex = leftIndex + 1
    const right = heap[rightIndex]

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) < 0) {
      // 先找到右子树中最小的
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right
        heap[rightIndex] = node
        index = rightIndex
      } else {
        // 右子树中最小的找到以后 再来比较左子树
        heap[index] = left
        heap[leftIndex] = node
        index = leftIndex
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right
      heap[rightIndex] = node
      index = rightIndex
    } else {
      // Neither child is smaller. Exit.
      return
    }
  }
}

// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id
function compare(a, b) {
  // Compare sort index first, then task id.
  const diff = a.sortIndex - b.sortIndex

  return diff !== 0 ? diff : a.id - b.id
}
<fim_middle>",correct,4782
Node,Node,f6127d3ca25913df8797295ddc538560f5ecbd34,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 任务存放的数据结构
 * 类似小顶堆 将heap中最小的节点放在第一个
 * @flow strict
 */

export type Heap = Array<Node>
export type Node = {
  id: number
  sortIndex: number
}

/**
 * push一个任务
 * 先将任务放在队列末尾
 * 然后进行二分遍历，将最小的任务放在第一个
 */
export function push(heap, node: <fim_suffix>) {
  const index = heap.length

  heap.push(node)
  siftUp(heap, node, index)
}

// 查看小顶堆的第一个任务
export function peek(heap) {
  return heap.length === 0 ? null : heap[0]
}

// 推出第一个任务
export function pop(heap) {
  if (heap.length === 0) {
    return null
  }

  const first = heap[0]
  const last = heap.pop() as Node

  if (last !== first) {
    heap[0] = last
    siftDown(heap, last, 0)
  }

  return first
}

/**
 * 上浮元素
 * 确保队列的第一个始终是sortIndex最小的
 *
 * 之所以不将入队的node直接和head[0]进行比较
 * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历
 */
function siftUp(heap, node, i) {
  let index = i

  while (index > 0) {
    // 获取队列中0到index的二分位置
    const parentIndex = (index - 1) >>> 1
    const parent = heap[parentIndex]

    /**
     * 如果中间位置的node和需要入队的node compare结果为正
     * 则表明需要入队的node需要继续往前移动
     * index为2或者1的时候 parentIndex会为0
     * 这样就比较了需要入队的node和head[0]
     */
    if (compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node
      heap[index] = parent
      index = parentIndex
    } else {
      // The parent is smaller. Exit.
      return
    }
  }
}

/**
 * 通过小顶堆寻找队列中最小的最小的
 * 确保队列的第一个始终是sortIndex最小的
 */
function siftDown(heap, node, i) {
  let index = i

  debugger
  const length = heap.length
  const halfLength = length >>> 1

  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1
    const left = heap[leftIndex]
    const rightIndex = leftIndex + 1
    const right = heap[rightIndex]

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) < 0) {
      // 先找到右子树中最小的
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right
        heap[rightIndex] = node
        index = rightIndex
      } else {
        // 右子树中最小的找到以后 再来比较左子树
        heap[index] = left
        heap[leftIndex] = node
        index = leftIndex
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right
      heap[rightIndex] = node
      index = rightIndex
    } else {
      // Neither child is smaller. Exit.
      return
    }
  }
}

// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id
function compare(a, b) {
  // Compare sort index first, then task id.
  const diff = a.sortIndex - b.sortIndex

  return diff !== 0 ? diff : a.id - b.id
}
<fim_middle>",correct,4789
Number,Number,b1ab8c4be427c0afaf3d2a41ca821482dd787a9e,"<fim_prefix>type DotNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per dot (36)
type BamNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per bam (36)
type CrakNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per crak (36)
type WindNumber = ""East"" | ""West"" | ""South"" | ""North""; // 4 tiles per wind (16)
type DragonNumber = ""White"" | ""Green"" | ""Red""; // 4 tiles per wind (12)
type FlowerNumber = ""Rose"" | ""Lily"" | ""Tulip"" | ""Juniper""; // 2 tiles per flower (8)

export type Number = DotNumber | BamNumber | CrakNumber | WindNumber | DragonNumber | FlowerNumber;

export enum Suit {
  Dot = ""DOT"",
  Bam = ""BAM"",
  Crak = ""CRAK"",
  Wind = ""WIND"",
  Dragon = ""DRAGON"",
  Flower = ""FLOWER"",
}

export default class Tile {
  x: number;
  y: number;
  z: number;
  number: Number;
  suit: Suit;
  static dotNumbers: DotNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static bamNumbers: BamNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static crakNumbers: CrakNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static windNumbers: WindNumber[] = [""East"", ""West"", ""South"", ""North""];
  static dragonNumbers: DragonNumber[] = [""White"", ""Green"", ""Red""];
  static flowerNumbers: FlowerNumber[] = [""Rose"", ""Lily"", ""Tulip"", ""Juniper""];

  constructor(number: <fim_suffix>, suit) {
    this.number = number;
    this.suit = suit;
    this.x = -10
    this.y = -10
    this.z = -10
  }

  place({ z, x, y }) {
    this.z = z
    this.x = x
    this.y = y
  }

  get tileCells() {
    return [
      {
        z: this.z,
        x: this.x,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x,
        y: this.y + 1,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y + 1,
      },
    ];
  }

  get id() {
    return `${this.suit}_${this.number}_${this.x}_${this.y}_${this.z}`;
  }

  tileIsAdjacent(tile) {
    const t1Cells = this.tileCells;
    const t2Cells = tile.tileCells;

    let isAdjacent = false;

    t1Cells.forEach((t1) => {
      t2Cells.forEach((t2) => {
        // tile is above or below
        if ((t1.z === t2.z - 1 || t1.z === t2.z + 1) && t1.x === t2.x && t1.y === t2.y) {
          isAdjacent = true;
        }

        // tile is to the left or the right
        if (t1.z === t2.z && t1.y === t2.y && (t1.x === t2.x - 1 || t1.x === t2.x + 1)) {
          isAdjacent = true;
        }
      });
    });

    return isAdjacent;
  }
}
<fim_middle>",correct,1120
O,O,827363613ce8b25b320df2a9f97559bc4db11fc5,"<fim_prefix>/* eslint-disable */
// @ts-nocheck
/*
* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY
*/

/**
 * base64 encoder and decoder
 * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js
 */
// Base64 encoding table
const b64 = new Array(64);

// Base64 decoding table
const s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (let i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

export function b64Encode(buffer, start, end) {
	let parts: string[] = null;
  const chunk = [];
  let i = 0, // output index
    j = 0, // goto index
    t;     // temporary
  while (start < end) {
    const b = buffer[start++];
    switch (j) {
      case 0:
        chunk[i++] = b64[b >> 2];
        t = (b & 3) << 4;
        j = 1;
        break;
      case 1:
        chunk[i++] = b64[t | b >> 4];
        t = (b & 15) << 2;
        j = 2;
        break;
      case 2:
        chunk[i++] = b64[t | b >> 6];
        chunk[i++] = b64[b & 63];
        j = 0;
        break;
    }
    if (i > 8191) {
      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (j) {
    chunk[i++] = b64[t];
    chunk[i++] = 61;
    if (j === 1)
      chunk[i++] = 61;
  }
  if (parts) {
    if (i)
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    return parts.join("""");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
}

const invalidEncoding = ""invalid encoding"";

export function b64Decode(s) {
	const buffer = [];
	let offset = 0;
  let j = 0, // goto index
      t;     // temporary
  for (let i = 0; i < s.length;) {
    let c = s.charCodeAt(i++);
    if (c === 61 && j > 1)
        break;
    if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
    switch (j) {
      case 0:
        t = c;
        j = 1;
        break;
      case 1:
        buffer[offset++] = t << 2 | (c & 48) >> 4;
        t = c;
        j = 2;
        break;
      case 2:
        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
        t = c;
        j = 3;
        break;
      case 3:
        buffer[offset++] = (t & 3) << 6 | c;
        j = 0;
        break;
    }
  }
  if (j === 1)
      throw Error(invalidEncoding);
  return new Uint8Array(buffer);
}

function b64Test(s) {
	return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);
}

export interface InitReq extends RequestInit {
  pathPrefix?: string
}

export function replacer(key, value) {
  if(value && value.constructor === Uint8Array) {
    return b64Encode(value, 0, value.length);
  }

  return value;
}

export function fetchReq<I, O>(path, init?) {
  const {pathPrefix, ...req} = init || {}

  const url = pathPrefix ? `${pathPrefix}${path}` : path

  return fetch(url, req).then(r => r.json().then((body: <fim_suffix>) => {
    if (!r.ok) { throw body; }
    return body;
  })) as Promise<O>
}

// NotifyStreamEntityArrival is a callback that will be called on streaming entity arrival
export type NotifyStreamEntityArrival<T> = (resp) => void

/**
 * fetchStreamingRequest is able to handle grpc-gateway server side streaming call
 * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call
 * all entities will be returned as an array after the call finishes.
 **/
export async function fetchStreamingRequest<S, R>(path, callback?, init?) {
  const {pathPrefix, ...req} = init || {}
  const url = pathPrefix ?`${pathPrefix}${path}` : path
  const result = await fetch(url, req)
  // needs to use the .ok to check the status of HTTP status code
  // http other than 200 will not throw an error, instead the .ok will become false.
  // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#
  if (!result.ok) {
    const resp = await result.json()
    const errMsg = resp.error && resp.error.message ? resp.error.message : """"
    throw new Error(errMsg)
  }

  if (!result.body) {
    throw new Error(""response doesnt have a body"")
  }

  await result.body
    .pipeThrough(new TextDecoderStream())
    .pipeThrough<R>(getNewLineDelimitedJSONDecodingStream<R>())
    .pipeTo(getNotifyEntityArrivalSink((e) => {
      if (callback) {
        callback(e)
      }
    }))

  // wait for the streaming to finish and return the success respond
  return
}

/**
 * JSONStringStreamController represents the transform controller that's able to transform the incoming
 * new line delimited json content stream into entities and able to push the entity to the down stream
 */
interface JSONStringStreamController<T> extends TransformStreamDefaultController {
  buf?: string
  pos?: number
  enqueue: (s) => void
}

/**
 * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities
 */
function getNewLineDelimitedJSONDecodingStream<T>() {
  return new TransformStream({
    start(controller) {
      controller.buf = ''
      controller.pos = 0
    },

    transform(chunk, controller) {
      if (controller.buf === undefined) {
        controller.buf = ''
      }
      if (controller.pos === undefined) {
        controller.pos = 0
      }
      controller.buf += chunk
      while (controller.pos < controller.buf.length) {
        if (controller.buf[controller.pos] === '\n') {
          const line = controller.buf.substring(0, controller.pos)
          const response = JSON.parse(line)
          controller.enqueue(response.result)
          controller.buf = controller.buf.substring(controller.pos + 1)
          controller.pos = 0
        } else {
          ++controller.pos
        }
      }
    }
  })

}

/**
 * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return
 * a sink that will call the callback on entity arrival
 * @param notifyCallback
 */
function getNotifyEntityArrivalSink<T>(notifyCallback) {
  return new WritableStream<T>({
    write(entity) {
      notifyCallback(entity)
    }
  })
}

type Primitive = string | boolean | number;
type RequestPayload = Record<string, unknown>;
type FlattenedRequestPayload = Record<string, Primitive | Array<Primitive>>;

/**
 * Checks if given value is a plain object
 * Logic copied and adapted from below source: 
 * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js
 * @param  {unknown} value
 * @return {boolean}
 */
function isPlainObject(value) {
  const isObject =
    Object.prototype.toString.call(value).slice(8, -1) === ""Object"";
  const isObjLike = value !== null && isObject;

  if (!isObjLike || !isObject) {
    return false;
  }

  const proto = Object.getPrototypeOf(value);

  const hasObjectConstructor =
    typeof proto === ""object"" &&
    proto.constructor === Object.prototype.constructor;

  return hasObjectConstructor;
}

/**
 * Checks if given value is of a primitive type
 * @param  {unknown} value
 * @return {boolean}
 */
function isPrimitive(value) {
  return [""string"", ""number"", ""boolean""].some(t => typeof value === t);
}

/**
 * Checks if given primitive is zero-value
 * @param  {Primitive} value
 * @return {boolean}
 */
function isZeroValuePrimitive(value) {
  return value === false || value === 0 || value === """";
}

/**
 * Flattens a deeply nested request payload and returns an object
 * with only primitive values and non-empty array of primitive values
 * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto
 * @param  {RequestPayload} requestPayload
 * @param  {String} path
 * @return {FlattenedRequestPayload>}
 */
function flattenRequestPayload<T extends RequestPayload>(
  requestPayload,
  path = """"
) {
  return Object.keys(requestPayload).reduce(
    (acc, key) => {
      const value = requestPayload[key];
      const newPath = path ? [path, key].join(""."") : key;

      const isNonEmptyPrimitiveArray =
        Array.isArray(value) &&
        value.every(v => isPrimitive(v)) &&
        value.length > 0;

      const isNonZeroValuePrimitive =
        isPrimitive(value) && !isZeroValuePrimitive(value as Primitive);

      let objectToMerge = {};

      if (isPlainObject(value)) {
        objectToMerge = flattenRequestPayload(value as RequestPayload, newPath);
      } else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {
        objectToMerge = { [newPath]: value };
      }

      return { ...acc, ...objectToMerge };
    },
    {} as T
  ) as FlattenedRequestPayload;
}

/**
 * Renders a deeply nested request payload into a string of URL search
 * parameters by first flattening the request payload and then removing keys
 * which are already present in the URL path.
 * @param  {RequestPayload} requestPayload
 * @param  {string[]} urlPathParams
 * @return {string}
 */
export function renderURLSearchParams<T extends RequestPayload>(
  requestPayload,
  urlPathParams = []
) {
  const flattenedRequestPayload = flattenRequestPayload(requestPayload);

  const urlSearchParams = Object.keys(flattenedRequestPayload).reduce(
    (acc, key) => {
      // key should not be present in the url path as a parameter
      const value = flattenedRequestPayload[key];
      if (urlPathParams.find(f => f === key)) {
        return acc;
      }
      return Array.isArray(value)
        ? [...acc, ...value.map(m => [key, m.toString()])]
        : (acc = [...acc, [key, value.toString()]]);
    },
    [] as string[][]
  );

  return new URLSearchParams(urlSearchParams).toString();
}<fim_middle>",correct,4897
Operator,Operator,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty) => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator: <fim_suffix>, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",correct,4709
Operator,Operator,30ede5eb6d0f28926363e13b72a9f5cb510cecdc,"<fim_prefix>declare global {
  interface Window {
    plausible: (s, p?) => void
  }
}
export interface Row {
  operandA?: number
  operator?: Operator
  operandB?: number
  result?: number
}
export type Equation = Required<Row>
export type Answer = Required<Row>
export enum PlayState {
  Playing = 'playing',
  Won = 'won',
  Lost = 'lost',
}
export enum Difficulty {
  Easy = 'easy',
  Normal = 'normal',
  Hard = 'hard',
}
export type Operator = '+' | '-' | '*' | '/' | '^' | '%'
export const numbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
const easyOperators: Operator[] = ['+', '-', '*', '/']
const normalOperators: Operator[] = ['^']
const hardOperators: Operator[] = ['%']
export const allOperators = easyOperators.concat(normalOperators, hardOperators)

export type Column = 0 | 1 | 2 | 3 | 4 | 5
export const columns: Column[] = [0, 1, 2, 3, 4, 5]
export const rowCount: number = 6

export enum CellStatus {
  Green = 'green',
  Yellow = 'yellow',
  Gray = 'gray',
  Unguessed = 'unguessed',
}
export function validOperators(difficulty) {
  switch (difficulty) {
    case Difficulty.Easy:
      return easyOperators
    case Difficulty.Normal:
      return easyOperators.concat(normalOperators)
    case Difficulty.Hard:
      return allOperators
  }
}

export function nextCharIsAnOperator(row) {
  return row && row.operandA !== undefined && row.operator === undefined
}

export function backspace(row) {
  if (row.result != null) {
    if (row.result >= 10) {
      row.result = Math.floor(row.result / 10)
    } else {
      row.result = undefined
    }
  } else if (row.operandB != null) {
    row.operandB = undefined
  } else if (row.operator) {
    row.operator = undefined
  } else if (row.operandA != null) {
    row.operandA = undefined
  }
}

export function addCharacter(row, character) {
  if (row.operandA == null) {
    row.operandA = parseInt(character)
  } else if (row.operator == null) {
    //TODO: avoid cast?
    row.operator = character as Operator
  } else if (row.operandB == null) {
    row.operandB = parseInt(character)
  } else if (row.result == null) {
    row.result = parseInt(character)
  } else if (row.result < 10) {
    row.result = row.result * 10 + parseInt(character)
  }
}

export function rowCharacter(row, col) {
  switch (col) {
    case 0:
      return row.operandA?.toString() || ''
    case 1:
      return row.operator || ''
    case 2:
      return row.operandB?.toString() || ''
    case 3:
      return '='
    case 4:
      return row.result?.toString()[0] || ''
    case 5:
      return row.result?.toString()[1] || ''
  }
}

export function rowCharacters(row) {
  return columns.map((col) => {
    return rowCharacter(row, col)
  })
}
export function rowToString(row) {
  return rowCharacters(row).join('')
}

export function getRandomAnswer(difficulty) {
  const operator = getRandomOperator(difficulty)

  while (true) {
    const operandA = getRandomDigit()
    const operandB = getRandomDigit()
    const potentialAnswer: Answer = {
      operandA,
      operator: operator,
      operandB,
      result: getResult(operandA, operator, operandB),
    }
    if (validEquation(potentialAnswer) && isFunAnswer(potentialAnswer)) {
      return potentialAnswer
    }
  }
}

const getRandomDigit = () => {
  return Math.floor(Math.random() * 10)
}

const getRandomOperator = (difficulty): <fim_suffix> => {
  const ops = validOperators(difficulty)
  const randomOperatorIndex = Math.floor(Math.random() * ops.length)
  return ops[randomOperatorIndex]
}

function getResult(operandA, operator, operandB) {
  switch (operator) {
    case '+':
      return operandA + operandB
    case '-':
      return operandA - operandB
    case '*':
      return operandA * operandB
    case '/':
      return operandA / operandB
    case '^':
      return Math.pow(operandA, operandB)
    case '%':
      return operandA % operandB
  }
}

export function validEquation(row) {
  if (row.operandA !== undefined && row.operator !== undefined && row.operandB !== undefined) {
    const correctResult = getResult(row.operandA, row.operator, row.operandB)
    return (
      correctResult >= 0 &&
      correctResult < 100 &&
      Number.isInteger(correctResult) &&
      correctResult === row.result
    )
  } else {
    return false
  }
}

export function isFunAnswer(row) {
  switch (row.operator) {
    case '+':
      return row.operandA !== 0 && row.operandB !== 0
    case '-':
      return row.operandB !== 0
    case '*':
      return row.operandA > 1 && row.operandB > 1
    case '/':
      if (row.operandA === row.operandB) {
        return false
      }
      return row.operandA !== 0 && row.operandB !== 1
    case '^':
      return row.operandA > 1 && row.operandB > 1
    case '%':
      return row.operandA !== 0 && row.operandB !== 1
  }
}

export function newCellStatuses(
  prev,
  rowNumber,
  row,
  answer
) {
  const newCellStatuses = [...prev]
  newCellStatuses[rowNumber] = [...prev[rowNumber]]
  const rowLength = rowCharacters(row).length
  const answerChars: string[] = rowCharacters(answer)

  // set all to gray
  for (let i = 0; i < rowLength; i++) {
    newCellStatuses[rowNumber][i] = CellStatus.Gray
  }

  // check greens
  for (let col of [...columns].reverse()) {
    if (isCellCorrect(row, col, answer)) {
      newCellStatuses[rowNumber][col] = CellStatus.Green
      answerChars.splice(col, 1)
    }
  }

  // check yellows
  // yellow if all:
  //   - answer contains this digit in a place that this row hasn't guessed correctly
  //   - answer doesn't contain this digit in this column
  for (let col of columns) {
    if (
      answerChars.includes(rowCharacter(row, col)) &&
      newCellStatuses[rowNumber][col] !== CellStatus.Green
    ) {
      newCellStatuses[rowNumber][col] = CellStatus.Yellow
    }
  }

  return newCellStatuses
}

function isCellCorrect(row, col, answer) {
  return rowCharacter(row, col) === rowCharacter(answer, col)
}
<fim_middle>",correct,4711
Options,Options,7c6b66273a2e2ae0cf4af96fca68877ec089846c,"<fim_prefix>type Placeholder = undefined | string | Function
interface Options {
  placeholder?: Placeholder
  freeze?: boolean
}

type Result = string | number | Function
type TextObject = Record<string, Result | object>
type TextPath = string
type Texts = TextObject[] | []
type TextFnArguments = string[] | number[]

const ALLOWED_TYPES = ['string', 'number']
const ERROR_TEXTS = Object.freeze({
  not_set: '[t-getter.js] There is no texts objects'
})

export default function GetText(
  texts,
  { placeholder = undefined, freeze = true }: <fim_suffix> = {}
) {
  if (!texts?.length) throw new Error(ERROR_TEXTS.not_set)
  texts = texts.map((o) => (freeze ? Object.freeze(o) : o))
  let placeholderOpt: any = placeholder

  function placeholderFn(options) {
    return typeof placeholderOpt == 'function'
      ? placeholderOpt(options)
      : placeholderOpt
  }

  function checkAllowedTypes(val) {
    return ALLOWED_TYPES.includes(typeof val)
  }

  function getTextValue({
    index,
    prop,
    args
  }) {
    const path = prop.split('.')
    let textObject: any = texts[index]

    let i = 0
    while (i < path.length) {
      let value: TextObject | Result = textObject[path[i]]
      if (value == null) break
      if (typeof value == 'function') value = value(...args)
      textObject = value
      i++
    }
    return textObject
  }

  function t(prop, ...args) {
    if (!texts.length) throw new Error(ERROR_TEXTS.not_set)

    let result: any = undefined
    let index = 0
    while (index < texts.length) {
      const value = getTextValue({ index, prop, args })
      if (checkAllowedTypes(value)) {
        result = value
        break
      }
      index++
    }

    if (!checkAllowedTypes(result)) return placeholderFn({ prop, args })

    return result
  }

  return t
}
<fim_middle>",correct,715
Options,Options,5a29a45f29dbe3ac69cfbfa2729fcd60bbc32789,"<fim_prefix>/*
 * @Author: wellen zhong
 * @Date: 2022-02-09 14:02:29
 * @LastEditors: wellen zhong
 * @LastEditTime: 2022-02-09 14:28:34
 * @Description: file content
 */

export interface Options {
    svgStr: string;
}
export default  (params: <fim_suffix>) =>{
    return `
    ;(function(window) {
      var svgSprite = \`${params.svgStr}\`
    var script = (function () {
      var scripts = document.getElementsByTagName(""script"");
      return scripts[scripts.length - 1];
    })();
    var shouldInjectCss = script.getAttribute(""data-injectcss"");
    var ready = function (fn) {
      if (document.addEventListener) {
        if (~[""complete"", ""loaded"", ""interactive""].indexOf(document.readyState)) {
          setTimeout(fn, 0);
        } else {
          var loadFn = function () {
            document.removeEventListener(""DOMContentLoaded"", loadFn, false);
            fn();
          };
          document.addEventListener(""DOMContentLoaded"", loadFn, false);
        }
      } else if (document.attachEvent) {
        IEContentLoaded(window, fn);
      }
      function IEContentLoaded(w, fn) {
        var d = w.document,
          done = false,
          init = function () {
            if (!done) {
              done = true;
              fn();
            }
          };
        var polling = function () {
          try {
            d.documentElement.doScroll(""left"");
          } catch (e) {
            setTimeout(polling, 50);
            return;
          }
          init();
        };
        polling();
        d.onreadystatechange = function () {
          if (d.readyState == ""complete"") {
            d.onreadystatechange = null;
            init();
          }
        };
      }
    };
    var before = function (el, target) {
      target.parentNode.insertBefore(el, target);
    };
    var prepend = function (el, target) {
      if (target.firstChild) {
        before(el, target.firstChild);
      } else {
        target.appendChild(el);
      }
    };
    function appendSvg() {
      var div, svg;
      div = document.createElement(""div"");
      div.innerHTML = svgSprite;
      svgSprite = null;
      svg = div.getElementsByTagName(""svg"")[0];
      if (svg) {
        svg.setAttribute(""aria-hidden"", ""true"");
        svg.style.position = ""absolute"";
        svg.style.width = 0;
        svg.style.height = 0;
        svg.style.overflow = ""hidden"";
        prepend(svg, document.body);
      }
    }
    if (shouldInjectCss && !window.__iconfont__svg__cssinject__) {
      window.__iconfont__svg__cssinject__ = true;
      try {
        document.write(
          ""<style>.svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}</style>""
        );
      } catch (e) {
        console && console.log(e);
      }
    }
    ready(appendSvg);
  })(window);  
    `
}
<fim_middle>",correct,2048
Options,Options,60111e8899acd1cb31c9e942a57447f8b8c80c3b,"<fim_prefix>type Mode = ""hard"" | ""soft"";

interface Options {
    mode: Mode;
}

export class Leet {
    private mode: Mode;
    public constructor(options: <fim_suffix>) {
        this.mode = options.mode;
    }

    public translate(message) {
        if (this.mode === ""hard"") {
            return message
                .replace(/i/gi, ""1"")
                .replace(/a/gi, ""/\\"")
                .replace(/b/gi, ""I3"")
                .replace(/c/gi, ""["")
                .replace(/d/gi, ""I)"")
                .replace(/e/gi, ""€"")
                .replace(/f/gi, ""|="")
                .replace(/g/gi, ""&"")
                .replace(/h/gi, ""/-/"")
                .replace(/j/gi, ""_|"")
                .replace(/k/gi, ""|<"")
                .replace(/l/gi, ""|"")
                .replace(/m/gi, ""^^"")
                .replace(/n/gi, ""^/"")
                .replace(/o/gi, ""()"")
                .replace(/p/gi, ""|°"")
                .replace(/q/gi, ""(,)"")
                .replace(/r/gi, ""I2"")
                .replace(/s/gi, ""$"")
                .replace(/t/gi, ""+"")
                .replace(/u/gi, ""|_|"")
                .replace(/v/gi, ""|/"")
                .replace(/w/gi, ""'//"")
                .replace(/x/gi, "")("")
                .replace(/y/gi, ""`/"")
                .replace(/z/gi, ""%"");
        } else {
            return message
                .replace(/a/gi, ""4"")
                .replace(/b/gi, ""8"")
                .replace(/e/gi, ""3"")
                .replace(/i/gi, ""1"")
                .replace(/o/gi, ""0"")
                .replace(/r/gi, ""2"")
                .replace(/s/gi, ""5"")
                .replace(/t/gi, ""7"")
                .toUpperCase();
        }
    }

    public reverse(message) {
        if (this.mode === ""hard"") {
            return message
                .replace(/\/\\/g, ""a"")
                .replace(/I3/g, ""b"")
                .replace(/\[/g, ""c"")
                .replace(/I\)/g, ""d"")
                .replace(/€/g, ""e"")
                .replace(/\|=/g, ""f"")
                .replace(/&/g, ""g"")
                .replace(/\/-\//g, ""h"")
                .replace(/1/g, ""i"")
                .replace(/(?<!\|)_\|/g, ""j"")
                .replace(/\|</g, ""k"")
                .replace(/(?<!_)\|(?![=<°/_])/g, ""l"")
                .replace(/\^\^/g, ""m"")
                .replace(/\^\//g, ""n"")
                .replace(/\(\)/g, ""o"")
                .replace(/\|°/g, ""p"")
                .replace(/\(,\)/g, ""q"")
                .replace(/I2/g, ""r"")
                .replace(/\$/g, ""s"")
                .replace(/\+/g, ""t"")
                .replace(/\|_\|/g, ""u"")
                .replace(/\|\//g, ""v"")
                .replace(/'\/\//g, ""w"")
                .replace(/\)\(/g, ""x"")
                .replace(/`\//g, ""y"")
                .replace(/%/g, ""z"");
        } else {
            return message
                .replace(/4/g, ""a"")
                .replace(/8/g, ""b"")
                .replace(/3/g, ""e"")
                .replace(/1/g, ""i"")
                .replace(/0/g, ""o"")
                .replace(/2/g, ""R"")
                .replace(/5/g, ""s"")
                .replace(/7/g, ""t"")
                .toLowerCase();
        }
    }
}
<fim_middle>",correct,3027
Options,Options,e8163c19af6d0400d21846442a54c5e20ba9eac3,"<fim_prefix>export enum LongOption {
  NUMBER = 'number',
  LONG = 'long',
  STRING = 'string',
}

export enum DateOption {
  DATE = 'date',
  STRING = 'string',
  TIMESTAMP = 'timestamp',
}

export enum EnvOption {
  NODE = 'node',
  BROWSER = 'browser',
  BOTH = 'both',
}

export enum OneofOption {
  PROPERTIES = 'properties',
  UNIONS = 'unions',
}

export enum ServiceOption {
  GRPC = 'grpc-js',
  GENERIC = 'generic-definitions',
  DEFAULT = 'default',
  NONE = 'none',
}

export type Options = {
  context: boolean;
  snakeToCamel: Array<'json' | 'keys'>;
  forceLong: LongOption;
  useOptionals: boolean | 'none' | 'messages' | 'all'; // boolean is deprecated
  useDate: DateOption;
  oneof: OneofOption;
  esModuleInterop: boolean;
  fileSuffix: string;
  outputEncodeMethods: boolean;
  outputJsonMethods: boolean;
  outputPartialMethods: boolean;
  outputTypeRegistry: boolean;
  stringEnums: boolean;
  constEnums: boolean;
  enumsAsLiterals: boolean;
  outputClientImpl: boolean | 'grpc-web';
  outputServices: ServiceOption;
  addGrpcMetadata: boolean;
  addNestjsRestParameter: boolean;
  returnObservable: boolean;
  lowerCaseServiceMethods: boolean;
  nestJs: boolean;
  env: EnvOption;
  unrecognizedEnum: boolean;
  exportCommonSymbols: boolean;
  outputSchema: boolean;
  // An alias of !output
  onlyTypes: boolean;
  emitImportedFiles: boolean;
  useExactTypes: boolean;
  delimitedMethods: boolean;
};

export function defaultOptions() {
  return {
    context: false,
    snakeToCamel: ['json', 'keys'],
    forceLong: LongOption.NUMBER,
    useOptionals: 'none',
    useDate: DateOption.DATE,
    oneof: OneofOption.PROPERTIES,
    esModuleInterop: false,
    fileSuffix: '',
    lowerCaseServiceMethods: false,
    outputEncodeMethods: true,
    outputJsonMethods: true,
    outputPartialMethods: true,
    outputTypeRegistry: false,
    stringEnums: false,
    constEnums: false,
    enumsAsLiterals: false,
    outputClientImpl: true,
    outputServices: ServiceOption.DEFAULT,
    returnObservable: false,
    addGrpcMetadata: false,
    addNestjsRestParameter: false,
    nestJs: false,
    env: EnvOption.BOTH,
    unrecognizedEnum: true,
    exportCommonSymbols: true,
    outputSchema: false,
    onlyTypes: false,
    emitImportedFiles: true,
    useExactTypes: true,
    delimitedMethods: false,
  };
}

const nestJsOptions: Partial<Options> = {
  lowerCaseServiceMethods: true,
  outputEncodeMethods: false,
  outputJsonMethods: false,
  outputPartialMethods: false,
  outputClientImpl: false,
  useDate: DateOption.TIMESTAMP,
};

export function optionsFromParameter(parameter): <fim_suffix> {
  const options = defaultOptions();
  if (parameter) {
    const parsed = parseParameter(parameter);
    if (parsed.nestJs) {
      Object.assign(options, nestJsOptions);
    }
    Object.assign(options, parsed);
  }
  // We should promote onlyTypes to its own documented flag, but just an alias for now
  if (!options.outputJsonMethods && !options.outputEncodeMethods && !options.outputClientImpl && !options.nestJs) {
    options.onlyTypes = true;
  }

  // Treat forceLong=true as LONG
  if ((options.forceLong as any) === true) {
    options.forceLong = LongOption.LONG;
  }

  // Treat outputServices=false as NONE
  if ((options.outputServices as any) === false) {
    options.outputServices = ServiceOption.NONE;
  }

  if ((options.useDate as any) === true) {
    // Treat useDate=true as DATE
    options.useDate = DateOption.DATE;
  } else if ((options.useDate as any) === false) {
    // Treat useDate=false as TIMESTAMP
    options.useDate = DateOption.TIMESTAMP;
  }

  if ((options.snakeToCamel as any) === false) {
    options.snakeToCamel = [];
  } else if ((options.snakeToCamel as any) === true) {
    options.snakeToCamel = ['keys', 'json'];
  }

  return options;
}

// A very naive parse function, eventually could/should use iots/runtypes
function parseParameter(parameter) {
  const options = {} as any;
  const pairs = parameter.split(',').map((s) => s.split('='));
  pairs.forEach(([key, value]) => {
    options[key] = value === 'true' ? true : value === 'false' ? false : value;
  });
  return options;
}

export function getTsPoetOpts(options) {
  if (options.esModuleInterop) {
    return { forceDefaultImport: ['protobufjs/minimal'] };
  } else {
    return {};
  }
}
<fim_middle>",correct,3851
Order,Order,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order): <fim_suffix> {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,68
Organization,Organization,d85172f11ad96056d5a23d70826940b9d72011d4,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IOrganization {
    description?: string;
    id?: string;
    image?: string;
    name?: string;
    website?: string;
}

export default class Organization {
    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _image: string | undefined;

    get image() {
        return this._image;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _website: string | undefined;

    get website() {
        return this._website;
    }

    constructor(props) {
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.image === 'string') {
            this._image = props.image.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.website === 'string') {
            this._website = props.website.trim();
        }
    }

    serialize() {
        const data: IOrganization = {};
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._image !== 'undefined') {
            data.image = this._image;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._website !== 'undefined') {
            data.website = this._website;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            image: !this._image
                ? true
                : typeof this._image === 'string' && !this._image
                ? true
                : this._image,
            website: !this._website
                ? true
                : typeof this._website === 'string' && !this._website
                ? true
                : this._website,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Organization({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,3100
Params,Params,55cd248251ed1b4cc30e54f7fe9cbb0002b63241,"<fim_prefix>interface Params {
  page?: number;
  size?: number;
  message?: string;
  [key: string]: any;
}

interface Result<T> {
  code: number;
  data: {
    list: T[];
    total: number;
  };
  message?: number;
}

type FetchFun<T> = (params) => Promise<Result<T>>;

/**
 * 将分页接口转换为获取所有的接口
 * @param fetch
 */
export default function createFetchAll<T = any>(fetch) {
  return async function (params: <fim_suffix> = {}) {
    // 总数
    let allTotal = 0;
    let fetchTotal = 0;
    // 存储列表数据
    let fetchList: T[] = [];

    return new Promise(async (resolve, reject) => {
      const { page = 1, size = 1000, ...rest } = params;

      // 通过第一次分页请求
      const {
        code,
        data: { list, total },
        message
      } = await fetch({ page, size, ...rest });
      allTotal = total;
      fetchTotal += list.length;
      fetchList = fetchList.concat(list);

      // 从第二页开始
      const allPromise: Promise<Result<T>>[] = [];
      const pageSize = parseInt(total / size + 1 + '');

      for (let i = 2; i <= pageSize; ++i) {
        allPromise.push(
          fetch({
            page: i,
            size: i === pageSize ? total % size : size,
            ...rest
          })
        );
      }

      const allResult = await Promise.all(allPromise);
      for (let i = 0; i < allResult.length; ++i) {
        const {
          data: { list }
        } = allResult[i];
        fetchTotal += list.length;
        fetchList = fetchList.concat(list);
      }

      if (fetchTotal === total) {
        resolve({
          code: code,
          message: message,
          data: {
            list: fetchList,
            total: fetchTotal
          }
        });
      } else {
        reject({
          code: 500,
          message: '数据请求出错',
          data: {
            list: [],
            total: 0
          }
        });
      }
    });
  };
}
<fim_middle>",correct,2240
Permission,Permission,b9e827c9b65a470da78b1369ea3f446284d6b91c,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IPermission {
    description?: string;
    id?: string;
    is_internal?: boolean;
    name?: string;
    xml?: string;
}

export default class Permission {
    readonly _description: string | undefined;

    get description() {
        return this._description;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _is_internal: boolean | undefined;

    get isInternal() {
        return this._is_internal;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _xml: string | undefined;

    get xml() {
        return this._xml;
    }

    constructor(props) {
        if (typeof props.description === 'string') {
            this._description = props.description.trim();
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.is_internal === 'boolean') {
            this._is_internal = props.is_internal;
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.xml === 'string') {
            this._xml = props.xml.trim();
        }
    }

    serialize() {
        const data: IPermission = {};
        if (typeof this._description !== 'undefined') {
            data.description = this._description;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._is_internal !== 'undefined') {
            data.is_internal = this._is_internal;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._xml !== 'undefined') {
            data.xml = this._xml;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            is_internal: !this._is_internal
                ? true
                : typeof this._is_internal === 'boolean',
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            description: !this._description
                ? true
                : typeof this._description === 'string' && !this._description
                ? true
                : this._description,
            xml: !this._xml
                ? true
                : typeof this._xml === 'string' && !this._xml
                ? true
                : this._xml,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Permission({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,384
Permission,Permission,c1d22b15c50f25666b0b3e495cc4ff6d4323db74,"<fim_prefix>// Errors
export const ESuccess: number = 0;      // Generic success
export const EFail: number = 1;         // Generic failure
export const EFull: number = 2;         // Too many clients attached to this session; try later
export const ERetry: number = 3;        // Try request again
export const ENoSession: number = 4;		// No record of such session
export const EClockSeen: number = 5;
export const EClockFailure: number = 6;
export const EClockReset: number = 7;
export const ENoUser: number = 8;       // No user specified (internal error since all authorized reqs have user)
export const EBadRequest: number = 9;   // Badly formed request
export const ELoadFailed: number = 10;  // Session exists in index, but load of state failed ((temp?) internal error)
export const ENoPerm: number = 11;      // No permissions (readonly)
export const ENoAccess: number = 12;    // No access (no read)
export const EMaintenance: number = 13; // Server under maintenance
export const EClockAnomaly: number = 14;  // Typically server restart and client is ahead

// Filters
export const FilterMyMaps: number = 0;
export const FilterSharedWithMe: number = 1;
export const FilterMyPublic: number = 2;
export const FilterRecent: number = 3;
export const FilterTrash: number = 4;
export const FilterPublic: number = 5;
export const FilterOfficial: number = 6;
export const FilterCOI: number = 7;
export const FilterMyGroups: number = 8;
export const FilterCount: number = 9;
export type Filter = number;

// Permissions
export const PermNone: number = 0;      // No permissions
export const PermRead: number = 1;      // Can view
export const PermWrite: number = 2;     // Can modify
export const PermOwner: number = 4;     // Can change deleted, published, access permissions
export const PermAdmin: number = 8;     // Can administer site
export const PermEdit: number = (PermWrite|PermOwner);
export const PermAll: number = (PermRead|PermWrite|PermOwner|PermAdmin);
export type Permission = number;

// Server State
export const ServerStateRunning: number = 0;
export const ServerStateMaintenance: number = 1;
export type ServerState = number;

// Maps Access Tokens (IDs) to SessionID
export interface AccessSessionMap
{
  [key: string]: string;
}

// Maps Access ID to { list of users, permission } (stored with session)
export interface AccessMap
{
  [key: string]: Access;
}

export interface Access
{
  userIDs: string[];  // empty implies ""anyone""
  perm: Permission;
}

export interface Revision
{
  id: string;
  modifyTime: any;  // JSON date
  label?: string;   // optional label
}

export type RevisionList = Revision[];

export interface SessionUser
{
	id: string;
	name: string;
  twitterhandle: string;
}

export interface ActiveUser
{
	id: string;
	name: string;
  twitterhandle: string;
	active: number;
}

export interface SessionUserIndex
{
	[key: string]: SessionUser;
}

export interface SessionUserList
{
	[key: string]: number;
}

export interface SessionProps
{
  id: string;
  name: string;
  type: string;
  description: string;
  labels: string[];
  createdBy: string;
  lastActive: any;		// JSON date (should be string)
  createTime: any;    // JSON date (should be string)
  modifyTime: any;    // JSON date (should be string)
  clientCount: number;
  maxClients: number;
  requestCount: number;
  deleted: boolean;
  published?: string;
  official: boolean;
	loadFailed: boolean;
  accessMap: AccessMap;
  revisions: RevisionList;
  expunged?: boolean;
  expungeDate?: string;
  xprops?: { [prop: string]: string };
  groups: any;  // DT.GroupsMapIndex
  xid?: string; // external ID
}

// True to add, False to remove
export type LabelUpdate = { [name: string]: boolean|null }

export interface SessionUpdateProps
{
	id?: string;
  xid?: string;
  ids?: string[];
	deleted?: boolean;
	published?: boolean;
	official?: boolean;
  name?: string;
  description?: string;
  labelupdate?: LabelUpdate;
  access?: Access;
  accessUpdate?: AccessMap;
  restore?: string; // Revision ID
  revision?: Revision;  // If ID is empty, snap a new revision, otherwise label it.
}

export interface SessionsIndex
{
	[key: string]: SessionProps;
}

// The semantics here are:
//  if aid is provided, only look through that access token.
//  if aid is missing, look for that user in any access token (but ignore anonymous tokens).
//  in either case, return the full set of permissions a user has.
//
export function accessFindUser(a, uid)
{
  if (a === undefined) return PermNone;
  if (a.userIDs.length == 0)
    return a.perm;
  for (let i: number = 0; i < a.userIDs.length; i++)
    if (a.userIDs[i] === uid) return a.perm;
  return PermNone;
}

export function accessMapFindUser(accessMap, uid, aid?): <fim_suffix>
{
  if (aid !== undefined)
    return accessFindUser(accessMap[aid], uid);
  else
  {
    let perm: Permission = PermNone;
    for (var aid1 in accessMap) if (accessMap.hasOwnProperty(aid1))
    {
      let a = accessMap[aid1];
      for (let i: number = 0; i < a.userIDs.length; i++)
        if (a.userIDs[i] === uid)
        {
          perm |= a.perm;
          break;
        }
    }
    return perm;
  }
}

export function SessionFilterFunction(p, uid, f)
{
	if (f === FilterPublic) return p.published !== undefined;

	if (f === FilterSharedWithMe)
	{
		if (p.createdBy === uid) return false;
    return true;
	}

	// All other filters require ownership of this session
	if (p.createdBy !== uid) return false;

	if (f === FilterTrash) return p.deleted;

  if (f === FilterRecent && !p.deleted && p.modifyTime)
  {
    let d = new Date();
    let interval = d.getTime() - new Date(p.modifyTime).getTime();
    return interval < (1000 * 60 * 60 * 24 * 7);  // one week
  }

	return !p.deleted;
}
<fim_middle>",correct,1318
Permission,Permission,c1d22b15c50f25666b0b3e495cc4ff6d4323db74,"<fim_prefix>// Errors
export const ESuccess: number = 0;      // Generic success
export const EFail: number = 1;         // Generic failure
export const EFull: number = 2;         // Too many clients attached to this session; try later
export const ERetry: number = 3;        // Try request again
export const ENoSession: number = 4;		// No record of such session
export const EClockSeen: number = 5;
export const EClockFailure: number = 6;
export const EClockReset: number = 7;
export const ENoUser: number = 8;       // No user specified (internal error since all authorized reqs have user)
export const EBadRequest: number = 9;   // Badly formed request
export const ELoadFailed: number = 10;  // Session exists in index, but load of state failed ((temp?) internal error)
export const ENoPerm: number = 11;      // No permissions (readonly)
export const ENoAccess: number = 12;    // No access (no read)
export const EMaintenance: number = 13; // Server under maintenance
export const EClockAnomaly: number = 14;  // Typically server restart and client is ahead

// Filters
export const FilterMyMaps: number = 0;
export const FilterSharedWithMe: number = 1;
export const FilterMyPublic: number = 2;
export const FilterRecent: number = 3;
export const FilterTrash: number = 4;
export const FilterPublic: number = 5;
export const FilterOfficial: number = 6;
export const FilterCOI: number = 7;
export const FilterMyGroups: number = 8;
export const FilterCount: number = 9;
export type Filter = number;

// Permissions
export const PermNone: number = 0;      // No permissions
export const PermRead: number = 1;      // Can view
export const PermWrite: number = 2;     // Can modify
export const PermOwner: number = 4;     // Can change deleted, published, access permissions
export const PermAdmin: number = 8;     // Can administer site
export const PermEdit: number = (PermWrite|PermOwner);
export const PermAll: number = (PermRead|PermWrite|PermOwner|PermAdmin);
export type Permission = number;

// Server State
export const ServerStateRunning: number = 0;
export const ServerStateMaintenance: number = 1;
export type ServerState = number;

// Maps Access Tokens (IDs) to SessionID
export interface AccessSessionMap
{
  [key: string]: string;
}

// Maps Access ID to { list of users, permission } (stored with session)
export interface AccessMap
{
  [key: string]: Access;
}

export interface Access
{
  userIDs: string[];  // empty implies ""anyone""
  perm: Permission;
}

export interface Revision
{
  id: string;
  modifyTime: any;  // JSON date
  label?: string;   // optional label
}

export type RevisionList = Revision[];

export interface SessionUser
{
	id: string;
	name: string;
  twitterhandle: string;
}

export interface ActiveUser
{
	id: string;
	name: string;
  twitterhandle: string;
	active: number;
}

export interface SessionUserIndex
{
	[key: string]: SessionUser;
}

export interface SessionUserList
{
	[key: string]: number;
}

export interface SessionProps
{
  id: string;
  name: string;
  type: string;
  description: string;
  labels: string[];
  createdBy: string;
  lastActive: any;		// JSON date (should be string)
  createTime: any;    // JSON date (should be string)
  modifyTime: any;    // JSON date (should be string)
  clientCount: number;
  maxClients: number;
  requestCount: number;
  deleted: boolean;
  published?: string;
  official: boolean;
	loadFailed: boolean;
  accessMap: AccessMap;
  revisions: RevisionList;
  expunged?: boolean;
  expungeDate?: string;
  xprops?: { [prop: string]: string };
  groups: any;  // DT.GroupsMapIndex
  xid?: string; // external ID
}

// True to add, False to remove
export type LabelUpdate = { [name: string]: boolean|null }

export interface SessionUpdateProps
{
	id?: string;
  xid?: string;
  ids?: string[];
	deleted?: boolean;
	published?: boolean;
	official?: boolean;
  name?: string;
  description?: string;
  labelupdate?: LabelUpdate;
  access?: Access;
  accessUpdate?: AccessMap;
  restore?: string; // Revision ID
  revision?: Revision;  // If ID is empty, snap a new revision, otherwise label it.
}

export interface SessionsIndex
{
	[key: string]: SessionProps;
}

// The semantics here are:
//  if aid is provided, only look through that access token.
//  if aid is missing, look for that user in any access token (but ignore anonymous tokens).
//  in either case, return the full set of permissions a user has.
//
export function accessFindUser(a, uid): <fim_suffix>
{
  if (a === undefined) return PermNone;
  if (a.userIDs.length == 0)
    return a.perm;
  for (let i: number = 0; i < a.userIDs.length; i++)
    if (a.userIDs[i] === uid) return a.perm;
  return PermNone;
}

export function accessMapFindUser(accessMap, uid, aid?)
{
  if (aid !== undefined)
    return accessFindUser(accessMap[aid], uid);
  else
  {
    let perm: Permission = PermNone;
    for (var aid1 in accessMap) if (accessMap.hasOwnProperty(aid1))
    {
      let a = accessMap[aid1];
      for (let i: number = 0; i < a.userIDs.length; i++)
        if (a.userIDs[i] === uid)
        {
          perm |= a.perm;
          break;
        }
    }
    return perm;
  }
}

export function SessionFilterFunction(p, uid, f)
{
	if (f === FilterPublic) return p.published !== undefined;

	if (f === FilterSharedWithMe)
	{
		if (p.createdBy === uid) return false;
    return true;
	}

	// All other filters require ownership of this session
	if (p.createdBy !== uid) return false;

	if (f === FilterTrash) return p.deleted;

  if (f === FilterRecent && !p.deleted && p.modifyTime)
  {
    let d = new Date();
    let interval = d.getTime() - new Date(p.modifyTime).getTime();
    return interval < (1000 * 60 * 60 * 24 * 7);  // one week
  }

	return !p.deleted;
}
<fim_middle>",correct,1322
Person,Person,9e9c118238962afa94fa08ff3f99466bbd1b84bf,"<fim_prefix>/* tslint:disable */

declare var Object: any;
export interface PersonInterface {
  id?: string;
  name: string;
  realm?: string;
  username?: string;
  password: string;
  email: string;
  emailVerified?: boolean;
  verificationToken?: string;
  created_at: Date;
  updated_at: Date;
  accessTokens?: Array<any>;
}

export class Person implements PersonInterface {
  id: string;
  name: string;
  realm: string;
  username: string;
  password: string;
  email: string;
  emailVerified: boolean;
  verificationToken: string;
  created_at: Date;
  updated_at: Date;
  accessTokens: Array<any>;
  constructor(data?) {
    Object.assign(this, data);
  }
  /**
   * The name of the model represented by this $resource,
   * i.e. `Person`.
   */
  public static getModelName() {
    return ""Person"";
  }
  /**
  * @method factory
  * @author Jonathan Casarrubias
  * @license MIT
  * This method creates an instance of Person for dynamic purposes.
  **/
  public static factory(data): <fim_suffix>{
    return new Person(data);
  }  
  /**
  * @method getModelDefinition
  * @author Julien Ledun
  * @license MIT
  * This method returns an object that represents some of the model
  * definitions.
  **/
  public static getModelDefinition() {
    return {
      name: 'Person',
      plural: 'Persons',
      properties: {
        id: {
          name: 'id',
          type: 'string'
        },
        name: {
          name: 'name',
          type: 'string'
        },
        realm: {
          name: 'realm',
          type: 'string'
        },
        username: {
          name: 'username',
          type: 'string'
        },
        password: {
          name: 'password',
          type: 'string'
        },
        email: {
          name: 'email',
          type: 'string'
        },
        emailVerified: {
          name: 'emailVerified',
          type: 'boolean'
        },
        verificationToken: {
          name: 'verificationToken',
          type: 'string'
        },
        created_at: {
          name: 'created_at',
          type: 'Date'
        },
        updated_at: {
          name: 'updated_at',
          type: 'Date'
        },
      },
      relations: {
        accessTokens: {
          name: 'accessTokens',
          type: 'Array<any>',
          model: ''
        },
      }
    }
  }
}
<fim_middle>",correct,2049
Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner(): <fim_suffix> {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4540
Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer(): <fim_suffix> {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4546
Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col): <fim_suffix> {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4551
Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece: <fim_suffix>) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4557
Piece,Piece,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col): <fim_suffix> {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4560
Point,Point,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2: <fim_suffix>)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,486
Point,Point,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p: <fim_suffix>, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,488
Point,Point,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2: <fim_suffix>)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,490
Point,Point,ccee70850d7be59ff29044ffd01e8ec90a3de543,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

// to suit your point format, run search/replace for '[0]' and '[1]';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

type Point = [number, number];

// square distance between 2 points
const getSqDist = (p1, p2: <fim_suffix>) => {
  const dx = p1[0] - p2[0];
  const dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
};

// square distance from a point to a segment
const getSqSegDist = (p, p1, p2) => {
  let [x, y] = p1;
  let dx = p2[0] - x;
  let dy = p2[1] - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      [x, y] = p2;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
};
// rest of the code doesn't care about point format

// basic distance-based simplification
const simplifyRadialDist = (points, sqTolerance) => {
  if (points.length === 0) return [];

  let prevPoint = points[0];
  const newPoints = [prevPoint];
  let point: Point | null = null;

  points.forEach((d) => {
    point = d;
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  });

  if (prevPoint !== point) newPoints.push(point as unknown as Point);

  return newPoints;
};

const simplifyDPStep = (
  points,
  first,
  last,
  sqTolerance,
  simplified,
) => {
  let maxSqDist = sqTolerance;
  let index: number | null = null;

  for (let i = first + 1; i < last; i += 1) {
    const sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if ((index as number) - first > 1) {
      simplifyDPStep(points, first, (index as number), sqTolerance, simplified);
    }
    simplified.push(points[(index as number)]);
    if (last - (index as number) > 1) {
      simplifyDPStep(points, (index as number), last, sqTolerance, simplified);
    }
  }
};

// simplification using Ramer-Douglas-Peucker algorithm
const simplifyDouglasPeucker = (points, sqTolerance) => {
  const last = points.length - 1;

  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);

  return simplified;
};

// both algorithms combined for awesome performance
export default (
  points,
  tolerance,
  highestQuality,
) => {
  if (points.length <= 2) return points;

  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
  let simplified = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  simplified = simplifyDouglasPeucker(points, sqTolerance);
  return simplified;
};
<fim_middle>",correct,2577
Point,Point,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2: <fim_suffix>, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3651
Point,Point,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
): <fim_suffix> => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3653
Point,Point,efd4212b5484e4a5a69aae848bc9a722b0c0e228,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

interface Point {
  x: number;
  y: number;
}

// eslint-disable-next-line import/prefer-default-export
export const createDensePath = (start, end: <fim_suffix>) => {
  // Given two integer positions,
  // interpolate a dense path from the start to the end.

  const path: Point[] = [];
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  if (dx === 0 && dy === 0) return [{ ...start }];

  if (Math.abs(dx) >= Math.abs(dy)) {
    const k = dy / dx;
    if (dx >= 0) {
      for (let i = 0; i <= dx; i += 1) {
        path.push({
          x: start.x + i,
          y: Math.round(start.y + k * i),
        });
      }
    } else {
      for (let i = 0; i >= dx; i -= 1) {
        path.push({
          x: start.x + i,
          y: Math.round(start.y + k * i),
        });
      }
    }
  } else {
    const k = dx / dy;
    if (dy >= 0) {
      for (let i = 0; i <= dy; i += 1) {
        path.push({
          x: Math.round(start.x + k * i),
          y: start.y + i,
        });
      }
    } else {
      for (let i = 0; i >= dy; i -= 1) {
        path.push({
          x: Math.round(start.x + k * i),
          y: start.y + i,
        });
      }
    }
  }
  return path;
};

/**
 * Compute the linear transformation that transform
 * the rectangle [xMin, xMax] x [yMin, yMax]
 * to fit the target rectangular area [0, targetWidth] x [0, targetHeight]
 * without changing the aspect ratio of the rectangle.
 */
export const calFittingTransform = (
  rect,
  targetWidth,
  targetHeight,
) => {
  const {
    xMin, xMax, yMin, yMax,
  } = rect;

  const width = xMax - xMin;
  const height = yMax - yMin;
  // the scale preserves the aspect ratio
  const scale = Math.min(
    targetWidth / width,
    targetHeight / height,
  );
  const cx = (xMax + xMin) / 2;
  const cy = (yMax + yMin) / 2;

  // the transformation for setting the object to the center of the target
  const strCenterBackground = `translate(${targetWidth / 2}, ${targetHeight / 2})`;
  // the transformation for scaling the concerned area of the object to fit the target size
  const strScale = Number.isNaN(scale) ? '' : `scale(${scale})`;
  // the transformation for setting the center of the object to the (0, 0) position in the target
  const strCenterItem = Number.isNaN(cx) || Number.isNaN(cy) ? '' : `translate(${-cx}, ${-cy})`;

  return strCenterBackground + strScale + strCenterItem;
};
<fim_middle>",correct,3913
Point,Point,efd4212b5484e4a5a69aae848bc9a722b0c0e228,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

interface Point {
  x: number;
  y: number;
}

// eslint-disable-next-line import/prefer-default-export
export const createDensePath = (start: <fim_suffix>, end) => {
  // Given two integer positions,
  // interpolate a dense path from the start to the end.

  const path: Point[] = [];
  const dx = end.x - start.x;
  const dy = end.y - start.y;
  if (dx === 0 && dy === 0) return [{ ...start }];

  if (Math.abs(dx) >= Math.abs(dy)) {
    const k = dy / dx;
    if (dx >= 0) {
      for (let i = 0; i <= dx; i += 1) {
        path.push({
          x: start.x + i,
          y: Math.round(start.y + k * i),
        });
      }
    } else {
      for (let i = 0; i >= dx; i -= 1) {
        path.push({
          x: start.x + i,
          y: Math.round(start.y + k * i),
        });
      }
    }
  } else {
    const k = dx / dy;
    if (dy >= 0) {
      for (let i = 0; i <= dy; i += 1) {
        path.push({
          x: Math.round(start.x + k * i),
          y: start.y + i,
        });
      }
    } else {
      for (let i = 0; i >= dy; i -= 1) {
        path.push({
          x: Math.round(start.x + k * i),
          y: start.y + i,
        });
      }
    }
  }
  return path;
};

/**
 * Compute the linear transformation that transform
 * the rectangle [xMin, xMax] x [yMin, yMax]
 * to fit the target rectangular area [0, targetWidth] x [0, targetHeight]
 * without changing the aspect ratio of the rectangle.
 */
export const calFittingTransform = (
  rect,
  targetWidth,
  targetHeight,
) => {
  const {
    xMin, xMax, yMin, yMax,
  } = rect;

  const width = xMax - xMin;
  const height = yMax - yMin;
  // the scale preserves the aspect ratio
  const scale = Math.min(
    targetWidth / width,
    targetHeight / height,
  );
  const cx = (xMax + xMin) / 2;
  const cy = (yMax + yMin) / 2;

  // the transformation for setting the object to the center of the target
  const strCenterBackground = `translate(${targetWidth / 2}, ${targetHeight / 2})`;
  // the transformation for scaling the concerned area of the object to fit the target size
  const strScale = Number.isNaN(scale) ? '' : `scale(${scale})`;
  // the transformation for setting the center of the object to the (0, 0) position in the target
  const strCenterItem = Number.isNaN(cx) || Number.isNaN(cy) ? '' : `translate(${-cx}, ${-cy})`;

  return strCenterBackground + strScale + strCenterItem;
};
<fim_middle>",correct,3914
Polygon,Polygon,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
): <fim_suffix> {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3380
Polygon,Polygon,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
): <fim_suffix> {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3384
Polygon,Polygon,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices): <fim_suffix> {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3401
Position,Position,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i) : <fim_suffix> =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,298
Position,Position,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i) : <fim_suffix> =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,303
Position,Position,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state: <fim_suffix>, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,305
Position,Position,d5ff2fa2b6826801f70c82d95dcdfcf780c62790,"<fim_prefix>const OCCUPIED_SEAT = '#';
const EMPTY_SEAT = 'L';
const FLOOR = '.';

interface Position {
  x: number,
  y: number
}

interface Vector {
  x: number,
  y: number
}

type AdjacentSeatFinder = (input, position, direction) => string;

export function getAdjacentSeat(input, position: <fim_suffix>, direction) {
  const adjacentLineIndex = position.y + direction.y;
  const adjacentColumnIndex = position.x + direction.x;
  
  const newPosition = { 
    x: position.x + direction.x,
    y: position.y + direction.y
  }

  if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length){
    return FLOOR;
  }

  return input[adjacentLineIndex][adjacentColumnIndex];
}


export function getFirstSeatAtDirection(input, position, direction) {
  let seat: string = FLOOR;

  let newPosition = position;
  while(true) {
    newPosition = { 
      x: newPosition.x + direction.x,
      y: newPosition.y + direction.y
    }

    if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length) break;

    const place = input[newPosition.y][newPosition.x];

    if (place !== FLOOR) {
      seat = place;
      break;
    }
  }

  return seat;
}

export function computeRound(input, adjacentSeatFinder, maximumAdjacentOccupiedSeats) {
  return input.map((line, lineIndex) => {
    return line
      .split('')
      .map((seat, seatIndex) => {
        if (seat === FLOOR) {
          return seat;
        }

        let numberOfAdjacentOccupiedSeat = 0;
        for (let iLine = -1; iLine <= 1; iLine++) {
          for (let iColumn = -1; iColumn <= 1; iColumn ++) {
            if(iLine === 0 && iColumn === 0) continue;

            const position = { x: seatIndex, y: lineIndex};
            const direction = { x: iColumn, y: iLine }
            const adjacentSeat = adjacentSeatFinder(input, position, direction);

            if (adjacentSeat === OCCUPIED_SEAT) {
              numberOfAdjacentOccupiedSeat++;
            }
          }
        }

        if (numberOfAdjacentOccupiedSeat === 0) {
          return OCCUPIED_SEAT;
        } else if (numberOfAdjacentOccupiedSeat >= maximumAdjacentOccupiedSeats) {
          return EMPTY_SEAT;
        } else {
          return seat;
        }
      })
      .join('');
  })
}

export function countNumberOfOccupiedSeatsAfterStabilization(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getAdjacentSeat, 4);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}

export function countNumberOfOccupiedSeatsAfterStabilizationWithRayCast(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getFirstSeatAtDirection, 5);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}
<fim_middle>",correct,4862
RegExp,RegExp,d7180447147db133f246707f18b8bdb014643e7a,"<fim_prefix>// Get balanced parentheses
// Ported from: https://github.com/juliangruber/balanced-match/blob/master/index.js

export interface Output {
	/**
	 * The index of the first match of a
	 */
	start: number;
	/**
	 * The index of the matching b
	 */
	end: number;
	/**
	 * The preamble, a and b not included
	 */
	pre: string;
	/**
	 * The match, a and b not included
	 */
	body: string;
	/**
	 * The postscript, a and b not included
	 */
	post: string;
}

function maybeMatch(reg: <fim_suffix>, str) {
	const m = str.match(reg);
	return m ? m[0] : null;
}

/**
 * For the first non-nested matching pair of a and b in str, return an object with those keys:
 * start the index of the first match of
 * `end` the index of the matching b
 * `pre` the preamble, a and b not included
 * `body` the match, a and b not included
 * `post` the postscript, a and b not included
 * If there's no match, `undefined` will be returned.
 * If the `str` contains more a than b / there are unmatched pairs,
 * the first match that was closed will be used.
 * For example, `{{a}` will match `['{', 'a', '']` and `{a}}` will match `['', 'a', '}']`
 */
export function balanced(
	a,
	b,
	str,
) {
	if (a instanceof RegExp) a = maybeMatch(a, str)!;
	if (b instanceof RegExp) b = maybeMatch(b, str)!;

	const r = range(a, b, str);

	return (
		r && {
			start: r[0] ?? 0,
			end: r[1] ?? 0,
			pre: str.slice(0, r[0]),
			body: str.slice(r[0]! + (a as string).length, r[1]),
			post: str.slice(r[1]! + (b as string).length),
		}
	);
}

/**
 * For the first non-nested matching pair of `a` and `b` in `str`,
 * return an array with indexes: `[ <a index>, <b index> ]`.
 */
export function range(a, b, str) {
	let begs, beg, left, right, result;
	let ai = str.indexOf(a);
	let bi = str.indexOf(b, ai + 1);
	let i = ai;

	if (ai >= 0 && bi > 0) {
		if (a === b) {
			return [ai, bi];
		}
		begs = [];
		left = str.length;

		while (i >= 0 && !result) {
			if (i === ai) {
				begs.push(i);
				ai = str.indexOf(a, i + 1);
			} else if (begs.length === 1) {
				result = [begs.pop(), bi];
			} else {
				beg = begs.pop();
				if (beg! < left!) {
					left = beg;
					right = bi;
				}

				bi = str.indexOf(b, i + 1);
			}

			i = ai < bi && ai >= 0 ? ai : bi;
		}

		if (begs.length) {
			result = [left, right];
		}
	}

	return result;
}

// Ported from: https://github.com/mugendi/balanced-match-all/blob/master/index.js
export function balancedAll(
	pre,
	post,
	str,
	includeInside = false,
	includeOutside = true,
	level = 0,
	arr = [],
) {
	const o = balanced(pre, post, str);

	if (o) {
		arr.push(o);
		const idx = arr.length - 1;

		if (idx > 0) {
			o.start += arr[idx - 1].start + pre.length;
			o.end += arr[idx - 1].start + post.length;
		}

		// loop till all are called
		if (includeInside) {
			arr = balancedAll(
				pre,
				post,
				o.body,
				includeInside,
				includeOutside,
				level++,
				arr,
			);
		}
		if (includeOutside && arr[idx].end < (str.length - 1)) {
			arr = balancedAll(
				pre,
				post,
				str.slice(arr[idx].end - 1),
				includeInside,
				true,
				0,
				arr,
			);
		}
	}

	return arr;
}
<fim_middle>",correct,1143
RegExp,RegExp,682aeec1fecbab4978758eab943eabd8aaf76c89,"<fim_prefix>/**
 * In order so that model can process validation, Every validation function must return this type.
 *
 * valid - if true all errors for property will be cleared
 * valid - if false - if errors are array - will replace all errors for property with array. if single string, will add it, if
 * there is no error with this message, else will ignore.
 *
 * errors - either array of error messages - if valid false will replace all errors for property, if single and false will add error if not there.
 *
 */
export interface ValidationReturn {
  valid: boolean
  errors?: string[] | string
  ignore?: boolean
}

export type ValidateFunction = (value, ...rest) => ValidationReturn

/**
 * valid false is value is undefined or empty string
 */
export const validateIsRequired = (
  value,
  message = 'required'
) => {
  if (!value && (value === '' || value === undefined)) {
    return { valid: false, errors: message }
  }
  return { valid: true }
}

/**
 * valid false if value does not match pattern
 */
export const validatePattern = (
  value,
  regEx: <fim_suffix>,
  message = 'errors.isNotEmail'
) => {
  if (regEx.test(value)) {
    return { valid: true }
  }
  return { valid: false, errors: message }
}

/**
 * valid false if length lt specified
 */
export const validateMinLength = (
  value,
  minLength,
  message = 'errors.tooShort'
) => {
  if (value && value.length >= minLength) {
    return { valid: true }
  }
  return { valid: false, errors: message }
}

/**
 * valid false if length gt than specified
 */
export const validateMaxLength = (
  value,
  maxLength,
  message = 'errors.tooLong'
) => {
  if (!value) {
    return { valid: false, errors: message }
  }
  if (value.length > maxLength) {
    return { valid: false, errors: message }
  }
  return { valid: true }
}

/**
 * valid false if value not equals toMatch
 */
export const validateEquals = (
  {
    value,
    toMatchWith
  },
  message = 'errors.notEqualTo'
) => {
  if (!value && !toMatchWith) {
    return { valid: true }
  }
  if (value !== toMatchWith) {
    return { valid: false, errors: message }
  }
  return { valid: true }
}
<fim_middle>",correct,2091
RegExp,RegExp,fe48985f9ace65089aa5d0dd92573b69804e7a66,"<fim_prefix>export const Kind = 'Core#HostRule';

/**
 * API Client host rule definition.
 */
export interface IHostRule {
  kind?: typeof Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from: string;
  /**
   * replacement value
   */
  to: string;
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;
}

export class HostRule {
  kind = Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from = '';
  /**
   * replacement value
   */
  to = '';
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;

  static fromValues(from, to ) {
    const result = new HostRule({
      kind: Kind,
      from,
      to,
      enabled: true,
    });
    return result;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IHostRule;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        from: '',
        to: '',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not an API Client thing.
   */
  new(init) {
    if (!HostRule.isHostRule(init)) {
      throw new Error(`Not a HostRule.`);
    }
    const { from='', to='', enabled, comment } = init;
    this.kind = Kind;
    this.from = from;
    this.to = to;
    this.enabled = enabled;
    this.comment = comment;
  }

  /**
   * Checks whether the input is a definition of a host rule.
   */
  static isHostRule(input) {
    const typed = input as IHostRule;
    if (input && typed.kind && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IHostRule = {
      kind: Kind,
      from : this.from,
      to : this.to,
    };
    if (typeof this.enabled === 'boolean') {
      result.enabled = this.enabled;
    }
    if (this.comment) {
      result.comment = this.comment;
    }
    return result;
  }

  /**
   * Applies `hosts` rules to the URL.
   *
   * @param value An URL to apply the rules to
   * @param rules List of host rules. It is a list of objects containing `from` and `to` properties.
   * @return Evaluated URL with hosts rules.
   */
  static applyHosts(value, rules) {
    if (!rules || !rules.length) {
      return value;
    }
    for (let i = 0; i < rules.length; i++) {
      const rule = rules[i];
      const result = HostRule.evaluateRule(value, rule);
      if (result) {
        value = result;
      }
    }
    return value;
  }

  /**
   * Evaluates hosts rule and applies it to the `url`.
   * @param {string} url The URL to evaluate
   * @param {HostRule} rule The host rule definition
   * @return {string} Processed url.
   */
  static evaluateRule(url, rule) {
    if (!rule || !rule.from || !rule.to) {
      return;
    }
    const re = HostRule.createRuleRe(rule.from);
    if (!re.test(url)) {
      return;
    }
    return url.replace(re, rule.to);
  }

  /**
   * @param input Rule body
   * @return Regular expression for the rule.
   */
  static createRuleRe(input): <fim_suffix> {
    input = input.replace(/\*/g, '(.*)');
    return new RegExp(input, 'gi');
  }
}
<fim_middle>",correct,3409
RegExp,RegExp,54795a90e2bd17f0016b0a39e21d9821b144d333,"<fim_prefix>/// <reference no-default-lib=""true""/>
/// <reference lib=""es6"" />

(function () {
  type primitiveObject = boolean | number | string;
  type primitive = primitiveObject | null | undefined;
  type ObjectCoercible = primitiveObject | {
      toString ();
    } | {
      valueOf ();
    };
  type anyNotSymbol = ObjectCoercible | null | undefined;
  interface StandardString {
    endsWith? (this, searchString, pos?);
    endsWith? (this, searchString?, pos?);
    includes? (this, searchString, pos?);
    includes? (this, searchString?, pos?);
    startsWith? (this, searchString, pos?);
    startsWith? (this, searchString?, pos?);
  }

  const symMatch = typeof Symbol === ""function"" && typeof Symbol.match === ""symbol"" &&
                    (Symbol.match as symbol | string as ""Symbol(Symbol.match)""),
  // eslint-disable-next-line id-denylist
  StrCls = String as StringConstructor & { readonly prototype: StandardString }, TECls = TypeError,
  StrProto = StrCls.prototype,
  toStr = Object.prototype.toString;

  """".startsWith || (
  StrProto.startsWith = function startsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""startsWith""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    return a.lastIndexOf(b, c) === c;
  });

  """".endsWith || (
  StrProto.endsWith = function endsWith(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""endsWith""));
    }
    let b = StrCls(searchString), args = arguments, u: undefined, c: number
      , p: primitive | object = args.length > 1 ? args[1] : u, l = a.length;
    c = (p === u ? l : (c = +<number | string> p) > 0 ? c | 0 : 0) - b.length;
    c > l && (c = l);
    return c >= 0 && a.indexOf(b, c) === c;
  });

  """".includes || (
  StrProto.includes = function includes(this, searchString) {
    const err = check(this, searchString), a = this != null && err !== 1 ? StrCls(this) : """";
    if (err !== 0) {
      if (err === 1 || err === 2) { return !((err < 2 ? this : searchString) + """"); }
      throw new TECls(err.replace(""${func}"", ""includes""));
    }
    let b = StrCls(searchString), args = arguments, c = args.length > 1 ? +args[1] : 0;
    c = c > 0 ? c | 0 : 0;
    c > a.length && (c = a.length);
    // eslint-disable-next-line @typescript-eslint/prefer-includes
    return a.indexOf(b, c) >= 0;
  });

  function check(a, b) {
    /** note: should never call `valueOf` or `toString` on a / b */
    if (a == null) { return ""String.prototype.${func} called on null or undefined""; }
    if (!b) { return 0; }
    let t: 0 | 1 | 2 = typeof a === ""symbol"" ? 1 : typeof b === ""symbol"" ? 2 : 0;
    if (t) { return t; }
    interface PossibleTypeOfB {
      [key: string]: ((this, re: <fim_suffix>) => boolean) | primitive;
    }
    let f: PossibleTypeOfB[string], u: undefined
      , i = symMatch && (f = (b as PossibleTypeOfB)[symMatch]) !== u ? f
          : toStr.call(b) === ""[object RegExp]"";
    return i ? ""First argument to String.prototype.${func} must not be a regular expression"" : 0;
  }
})();
<fim_middle>",correct,4571
Resolved,Resolved,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?: <fim_suffix>) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use() {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query) {
  return new StrictQuery(query)
}
<fim_middle>",correct,541
Rgb,Rgb,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l): <fim_suffix> => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,775
Role,Role,7f13942c6e9e03b58ec207e726168e13dd86cef1,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IRole {
    id?: string;
    name?: string;
    oauth_client_id?: string;
}

export default class Role {
    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _name: string | undefined;

    get name() {
        return this._name;
    }

    readonly _oauth_client_id: string | undefined;

    get oauthClientId() {
        return this._oauth_client_id;
    }

    constructor(props) {
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.name === 'string') {
            this._name = props.name.trim();
        }
        if (typeof props.oauth_client_id === 'string') {
            this._oauth_client_id = props.oauth_client_id.trim();
        }
    }

    serialize() {
        const data: IRole = {};
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._name !== 'undefined') {
            data.name = this._name;
        }
        if (typeof this._oauth_client_id !== 'undefined') {
            data.oauth_client_id = this._oauth_client_id;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            name: !this._name
                ? true
                : typeof this._name === 'string' && !this._name
                ? true
                : this._name,
            oauth_client_id: !this._oauth_client_id
                ? true
                : typeof this._oauth_client_id === 'string' &&
                  !this._oauth_client_id
                ? true
                : this._oauth_client_id,
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new Role({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,4821
Rule,Rule,326d9d855454c3462da30894d82c92685bff1b6e,"<fim_prefix>export interface Rule {
    calculateNewValue(cellValue, neighbourValues)
}

export function normalizeToOneOrZero(values) {
    return values.map(v => {
        if (v > 0) return 1
        else return 0
    })
}

function countLivingNeighbours(neighbourValues) {
    const normalizedValues = normalizeToOneOrZero(neighbourValues)
    return normalizedValues.reduce((sum, current) => sum + current, 0)
}

export class BSRule implements Rule {
    readonly born: Array<number>
    readonly stay: Array<number>

    constructor(born, stayAlive) {
        this.born = born
        this.stay = stayAlive
    }

    calculateNewValue(cellValue, neighbourValues) {
        const livingNeighbours = countLivingNeighbours(neighbourValues)
        if(cellValue > 0 && this.stay.indexOf(livingNeighbours) >= 0) {
            return cellValue
        }
        else if(cellValue == 0 && this.born.indexOf(livingNeighbours) >= 0) {
            return 1
        }
        return 0
    }

    static convert(rule: <fim_suffix>) {
        if(rule instanceof EEFFRule) {
            const eeffRule = rule as EEFFRule
            var born = Array<number>();
            for(var i = eeffRule.fl; i <= eeffRule.fu; i++) {
                born.push(i)
            }
            var stay = Array<number>();
            for(var i = eeffRule.el; i <= eeffRule.eu; i++) {
                stay.push(i)
            }
            return new BSRule(born, stay)
        }
        else if(rule instanceof BSRule) {
            return rule as BSRule
        }
        throw new Error(`can not convert rule: ${rule}`)
    }
}

export class EEFFRule implements Rule {
    readonly el: number
    readonly eu: number
    readonly fl: number
    readonly fu: number

    constructor(el, eu, fl, fu) {
        this.el = el
        this.eu = eu
        this.fl = fl
        this.fu = fu
    }
    
    calculateNewValue(cellValue, neighbourValues) {
        const livingNeighbours = countLivingNeighbours(neighbourValues)
        if(cellValue > 0 && (livingNeighbours < this.el || livingNeighbours > this.eu)) {
            return 0
        }
        else if(cellValue == 0 && (livingNeighbours >= this.fl && livingNeighbours <= this.fu)) {
            return 1
        }
        return cellValue
    }
}
<fim_middle>",correct,2598
Rule,Rule,0543f4f2b9cde1baf6a4d3e67f630175d9c7dcae,"<fim_prefix>interface Rule {
  ruleRaw: string,
  ruleIndex: number,
  ruleString: string,
  ruleRegex: string
}

const getRulesAndData = (input) => {
  let rules = input.filter(line => line !== '' && line.includes(':'));
  let data = input.filter(line => line !== '' && !line.includes(':'));

  return { 
    rules,
    data
  }
}

export function parseRules(rules) {
  return rules.map(rule => {
    const [ruleIndex, ruleString] = rule.split(': ');

    return {
      ruleRaw: rule,
      ruleIndex: parseInt(ruleIndex),
      ruleString,
      ruleRegex: ''
    }
  });
}

export function transformRuleToRegex(rule: <fim_suffix>, rules) {
  const ruleString = rule.ruleString;

  // Part 2 handle loop
  if (rule.ruleIndex === 8 && rule.ruleString.includes('8')) {
    // f(x) = x | x f(x) means a succession of 1 or more 'x'
    // ex: x
    // ex: xx
    // ex: xxx
    // ex: xxxx
    const correspondingRule = rules.find(rule => rule.ruleIndex === 42)!;
    const regex = '(' + transformRuleToRegex(correspondingRule, rules) + ')';

    return `${regex}+`;
  } else if (rule.ruleIndex === 11 && rule.ruleString.includes('11')) {
    // f(x, y) = xy | x f(xy) y means a succession of 1 or more 'x' then 1 or more 'y' but with same number of each
    // ex: xy
    // ex: xxyy
    // ex: xxxyyy
    // ex: xxxxyyyy
    const correspondingRule1 = rules.find(rule => rule.ruleIndex === 42)!;
    const regex1 = '(' + transformRuleToRegex(correspondingRule1, rules) + ')';

    const correspondingRule2 = rules.find(rule => rule.ruleIndex === 31)!;
    const regex2 = '(' + transformRuleToRegex(correspondingRule2, rules) + ')';

    const case1 = `(${regex1}{1}${regex2}{1})`;
    const case2 = `(${regex1}{2}${regex2}{2})`;
    const case3 = `(${regex1}{3}${regex2}{3})`;
    const case4 = `(${regex1}{4}${regex2}{4})`;

    return `((${case1})|(${case2})|(${case3})|(${case4}))`;
  } 
  // Part 1
  else {
    const regex = ruleString
      .split(' | ')
      .map(rulePart => {
        const partRegex = rulePart
          .split(' ')
          .map(ruleIndex => {
            const correspondingRule = rules.find(rule => rule.ruleIndex === parseInt(ruleIndex))!;
            
            if(correspondingRule.ruleString.includes('""')) {
              return correspondingRule.ruleString.replace(/\""/gi, '');
            } else {
              return '(' + transformRuleToRegex(correspondingRule, rules) + ')'
            }
          })
          .join('')
  
        return '(' + partRegex + ')';
      })
      .join('|');
  
    return regex;
  }

}

export function getRule0ToRegex(rules) {
  const rule0 = rules.find(rule => rule.ruleIndex === 0)!;

  const regex = transformRuleToRegex(rule0, rules)

  return regex;
}

export function getNumberOfMatchingLines(input) {
  const { rules, data } = getRulesAndData(input)

  const regexStr = '^' + getRule0ToRegex(parseRules(rules)) + '$';

  const regex = RegExp(regexStr);

  const matchingLines = data.filter(line => {
    return regex.test(line);
  });

  return matchingLines.length
}<fim_middle>",correct,3439
Schema,Schema,181ec44034d7ff44d9293788b657b1a2036d874b,"<fim_prefix>type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema: <fim_suffix>) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance) {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance, schema, location) {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance) {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
<fim_middle>",correct,235
SearchResult,SearchResult,2f9ed4c5926a0fcede392151f980e017c0c93acb,"<fim_prefix>interface WordCoord {
  start: number[]
  end: number[]
}

interface SearchResult {
  [k: string]: WordCoord | undefined
}

export default class WordSearch {
  // For searching in all 8 directions
  static directions: { row: number; col: number }[] = [
    { row: 0, col: 1 }, // left to right
    { row: 0, col: -1 }, // right to left
    { row: 1, col: 0 }, // top to bottom
    { row: -1, col: 0 }, // bottom to top
    { row: 1, col: 1 }, // top left to bottom right
    { row: 1, col: -1 }, // top right to bottom left
    { row: -1, col: 1 }, // bottom left to top right
    { row: -1, col: -1 }, // bottom right to top left
  ]

  private rowLen: number
  private colLen: number

  constructor(private grid = []) {
    this.rowLen = this.grid.length
    this.colLen = this.grid[0]?.length || 0
  }

  find(words): <fim_suffix> {
    const result: SearchResult = {}

    for (const word of words) {
      for (let row = 0; row < this.rowLen; row++) {
        for (let col = 0; col < this.colLen; col++) {
          if (!result[word]) {
            result[word] = this.findWord(word, row, col)
          }
        }
      }
    }

    return result
  }

  findWord(word, row, col) {
    // Word is not found if the first letter doesn't match.
    if (this.grid[row][col] !== word[0]) {
      return
    }

    // Search in all directions starting from (row, col).
    for (const direction of WordSearch.directions) {
      let rowDir = row + direction.row
      let colDir = col + direction.col
      let i = 0

      // First letter is already checked, start searching from the second letter.
      for (i = 1; i < word.length; i++) {
        // Stop if out of bound.
        if (rowDir >= this.rowLen || rowDir < 0 || colDir >= this.colLen || colDir < 0) {
          break
        }

        // Stop if letter doesn't match.
        if (this.grid[rowDir][colDir] !== word[i]) {
          break
        }

        // Move in particular direction.
        rowDir += direction.row
        colDir += direction.col
      }

      // If all letters matched then value of i is equal to the length of the word.
      if (i === word.length) {
        // Result should be in math indexes which start from (1, 1).
        // So we need to add 1 to indexes but it depends on direction in which word was found.
        const rowAdd = 1 - direction.row
        const colAdd = 1 - direction.col

        return {
          start: [row + 1, col + 1],
          end: [rowDir + rowAdd, colDir + colAdd],
        }
      }
    }
  }
}
<fim_middle>",correct,643
Section,Section,4ab9eed9cbc53ed6e544dca10cf2f6417c2bdcd7,"<fim_prefix>export type Section = [number, number];

export function getPreviousTitleLine(lines, lineIndex) {
  do {
    const line = lines[lineIndex];

    if (line.match(/#+ /) !== null) {
      return lineIndex;
    }

    lineIndex--;
  } while (lineIndex >= 0);

  throw Error(""cannot find previous title"");
}

export function getEndOfSectionLine(lines, lineIndex, sectionDepth) {
  const nextHeaderRe = new RegExp(`^(\\#){1,${sectionDepth}} `);

  let cursor = lineIndex + 1;

  while (lines[cursor] !== undefined) {
    const line = lines[cursor];

    if (line.match(nextHeaderRe) && cursor !== 0) {
      return cursor - 1;
    }

    cursor++;
  }

  return lines.length - 1;
}

/**
 * @returns index of started / ended line index
 */
export function getSection(lines, lineIndex): <fim_suffix> {
  const titleLine = getPreviousTitleLine(lines, lineIndex);
  const sectionDeep = lines[titleLine].split("" "")[0].length;

  const lastLine = getEndOfSectionLine(lines, lineIndex, sectionDeep);

  return [titleLine, lastLine];
}

export function promote(lines, lineIndex) {
  const section = getSection(lines, lineIndex);
  const newLines = [...lines];

  for (let i = section[0]; i <= section[1]; i++) {
    const line = newLines[i];

    if (line.match(/^(\#){2,6} +/) !== null) {
      newLines[i] = line.substring(1);
    }
  }

  return newLines;
}

export function demote(lines, lineIndex) {
  const section = getSection(lines, lineIndex);
  const newLines = [...lines];

  for (let i = section[0]; i <= section[1]; i++) {
    const line = newLines[i];

    if (line.match(/^(\#){1,5} +/) !== null) {
      newLines[i] = ""#"".concat(line);
    }
  }

  return newLines;
}
<fim_middle>",correct,2156
Serialized,Serialized,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON(): <fim_suffix> {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3854
Settings,Settings,7f5712ec06dabff06003ba15417bd3dcb2d15f53,"<fim_prefix>export type Settings = {
  parserName: string;
  typeHints: boolean;
  mainContents: string;
  mainName: string;
  cliName: string;
  argsName: string;
};

export const defaultSettings = () => {
  return {
    parserName: 'parser',
    typeHints: true,
    mainContents: '# Contents of main',
    mainName: 'main',
    cliName: 'cli',
    argsName: 'args',
  };
};

export type Argument = {
  name: string;
  type: string;
  variableName: string;
  default: string;
  required: boolean;
};

export const newArgument = (
  name,
  type,
  variableName = '',
  defaultValue = '',
  required = false,
) => {
  if (variableName === '') {
    variableName = name.replace(/-/g, '');
  }
  return { name, type, variableName, default: defaultValue, required };
};

function argumentToText(argument, parserName) {
  switch (argument.type) {
    case 'bool':
      return `${parserName}.add_argument(""${argument.name}"", action=""store_${argument.default}"")`;
    default:
      let defaultDisplay;

      if (argument.type === 'str') {
        defaultDisplay = `""${argument.default}""`;
      } else {
        defaultDisplay = argument.default;
      }

      if (argument.default === '') {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type})`;
      } else {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type}, default=${defaultDisplay})`;
      }
  }
}

const argumentToMainParams = (argument, typeHints) => {
  if (typeHints) {
    return `${argument.variableName}: ${argument.type}`;
  } else {
    return `${argument.variableName}`;
  }
};

export const argparseCode = (args, settings: <fim_suffix> = defaultSettings()) => {
  const parserName: string = settings.parserName;
  const argsName: string = settings.argsName;
  const mainParameters: string[] = args.map((arg) => argumentToMainParams(arg, settings.typeHints));
  const argumentsText: string[] = args.map((arg) => argumentToText(arg, parserName));
  const returnText: string[] = args.map((x) => {
    if (x.type === 'str') {
      return `""${x.variableName}"": ${argsName}.${x.variableName},`;
    } else {
      return `""${x.variableName}"": ${x.type}(${argsName}.${x.variableName}),`;
    }
  });

  const mainReturnType = settings.typeHints ? ' -> None' : '';
  const cliReturnType = settings.typeHints ? ' -> Dict[str, Any]' : '';
  const typeImports = settings.typeHints ? '\nfrom typing import Dict, Any' : '';

  const output = `import argparse${typeImports}


def ${settings.mainName}(${mainParameters.join(', ')})${mainReturnType}:
    ${settings.mainContents}
    return


def ${settings.cliName}()${cliReturnType}:
    formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ${parserName} = argparse.ArgumentParser(formatter_class=formatter_class)

    ${argumentsText.join('\n    ')}

    ${argsName} = ${parserName}.parse_args()

    return {${returnText.join('\n            ').slice(0, -1)}}


if __name__ == '__main__':
    ${argsName} = ${settings.cliName}()
    ${settings.mainName}(${args.map((x) => `${x.variableName}=${argsName}[""${x.variableName}""]`).join(',\n         ')})
`;
  return output;
};
<fim_middle>",correct,4829
Settings,Settings,7f5712ec06dabff06003ba15417bd3dcb2d15f53,"<fim_prefix>export type Settings = {
  parserName: string;
  typeHints: boolean;
  mainContents: string;
  mainName: string;
  cliName: string;
  argsName: string;
};

export const defaultSettings = (): <fim_suffix> => {
  return {
    parserName: 'parser',
    typeHints: true,
    mainContents: '# Contents of main',
    mainName: 'main',
    cliName: 'cli',
    argsName: 'args',
  };
};

export type Argument = {
  name: string;
  type: string;
  variableName: string;
  default: string;
  required: boolean;
};

export const newArgument = (
  name,
  type,
  variableName = '',
  defaultValue = '',
  required = false,
) => {
  if (variableName === '') {
    variableName = name.replace(/-/g, '');
  }
  return { name, type, variableName, default: defaultValue, required };
};

function argumentToText(argument, parserName) {
  switch (argument.type) {
    case 'bool':
      return `${parserName}.add_argument(""${argument.name}"", action=""store_${argument.default}"")`;
    default:
      let defaultDisplay;

      if (argument.type === 'str') {
        defaultDisplay = `""${argument.default}""`;
      } else {
        defaultDisplay = argument.default;
      }

      if (argument.default === '') {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type})`;
      } else {
        return `${parserName}.add_argument(""${argument.name}"", type=${argument.type}, default=${defaultDisplay})`;
      }
  }
}

const argumentToMainParams = (argument, typeHints) => {
  if (typeHints) {
    return `${argument.variableName}: ${argument.type}`;
  } else {
    return `${argument.variableName}`;
  }
};

export const argparseCode = (args, settings = defaultSettings()) => {
  const parserName: string = settings.parserName;
  const argsName: string = settings.argsName;
  const mainParameters: string[] = args.map((arg) => argumentToMainParams(arg, settings.typeHints));
  const argumentsText: string[] = args.map((arg) => argumentToText(arg, parserName));
  const returnText: string[] = args.map((x) => {
    if (x.type === 'str') {
      return `""${x.variableName}"": ${argsName}.${x.variableName},`;
    } else {
      return `""${x.variableName}"": ${x.type}(${argsName}.${x.variableName}),`;
    }
  });

  const mainReturnType = settings.typeHints ? ' -> None' : '';
  const cliReturnType = settings.typeHints ? ' -> Dict[str, Any]' : '';
  const typeImports = settings.typeHints ? '\nfrom typing import Dict, Any' : '';

  const output = `import argparse${typeImports}


def ${settings.mainName}(${mainParameters.join(', ')})${mainReturnType}:
    ${settings.mainContents}
    return


def ${settings.cliName}()${cliReturnType}:
    formatter_class = argparse.ArgumentDefaultsHelpFormatter
    ${parserName} = argparse.ArgumentParser(formatter_class=formatter_class)

    ${argumentsText.join('\n    ')}

    ${argsName} = ${parserName}.parse_args()

    return {${returnText.join('\n            ').slice(0, -1)}}


if __name__ == '__main__':
    ${argsName} = ${settings.cliName}()
    ${settings.mainName}(${args.map((x) => `${x.variableName}=${argsName}[""${x.variableName}""]`).join(',\n         ')})
`;
  return output;
};
<fim_middle>",correct,4841
Solution,Solution,782540af99146e3e07fdd0219b9a1b8603c98c86,"<fim_prefix>// Super fast physics simulations for JavaScript
// Copyright 2014 Ralph Thomas
// Licensed under the Apache License, Version 2.0
// https://github.com/iamralpht/gravitas.js

// Adapted to TypeScript and customized by Tanner Linsley (@tannerlinsley)

type Solution = {
  x: (num) => number
  dx: (num) => number
}

const epsilon = 0.001

function almostEqual(a, b) {
  if (Number.isNaN(a) && Number.isNaN(b)) {
    return true
  }
  return a > b - epsilon && a < b + epsilon
}

function almostZero(a) {
  return almostEqual(a, 0)
}

export class Spring {
  private _m: number
  private _k: number
  private _c: number
  private _solution: null | Solution
  private _startTime: number
  endPosition: number

  constructor(
    init,
    mass,
    springConstant,
    damping
  ) {
    this._m = mass
    this._k = springConstant
    this._c = damping
    this._solution = null
    this.endPosition = init
    this._startTime = 0
  }

  x(dt?) {
    if (dt === undefined) {
      dt = (new Date().getTime() - this._startTime) / 1000.0
    }
    return this._solution
      ? this.endPosition + this._solution.x(dt)
      : this.endPosition
  }

  private dx(dt?) {
    if (dt === undefined) {
      dt = (new Date().getTime() - this._startTime) / 1000.0
    }
    return this._solution ? this._solution.dx(dt) : 0
  }

  setEnd(x) {
    const t = new Date().getTime()

    let velocity = 0
    let position = this.endPosition
    if (this._solution) {
      // Don't whack incoming velocity.
      if (almostZero(velocity))
        velocity = this._solution.dx((t - this._startTime) / 1000.0)
      position = this._solution.x((t - this._startTime) / 1000.0)
      if (almostZero(velocity)) velocity = 0
      if (almostZero(position)) position = 0
      position += this.endPosition
    }
    if (this._solution && almostZero(position - x) && almostZero(velocity)) {
      return
    }
    this.endPosition = x
    this._solution = this._solve(position - this.endPosition, velocity)
    this._startTime = t
  }

  snap(x) {
    this._startTime = new Date().getTime()
    this.endPosition = x
    this._solution = {
      x() {
        return 0
      },
      dx() {
        return 0
      },
    }
  }

  done() {
    return almostEqual(this.x(), this.endPosition) && almostZero(this.dx())
  }

  // reconfigure(mass: number, springConstant: number, damping: number) {
  //   this._m = mass
  //   this._k = springConstant
  //   this._c = damping

  //   if (this.done()) {
  //     return
  //   }
  //   this._solution = this._solve(this.x() - this.endPosition, this.dx())
  //   this._startTime = new Date().getTime()
  // }

  // springConstant() {
  //   return this._k
  // }

  // damping() {
  //   return this._c
  // }

  private _solve(initial, velocity): <fim_suffix> {
    const c = this._c
    const m = this._m
    const k = this._k
    // Solve the quadratic equation; root = (-c +/- sqrt(c^2 - 4mk)) / 2m.
    const cmk = c * c - 4 * m * k
    if (cmk === 0) {
      // The spring is critically damped.
      // x = (c1 + c2*t) * e ^(-c/2m)*t
      const r = -c / (2 * m)
      const c1 = initial
      const c2 = velocity / (r * initial)
      return {
        x(t) {
          return (c1 + c2 * t) * Math.pow(Math.E, r * t)
        },
        dx(t) {
          const pow = Math.pow(Math.E, r * t)
          return r * (c1 + c2 * t) * pow + c2 * pow
        },
      }
    } else if (cmk > 0) {
      // The spring is overdamped; no bounces.
      // x = c1*e^(r1*t) + c2*e^(r2t)
      // Need to find r1 and r2, the roots, then solve c1 and c2.
      const r1 = (-c - Math.sqrt(cmk)) / (2 * m)
      const r2 = (-c + Math.sqrt(cmk)) / (2 * m)
      const c2 = (velocity - r1 * initial) / (r2 - r1)
      const c1 = initial - c2

      return {
        x(t) {
          return c1 * Math.pow(Math.E, r1 * t) + c2 * Math.pow(Math.E, r2 * t)
        },
        dx(t) {
          return (
            c1 * r1 * Math.pow(Math.E, r1 * t) +
            c2 * r2 * Math.pow(Math.E, r2 * t)
          )
        },
      }
    } else {
      // The spring is underdamped, it has imaginary roots.
      // r = -(c / 2*m) +- w*i
      // w = sqrt(4mk - c^2) / 2m
      // x = (e^-(c/2m)t) * (c1 * cos(wt) + c2 * sin(wt))
      const w = Math.sqrt(4 * m * k - c * c) / (2 * m)
      const r = -((c / 2) * m)
      const c1 = initial
      const c2 = (velocity - r * initial) / w

      return {
        x(t) {
          return (
            Math.pow(Math.E, r * t) *
            (c1 * Math.cos(w * t) + c2 * Math.sin(w * t))
          )
        },
        dx(t) {
          const power = Math.pow(Math.E, r * t)
          const cos = Math.cos(w * t)
          const sin = Math.sin(w * t)
          return (
            power * (c2 * w * cos - c1 * w * sin) +
            r * power * (c2 * sin + c1 * cos)
          )
        },
      }
    }
  }
}
<fim_middle>",correct,2754
Source,Source,de53b444284e879ad933dd4404a7e3f697c8dfe0,"<fim_prefix>export type Mapping<Source, Target> = {
  [P in keyof Target]:
    | keyof PickByType<Source, Target[P]>
    | ((source) => Target[P]);
};

export type KeysOfType<Base, Condition> = {
  [Key in keyof Base]: Base[Key] extends Condition ? Key : never;
}[keyof Base];

export type OmitByType<Base, Condition> = Omit<
  Base,
  KeysOfType<Base, Condition>
>;

export type PickByType<Base, Condition> = Pick<
  Base,
  KeysOfType<Base, Condition>
>;

export type MapTarget<Source> = {
  using: <Target>(mapping) => Target;
};
export type MapSource<Source> = (from) => MapTarget<Source>;

export const map = <Source>(source) => ({
  using: <S, Target>(mapping) => {
    const target = {} as Target;
    for (const targetKey of Object.keys(mapping)) {
      const value = mapping[targetKey];
      if (typeof value === 'string') {
        const sourceKey = value;
        target[targetKey] = source[sourceKey];
      } else if (typeof value === 'function') {
        const fn = value;
        target[targetKey] = fn(source);
      }
    }

    return target;
  },
});

export const using =
  <Source, Target>(mapping) =>
  (source: <fim_suffix>) =>
    map(source).using(mapping);

export function parsePage(
  defaultCount,
  page,
) {
  if (typeof page.first === 'number' || typeof page.after === 'string') {
    const count = page.first || defaultCount;
    return {
      count,
      uniqueId: page.after,
      limit: page.after ? count + 2 : count + 1,
      direction: 'forward',
    };
  } else if (typeof page.last === 'number' || typeof page.before === 'string') {
    const count = page.last || defaultCount;
    return {
      count,
      uniqueId: page.before,
      limit: page.before ? count + 2 : count + 1,
      direction: 'backward',
    };
  }

  return {
    count: defaultCount,
    limit: defaultCount + 1,
    direction: 'forward',
  };
}

export function buildPage<T>(
  items,
  count,
  usedCursor,
  direction,
  getUniqueId,
) {
  const previous = usedCursor ? items[0] : undefined;
  const next: T | undefined = usedCursor ? items[count + 1] : items[count];
  const data = usedCursor ? items.slice(1, count + 1) : items.slice(0, count);

  const first: T | undefined = data[0];
  const last: T | undefined = data[data.length - 1];

  if (direction === 'forward') {
    return {
      items: data,
      hasNextPage: !!next,
      hasPreviousPage: !!previous,
      startCursor: getUniqueId(first),
      endCursor: getUniqueId(last),
    };
  } else {
    return {
      items: data.reverse(),
      hasNextPage: !!previous,
      hasPreviousPage: !!next,
      startCursor: getUniqueId(first),
      endCursor: getUniqueId(last),
    };
  }
}

export function buildInClause<T>(
  items,
  startingAt = 1,
) {
  return {
    in: items.map((_, i) => `$${i + startingAt}`).join(', '),
    values: items,
  };
}
<fim_middle>",correct,5113
Square,Square,035143ca918f5ec39ef8a6d403d38090c1efd46d,"<fim_prefix>/**
 * Collection of 0x88-based methods to represent chessboard state.
 *
 * https://www.chessprogramming.org/0x88
 */

export const SQUARE_COLORS = [""light"", ""dark""] as const;
export const SIDE_COLORS = [""white"", ""black""] as const;
export const PIECE_TYPES = [
  ""queen"",
  ""king"",
  ""knight"",
  ""bishop"",
  ""rook"",
  ""pawn"",
] as const;

export type SquareColor = typeof SQUARE_COLORS[number];
export type Side = typeof SIDE_COLORS[number];
export type PieceType = typeof PIECE_TYPES[number];
export type Position = Partial<Record<Square, Piece>>;

export interface Piece {
  pieceType: PieceType;
  color: Side;
}

// prettier-ignore
const SQUARES_MAP = {
  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
}
const SQUARES = Object.keys(SQUARES_MAP) as Square[];
export type Square = keyof typeof SQUARES_MAP;

// prettier-ignore
const SQUARE_DISTANCE_TABLE = [
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  7 , 6 , 5 , 4 , 3 , 2, 1, 0, 1, 2, 3 , 4 , 5 , 6 , 7 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
]

const REVERSE_SQUARES_MAP = SQUARES.reduce((acc, key) => {
  acc[SQUARES_MAP[key]] = key;
  return acc;
}, {} as Record<number, Square>);

const FEN_PIECE_TYPE_MAP: { [key: string]: PieceType } = {
  p: ""pawn"",
  n: ""knight"",
  b: ""bishop"",
  r: ""rook"",
  q: ""queen"",
  k: ""king"",
};
const REVERSE_FEN_PIECE_TYPE_MAP: Record<PieceType, string> = Object.keys(
  FEN_PIECE_TYPE_MAP
).reduce((acc, key) => {
  acc[FEN_PIECE_TYPE_MAP[key]] = key;
  return acc;
}, {} as Record<PieceType, string>);

export type PositionDiff = {
  added: Array<{ piece: Piece; square: Square }>;
  removed: Array<{ piece: Piece; square: Square }>;
  moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }>;
};

/**
 * Parse a FEN string and return an object that maps squares to pieces.
 *
 * Also accepts the special string ""initial"" or ""start"" to represent
 * standard game starting position.
 *
 * Note that only the first part of the FEN string (piece placement) is
 * parsed; any additional components are ignored.
 *
 * @param fen the FEN string
 * @returns an object where key is of type Square (string) and value is
 *          of type Piece
 */
export function getPosition(fen) {
  if (fen === ""initial"" || fen === ""start"") {
    fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"";
  }

  const parts = fen.split("" "");
  const ranks = parts[0].split(""/"");
  if (ranks.length !== 8) {
    return undefined;
  }

  const position: Position = {};
  for (let i = 0; i < 8; i++) {
    const rank = 8 - i;
    let fileOffset = 0;
    for (let j = 0; j < ranks[i].length; j++) {
      const pieceLetter = ranks[i][j].toLowerCase();
      if (pieceLetter in FEN_PIECE_TYPE_MAP) {
        const square = (String.fromCharCode(97 + fileOffset) + rank) as Square;
        position[square] = {
          pieceType: FEN_PIECE_TYPE_MAP[pieceLetter],
          color: pieceLetter === ranks[i][j] ? ""black"" : ""white"",
        };
        fileOffset += 1;
      } else {
        const emptySpaces = parseInt(ranks[i][j]);
        if (isNaN(emptySpaces) || emptySpaces === 0 || emptySpaces > 8) {
          return undefined;
        } else {
          fileOffset += emptySpaces;
        }
      }
    }
    if (fileOffset !== 8) {
      return undefined;
    }
  }
  return position;
}

/**
 * Get FEN string corresponding to Position object. Note that this only returns
 * the first (piece placement) component of the FEN string.
 */
export function getFen(position) {
  const rankSpecs = [];
  for (let i = 0; i < 8; i++) {
    let rankSpec = """";
    let gap = 0;
    for (let j = 0; j < 8; j++) {
      const square = REVERSE_SQUARES_MAP[16 * i + j];
      const piece = position[square];
      if (piece !== undefined) {
        const pieceStr = REVERSE_FEN_PIECE_TYPE_MAP[piece.pieceType];
        if (gap > 0) {
          rankSpec += gap;
        }
        rankSpec += piece.color === ""white"" ? pieceStr.toUpperCase() : pieceStr;
        gap = 0;
      } else {
        gap += 1;
      }
    }
    if (gap > 0) {
      rankSpec += gap;
    }
    rankSpecs.push(rankSpec);
  }
  return rankSpecs.join(""/"");
}

/**
 * Return square identifier for visual index in a grid, depending on
 * orientation. If `orientation` is ""white"", then a8 is on the top
 * left (0) and h8 is on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 */
export function getSquare(visualIndex, orientation) {
  const idx = visualIndex + (visualIndex & ~0x7);
  return REVERSE_SQUARES_MAP[orientation === ""black"" ? 0x77 - idx : idx];
}

/**
 * Get the ""visual"" index for `square` depending on `orientation`.
 * If `orientation` is ""white"", then a8 is on the top left (0) and h8 is
 * on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 *
 * @param square square to convert to visual index.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns a visual index for the square in question.
 */
export function getVisualIndex(square, orientation) {
  const idx = SQUARES_MAP[square];
  const orientedIdx = orientation === ""black"" ? 0x77 - idx : idx;
  return (orientedIdx + (orientedIdx & 0x7)) >> 1;
}

/**
 * Like `getVisualIndex`, but returns a row and column combination.
 *
 * @param square square to convert to visual row and column.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns an array containing [row, column] for the square in question.
 */
export function getVisualRowColumn(
  square: <fim_suffix>,
  orientation
) {
  const idx = getVisualIndex(square, orientation);
  return [idx >> 3, idx & 0x7];
}

/**
 * https://www.chessprogramming.org/Color_of_a_Square#By_Anti-Diagonal_Index
 */
export function getSquareColor(square) {
  const idx0x88 = SQUARES_MAP[square];
  const idx = (idx0x88 + (idx0x88 & 0x7)) >> 1;
  return ((idx * 9) & 8) === 0 ? ""light"" : ""dark"";
}

/**
 * Type guard to check if `key` (string) is a valid chess square.
 */
export function keyIsSquare(key): key is Square {
  return key !== undefined && key in SQUARES_MAP;
}

/**
 * Deep equality check for two Piece objects.
 */
export function pieceEqual(a, b) {
  return (
    (a === undefined && b === undefined) ||
    (a !== undefined &&
      b !== undefined &&
      a.color === b.color &&
      a.pieceType === b.pieceType)
  );
}

/**
 * Type guard for string values that need to conform to a `Side` definition.
 */
export function isSide(s): s is Side {
  return SIDE_COLORS.includes(s as Side);
}

/**
 * Deep equality check for Position objects.
 */
export function positionsEqual(a, b) {
  return SQUARES.every((square) => pieceEqual(a[square], b[square]));
}

export function calcPositionDiff(
  oldPosition,
  newPosition
) {
  // Limit old and new positions only to squares that are different
  const oldPositionLimited = { ...oldPosition };
  const newPositionLimited = { ...newPosition };
  Object.keys(newPosition).forEach((k) => {
    const square = k as Square;
    if (pieceEqual(newPosition[square], oldPosition[square])) {
      delete oldPositionLimited[square];
      delete newPositionLimited[square];
    }
  });

  const added: Array<{ piece: Piece; square: Square }> = [];
  const removed: Array<{ piece: Piece; square: Square }> = [];
  const moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }> =
    [];

  Object.entries(newPositionLimited).forEach(([k, newPiece]) => {
    const newSquare = k as Square;
    let minDistance = 15;
    let closestSquare: Square | undefined;
    Object.entries(oldPositionLimited).forEach(([l, oldPiece]) => {
      const oldSquare = l as Square;
      if (pieceEqual(newPiece, oldPiece)) {
        const distance = squareDistance(newSquare, oldSquare);
        if (distance < minDistance) {
          minDistance = distance;
          closestSquare = oldSquare;
        }
      }
    });
    if (closestSquare !== undefined) {
      moved.push({ piece: newPiece, oldSquare: closestSquare, newSquare });
      delete oldPositionLimited[closestSquare];
      delete newPositionLimited[newSquare];
    }
  });

  Object.entries(newPositionLimited).forEach(([k, piece]) => {
    added.push({ piece, square: k as Square });
  });

  Object.entries(oldPositionLimited).forEach(([k, piece]) => {
    removed.push({ piece, square: k as Square });
  });

  return { added, removed, moved };
}

export function squareDistance(a, b) {
  return SQUARE_DISTANCE_TABLE[SQUARES_MAP[a] - SQUARES_MAP[b] + 0x77];
}
<fim_middle>",correct,2259
Square,Square,035143ca918f5ec39ef8a6d403d38090c1efd46d,"<fim_prefix>/**
 * Collection of 0x88-based methods to represent chessboard state.
 *
 * https://www.chessprogramming.org/0x88
 */

export const SQUARE_COLORS = [""light"", ""dark""] as const;
export const SIDE_COLORS = [""white"", ""black""] as const;
export const PIECE_TYPES = [
  ""queen"",
  ""king"",
  ""knight"",
  ""bishop"",
  ""rook"",
  ""pawn"",
] as const;

export type SquareColor = typeof SQUARE_COLORS[number];
export type Side = typeof SIDE_COLORS[number];
export type PieceType = typeof PIECE_TYPES[number];
export type Position = Partial<Record<Square, Piece>>;

export interface Piece {
  pieceType: PieceType;
  color: Side;
}

// prettier-ignore
const SQUARES_MAP = {
  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,
  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,
  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,
  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,
  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,
  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,
  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,
  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119
}
const SQUARES = Object.keys(SQUARES_MAP) as Square[];
export type Square = keyof typeof SQUARES_MAP;

// prettier-ignore
const SQUARE_DISTANCE_TABLE = [
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  7 , 6 , 5 , 4 , 3 , 2, 1, 0, 1, 2, 3 , 4 , 5 , 6 , 7 , 0,
  8 , 7 , 6 , 5 , 4 , 3, 2, 1, 2, 3, 4 , 5 , 6 , 7 , 8 , 0,
  9 , 8 , 7 , 6 , 5 , 4, 3, 2, 3, 4, 5 , 6 , 7 , 8 , 9 , 0,
  10, 9 , 8 , 7 , 6 , 5, 4, 3, 4, 5, 6 , 7 , 8 , 9 , 10, 0,
  11, 10, 9 , 8 , 7 , 6, 5, 4, 5, 6, 7 , 8 , 9 , 10, 11, 0,
  12, 11, 10, 9 , 8 , 7, 6, 5, 6, 7, 8 , 9 , 10, 11, 12, 0,
  13, 12, 11, 10, 9 , 8, 7, 6, 7, 8, 9 , 10, 11, 12, 13, 0,
  14, 13, 12, 11, 10, 9, 8, 7, 8, 9, 10, 11, 12, 13, 14, 0,
]

const REVERSE_SQUARES_MAP = SQUARES.reduce((acc, key) => {
  acc[SQUARES_MAP[key]] = key;
  return acc;
}, {} as Record<number, Square>);

const FEN_PIECE_TYPE_MAP: { [key: string]: PieceType } = {
  p: ""pawn"",
  n: ""knight"",
  b: ""bishop"",
  r: ""rook"",
  q: ""queen"",
  k: ""king"",
};
const REVERSE_FEN_PIECE_TYPE_MAP: Record<PieceType, string> = Object.keys(
  FEN_PIECE_TYPE_MAP
).reduce((acc, key) => {
  acc[FEN_PIECE_TYPE_MAP[key]] = key;
  return acc;
}, {} as Record<PieceType, string>);

export type PositionDiff = {
  added: Array<{ piece: Piece; square: Square }>;
  removed: Array<{ piece: Piece; square: Square }>;
  moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }>;
};

/**
 * Parse a FEN string and return an object that maps squares to pieces.
 *
 * Also accepts the special string ""initial"" or ""start"" to represent
 * standard game starting position.
 *
 * Note that only the first part of the FEN string (piece placement) is
 * parsed; any additional components are ignored.
 *
 * @param fen the FEN string
 * @returns an object where key is of type Square (string) and value is
 *          of type Piece
 */
export function getPosition(fen) {
  if (fen === ""initial"" || fen === ""start"") {
    fen = ""rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR"";
  }

  const parts = fen.split("" "");
  const ranks = parts[0].split(""/"");
  if (ranks.length !== 8) {
    return undefined;
  }

  const position: Position = {};
  for (let i = 0; i < 8; i++) {
    const rank = 8 - i;
    let fileOffset = 0;
    for (let j = 0; j < ranks[i].length; j++) {
      const pieceLetter = ranks[i][j].toLowerCase();
      if (pieceLetter in FEN_PIECE_TYPE_MAP) {
        const square = (String.fromCharCode(97 + fileOffset) + rank) as Square;
        position[square] = {
          pieceType: FEN_PIECE_TYPE_MAP[pieceLetter],
          color: pieceLetter === ranks[i][j] ? ""black"" : ""white"",
        };
        fileOffset += 1;
      } else {
        const emptySpaces = parseInt(ranks[i][j]);
        if (isNaN(emptySpaces) || emptySpaces === 0 || emptySpaces > 8) {
          return undefined;
        } else {
          fileOffset += emptySpaces;
        }
      }
    }
    if (fileOffset !== 8) {
      return undefined;
    }
  }
  return position;
}

/**
 * Get FEN string corresponding to Position object. Note that this only returns
 * the first (piece placement) component of the FEN string.
 */
export function getFen(position) {
  const rankSpecs = [];
  for (let i = 0; i < 8; i++) {
    let rankSpec = """";
    let gap = 0;
    for (let j = 0; j < 8; j++) {
      const square = REVERSE_SQUARES_MAP[16 * i + j];
      const piece = position[square];
      if (piece !== undefined) {
        const pieceStr = REVERSE_FEN_PIECE_TYPE_MAP[piece.pieceType];
        if (gap > 0) {
          rankSpec += gap;
        }
        rankSpec += piece.color === ""white"" ? pieceStr.toUpperCase() : pieceStr;
        gap = 0;
      } else {
        gap += 1;
      }
    }
    if (gap > 0) {
      rankSpec += gap;
    }
    rankSpecs.push(rankSpec);
  }
  return rankSpecs.join(""/"");
}

/**
 * Return square identifier for visual index in a grid, depending on
 * orientation. If `orientation` is ""white"", then a8 is on the top
 * left (0) and h8 is on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 */
export function getSquare(visualIndex, orientation) {
  const idx = visualIndex + (visualIndex & ~0x7);
  return REVERSE_SQUARES_MAP[orientation === ""black"" ? 0x77 - idx : idx];
}

/**
 * Get the ""visual"" index for `square` depending on `orientation`.
 * If `orientation` is ""white"", then a8 is on the top left (0) and h8 is
 * on the bottom right (63):
 *
 * a8 ...... .
 * .  ...... .
 * .  ...... h1
 *
 * otherwise h1 is on the top left:
 *
 * h1 ...... .
 * .  ...... .
 * .  ...... a8
 *
 * https://www.chessprogramming.org/0x88#Coordinate_Transformation
 *
 * @param square square to convert to visual index.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns a visual index for the square in question.
 */
export function getVisualIndex(square: <fim_suffix>, orientation) {
  const idx = SQUARES_MAP[square];
  const orientedIdx = orientation === ""black"" ? 0x77 - idx : idx;
  return (orientedIdx + (orientedIdx & 0x7)) >> 1;
}

/**
 * Like `getVisualIndex`, but returns a row and column combination.
 *
 * @param square square to convert to visual row and column.
 * @param orientation  what side is at the bottom (""white"" = a1 on bottom left)
 * @returns an array containing [row, column] for the square in question.
 */
export function getVisualRowColumn(
  square,
  orientation
) {
  const idx = getVisualIndex(square, orientation);
  return [idx >> 3, idx & 0x7];
}

/**
 * https://www.chessprogramming.org/Color_of_a_Square#By_Anti-Diagonal_Index
 */
export function getSquareColor(square) {
  const idx0x88 = SQUARES_MAP[square];
  const idx = (idx0x88 + (idx0x88 & 0x7)) >> 1;
  return ((idx * 9) & 8) === 0 ? ""light"" : ""dark"";
}

/**
 * Type guard to check if `key` (string) is a valid chess square.
 */
export function keyIsSquare(key): key is Square {
  return key !== undefined && key in SQUARES_MAP;
}

/**
 * Deep equality check for two Piece objects.
 */
export function pieceEqual(a, b) {
  return (
    (a === undefined && b === undefined) ||
    (a !== undefined &&
      b !== undefined &&
      a.color === b.color &&
      a.pieceType === b.pieceType)
  );
}

/**
 * Type guard for string values that need to conform to a `Side` definition.
 */
export function isSide(s): s is Side {
  return SIDE_COLORS.includes(s as Side);
}

/**
 * Deep equality check for Position objects.
 */
export function positionsEqual(a, b) {
  return SQUARES.every((square) => pieceEqual(a[square], b[square]));
}

export function calcPositionDiff(
  oldPosition,
  newPosition
) {
  // Limit old and new positions only to squares that are different
  const oldPositionLimited = { ...oldPosition };
  const newPositionLimited = { ...newPosition };
  Object.keys(newPosition).forEach((k) => {
    const square = k as Square;
    if (pieceEqual(newPosition[square], oldPosition[square])) {
      delete oldPositionLimited[square];
      delete newPositionLimited[square];
    }
  });

  const added: Array<{ piece: Piece; square: Square }> = [];
  const removed: Array<{ piece: Piece; square: Square }> = [];
  const moved: Array<{ piece: Piece; oldSquare: Square; newSquare: Square }> =
    [];

  Object.entries(newPositionLimited).forEach(([k, newPiece]) => {
    const newSquare = k as Square;
    let minDistance = 15;
    let closestSquare: Square | undefined;
    Object.entries(oldPositionLimited).forEach(([l, oldPiece]) => {
      const oldSquare = l as Square;
      if (pieceEqual(newPiece, oldPiece)) {
        const distance = squareDistance(newSquare, oldSquare);
        if (distance < minDistance) {
          minDistance = distance;
          closestSquare = oldSquare;
        }
      }
    });
    if (closestSquare !== undefined) {
      moved.push({ piece: newPiece, oldSquare: closestSquare, newSquare });
      delete oldPositionLimited[closestSquare];
      delete newPositionLimited[newSquare];
    }
  });

  Object.entries(newPositionLimited).forEach(([k, piece]) => {
    added.push({ piece, square: k as Square });
  });

  Object.entries(oldPositionLimited).forEach(([k, piece]) => {
    removed.push({ piece, square: k as Square });
  });

  return { added, removed, moved };
}

export function squareDistance(a, b) {
  return SQUARE_DISTANCE_TABLE[SQUARES_MAP[a] - SQUARES_MAP[b] + 0x77];
}
<fim_middle>",correct,2261
State,State,6fe76b5aaf422ac45ea3f391258b2aeb7c5ddf67,"<fim_prefix>export type State = {
	room_id: string,
	room_name: string,
	room_icon: string,
	owner_data: {
		client_id: string,
		client_name: string,
		client_profile: string
	}
	active_clients: {
		client_id: string,
		client_name: string,
		client_profile: string
	}[]
}

const roomDefault: State = {
	room_id: '',
	room_name: '',
	room_icon: '',
	owner_data: {
		client_id: '',
		client_name: '',
		client_profile: ''		
	},
	active_clients: [],
}

type ActionType = ""LOAD_ROOM_DATA"" | ""ROOM_BAN_ADD"" | ""ROOM_BAN_REMOVE"" | ""ROOM_MEMBER_UPDATE"" | ""ROOM_MEMBER_REMOVE"" | ""NEW_OWNER""| ""CHANGE_ROOM"" | ""SET_ONLINE_MEMBERS""
type ActionPayload = {
	ip?: string,
	client_id?: string,
	client_name?: string,
	client_profile?: string
	room_name?: string,
	room_icon?: string,
	room_id?: string
	active_clients: {
		client_id: string,
		client_name: string,
		client_profile: string
	}[],
	owner_data: {
		client_id: string,
		client_name: string,
		client_profile: string
	}
}

type Action = {
	type: ActionType,
	payload: ActionPayload
}



export const roomInfo = (state = roomDefault, action): <fim_suffix> => {
	switch(action.type){
		//LOAD ROOM DATA
		case ""LOAD_ROOM_DATA"": {
			const {room_icon, room_id, room_name, owner_data, active_clients} = action.payload
			
			return {
				room_id: room_id!,
				room_name: room_name!,
				room_icon: room_icon!,
				owner_data: owner_data,
				active_clients: active_clients,
			}
		}
		//WHEN OWNER GIVES NEW MEMBER OWNERHOST
		case ""NEW_OWNER"" : {
			const {client_id, client_name, client_profile} = action.payload
			
			return {
				...state,
				owner_data: {
					client_id: client_id!,
					client_name: client_name!,
					client_profile: client_profile!		
				},
			}
		}
		//MEMBER LEAVES ROOM
		case ""ROOM_MEMBER_REMOVE"": {
			const {client_id} = action.payload

			const memberLeft = state.active_clients.filter(e => e.client_id !== client_id)
			
			return {
				...state,
				active_clients: memberLeft
			}
		}
		case ""SET_ONLINE_MEMBERS"": {
			const {active_clients} = action.payload

			return {
				...state,
				active_clients: active_clients
			}
		}
		//MEMBER JOINS ROOM	
		case ""ROOM_MEMBER_UPDATE"": {
			const {client_id, client_name, client_profile} = action.payload
			const duplicateUser = state.active_clients.some(e => e.client_id === client_id)

			if(duplicateUser) return state

			return {
				...state,
				active_clients: [
					...state.active_clients,
					{
						client_id: client_id!,
						client_name: client_name!,
						client_profile: client_profile!
					}
				]
			}
		}
		case ""CHANGE_ROOM"": {
			return {
				...state,
				room_name: action.payload.room_name!,
				room_icon: action.payload.room_icon!
			}
		}
		default: return state
	}
}<fim_middle>",correct,2001
State,State,da0ef1973818334ec9af63eb9d4d8f9b49d3597e,"<fim_prefix>export type State = {
	username: string,
	profile_src: string,
	createdAt: string,
	client_id: string
	message: string,
	message_id: string,
	reply?: {
		reply_username: string,
		reply_picture: string,
		reply_message: string,
		reply_message_owner_id: string
	}
}

type Action = {
	type: ""SET_USER"" | ""MESSAGE_INPUT"" | ""CLEAR_MESSAGE_FIELD"" | ""SET_MESSAGE_ID"" | ""SET_REPLY_MESSAGE"" | ""CLEAR_REPLY"",
	payload: {
		username: string,
		profile_src: string,
		createdAt: string,
		client_id: string,
		message: string,
		message_id: string,
		reply_username?: string,
		reply_picture?: string,
		reply_message?: string,
		reply_message_id?: string
	}
}

const clientState: State = {
	username: '',
	profile_src: '',
	createdAt: '',
	client_id: '',
	message: '',
	message_id: ''
}

export const clientReducer = (state = clientState, action): <fim_suffix> => {
	
	switch(action.type){
		case ""SET_USER"": {
			const {username, message_id, profile_src, createdAt, client_id} = action.payload
			return {
				...state,
				username: username,
				profile_src: profile_src,
				createdAt: createdAt,
				client_id: client_id,
				message_id: message_id
			}
		}case ""MESSAGE_INPUT"": {
			const {message} = action.payload
			return {
				...state,
				message: message
			}
		}
		case ""CLEAR_MESSAGE_FIELD"": {
			return {
				...state,
				message: """"
			}
		}
		case ""SET_MESSAGE_ID"": {
			return {
				...state,
				message_id: action.payload.message_id
			}
		}
		case ""SET_REPLY_MESSAGE"": {
			const {reply_username, reply_picture, reply_message, reply_message_id} = action.payload

			return {
				...state,
				reply: {
					reply_username: reply_username as string,
					reply_picture: reply_picture as string,
					reply_message: reply_message as string,
					reply_message_owner_id: reply_message_id as string
				}
			}
		}
		case ""CLEAR_REPLY"": {
			return {
				...state,
				reply: undefined
			}
		}
		default: return state
	}
}<fim_middle>",correct,3545
State,State,da0ef1973818334ec9af63eb9d4d8f9b49d3597e,"<fim_prefix>export type State = {
	username: string,
	profile_src: string,
	createdAt: string,
	client_id: string
	message: string,
	message_id: string,
	reply?: {
		reply_username: string,
		reply_picture: string,
		reply_message: string,
		reply_message_owner_id: string
	}
}

type Action = {
	type: ""SET_USER"" | ""MESSAGE_INPUT"" | ""CLEAR_MESSAGE_FIELD"" | ""SET_MESSAGE_ID"" | ""SET_REPLY_MESSAGE"" | ""CLEAR_REPLY"",
	payload: {
		username: string,
		profile_src: string,
		createdAt: string,
		client_id: string,
		message: string,
		message_id: string,
		reply_username?: string,
		reply_picture?: string,
		reply_message?: string,
		reply_message_id?: string
	}
}

const clientState: State = {
	username: '',
	profile_src: '',
	createdAt: '',
	client_id: '',
	message: '',
	message_id: ''
}

export const clientReducer = (state: <fim_suffix> = clientState, action) => {
	
	switch(action.type){
		case ""SET_USER"": {
			const {username, message_id, profile_src, createdAt, client_id} = action.payload
			return {
				...state,
				username: username,
				profile_src: profile_src,
				createdAt: createdAt,
				client_id: client_id,
				message_id: message_id
			}
		}case ""MESSAGE_INPUT"": {
			const {message} = action.payload
			return {
				...state,
				message: message
			}
		}
		case ""CLEAR_MESSAGE_FIELD"": {
			return {
				...state,
				message: """"
			}
		}
		case ""SET_MESSAGE_ID"": {
			return {
				...state,
				message_id: action.payload.message_id
			}
		}
		case ""SET_REPLY_MESSAGE"": {
			const {reply_username, reply_picture, reply_message, reply_message_id} = action.payload

			return {
				...state,
				reply: {
					reply_username: reply_username as string,
					reply_picture: reply_picture as string,
					reply_message: reply_message as string,
					reply_message_owner_id: reply_message_id as string
				}
			}
		}
		case ""CLEAR_REPLY"": {
			return {
				...state,
				reply: undefined
			}
		}
		default: return state
	}
}<fim_middle>",correct,3547
StateMachine,StateMachine,f49da3344f8374115865cb50cd0ff119cbf7301c,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

const code_CarriageReturn = ""\r"".charCodeAt(0);
const code_NewLine = ""\n"".charCodeAt(0);
const code_Space = "" "".charCodeAt(0);
const code_Tab = ""\t"".charCodeAt(0);
const code_Slash = ""/"".charCodeAt(0);
const code_Backslash = ""\\"".charCodeAt(0);
const code_Star = ""*"".charCodeAt(0);
const code_Hash = ""#"".charCodeAt(0);
const code_Bang = ""!"".charCodeAt(0);
const code_SingleQuote = ""'"".charCodeAt(0);
const code_DoubleQuote = ""\"""".charCodeAt(0);
const code_OpenBrace = ""{"".charCodeAt(0);
const code_CloseBrace = ""}"".charCodeAt(0);
const code_OpenBracket = ""["".charCodeAt(0);
const code_CloseBracket = ""]"".charCodeAt(0);
const code_Backtick = ""`"".charCodeAt(0);
const code_Dollar = ""$"".charCodeAt(0);

const enum State {
    Uninitialized,
    Default,
    StartSingleLineComment,
    SingleLineComment,
    StartMultiLineComment,
    MultiLineComment,
    EndMultiLineComment,
    StartShebangComment,
    ShebangComment,
    SingleQuoteString,
    SingleQuoteStringEscapeBackslash,
    SingleQuoteStringEscapeQuote,
    DoubleQuoteString,
    DoubleQuoteStringEscapeBackslash,
    DoubleQuoteStringEscapeQuote,
    TemplateString,
    TemplateStringEscapeBackslash,
    TemplateStringEscapeQuote,
    StartExpressionHole,
    Regex,
    RegexEscapeBackslash,
    RegexEscapeSlash,
    RegexEscapeOpenBracket,
    CharClass,
    CharClassEscapeBackslash,
    CharClassEscapeCloseBracket,
}

export type CharKind =
    | ""whitespace""
    | ""comment""
    | ""string""
    | ""regex""
    | ""code""
    ;

interface StepResult {
    charKind: CharKind;
    wrapLine: boolean;
}

export interface StateMachine {
    step(ch, nextCh);
}

export function create(): <fim_suffix> {
    let state = State.Default;
    let braceDepth = 0;
    let templateStringBraceDepthStack: number[] = [];
    let isBOF = true;

    function step(ch, nextCh) {
        let nextStateId = State.Uninitialized;;
        let wrapLine = false;
        switch (ch) {
            case code_CarriageReturn:
                if (nextCh === code_NewLine) {
                    if (state === State.ShebangComment ||
                        state === State.SingleLineComment ||
                        // Cases below are for error recovery
                        state === State.SingleQuoteString ||
                        state === State.DoubleQuoteString ||
                        state === State.Regex ||
                        state === State.CharClass) {
                        state = State.Default;
                    }
                    break;
                }
                // Fall through
            case code_NewLine:
                wrapLine = true;
                if (state === State.ShebangComment ||
                    state === State.SingleLineComment) {
                    state = State.Default;
                }
                else if (state === State.SingleQuoteString || // Error recovery
                    state === State.DoubleQuoteString) { // Error recovery
                    state = State.Default;
                }
                break;

            case code_Slash:
                if (state === State.Default) {
                    if (nextCh === code_Slash) {
                        state = State.StartSingleLineComment;
                    }
                    else if (nextCh === code_Star) {
                        // It seems like there might technically be a corner case where this is the beginning of an invalid regex
                        state = State.StartMultiLineComment;
                    }
                    else {
                        // TODO (https://github.com/microsoft/typescript-analyze-trace/issues/14): this is too aggressive - it will catch division
                        state = State.Regex;
                    }
                }
                else if (state === State.StartSingleLineComment) {
                    state = State.SingleLineComment;
                }
                else if (state === State.EndMultiLineComment) {
                    nextStateId = State.Default;
                }
                else if (state === State.Regex) {
                    nextStateId = State.Default;
                }
                else if (state === State.RegexEscapeSlash) {
                    nextStateId = State.Regex;
                }
                break;

            case code_Star:
                if (state === State.StartMultiLineComment) {
                    state = State.MultiLineComment;
                }
                else if (state === State.MultiLineComment) {
                    if (nextCh === code_Slash) {
                        state = State.EndMultiLineComment;
                    }
                }
                break;

            case code_Hash:
                if (isBOF && state === State.Default && nextCh === code_Bang) {
                    state = State.StartShebangComment;
                }
                break;

            case code_Bang:
                if (state === State.StartShebangComment) {
                    state = State.ShebangComment;
                }
                break;

            case code_SingleQuote:
                if (state === State.Default) {
                    state = State.SingleQuoteString;
                }
                else if (state === State.SingleQuoteStringEscapeQuote) {
                    nextStateId = State.SingleQuoteString;
                }
                else if (state === State.SingleQuoteString) {
                    nextStateId = State.Default;
                }
                break;

            case code_DoubleQuote:
                if (state === State.Default) {
                    state = State.DoubleQuoteString;
                }
                else if (state === State.DoubleQuoteStringEscapeQuote) {
                    nextStateId = State.DoubleQuoteString;
                }
                else if (state === State.DoubleQuoteString) {
                    nextStateId = State.Default;
                }
                break;

            case code_Backtick:
                if (state === State.Default) {
                    state = State.TemplateString;
                }
                else if (state === State.TemplateStringEscapeQuote) {
                    nextStateId = State.TemplateString;
                }
                else if (state === State.TemplateString) {
                    nextStateId = State.Default;
                }
                break;

            case code_Backslash:
                if (state === State.SingleQuoteString) {
                    if (nextCh === code_SingleQuote) {
                        state = State.SingleQuoteStringEscapeQuote;
                    }
                    else if (nextCh === code_Backslash) {
                        state = State.SingleQuoteStringEscapeBackslash;
                    }
                }
                else if (state === State.DoubleQuoteString) {
                    if (nextCh === code_DoubleQuote) {
                        state = State.DoubleQuoteStringEscapeQuote;
                    }
                    else if (nextCh === code_Backslash) {
                        state = State.DoubleQuoteStringEscapeBackslash;
                    }
                }
                else if (state === State.TemplateString) {
                    if (nextCh === code_Backtick) {
                        state = State.TemplateStringEscapeQuote;
                    }
                    else if (nextCh === code_Backslash) {
                        state = State.TemplateStringEscapeBackslash;
                    }
                }
                else if (state === State.Regex) {
                    if (nextCh === code_OpenBracket) {
                        state = State.RegexEscapeOpenBracket;
                    }
                    else if (nextCh === code_Slash) {
                        state = State.RegexEscapeSlash;
                    }
                    else if (nextCh === code_Backslash) {
                        state = State.RegexEscapeBackslash;
                    }
                }
                else if (state === State.CharClass) {
                    if (nextCh === code_CloseBracket) {
                        state = State.CharClassEscapeCloseBracket;
                    }
                    else if (nextCh === code_Backslash) {
                        state = State.CharClassEscapeBackslash;
                    }
                }
                else if (state === State.SingleQuoteStringEscapeBackslash) {
                    nextStateId = State.SingleQuoteString;
                }
                else if (state === State.DoubleQuoteStringEscapeBackslash) {
                    nextStateId = State.DoubleQuoteString;
                }
                else if (state === State.TemplateStringEscapeBackslash) {
                    nextStateId = State.TemplateString;
                }
                else if (state === State.RegexEscapeBackslash) {
                    nextStateId = State.Regex;
                }
                else if (state === State.CharClassEscapeBackslash) {
                    nextStateId = State.CharClass;
                }
                break;

            case code_Dollar:
                if (state === State.TemplateString && nextCh === code_OpenBrace) {
                    state = State.StartExpressionHole;
                }
                break;

            case code_OpenBrace:
                if (state === State.Default) {
                    braceDepth++;
                }
                else if (state === State.StartExpressionHole) {
                    templateStringBraceDepthStack.push(braceDepth);
                    nextStateId = State.Default;
                }
                break;

            case code_CloseBrace:
                if (templateStringBraceDepthStack.length && braceDepth === templateStringBraceDepthStack[templateStringBraceDepthStack.length - 1]) {
                    templateStringBraceDepthStack.pop();
                    state = State.TemplateString;
                }
                else if (state === State.Default && braceDepth > 0) { // Error recovery
                    braceDepth--;
                }
                break;

            case code_OpenBracket:
                if (state === State.RegexEscapeOpenBracket) {
                    nextStateId = State.Regex;
                }
                else if (state === State.Regex) {
                    state = State.CharClass;
                }
                break;

            case code_CloseBracket:
                if (state === State.CharClassEscapeCloseBracket) {
                    nextStateId = State.CharClass;
                }
                else if (state === State.CharClass) {
                    nextStateId = State.Regex;
                }
                break;
        }

        let charKind: CharKind;

        switch (state) {
            case State.StartSingleLineComment:
            case State.SingleLineComment:
            case State.StartMultiLineComment:
            case State.MultiLineComment:
            case State.EndMultiLineComment:
            case State.StartShebangComment:
            case State.ShebangComment:
                charKind = ""comment"";
                break;
            case State.SingleQuoteString:
            case State.SingleQuoteStringEscapeBackslash:
            case State.SingleQuoteStringEscapeQuote:
            case State.DoubleQuoteString:
            case State.DoubleQuoteStringEscapeBackslash:
            case State.DoubleQuoteStringEscapeQuote:
            case State.TemplateString:
            case State.TemplateStringEscapeBackslash:
            case State.TemplateStringEscapeQuote:
            case State.StartExpressionHole:
                charKind = ""string"";
                break;
            case State.Regex:
            case State.RegexEscapeBackslash:
            case State.RegexEscapeSlash:
            case State.RegexEscapeOpenBracket:
            case State.CharClass:
            case State.CharClassEscapeBackslash:
            case State.CharClassEscapeCloseBracket:
                charKind = ""regex"";
                break;
            default:
                const isWhitespace =
                    ch === code_Space ||
                    ch === code_Tab ||
                    ch === code_NewLine ||
                    ch === code_CarriageReturn ||
                    /^\s$/.test(String.fromCharCode(ch));
                charKind = isWhitespace ? ""whitespace"" : ""code"";
                break;
        }

        if (nextStateId !== State.Uninitialized) {
            state = nextStateId;
        }

        isBOF = false;

        return { charKind, wrapLine };
    }

    return { step };
}<fim_middle>",correct,5058
StateMachine,StateMachine,4090fc569ef5576bf3bdce304e81cf32fca2f089,"<fim_prefix>export type StateMachineDefinition = {
    states: {
        [key: string]: {
            onEnter?: (subject) => void;
            onEntered?: (subject) => void;
            onExit?: (subject) => void;
            transitions: {
                [key: string]: {
                    to: keyof StateMachineDefinition['states'];
                    action?: (subject) => void;
                };
            };
        };
    };
};

export type StateMachine = {
    subject: any;
    transition: (transitionName) => void;
    canTransit: (transitionName) => boolean;
};
export function createStateMachine(
    subject,
    stateProperty,
    definition,
): <fim_suffix> {
    const { states } = definition;

    const actionInfos = (transitionName) => {
        const currentState = subject[stateProperty];
        const currentStateDefinition = states[currentState as keyof typeof states];
        const destinationTransition =
            currentStateDefinition.transitions[transitionName as keyof typeof currentStateDefinition.transitions];
        if (!destinationTransition) {
            throw new TransitionError(
                `Cannot find the transition '${transitionName}' on subject with state '${currentState}'.`,
            );
        }
        const destinationState = destinationTransition.to;
        const destinationStateDefinition = states[destinationState as keyof typeof states];
        if (!destinationStateDefinition) {
            throw new TransitionError(
                `Cannot transition to '${destinationState}' from '${currentState}'. It does not exist.`,
            );
        }

        return {
            currentStateDefinition,
            destinationTransition,
            destinationStateDefinition,
            destinationState,
        };
    };

    return {
        subject,
        transition(transitionName) {
            const { currentStateDefinition, destinationTransition, destinationStateDefinition, destinationState } =
                actionInfos(transitionName);

            if (destinationTransition.action) {
                destinationTransition.action(subject);
            }
            if (currentStateDefinition.onExit) {
                currentStateDefinition.onExit(subject);
            }
            if (destinationStateDefinition.onEnter) {
                destinationStateDefinition.onEnter(subject);
            }
            subject[stateProperty] = destinationState;
            if (destinationStateDefinition.onEntered) {
                destinationStateDefinition.onEntered(subject);
            }
        },
        canTransit(transitionName) {
            try {
                actionInfos(transitionName);
                return true;
            } catch (exception) {
                return false;
            }
        },
    };
}

export class TransitionError extends Error {
    code: number;
    constructor(message) {
        super(message);
        this.name = 'TransitionError';
        this.code = 400;
    }
}
<fim_middle>",correct,5083
StringField,StringField,5f2d2febe1a2a566772fc84aa89c133d84d3093b,"<fim_prefix>/**
 * Number
 */
type NumberField = {
  type: 'number';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const number = (options) => {
  return {
    type: 'number',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * BigInt
 */
type BigIntField = {
  type: 'bigint';
  canBeNull: boolean;
  default: number | null;
  primaryKey: boolean;
};

export const bigInt = (options) => {
  return {
    type: 'bigint',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * String
 */
type StringField = {
  type: 'string';
  maxLength: number;
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const string = (options): <fim_suffix> => {
  return {
    type: 'string',
    maxLength: options.maxLength,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Boolean
 */
type BooleanField = {
  type: 'boolean';
  canBeNull: boolean;
  default: boolean | null;
  primaryKey: boolean;
};

export const boolean = (options) => {
  return {
    type: 'boolean',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Enumerated
 */
type EnumeratedField = {
  type: 'enumerated';
  values: string[];
  canBeNull: boolean;
  default: string | null;
  primaryKey: boolean;
};

export const enumerated = (options) => {
  return {
    type: 'enumerated',
    values: options.values,
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * DateTime
 */
type DateTimeField = {
  type: 'datetime';
  canBeNull: boolean;
  default: Date | null;
  primaryKey: boolean;
};

export const dateTime = (options) => {
  return {
    type: 'datetime',
    canBeNull: options.canBeNull || false,
    default: options.default || null,
    primaryKey: options.primaryKey || false,
  };
};

/**
 * Any Field
 */
export type AnyField =
  | NumberField
  | BigIntField
  | StringField
  | BooleanField
  | EnumeratedField
  | DateTimeField;

export type Fields = {
  [key: string]: AnyField;
};
<fim_middle>",correct,4937
Student,Student,861ae1a426b6f731e00a301bff6f6c52ce26d4d9,"<fim_prefix>/* Defines the license entity */
export interface Student {
    adminNotes: string;
    appNum: string;
    appTitle: string;
    appURL: string;     
    applicationFee: number | null;
    authority: string;   
 //   authorityId: number;
    authURL: string;
    authEmail: string;
    authExt: string | null;
    authPhone: string;
    busCoordNotes: string;
    certification: string | null;   
    continuingedu: string | null;  
    coordURL: string;
    coordEmail: string;
    coordExt: string;
    coordPhone: string;
    criminal: string | null;
    duration: string;
    education: string | null;  
    exam: string | null;
    exemptions: string;
    experience: string | null;   
    id: number;
    inactive: string| null;
    keywords: string | null;
    licAuth: string;   
    licAuthId: string;   
    licDesc: string;   
    licNum: number;
    licNumType: string;   
    licTitle: string;   
    licenseId: string;   
    licenseType: string;   
    licenseUpdated: string; 
    licenseURL: string;
    markForAuthXfer: boolean;
    markForDelete: boolean;
    markForDeleteBLNC: boolean;  
    markForDeleteLEAD: boolean;
    miscFee: number;
    newLicFee: number;
    otherReq: string; 
    physical: string;  
    reasonForDelete: string;   
    reciprocity: string;   
    recipStates;
    renewalFee: number;
    ricipFee: number;
    socCode: string;   
    socDesc: string;   
    socTitle: string;
    updatedBy: string;   
    veteran: string;

    tagList: any;
    coordId: string;
    department: string;
    division: string;
    board: string;
    address1: string;
    address2: string;
    city: string;
    st: string;
    zip: string;
    multipleLocation: boolean;
    authphone: string;
    fax: string;
    contact: string;
    url: string;
    officeHours: string;
    coordName: string;
    hasOccProfile: boolean; 
  }
  
  export interface StudentResolved {
    student: any;
    error?: any;
  }

  export function newStudent() : <fim_suffix> {
    const l:Student = {
      adminNotes: '',     
      appNum: '',
      appTitle: '',
      appURL: '',    
      applicationFee: null,
      authority: '',  
      authEmail: '',
      authExt: '',
      authPhone: '',
      authURL: '',
      busCoordNotes: '',   
      certification: null,
      continuingedu: null,
      coordEmail: '',
      coordExt: '',
      coordPhone: '',
      coordURL: '',
      criminal: null, 
      duration: '',
      education: null, 
      exam: null,
      exemptions: '',   
      experience: null,
      id: 0,
      inactive: null,
      keywords: '',
      licAuth: '',   
      licAuthId: null,   
      licDesc: '',   
      licNum: null,
      licNumType: '',   
      licTitle: '',   
      licenseId: null, 
      licenseType: null, 
      licenseUpdated: '',
      licenseURL: '',
      markForAuthXfer: false,
      markForDelete: false,
      markForDeleteBLNC: false, 
      markForDeleteLEAD: false,
      miscFee: null,
      newLicFee: null,
      otherReq: '',
      physical: null,   
      reasonForDelete: '',  
      reciprocity: '',   
      recipStates: [],
      renewalFee: null,
      ricipFee: null,
      socCode: null,  
      socDesc: null,   
      socTitle: '',
      updatedBy: null,
      veteran: null,
      tagList: null,
      coordId: '',
      department: '',
      division: '',
      board: '',
      address1: '',
      address2: '',
      city: '',
      st: '',
      zip: '',
      multipleLocation: false,
      authphone: '',
      fax: '',
      contact: '',
      url: '',
      officeHours: '',
      coordName: '',
      hasOccProfile: false,        
    };
    return l;
  }

  export const enumFields=[
    {name: 'edu', col: 'education', label: 'Education:', sel: '--Please select'},
    {name: 'cert', col: 'certification', label: 'Certification:', sel: '--Please select'},
    {name: 'cedu', col: 'continuingedu', label: 'Continuing education:', sel: '--Please select'},
    {name: 'exp', col: 'experience', label: 'Experience:', sel: '--Please select'},
    {name: 'exam', col: 'exam', label: 'Exam:', sel: '--Please select'},
    {name: 'crim', col: 'criminal', label: 'Criminal:', sel: '--Please select'},
    {name: 'phy', col: 'physical', label: 'Physical requirements:', sel: '--Please select'},
    {name: 'vet', col: 'veteran', label: 'Veteran:', sel: '--Please select'},
    {name: 'active', col: 'inactive', label: 'Active status:', sel: '--Please select'},
    {name: 'types', col: 'licenseType', label: 'License Type:', sel: '--Please select'},
   ];  <fim_middle>",correct,3574
Suit,Suit,b1ab8c4be427c0afaf3d2a41ca821482dd787a9e,"<fim_prefix>type DotNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per dot (36)
type BamNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per bam (36)
type CrakNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per crak (36)
type WindNumber = ""East"" | ""West"" | ""South"" | ""North""; // 4 tiles per wind (16)
type DragonNumber = ""White"" | ""Green"" | ""Red""; // 4 tiles per wind (12)
type FlowerNumber = ""Rose"" | ""Lily"" | ""Tulip"" | ""Juniper""; // 2 tiles per flower (8)

export type Number = DotNumber | BamNumber | CrakNumber | WindNumber | DragonNumber | FlowerNumber;

export enum Suit {
  Dot = ""DOT"",
  Bam = ""BAM"",
  Crak = ""CRAK"",
  Wind = ""WIND"",
  Dragon = ""DRAGON"",
  Flower = ""FLOWER"",
}

export default class Tile {
  x: number;
  y: number;
  z: number;
  number: Number;
  suit: Suit;
  static dotNumbers: DotNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static bamNumbers: BamNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static crakNumbers: CrakNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static windNumbers: WindNumber[] = [""East"", ""West"", ""South"", ""North""];
  static dragonNumbers: DragonNumber[] = [""White"", ""Green"", ""Red""];
  static flowerNumbers: FlowerNumber[] = [""Rose"", ""Lily"", ""Tulip"", ""Juniper""];

  constructor(number, suit: <fim_suffix>) {
    this.number = number;
    this.suit = suit;
    this.x = -10
    this.y = -10
    this.z = -10
  }

  place({ z, x, y }) {
    this.z = z
    this.x = x
    this.y = y
  }

  get tileCells() {
    return [
      {
        z: this.z,
        x: this.x,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x,
        y: this.y + 1,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y + 1,
      },
    ];
  }

  get id() {
    return `${this.suit}_${this.number}_${this.x}_${this.y}_${this.z}`;
  }

  tileIsAdjacent(tile) {
    const t1Cells = this.tileCells;
    const t2Cells = tile.tileCells;

    let isAdjacent = false;

    t1Cells.forEach((t1) => {
      t2Cells.forEach((t2) => {
        // tile is above or below
        if ((t1.z === t2.z - 1 || t1.z === t2.z + 1) && t1.x === t2.x && t1.y === t2.y) {
          isAdjacent = true;
        }

        // tile is to the left or the right
        if (t1.z === t2.z && t1.y === t2.y && (t1.x === t2.x - 1 || t1.x === t2.x + 1)) {
          isAdjacent = true;
        }
      });
    });

    return isAdjacent;
  }
}
<fim_middle>",correct,1119
T,T,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB: <fim_suffix>
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,222
T,T,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB: <fim_suffix>
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,225
T,T,23796ef71f89aeadfa7a847ca66d62e557cfdbbb,"<fim_prefix>type RawQuery = string | string[] | undefined

function normalizeToString<T extends string = string>(
  query,
) {
  const param = Array.isArray(query) ? query[0] : query
  return param !== undefined ? (param as T) : undefined
}

function normalizeToArray<T extends string = string>(query) {
  if (Array.isArray(query)) {
    return query as T[]
  }
  if (query !== undefined) {
    return [query as T]
  }
  return []
}

/**
 * query의 value가 undefined이거나 false일 때 false.
 * 그 외의 value를 가지고 있으면 모두 true
 * @param query
 */
function normalizeToBoolean(query) {
  return !(
    query === undefined || (Array.isArray(query) ? query[0] : query) === 'false'
  )
}

// eslint-disable-next-line @typescript-eslint/ban-types
class StrictQuery<Resolved = {}> {
  private raw: { [key: string]: RawQuery }

  private resolved: Resolved

  public constructor(raw, resolved?) {
    this.raw = raw
    this.resolved = resolved || ({} as Resolved)
  }

  public use() {
    return this.resolved
  }

  public string<Key extends string, Value extends string = string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToString<Value>(value),
    } as { [key in Key]: Value | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public number<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const stringified = normalizeToString(value)
    const normalized = {
      [key]: stringified ? parseFloat(stringified) : undefined,
    } as { [key in Key]: number | undefined }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public stringArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value),
    } as { [key in Key]: string[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public numberArray<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToArray(value).map(parseFloat),
    } as { [key in Key]: number[] }
    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }

  public boolean<Key extends string>(
    key,
  ) {
    const { [key]: value, ...restRaw } = this.raw
    const normalized = {
      [key]: normalizeToBoolean(value),
    } as { [key in Key]: boolean }

    return new StrictQuery(restRaw, {
      ...this.resolved,
      ...normalized,
    })
  }
}

export function strictQuery<T extends { [key: string]: RawQuery }>(query: <fim_suffix>) {
  return new StrictQuery(query)
}
<fim_middle>",correct,529
T,T,a502da435a6278844d221141f6cce947032e53cc,"<fim_prefix>export interface LanguageInterface {
  name: string;
  code: string;
  nativeName: string;
  layout: ""ltr"" | ""rtl"";
}

export interface LanguagesInterface {
  [key: string]: LanguageInterface;
}

export interface TranslatorOptions {
  cache?: boolean;
  defaultLanguage: string;
  currentLangauge: string;
  engine: TranslateEngine;
}

export type TranslationResponseShape = Record<string, string>;

export type TranslateEngine = (
  language,
  targets
) => Promise<TranslationResponseShape> | TranslationResponseShape;

export type CacheSetter = (key, value) => Promise<void> | void;
export type CacheGetter = (
  key
) => Promise<string | null> | string | null;

export class Translator {
  protected TranslationTargets: string[] = [];
  protected TranslationResults: Record<string, string> = {};
  protected CacheEngines?: {
    setter: CacheSetter;
    getter: CacheGetter;
  };

  // Global Metadata
  public metadata: Record<string, any> = {};

  constructor(protected Options) {
    // Validate Options
    this.setOptions(this.Options);
  }

  public setTranslations(
    translations
  ) {
    if (typeof translations === ""object"")
      this.TranslationTargets = translations;
    else if (typeof translations === ""function"") {
      this.TranslationTargets = translations(this.TranslationTargets);
    }

    return this;
  }

  public getTranslated() {
    return this.TranslationResults;
  }

  public setCacheEngines(setter, getter) {
    if (typeof setter !== ""function"")
      throw new Error(`Please provide a valid Cache Setter Function!`);
    else if (typeof getter !== ""function"")
      throw new Error(`Please provide a valid Cache Getter Function!`);

    this.CacheEngines = { setter, getter };
    return this;
  }

  public setOptions(options) {
    // Validate Options
    if (options.engine && typeof options.engine !== ""function"")
      throw new Error(`Please provide a valid Translation Engine Function!`);

    // Set Options
    this.Options = {
      ...this.Options,
      ...options,
    };

    return this;
  }

  public async setCache(key, value) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.setter === ""function""
    )
      this.CacheEngines.setter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key,
        value
      );
  }

  public async getCache(key) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.getter === ""function""
    )
      return this.CacheEngines.getter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key
      );
    else return null;
  }

  public async translate<T extends string | string[]>(
    targets?: <fim_suffix>
  ) {
    // Resolve Targets
    if (targets === undefined) targets = this.TranslationTargets as T;

    // Collect Translations from Cache
    let Translated: Record<string, string> = {
      ...(
        await Promise.all(
          (targets instanceof Array ? targets : [targets]).map(
            async (target) => {
              const value = await this.getCache(target);
              if (value || target === """")
                return {
                  key: target,
                  value: target === """" ? target : value,
                };
              else return undefined;
            }
          )
        )
      )
        .filter((v) => v !== undefined)
        .reduce(
          (object, item) => ({
            ...object,
            [item!.key]: item!.value,
          }),
          {}
        ),
    };

    // Get Translated Targets
    const TranslatedTargets = Object.keys(Translated);

    // Filter Remaining Targets
    const RemainingTranslations = (targets instanceof Array
      ? targets
      : [targets]
    ).filter((target) => !TranslatedTargets.includes(target));

    // Check Remaining Length
    if (RemainingTranslations.length) {
      try {
        // Fetch New Translations
        const Results =
          this.Options.defaultLanguage !== this.Options.currentLangauge
            ? await this.Options.engine(
                {
                  default: this.Options.defaultLanguage,
                  current: this.Options.currentLangauge,
                },
                RemainingTranslations
              )
            : RemainingTranslations.reduce<TranslationResponseShape>(
                (object, target) => ({ ...object, [target]: target }),
                {}
              );

        if (typeof Results === ""object"") {
          // Store Translation to Cache
          if (this.Options.defaultLanguage !== this.Options.currentLangauge)
            await Promise.all(
              Object.keys(Results).map((target) =>
                this.setCache(target, Results[target])
              )
            );

          // Combine Results
          Translated = {
            ...Translated,
            ...Results,
          };
        }
      } catch (e) {
        // Combine Results
        Translated = {
          ...Translated,
          ...RemainingTranslations.reduce<TranslationResponseShape>(
            (object, target) => ({ ...object, [target]: target }),
            {}
          ),
        };
      }
    }

    // Store Results
    this.TranslationResults = ((targets instanceof Array
      ? targets
      : [targets]) as string[]).reduce(
      (object, target) => ({
        ...object,
        [target]: Translated[target],
      }),
      {}
    );

    // Return Results
    return (typeof targets === ""string""
      ? Object.values(this.TranslationResults)[0]
      : this.TranslationResults) as any;
  }
}
<fim_middle>",correct,564
T,T,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone): <fim_suffix> {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date) {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",correct,697
T,T,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass: <fim_suffix>, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,999
T,T,b6bfc45eb561308bc0f3960f3a75e7c4a2d28a90,"<fim_prefix>/**
 * Options for Chan.
 */
export type ChanOpts = {
  /**
   * Yield reject to iterator if the value is rejected in receiver(generator).
   */
  rejectInReceiver?: boolean
}

/**
 * Class reperesenting a channel.
 * @template T - Type of the value that will be send via Channel.
 */
export class Chan<T> {
  protected opts: ChanOpts = { rejectInReceiver: false }
  protected bufSize = 0
  protected buf!: T[]
  protected sendFunc!: (p) => Promise<void>

  protected bufPromise!: Promise<void>
  protected bufResolve!: (value) => void

  protected valuePromise!: Promise<void>
  protected valueResolve!: (value) => void

  protected generatorClosed: boolean = false
  protected closed: boolean = false

  /**
   * Make a channel.
   * @param bufSize - size of buffer in channel.
   * @param opts - options.
   */
  constructor(bufSize = 0, opts = {}) {
    if (opts.rejectInReceiver !== undefined) {
      this.opts.rejectInReceiver = opts.rejectInReceiver
    }
    this.bufSize = bufSize === 0 ? 1 : bufSize // バッファーサイズ 0 のときも内部的にはバッファーは必要.
    this.sendFunc = bufSize === 0 ? this._sendWithoutBuf : this._sendWithBuf
    this.buf = []
    this.bufReset()
    this.valueReset()
  }
  protected bufReset() {
    this.bufPromise = new Promise((resolve) => {
      this.bufResolve = resolve
    })
  }
  protected bufRelease() {
    this.bufResolve()
  }
  protected valueReset() {
    this.valuePromise = new Promise((resolve, reject) => {
      this.valueResolve = resolve
    })
  }
  protected valueRelease() {
    this.valueResolve()
  }
  protected async _sendWithoutBuf(p) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        await this.valuePromise
        return
      }
      await this.valuePromise
    }
  }
  protected async _sendWithBuf(p) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        return
      }
      await this.valuePromise
    }
  }
  /**
   * Send the value to receiver via channel.
   * This method required to call with `await`.
   * It will be blocking durring buffer is filled.
   * ```
   * await ch.send(value)
   * ```
   * @param value - the value
   * @returns
   */
  readonly send = async (value: <fim_suffix>) => {
    if (this.closed) {
      throw new Error('panic: send on closed channel')
    }
    // TOOD: generatorClosed でループを抜けたかのステータスを返すか検討.
    // rejectInReceiver が有効だとバッファーに乗っているものでもドロップするので、
    // (yeield で reject を for await...of などに渡すと finally が実行されるので)
    // ここのステータスだけわかってもあまり意味はないか.
    return this.sendFunc(value)
  }
  private async gate() {
    // バッファーが埋まっていない場合は、send されるまで待つ.
    // close されていれば素通し.
    while (this.buf.length === 0 && !this.closed) {
      await this.bufPromise
      this.bufReset()
    }
    // バッファーを消費していたら終了.
    // 通常は消費しない、close されていれば何度か呼びだされるうちに消費される.
    if (this.buf.length > 0) {
      return { done: false }
    }
    return { done: true }
  }
  /**
   * Get async generator to receive the value was sended.
   * @returns - Async Generator.
   */
  async *receiver() {
    try {
      while (true) {
        try {
          const i = await this.gate()
          if (i.done) {
            return
          }
          const v = await this.buf[0]
          // バッファーを空ける(yeild の後でやると次回の next() まで実行されないので注意).
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          yield v
        } catch (e) {
          // rejct された場合もバッファーを空ける.
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          if (this.opts.rejectInReceiver) {
            // value が Promise だった場合、receiver 側の for await...of などに reject を伝播させる.
            yield Promise.reject(e)
          }
        }
      }
    } finally {
      this.generatorClosed = true
      this.clean()
    }
  }
  protected clean() {
    this.bufRelease()
    this.valueRelease()
  }
  /**
   * Close channel.
   */
  close() {
    this.closed = true
    this.clean()
  }
}

/**
 * Type of send method Chan class.
 */
export type ChanSend<T> = Chan<T>['send']
/**
 * Type of async generator that is returned from receiver method of Chan class.
 */
export type ChanRecv<T> = ReturnType<Chan<T>['receiver']>
<fim_middle>",correct,1013
T,T,b6bfc45eb561308bc0f3960f3a75e7c4a2d28a90,"<fim_prefix>/**
 * Options for Chan.
 */
export type ChanOpts = {
  /**
   * Yield reject to iterator if the value is rejected in receiver(generator).
   */
  rejectInReceiver?: boolean
}

/**
 * Class reperesenting a channel.
 * @template T - Type of the value that will be send via Channel.
 */
export class Chan<T> {
  protected opts: ChanOpts = { rejectInReceiver: false }
  protected bufSize = 0
  protected buf!: T[]
  protected sendFunc!: (p) => Promise<void>

  protected bufPromise!: Promise<void>
  protected bufResolve!: (value) => void

  protected valuePromise!: Promise<void>
  protected valueResolve!: (value) => void

  protected generatorClosed: boolean = false
  protected closed: boolean = false

  /**
   * Make a channel.
   * @param bufSize - size of buffer in channel.
   * @param opts - options.
   */
  constructor(bufSize = 0, opts = {}) {
    if (opts.rejectInReceiver !== undefined) {
      this.opts.rejectInReceiver = opts.rejectInReceiver
    }
    this.bufSize = bufSize === 0 ? 1 : bufSize // バッファーサイズ 0 のときも内部的にはバッファーは必要.
    this.sendFunc = bufSize === 0 ? this._sendWithoutBuf : this._sendWithBuf
    this.buf = []
    this.bufReset()
    this.valueReset()
  }
  protected bufReset() {
    this.bufPromise = new Promise((resolve) => {
      this.bufResolve = resolve
    })
  }
  protected bufRelease() {
    this.bufResolve()
  }
  protected valueReset() {
    this.valuePromise = new Promise((resolve, reject) => {
      this.valueResolve = resolve
    })
  }
  protected valueRelease() {
    this.valueResolve()
  }
  protected async _sendWithoutBuf(p) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        await this.valuePromise
        return
      }
      await this.valuePromise
    }
  }
  protected async _sendWithBuf(p: <fim_suffix>) {
    while (!this.generatorClosed) {
      if (this.buf.length < this.bufSize) {
        this.buf.push(p)
        this.bufRelease()
        return
      }
      await this.valuePromise
    }
  }
  /**
   * Send the value to receiver via channel.
   * This method required to call with `await`.
   * It will be blocking durring buffer is filled.
   * ```
   * await ch.send(value)
   * ```
   * @param value - the value
   * @returns
   */
  readonly send = async (value) => {
    if (this.closed) {
      throw new Error('panic: send on closed channel')
    }
    // TOOD: generatorClosed でループを抜けたかのステータスを返すか検討.
    // rejectInReceiver が有効だとバッファーに乗っているものでもドロップするので、
    // (yeield で reject を for await...of などに渡すと finally が実行されるので)
    // ここのステータスだけわかってもあまり意味はないか.
    return this.sendFunc(value)
  }
  private async gate() {
    // バッファーが埋まっていない場合は、send されるまで待つ.
    // close されていれば素通し.
    while (this.buf.length === 0 && !this.closed) {
      await this.bufPromise
      this.bufReset()
    }
    // バッファーを消費していたら終了.
    // 通常は消費しない、close されていれば何度か呼びだされるうちに消費される.
    if (this.buf.length > 0) {
      return { done: false }
    }
    return { done: true }
  }
  /**
   * Get async generator to receive the value was sended.
   * @returns - Async Generator.
   */
  async *receiver() {
    try {
      while (true) {
        try {
          const i = await this.gate()
          if (i.done) {
            return
          }
          const v = await this.buf[0]
          // バッファーを空ける(yeild の後でやると次回の next() まで実行されないので注意).
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          yield v
        } catch (e) {
          // rejct された場合もバッファーを空ける.
          this.buf.shift()
          // send 側へ空きができたことを通知.
          this.valueRelease()
          this.valueReset()
          if (this.opts.rejectInReceiver) {
            // value が Promise だった場合、receiver 側の for await...of などに reject を伝播させる.
            yield Promise.reject(e)
          }
        }
      }
    } finally {
      this.generatorClosed = true
      this.clean()
    }
  }
  protected clean() {
    this.bufRelease()
    this.valueRelease()
  }
  /**
   * Close channel.
   */
  close() {
    this.closed = true
    this.clean()
  }
}

/**
 * Type of send method Chan class.
 */
export type ChanSend<T> = Chan<T>['send']
/**
 * Type of async generator that is returned from receiver method of Chan class.
 */
export type ChanRecv<T> = ReturnType<Chan<T>['receiver']>
<fim_middle>",correct,1015
T,T,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ): <fim_suffix> {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1075
T,T,d7288789b6e870c947d9b5d2c8fe51bb8de33ca3,"<fim_prefix>export type HttpResponse = {
  statusCode: number;
  body: any;
};

export function ok<T>(dto?: <fim_suffix>) {
  return {
    statusCode: 200,
    body: dto,
  };
}

export function created(body?) {
  return {
    statusCode: 201,
    body: body !== undefined ? body : undefined,
  };
}

export function noContent(body?) {
  return {
    statusCode: 204,
    body: body !== undefined ? body : undefined,
  };
}

export function clientError(error) {
  return {
    statusCode: 400,
    body: {
      error: error.message,
    },
  };
}

export function unauthorized(error) {
  return {
    statusCode: 401,
    body: {
      error: error.message,
    },
  };
}

export function forbidden(error) {
  return {
    statusCode: 403,
    body: {
      error: error.message,
    },
  };
}

export function notFound(error) {
  return {
    statusCode: 404,
    body: {
      error: error.message,
    },
  };
}

export function notAcceptable(error) {
  return {
    statusCode: 406,
    body: {
      error: error.message,
    },
  };
}

export function conflict(error) {
  return {
    statusCode: 409,
    body: {
      error: error.message,
    },
  };
}

export function tooMany(error) {
  return {
    statusCode: 429,
    body: {
      error: error.message,
    },
  };
}

export function fail(error) {
  return {
    statusCode: 500,
    body: {
      error: error.message,
    },
  };
}
<fim_middle>",correct,1164
T,T,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings: <fim_suffix> = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",correct,1724
T,T,5bf8f0f2946da835300025c6804a609bef4277ab,"<fim_prefix>// @strict: true
// @declaration: true

type T01 = {} & string;  // string
type T02 = {} & 'a';  // 'a'
type T03 = {} & object;  // object
type T04 = {} & { x: number };  // { x: number }
type T05 = {} & null;  // never
type T06 = {} & undefined;  // never
type T07 = undefined & void;  // undefined

type T10 = string & {};  // Specially preserved
type T11 = number & {};  // Specially preserved
type T12 = bigint & {};  // Specially preserved

type ThisNode = {};
type ThatNode = {};
type ThisOrThatNode = ThisNode | ThatNode;

function f01(u) {
    let x1: {} = u;  // Error
    let x2: {} | null | undefined = u;
    let x3: {} | { x: string } | null | undefined = u;
    let x4: ThisOrThatNode | null | undefined = u;
}

function f10(x) {
    if (x) {
        x;  // {}
    }
    else {
        x;  // unknown
    }
    if (!x) {
        x;  // unknown
    }
    else {
        x;  // {}
    }
}

function f11<T>(x: <fim_suffix>) {
    if (x) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (!x) {
        x;  // T
    }
    else {
        x;  // T & {}
    }
}

function f12<T extends {}>(x) {
    if (x) {
        x;  // T
    }
    else {
        x;  // T
    }
}

function f20(x) {
    if (x !== undefined) {
        x;  // {} | null
    }
    else {
        x;  // undefined
    }
    if (x !== null) {
        x;  // {} | undefined
    }
    else {
        x;  // null
    }
    if (x !== undefined && x !== null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != undefined) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
}

function f21<T>(x) {
    if (x !== undefined) {
        x;  // T & ({} | null)
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T & ({} | undefined)
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f22<T extends {} | undefined>(x) {
    if (x !== undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f23<T>(x) {
    if (x !== undefined) {
        x;  // T & {} | null
    }
    if (x !== null) {
        x;  // T & {} | undefined
    }
    if (x != undefined) {
        x;  // T & {}
    }
    if (x != null) {
        x;  // T & {}
    }
}

function f30(x) {
    if (typeof x === ""object"") {
        x;  // object
    }
}

function f31<T>(x) {
    if (typeof x === ""object"") {
        x;  // T & object | T & null
    }
    if (x && typeof x === ""object"") {
        x;  // T & object
    }
    if (typeof x === ""object"" && x) {
        x;  // T & object
    }
}

function f32<T extends {} | undefined>(x) {
    if (typeof x === ""object"") {
        x;  // T & object
    }
}

function possiblyNull<T>(x) {
    return !!true ? x : null;  // T | null
}

function possiblyUndefined<T>(x) {
    return !!true ? x : undefined;  // T | undefined
}

function possiblyNullOrUndefined<T>(x) {
    return possiblyUndefined(possiblyNull(x));  // T | null | undefined
}

function ensureNotNull<T>(x) {
    if (x === null) throw Error();
    return x;  // T & ({} | undefined)
}

function ensureNotUndefined<T>(x) {
    if (x === undefined) throw Error();
    return x;  // T & ({} | null)
}

function ensureNotNullOrUndefined<T>(x) {
    return ensureNotUndefined(ensureNotNull(x));  // T & {}
}

function f40(a, b) {
    let a1 = ensureNotNullOrUndefined(a);  // string
    let b1 = ensureNotNullOrUndefined(b);  // number
}

type QQ<T> = NonNullable<NonNullable<NonNullable<T>>>;

function f41<T>(a) {
    let a1 = ensureNotUndefined(ensureNotNull(a));  // T & {}
    let a2 = ensureNotNull(ensureNotUndefined(a));  // T & {}
    let a3 = ensureNotNull(ensureNotNull(a));  // T & {} | T & undefined
    let a4 = ensureNotUndefined(ensureNotUndefined(a));  // T & {} | T & null
    let a5 = ensureNotNullOrUndefined(ensureNotNullOrUndefined(a));  // T & {}
    let a6 = ensureNotNull(possiblyNullOrUndefined(a));  // T & {} | undefined
    let a7 = ensureNotUndefined(possiblyNullOrUndefined(a));  // T & {} | null
    let a8 = ensureNotNull(possiblyUndefined(a));  // T & {} | undefined
    let a9 = ensureNotUndefined(possiblyNull(a));  // T & {} | null
}

// Repro from #48468

function deepEquals<T>(a, b) {
    if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) {
        return false;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        return false;
    }
    if (Object.keys(a).length !== Object.keys(b).length) { // Error here
        return false;
    }
    return true;
}

// Repro from #49386

function foo<T>(x) {
    let y = x;
    if (y !== null) {
        y;
    }
}
<fim_middle>",correct,1978
T,T,1f2f2487f7f88bf87e6700f3a15415f1c549403e,"<fim_prefix>type DataType<T> = {
  persistent: boolean,
  value: T,
};

export default class Dadado<T> {
  capacity: number;
  private cache: Map<T, DataType<T>>;

  /*
   * @param {number} capacity - Defines the maximum of items that can be in the cache
  */
  constructor(capacity) {
    if (!Number.isInteger(capacity)) {
      throw Error('Expected an integer number');
    }

    if (Math.sign(capacity) <= 0) {
      throw Error('Expected a positive number greater or equal to 1');
    }

    this.capacity = capacity;
    this.cache = new Map();
  }

  /*
   * Returns the cache size.
   *
   * @returns {number}
  */
  size() {
    return this.cache.size;
  }

  /*
   * Removes all elements from the cache.
   *
   * @returns {void}
  */
  clear() {
    this.cache.clear();
  }

  /*
   * Checks if the given key exist within the cache.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  contains(key) {
    return this.cache.has(key);
  }

  /*
   * Adds the key-value pair to the cache if the key is not in the cache yet.
   * Otherwise, if the key exists, updates the value of the key.
   * In case the current number of keys exceeds the `capacity`, then it evicts the least recently used key.
   *
   * @param {T} key - The cache key
   * @param {T} value - The value associated with the key
   * @returns {boolean}
  */
  setItem(key, value) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      this.cache.delete(key);
      data.value = value;
      this.cache.set(key, data);
    } else {
      this.cache.set(key, {
        value,
        persistent: false
      });
    }

    if (this.cache.size > this.capacity) {
      const keys = this.cache.keys();
      let wasDeleted = false;

      if (!this.cache.size) {
        return false;
      }

      while (!wasDeleted && this.cache.size) {
        const key = keys.next().value;
        const item = this.cache.get(key as T) as DataType<T>;

        if (!item.persistent) {
          wasDeleted = true;
          this.cache.delete(key as T);
        }
      }
    }

    if (!this.cache.has(key)) {
      return false;
    }

    return true;
  }

  /*
   * Retrieves the value associated with the given key.
   * If the key is not in the cache, it returns `undefined`.
   *
   * @param {T} key - The cache key
   * @returns {T}
  */
  getItem(key) {
    if (!this.cache.has(key)) {
      return;
    }

    const data = this.cache.get(key) as DataType<T>;
    this.cache.delete(key);
    this.cache.set(key, data);

    return data.value;
  }

  /*
   * Deletes item and returns true if the item existed in the storage.
   * Returns false if the element doesn't exist.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  removeItem(key) {
    return this.cache.delete(key);
  }

  /*
   * Makes item persistent, i.e the item can no longer be automatically evicted.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  setPersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = true;
    }
  }

  /*
   * Makes item no longer a persistent item if it was one.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  removePersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = false;
    }
  }

  /*
   * Makes item persistent if it was not yet, or otherwise undo the persistent flag.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  togglePersistent(key: <fim_suffix>) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      data.persistent = !data.persistent;
    }
  }

  /*
   * Returns an Array based in the current cache with each key-value pair sorted by least-recently-used.
   *
   * @returns {T[][]}
  */
  toArray() {
    return Array.from(this.cache.entries()).reduce((acc, [key, item]) => {
      acc.push([key, item.value])
      return acc;
    }, [] as T[][]);
  }
}
<fim_middle>",correct,2280
T,T,1f2f2487f7f88bf87e6700f3a15415f1c549403e,"<fim_prefix>type DataType<T> = {
  persistent: boolean,
  value: T,
};

export default class Dadado<T> {
  capacity: number;
  private cache: Map<T, DataType<T>>;

  /*
   * @param {number} capacity - Defines the maximum of items that can be in the cache
  */
  constructor(capacity) {
    if (!Number.isInteger(capacity)) {
      throw Error('Expected an integer number');
    }

    if (Math.sign(capacity) <= 0) {
      throw Error('Expected a positive number greater or equal to 1');
    }

    this.capacity = capacity;
    this.cache = new Map();
  }

  /*
   * Returns the cache size.
   *
   * @returns {number}
  */
  size() {
    return this.cache.size;
  }

  /*
   * Removes all elements from the cache.
   *
   * @returns {void}
  */
  clear() {
    this.cache.clear();
  }

  /*
   * Checks if the given key exist within the cache.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  contains(key) {
    return this.cache.has(key);
  }

  /*
   * Adds the key-value pair to the cache if the key is not in the cache yet.
   * Otherwise, if the key exists, updates the value of the key.
   * In case the current number of keys exceeds the `capacity`, then it evicts the least recently used key.
   *
   * @param {T} key - The cache key
   * @param {T} value - The value associated with the key
   * @returns {boolean}
  */
  setItem(key, value) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      this.cache.delete(key);
      data.value = value;
      this.cache.set(key, data);
    } else {
      this.cache.set(key, {
        value,
        persistent: false
      });
    }

    if (this.cache.size > this.capacity) {
      const keys = this.cache.keys();
      let wasDeleted = false;

      if (!this.cache.size) {
        return false;
      }

      while (!wasDeleted && this.cache.size) {
        const key = keys.next().value;
        const item = this.cache.get(key as T) as DataType<T>;

        if (!item.persistent) {
          wasDeleted = true;
          this.cache.delete(key as T);
        }
      }
    }

    if (!this.cache.has(key)) {
      return false;
    }

    return true;
  }

  /*
   * Retrieves the value associated with the given key.
   * If the key is not in the cache, it returns `undefined`.
   *
   * @param {T} key - The cache key
   * @returns {T}
  */
  getItem(key) {
    if (!this.cache.has(key)) {
      return;
    }

    const data = this.cache.get(key) as DataType<T>;
    this.cache.delete(key);
    this.cache.set(key, data);

    return data.value;
  }

  /*
   * Deletes item and returns true if the item existed in the storage.
   * Returns false if the element doesn't exist.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  removeItem(key) {
    return this.cache.delete(key);
  }

  /*
   * Makes item persistent, i.e the item can no longer be automatically evicted.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  setPersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = true;
    }
  }

  /*
   * Makes item no longer a persistent item if it was one.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  removePersistent(key: <fim_suffix>) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = false;
    }
  }

  /*
   * Makes item persistent if it was not yet, or otherwise undo the persistent flag.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  togglePersistent(key) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      data.persistent = !data.persistent;
    }
  }

  /*
   * Returns an Array based in the current cache with each key-value pair sorted by least-recently-used.
   *
   * @returns {T[][]}
  */
  toArray() {
    return Array.from(this.cache.entries()).reduce((acc, [key, item]) => {
      acc.push([key, item.value])
      return acc;
    }, [] as T[][]);
  }
}
<fim_middle>",correct,2281
T,T,1f2f2487f7f88bf87e6700f3a15415f1c549403e,"<fim_prefix>type DataType<T> = {
  persistent: boolean,
  value: T,
};

export default class Dadado<T> {
  capacity: number;
  private cache: Map<T, DataType<T>>;

  /*
   * @param {number} capacity - Defines the maximum of items that can be in the cache
  */
  constructor(capacity) {
    if (!Number.isInteger(capacity)) {
      throw Error('Expected an integer number');
    }

    if (Math.sign(capacity) <= 0) {
      throw Error('Expected a positive number greater or equal to 1');
    }

    this.capacity = capacity;
    this.cache = new Map();
  }

  /*
   * Returns the cache size.
   *
   * @returns {number}
  */
  size() {
    return this.cache.size;
  }

  /*
   * Removes all elements from the cache.
   *
   * @returns {void}
  */
  clear() {
    this.cache.clear();
  }

  /*
   * Checks if the given key exist within the cache.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  contains(key) {
    return this.cache.has(key);
  }

  /*
   * Adds the key-value pair to the cache if the key is not in the cache yet.
   * Otherwise, if the key exists, updates the value of the key.
   * In case the current number of keys exceeds the `capacity`, then it evicts the least recently used key.
   *
   * @param {T} key - The cache key
   * @param {T} value - The value associated with the key
   * @returns {boolean}
  */
  setItem(key, value) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      this.cache.delete(key);
      data.value = value;
      this.cache.set(key, data);
    } else {
      this.cache.set(key, {
        value,
        persistent: false
      });
    }

    if (this.cache.size > this.capacity) {
      const keys = this.cache.keys();
      let wasDeleted = false;

      if (!this.cache.size) {
        return false;
      }

      while (!wasDeleted && this.cache.size) {
        const key = keys.next().value;
        const item = this.cache.get(key as T) as DataType<T>;

        if (!item.persistent) {
          wasDeleted = true;
          this.cache.delete(key as T);
        }
      }
    }

    if (!this.cache.has(key)) {
      return false;
    }

    return true;
  }

  /*
   * Retrieves the value associated with the given key.
   * If the key is not in the cache, it returns `undefined`.
   *
   * @param {T} key - The cache key
   * @returns {T}
  */
  getItem(key) {
    if (!this.cache.has(key)) {
      return;
    }

    const data = this.cache.get(key) as DataType<T>;
    this.cache.delete(key);
    this.cache.set(key, data);

    return data.value;
  }

  /*
   * Deletes item and returns true if the item existed in the storage.
   * Returns false if the element doesn't exist.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  removeItem(key: <fim_suffix>) {
    return this.cache.delete(key);
  }

  /*
   * Makes item persistent, i.e the item can no longer be automatically evicted.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  setPersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = true;
    }
  }

  /*
   * Makes item no longer a persistent item if it was one.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  removePersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = false;
    }
  }

  /*
   * Makes item persistent if it was not yet, or otherwise undo the persistent flag.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  togglePersistent(key) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      data.persistent = !data.persistent;
    }
  }

  /*
   * Returns an Array based in the current cache with each key-value pair sorted by least-recently-used.
   *
   * @returns {T[][]}
  */
  toArray() {
    return Array.from(this.cache.entries()).reduce((acc, [key, item]) => {
      acc.push([key, item.value])
      return acc;
    }, [] as T[][]);
  }
}
<fim_middle>",correct,2283
T,T,1f2f2487f7f88bf87e6700f3a15415f1c549403e,"<fim_prefix>type DataType<T> = {
  persistent: boolean,
  value: T,
};

export default class Dadado<T> {
  capacity: number;
  private cache: Map<T, DataType<T>>;

  /*
   * @param {number} capacity - Defines the maximum of items that can be in the cache
  */
  constructor(capacity) {
    if (!Number.isInteger(capacity)) {
      throw Error('Expected an integer number');
    }

    if (Math.sign(capacity) <= 0) {
      throw Error('Expected a positive number greater or equal to 1');
    }

    this.capacity = capacity;
    this.cache = new Map();
  }

  /*
   * Returns the cache size.
   *
   * @returns {number}
  */
  size() {
    return this.cache.size;
  }

  /*
   * Removes all elements from the cache.
   *
   * @returns {void}
  */
  clear() {
    this.cache.clear();
  }

  /*
   * Checks if the given key exist within the cache.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  contains(key) {
    return this.cache.has(key);
  }

  /*
   * Adds the key-value pair to the cache if the key is not in the cache yet.
   * Otherwise, if the key exists, updates the value of the key.
   * In case the current number of keys exceeds the `capacity`, then it evicts the least recently used key.
   *
   * @param {T} key - The cache key
   * @param {T} value - The value associated with the key
   * @returns {boolean}
  */
  setItem(key, value: <fim_suffix>) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      this.cache.delete(key);
      data.value = value;
      this.cache.set(key, data);
    } else {
      this.cache.set(key, {
        value,
        persistent: false
      });
    }

    if (this.cache.size > this.capacity) {
      const keys = this.cache.keys();
      let wasDeleted = false;

      if (!this.cache.size) {
        return false;
      }

      while (!wasDeleted && this.cache.size) {
        const key = keys.next().value;
        const item = this.cache.get(key as T) as DataType<T>;

        if (!item.persistent) {
          wasDeleted = true;
          this.cache.delete(key as T);
        }
      }
    }

    if (!this.cache.has(key)) {
      return false;
    }

    return true;
  }

  /*
   * Retrieves the value associated with the given key.
   * If the key is not in the cache, it returns `undefined`.
   *
   * @param {T} key - The cache key
   * @returns {T}
  */
  getItem(key) {
    if (!this.cache.has(key)) {
      return;
    }

    const data = this.cache.get(key) as DataType<T>;
    this.cache.delete(key);
    this.cache.set(key, data);

    return data.value;
  }

  /*
   * Deletes item and returns true if the item existed in the storage.
   * Returns false if the element doesn't exist.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  removeItem(key) {
    return this.cache.delete(key);
  }

  /*
   * Makes item persistent, i.e the item can no longer be automatically evicted.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  setPersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = true;
    }
  }

  /*
   * Makes item no longer a persistent item if it was one.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  removePersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = false;
    }
  }

  /*
   * Makes item persistent if it was not yet, or otherwise undo the persistent flag.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  togglePersistent(key) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      data.persistent = !data.persistent;
    }
  }

  /*
   * Returns an Array based in the current cache with each key-value pair sorted by least-recently-used.
   *
   * @returns {T[][]}
  */
  toArray() {
    return Array.from(this.cache.entries()).reduce((acc, [key, item]) => {
      acc.push([key, item.value])
      return acc;
    }, [] as T[][]);
  }
}
<fim_middle>",correct,2285
T,T,1f2f2487f7f88bf87e6700f3a15415f1c549403e,"<fim_prefix>type DataType<T> = {
  persistent: boolean,
  value: T,
};

export default class Dadado<T> {
  capacity: number;
  private cache: Map<T, DataType<T>>;

  /*
   * @param {number} capacity - Defines the maximum of items that can be in the cache
  */
  constructor(capacity) {
    if (!Number.isInteger(capacity)) {
      throw Error('Expected an integer number');
    }

    if (Math.sign(capacity) <= 0) {
      throw Error('Expected a positive number greater or equal to 1');
    }

    this.capacity = capacity;
    this.cache = new Map();
  }

  /*
   * Returns the cache size.
   *
   * @returns {number}
  */
  size() {
    return this.cache.size;
  }

  /*
   * Removes all elements from the cache.
   *
   * @returns {void}
  */
  clear() {
    this.cache.clear();
  }

  /*
   * Checks if the given key exist within the cache.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  contains(key) {
    return this.cache.has(key);
  }

  /*
   * Adds the key-value pair to the cache if the key is not in the cache yet.
   * Otherwise, if the key exists, updates the value of the key.
   * In case the current number of keys exceeds the `capacity`, then it evicts the least recently used key.
   *
   * @param {T} key - The cache key
   * @param {T} value - The value associated with the key
   * @returns {boolean}
  */
  setItem(key: <fim_suffix>, value) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      this.cache.delete(key);
      data.value = value;
      this.cache.set(key, data);
    } else {
      this.cache.set(key, {
        value,
        persistent: false
      });
    }

    if (this.cache.size > this.capacity) {
      const keys = this.cache.keys();
      let wasDeleted = false;

      if (!this.cache.size) {
        return false;
      }

      while (!wasDeleted && this.cache.size) {
        const key = keys.next().value;
        const item = this.cache.get(key as T) as DataType<T>;

        if (!item.persistent) {
          wasDeleted = true;
          this.cache.delete(key as T);
        }
      }
    }

    if (!this.cache.has(key)) {
      return false;
    }

    return true;
  }

  /*
   * Retrieves the value associated with the given key.
   * If the key is not in the cache, it returns `undefined`.
   *
   * @param {T} key - The cache key
   * @returns {T}
  */
  getItem(key) {
    if (!this.cache.has(key)) {
      return;
    }

    const data = this.cache.get(key) as DataType<T>;
    this.cache.delete(key);
    this.cache.set(key, data);

    return data.value;
  }

  /*
   * Deletes item and returns true if the item existed in the storage.
   * Returns false if the element doesn't exist.
   *
   * @param {T} key - The cache key
   * @returns {boolean}
  */
  removeItem(key) {
    return this.cache.delete(key);
  }

  /*
   * Makes item persistent, i.e the item can no longer be automatically evicted.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  setPersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = true;
    }
  }

  /*
   * Makes item no longer a persistent item if it was one.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  removePersistent(key) {
    if (this.cache.has(key)) {
      (this.cache.get(key) as DataType<T>).persistent = false;
    }
  }

  /*
   * Makes item persistent if it was not yet, or otherwise undo the persistent flag.
   *
   * @param {T} key - The cache key
   * @returns {void}
  */
  togglePersistent(key) {
    if (this.cache.has(key)) {
      const data = this.cache.get(key) as DataType<T>;
      data.persistent = !data.persistent;
    }
  }

  /*
   * Returns an Array based in the current cache with each key-value pair sorted by least-recently-used.
   *
   * @returns {T[][]}
  */
  toArray() {
    return Array.from(this.cache.entries()).reduce((acc, [key, item]) => {
      acc.push([key, item.value])
      return acc;
    }, [] as T[][]);
  }
}
<fim_middle>",correct,2286
T,T,db376862601a94fa1ae1b06de6200da26d207e77,"<fim_prefix>export const brStates = [
  'AC', 'AL', 'AM', 'AP', 'BA', 'CE', 'DF', 'ES', 'GO',
  'MA', 'MG', 'MS', 'MT', 'PA', 'PB', 'PE', 'PI', 'PR',
  'RJ', 'RN', 'RO', 'RR', 'RS', 'SC', 'SE', 'SP', 'TO'
] as const

export type BrState = typeof brStates[number]

function isBrState (stateCode): stateCode is BrState {
  return brStates.includes(stateCode)
}

const timezoneByCity: Array<[string, string[]]> = [
  ['America/Araguaina', ['1702109']],
  ['America/Eirunepe', ['1301407']],
  ['America/Noronha', ['2605459']],
  [
    'America/Rio_Branco',
    [
      '1300201', '1300607', '1300706', '1301506', '1301654', '1301803',
      '1301951', '1302306', '1302405', '1303502', '1303908', '1304062'
    ]
  ],
  ['America/Santarem', ['1506807']]
]

const timezoneByState: Array<[string, BrState[]]> = [
  ['America/Bahia', ['BA']],
  ['America/Belem', ['AP', 'PA', 'TO']],
  ['America/Boa_Vista', ['RR']],
  ['America/Campo_Grande', ['MS']],
  ['America/Cuiaba', ['MT']],
  ['America/Fortaleza', ['CE', 'MA', 'PI', 'RN']],
  ['America/Maceio', ['AL', 'SE']],
  ['America/Manaus', ['AM']],
  ['America/Porto_Velho', ['RO']],
  ['America/Recife', ['PB', 'PE']],
  ['America/Rio_Branco', ['AC']],
  ['America/Sao_Paulo', ['DF', 'ES', 'GO', 'MG', 'PR', 'RJ', 'RS', 'SC', 'SP']]
]

function findTimezone <T> (map, value: <fim_suffix>) {
  for (const [timezone, list] of map) {
    if (list.includes(value)) {
      return timezone
    }
  }
  return null
}

export function getBrTimezone (stateCode, ibgeCode?) {
  if (!isBrState(stateCode)) {
    throw new Error(`Invalid State Code: '${stateCode}'`)
  }

  let timezone: string | null

  if (ibgeCode !== undefined) {
    timezone = findTimezone(timezoneByCity, ibgeCode)
    if (timezone !== null) {
      return timezone
    }
  }

  timezone = findTimezone(timezoneByState, stateCode)
  if (timezone !== null) {
    return timezone
  }

  throw new Error(`State Code '${stateCode}' is not mapped to a timezone`)
}
<fim_middle>",correct,2354
T,T,f7f098de6ce0870153a7af6a953c190cf705eb1b,"<fim_prefix>export interface OrderedListEntry<T>
{
  prev: OrderedListEntry<T>;
  next: OrderedListEntry<T>;
  value: T;
}

export type OrderedListIndex<T> = { [key: string]: OrderedListEntry<T> };

export class OrderedList<T>
{
  head: OrderedListEntry<T>;
  tail: OrderedListEntry<T>;
  index: OrderedListIndex<T>;

  constructor()
    {
      this.clear();
    }

  isempty()
    {
      return this.head == null;
    }

  clear()
    {
      this.head = null;
      this.tail = null;
      this.index = {};
    }

  insert(key, value: <fim_suffix>)
    {
      if (this.index[key] !== undefined)
        return `memsqs: send: message uid ${key} already exists`;

      let e: OrderedListEntry<T> = { prev: this.tail, next: null, value: value };
      if (this.tail)
        this.tail.next = e;
      this.tail = e;
      if (this.head === null)
        this.head = e;
      this.index[key] = e;
      return null;
    }

  remove(key)
    {
      let e = this.index[key];
      if (e === undefined)
        return `memsqs: remove: message uid ${key} does not exist`;

      if (e === this.tail)
        this.tail = e.prev;
      else
        e.next.prev = e.prev;

      if (e === this.head)
        this.head = e.next;
      else
        e.prev.next = e.next;

      delete this.index[key];

      return null;
    }

  forEach(cb)
    {
      for (let p = this.head; p && cb(p.value); p = p.next)
        continue;
    }
}
<fim_middle>",correct,2496
T,T,cc966119a9d0804aa81737f900326caade60f340,"<fim_prefix>interface ErrorOption {
  cause?: Error;
  status?: number;
}

interface Convertable {
  [key: string]: string | number;
}

type ConvertString<T extends Convertable, Group extends string> = {
  [P in keyof T]: P extends string
    ? T[P] extends number
      ? `${Uppercase<Group>}_${T[P]}`
      : never
    : never;
};

const codeGroup = new Set();

/**
 * Register error group and code, return the standard ErrorCode
 * @param errorGroup
 * @param errorCodeMapping
 */
export function registerErrorCode<T extends Convertable, G extends string>(
  errorGroup,
  errorCodeMapping: <fim_suffix>
) {
  if (codeGroup.has(errorGroup)) {
    throw new MidwayError(
      `Error group ${errorGroup} is duplicated, please check before adding.`
    );
  } else {
    codeGroup.add(errorGroup);
  }
  const newCodeEnum = {} as Convertable;
  // ERROR => GROUP_10000
  for (const errKey in errorCodeMapping) {
    newCodeEnum[errKey as string] =
      errorGroup.toUpperCase() +
      '_' +
      String(errorCodeMapping[errKey]).toUpperCase();
  }
  return newCodeEnum as ConvertString<T, G>;
}

export class MidwayError extends Error {
  code: number | string;
  cause: Error;

  constructor(message, options?);
  constructor(message, code, options?);
  constructor(message, code, options?) {
    super(message);
    if (!code || typeof code === 'object') {
      options = code;
      code = 'MIDWAY_10000';
    }
    this.name = this.constructor.name;
    this.code = code;
    this.cause = options?.cause;
  }
}

export type ResOrMessage = string | { message: string };

export class MidwayHttpError extends MidwayError {
  status: number;

  constructor(resOrMessage, status);
  constructor(
    resOrMessage,
    status,
    code,
    options?
  );
  constructor(
    resOrMessage,
    status,
    code?,
    options?
  ) {
    super(
      typeof resOrMessage === 'string' ? resOrMessage : resOrMessage.message,
      code ?? String(status),
      options
    );
    this.status = status;
  }
}
<fim_middle>",correct,2536
T,T,b0280f038563e54e983ad28728ead564ef36b563,"<fim_prefix>/*
 * Notifo.io
 *
 * @license
 * Copyright (c) Sebastian Stehle. All rights reserved.
 */

/* eslint-disable */

interface ReadonlyArray<T> {
    replacedBy(field, value);

    removedBy(field, value);

    removed(value?);

    sorted();

    sortedByString(selector);

    toMap(selector);
}

interface Array<T> {
    replacedBy(field, value);

    replaceBy(field, value);

    removedBy(field, value);

    removeBy(field, value);

    removeByValue<TId>(field, oldId);

    removed(value);

    remove(value);

    sorted();

    sortedByString(selector);

    sortByString(selector);

    set<TId>(field, value);

    setOrPush<TId>(field, value);

    setOrUnshift<TId>(field, value);

    toMap(selector);
}

Array.prototype.replaceBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            self[i] = value;
            break;
        }
    }

    return self;
};

Array.prototype.replacedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    for (let i = 0; i < self.length; i++) {
        const item = self[i];

        if (value[field] === item[field]) {
            copy[i] = value;
            break;
        }
    }

    return copy;
};

Array.prototype.removeBy = function<T>(field, value) {
    const self: T[] = this;

    if (!field || !value) {
        return self;
    }

    self.splice(self.findIndex(x => x[field] === value[field]), 1);

    return self;
};

Array.prototype.removeByValue = function<T, TId>(field, oldId) {
    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === oldId) {
            this.splice(i, 1);
            return true;
        }
    }

    return false;
};

Array.prototype.removed = function<T>(value?) {
    const self: ReadonlyArray<T> = this;

    if (!value) {
        return this;
    }

    return self.filter((v) => v !== value);
};

Array.prototype.remove = function<T>(value?: <fim_suffix>) {
    const self: T[] = this;

    if (!value) {
        return this;
    }

    const index = self.indexOf(value);

    self.splice(index, 1);

    return self;
};

Array.prototype.removedBy = function<T>(field, value) {
    const self: ReadonlyArray<T> = this;

    if (!field || !value) {
        return self;
    }

    return self.filter((v) => v[field] !== value[field]);
};

Array.prototype.sorted = function() {
    const self: any[] = this;

    const copy: any[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort();

    return copy;
};

Array.prototype.sortedByString = function<T>(selector) {
    const self: ReadonlyArray<any> = this;

    if (!selector) {
        return self;
    }

    const copy: T[] = [];

    for (const item of self) {
        copy.push(item);
    }

    copy.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return copy;
};

Array.prototype.sortByString = function<T>(selector) {
    const self: any[] = this;

    if (!selector) {
        return self;
    }

    self.sort((a, b) => selector(a).localeCompare(selector(b), undefined, { sensitivity: 'base' }));

    return self;
};

Array.prototype.toMap = function<T>(selector) {
    const result: { [key: string]: T } = {};

    for (const item of this) {
        result[selector(item)] = item;
    }

    return result;
};

Array.prototype.set = function<T, TId>(field, newValue) {
    if (!newValue) {
        return false;
    }

    const newId = field(newValue);

    for (let i = 0; i < this.length; i++) {
        if (field(this[i]) === newId) {
            this[i] = newValue;
            return true;
        }
    }

    return false;
};

Array.prototype.setOrPush = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.push(newValue);
    }
};

Array.prototype.setOrUnshift = function<T, TId>(field, newValue) {
    if (!this.set(field, newValue)) {
        this.unshift(newValue);
    }
};<fim_middle>",correct,2694
T,T,595681bb13aee410a4c20056b48f731d78418652,"<fim_prefix>type Comparator<T> = (a, b) => number;

export const RankingFunctionComparator =
    <T>(rank) =>
    (a, b: <fim_suffix>) =>
        rank(b) - rank(a);

export const NumericComparator = RankingFunctionComparator<number>((x) => x);

/**
 * Min heap implementation.
 * Comparator function is expected to return a positive number, zero or a negative number if a > b, a === b or a < b.
 */
const MinHeap = <T>(comparator) => {
    // heap-ordered complete binary tree in heap[1..n] with heap[0] unused
    const heap: T[] = [];
    const compare = comparator;
    let n = 0;

    // comparator function
    const greater = (i, j) => compare(heap[i], heap[j]) < 0;

    // swap two elements
    const swap = (i, j) => {
        const temp = heap[i];
        heap[i] = heap[j];
        heap[j] = temp;
    };

    // bubble k-th element up
    const swim = (k) => {
        let k2 = k >> 1;
        while (k > 1 && greater(k2, k)) {
            swap(k2, k);
            k = k2;
            k2 = k >> 1;
        }
    };

    // bubble k-th element down
    const sink = (k) => {
        let j = k << 1;
        while (j <= n) {
            if (j < n && greater(j, j + 1)) j++;
            if (!greater(k, j)) break;
            swap(k, j);
            k = j;
            j = k << 1;
        }
    };

    return {
        /** add element to the heap */
        push: (element) => {
            n += 1;
            heap[n] = element;
            swim(n);
        },

        /** remove the first element from the heap */
        pop: () => {
            if (n === 0) return undefined;
            swap(1, n);
            n -= 1;
            const max = heap.pop();
            sink(1);
            return max;
        },

        /** heap size */
        size: () => n,
    };
};

export default MinHeap;
<fim_middle>",correct,2797
T,T,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ): <fim_suffix> {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3060
T,T,6c5d24a5d99d75f367877e7cca717ee288b6d93d,"<fim_prefix>// To parse this data:
//
//   import { Convert, Intoto } from ""./file"";
//
//   const intoto = Convert.toIntoto(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for intoto object
 */
export interface Intoto {
    content: Content;
    /**
     * The public key that can verify the signature
     */
    publicKey: string;
}

export interface Content {
    /**
     * envelope
     */
    envelope?: string;
    /**
     * Specifies the hash algorithm and value encompassing the entire signed envelope
     */
    hash?: Hash;
    /**
     * Specifies the hash algorithm and value covering the payload within the DSSE envelope
     */
    payloadHash?: PayloadHash;
}

/**
 * Specifies the hash algorithm and value encompassing the entire signed envelope
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the archive
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Specifies the hash algorithm and value covering the payload within the DSSE envelope
 */
export interface PayloadHash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the envelope's payload
     */
    value: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toIntoto(json) {
        return cast(JSON.parse(json), r(""Intoto""));
    }

    public static intotoToJson(value) {
        return JSON.stringify(uncast(value, r(""Intoto"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ): <fim_suffix> {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Intoto"": o([
        { json: ""content"", js: ""content"", typ: r(""Content"") },
        { json: ""publicKey"", js: ""publicKey"", typ: """" },
    ], ""any""),
    ""Content"": o([
        { json: ""envelope"", js: ""envelope"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
        { json: ""payloadHash"", js: ""payloadHash"", typ: u(undefined, r(""PayloadHash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""PayloadHash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3505
T,T,c345024143db0e7f2d60174bc07a582029bfedc5,"<fim_prefix>// To parse this data:
//
//   import { Convert, Rekord } from ""./file"";
//
//   const rekord = Convert.toRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Rekord object
 */
export interface Rekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the content inline within the document
     */
    content?: string;
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content: string;
    /**
     * Specifies the format of the signature
     */
    format: Format;
    /**
     * The public key that can verify the signature
     */
    publicKey: PublicKey;
}

/**
 * Specifies the format of the signature
 */
export enum Format {
    Minisign = ""minisign"",
    PGP = ""pgp"",
    SSH = ""ssh"",
    X509 = ""x509"",
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toRekord(json) {
        return cast(JSON.parse(json), r(""Rekord""));
    }

    public static rekordToJson(value) {
        return JSON.stringify(uncast(value, r(""Rekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ): <fim_suffix> {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Rekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: """" },
        { json: ""format"", js: ""format"", typ: r(""Format"") },
        { json: ""publicKey"", js: ""publicKey"", typ: r(""PublicKey"") },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
    ""Format"": [
        ""minisign"",
        ""pgp"",
        ""ssh"",
        ""x509"",
    ],
};
<fim_middle>",correct,3672
T,T,4ecebdfe2a83e32ca2665144d05b64c53181178a,"<fim_prefix>/**
 *
 *
 * Copied direcly from: https://github.com/pmndrs/jotai/blob/main/src/utils/weakCache.ts
 *
 * Eventually just import it from Jotai if it's exported.
 *
 *
 *
 */
export type WeakCache<T> = WeakMap<object, [WeakCache<T>] | [WeakCache<T>, T]>;

const getWeakCacheItem = <T>(
  cache,
  deps
) => {
  while (true) {
    const [dep, ...rest] = deps;
    const entry = cache.get(dep as object);
    if (!entry) {
      return;
    }
    if (!rest.length) {
      return entry[1];
    }
    cache = entry[0];
    deps = rest;
  }
};

const setWeakCacheItem = <T>(
  cache,
  deps,
  item: <fim_suffix>
) => {
  while (true) {
    const [dep, ...rest] = deps;
    let entry = cache.get(dep as object);
    if (!entry) {
      entry = [new WeakMap()];
      cache.set(dep as object, entry);
    }
    if (!rest.length) {
      entry[1] = item;
      return;
    }
    cache = entry[0];
    deps = rest;
  }
};

export const createMemoizeAtom = () => {
  const cache: WeakCache<{}> = new WeakMap();
  const memoizeAtom = <T extends {}, Deps extends readonly object[]>(
    createAtom,
    deps
  ) => {
    const cachedAtom = getWeakCacheItem(cache, deps);
    if (cachedAtom) {
      return cachedAtom as T;
    }
    const createdAtom = createAtom();
    setWeakCacheItem(cache, deps, createdAtom);
    return createdAtom;
  };
  return memoizeAtom;
};
<fim_middle>",correct,3789
T,T,9b43716649831a6b0a5fff85e210dfc54b96687f,"<fim_prefix>export function convertComponents<T extends Component>(components) {
  for (let i = 0; i < components.length; i++) {
    const component = components[i];
    const args: string[] = [];
    for (const part of component.route.split(""/"")) {
      if (part.startsWith("":"")) {
        args.push(part.slice(1));
      }
    }
    component.route = component.route.toLowerCase();
    component.args = args;
    // Remove extension
    const file = component.path;
    let idx = file.length - 1;
    while (file[idx] !== ""."") {
      idx--;
    }
    const ext = file.slice(idx + 1, file.length);
    let relativePath = component.path.split(""pages"")[1];
    relativePath = relativePath.replace(`.${ext}`, """");
    component.ext = ext;
    component.alias = `route${i}`;
    component.relativePath = ""pages"" + relativePath;
    const route = `${component.route}`;
    if (route === """") {
      continue;
    }
    let parentRoute: string | undefined;
    if (route.endsWith(""/"")) {
      parentRoute = route.slice(0, -1);
    } else {
      let implicitIndex = false;
      const implicitRoute = route + ""/"";
      for (const c of components) {
        if (c.route === implicitRoute) {
          implicitIndex = true;
          break;
        }
      }
      component.implicitIndex = implicitIndex;
      // /settings/admin --> /settings --> """"
      // /settings/ --> /settings --> """"
      // /settings --> """"
      parentRoute = route.split(""/"").slice(0, -1).join(""/"");
    }
    const hasParentRoute = components.find((c) => c.route === parentRoute);
    if (hasParentRoute !== undefined && parentRoute !== ""/"") {
      component.parentRoute = parentRoute;
    } else if (parentRoute === ""/"") {
      const rootComponent = components.find((c) => c.route === """");
      if (rootComponent) {
        component.parentRoute = """";
      }
    }
  }

  return components
    .sort((a, b) => {
      if (a.route < b.route) {
        return -1;
      }
      if (a.route > b.route) {
        return 1;
      }
      return 0;
    })
    .reverse();
}

export function getComponentTree<T extends Component>(
  component: <fim_suffix>,
  components
) {
  const tree: T[] = [component];

  while (component.parentRoute) {
    const parent = components.find((c) => c.route === component.parentRoute);
    if (parent) {
      tree.push(parent);
      component = parent;
    } else {
      break;
    }
  }

  // Add root
  const root = components.find((c) => c.route === """");
  if (root && root !== component) {
    tree.push(root);
  }

  return tree.reverse();
}

export interface Component {
  route: string;
  name: string;
  path: string;
  ext?: string;
  relativePath?: string;
  alias?: string;
  implicitIndex?: boolean;
  parentRoute?: string;
  args: string[];
}
<fim_middle>",correct,4330
T,T,24999e29aa18a7e6c16f4de040738b69ba73f9fe,"<fim_prefix>/* eslint-disable curly */
/* eslint-disable @typescript-eslint/naming-convention */
// To parse this data:
//
//   import { Convert, SwiftPackageManifest } from ""./file"";
//
//   const swiftPackageManifest = SwiftPackageManifestParser.toSwiftPackageManifest(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface SwiftPackageManifest {
    name:         string;
    targets: SwiftTarget[];
    toolsVersion: ToolsVersion;
}

export interface SwiftTarget {
    name:  string;
    path?: null | string;
    type:  TargetType;
}

export enum TargetType {
    Executable = ""executable"",
    Regular = ""regular"",
    Test = ""test"",
    System = ""system"",
    Binary = ""binary"",
    Plugin = ""plugin"",
    Snippet = ""snippet"",
}

export interface ToolsVersion {
    _version: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class SwiftPackageManifestParser {
    public static toSwiftPackageManifest(json) {
        return cast(JSON.parse(json), r(""SwiftPackageManifest""));
    }

    public static swiftPackageManifestToJson(value) {
        return JSON.stringify(uncast(value, r(""SwiftPackageManifest"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = val[key];
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ): <fim_suffix> {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""SwiftPackageManifest"": o([
        { json: ""name"", js: ""name"", typ: """" },
        { json: ""targets"", js: ""targets"", typ: a(r(""SwiftTarget"")) },
        { json: ""toolsVersion"", js: ""toolsVersion"", typ: r(""ToolsVersion"") },
    ], false),
    ""SwiftTarget"": o([
        { json: ""name"", js: ""name"", typ: """" },
        { json: ""path"", js: ""path"", typ: u(undefined, u(null, """")) },
        { json: ""type"", js: ""type"", typ: r(""TargetType"") },
    ], false),
    ""ToolsVersion"": o([
        { json: ""_version"", js: ""_version"", typ: """" },
    ], false),
    ""TargetType"": [
        ""executable"",
        ""regular"",
        ""test"",
        ""system"",
        ""binary"",
        ""plugin"",
        ""snippet"",
    ],
};
<fim_middle>",correct,4479
T,T,24c8679a54aa8d683698c7b4de74d262fde12731,"<fim_prefix>// eslint-disable-next-line @typescript-eslint/ban-types
export interface CustomResponse<T = {}> {
	data: T;
	meta: {
		message?: string;
		statusCode?: number;
		page?: number | string;
		perPage?: number | string;
		totalPage?: number | string;
		totalData?: number | string;
		isEmailChanged?: boolean;
		isPhoneNumberChanged?: boolean;
	};
}

export class OkResponse<T> implements CustomResponse<T> {
	meta: {
		message: string;
		statusCode: number;
		page?: number | string;
		perPage?: number | string;
		totalPage?: number | string;
		totalData?: number | string;
	};
	data: T;
	constructor(data, meta?, statusCode?) {
		this.data = data;
		if (Array.isArray(data)) {
			this.meta = {
				...meta,
				message:
					(meta && meta.message) || ""Data successfully retrieved/transmitted!"",
				statusCode: 200,
				totalData: (meta && meta.totalData) || 0,
				page: (meta && Number(meta.page)) || 1,
				perPage: (meta && Number(meta.perPage)) || 10,
				totalPage: Math.ceil(
					((meta && Number(meta.totalData)) || 1) /
						(meta && meta.perPage ? Number(meta.perPage) : 10),
				),
			};
		} else {
			this.meta = {
				...meta,
				message:
					(meta && meta.message) || ""Data successfully retrieved/transmitted!"",
				statusCode: statusCode || 200,
			};
		}
	}
}

export class CreateDataResponse<T> implements CustomResponse<T> {
	meta: {
		message?: string;
		statusCode?: number;
	} = {};
	data: T;
	constructor(data, meta?, statusCode?) {
		this.data = data;
		this.meta = {
			...meta,
			message: (meta && meta.message) || ""Data successfully created!"",
			statusCode: statusCode || 201,
		};
	}
}

export class UpdateDataResponse<T> implements CustomResponse<T> {
	meta: {
		message: string;
		statusCode: number;
	};
	data: T;
	constructor(data: <fim_suffix>, meta?, statusCode?) {
		this.data = data;

		this.meta = {
			...meta,
			message: (meta && meta.message) || ""Data successfully updated!"",
			statusCode: statusCode || 200,
		};
	}
}

export class DeleteDataResponse<T> implements CustomResponse<T> {
	meta: {
		message: string;
		statusCode?: number;
		page?: number | string;
		perPage?: number | string;
		totalPage?: number | string;
		totalData?: number | string;
	};
	data: T;
	constructor(data, meta?, statusCode?) {
		this.data = data;
		this.meta = {
			...meta,
			message: (meta && meta.message) || ""Data successfully deleted!"",
			statusCode: statusCode || 200,
		};
	}
}
<fim_middle>",correct,4524
T,T,24c8679a54aa8d683698c7b4de74d262fde12731,"<fim_prefix>// eslint-disable-next-line @typescript-eslint/ban-types
export interface CustomResponse<T = {}> {
	data: T;
	meta: {
		message?: string;
		statusCode?: number;
		page?: number | string;
		perPage?: number | string;
		totalPage?: number | string;
		totalData?: number | string;
		isEmailChanged?: boolean;
		isPhoneNumberChanged?: boolean;
	};
}

export class OkResponse<T> implements CustomResponse<T> {
	meta: {
		message: string;
		statusCode: number;
		page?: number | string;
		perPage?: number | string;
		totalPage?: number | string;
		totalData?: number | string;
	};
	data: T;
	constructor(data, meta?, statusCode?) {
		this.data = data;
		if (Array.isArray(data)) {
			this.meta = {
				...meta,
				message:
					(meta && meta.message) || ""Data successfully retrieved/transmitted!"",
				statusCode: 200,
				totalData: (meta && meta.totalData) || 0,
				page: (meta && Number(meta.page)) || 1,
				perPage: (meta && Number(meta.perPage)) || 10,
				totalPage: Math.ceil(
					((meta && Number(meta.totalData)) || 1) /
						(meta && meta.perPage ? Number(meta.perPage) : 10),
				),
			};
		} else {
			this.meta = {
				...meta,
				message:
					(meta && meta.message) || ""Data successfully retrieved/transmitted!"",
				statusCode: statusCode || 200,
			};
		}
	}
}

export class CreateDataResponse<T> implements CustomResponse<T> {
	meta: {
		message?: string;
		statusCode?: number;
	} = {};
	data: T;
	constructor(data: <fim_suffix>, meta?, statusCode?) {
		this.data = data;
		this.meta = {
			...meta,
			message: (meta && meta.message) || ""Data successfully created!"",
			statusCode: statusCode || 201,
		};
	}
}

export class UpdateDataResponse<T> implements CustomResponse<T> {
	meta: {
		message: string;
		statusCode: number;
	};
	data: T;
	constructor(data, meta?, statusCode?) {
		this.data = data;

		this.meta = {
			...meta,
			message: (meta && meta.message) || ""Data successfully updated!"",
			statusCode: statusCode || 200,
		};
	}
}

export class DeleteDataResponse<T> implements CustomResponse<T> {
	meta: {
		message: string;
		statusCode?: number;
		page?: number | string;
		perPage?: number | string;
		totalPage?: number | string;
		totalData?: number | string;
	};
	data: T;
	constructor(data, meta?, statusCode?) {
		this.data = data;
		this.meta = {
			...meta,
			message: (meta && meta.message) || ""Data successfully deleted!"",
			statusCode: statusCode || 200,
		};
	}
}
<fim_middle>",correct,4527
T,T,d5a320d9afa591ebd0028bd17f5c2c381936027b,"<fim_prefix>interface QueueNode<T> {
  value: T;
  next: QueueNode<T> | null;
}

interface Queue<T extends any> {
  enqueue: (value) => void;
  dequeue: () => T | undefined;
  peek: () => T | undefined;
  clear: () => void;
  size: () => void;
  forEach: (callback?d;
  toArray: () => T[];
}

const createNode = <T>(value: <fim_suffix>) => {
  return {
    value,
    next: null
  }
}
export const createQueue = <T extends any>() => {
  let head: QueueNode<T> | null = null;
  let tail: QueueNode<T> | null = null;
  let size = 0;
  return {
    enqueue(value) {
      const node = createNode<T>(value);
      if (head && tail) {
        tail.next = node
        tail = node
      } else {
        head = node
        tail = node
      }
      size++
    },
    dequeue() {
      const current = head
      if (!current) {
        return undefined
      }
      head = current.next
      size--
      return current.value
    },
    peek() {
      if (!head) {
        return
      }
      return head.value
    },
    clear() {
      head = null
      tail = null
      size = 0
    },
    size() {
      return size
    },
    forEach(callback) {
      let current = head
      let index = 0
      while(current) {
        if (typeof callback === ""function"") {
          callback(current.value, index)
        }
        current = current.next
        index++
      }
    },
    toArray() {
      const arr: T[] = []
      this.forEach((value) => {
        arr.push(value)
      })
      return arr
    }
  }
}<fim_middle>",correct,4845
T,T,827363613ce8b25b320df2a9f97559bc4db11fc5,"<fim_prefix>/* eslint-disable */
// @ts-nocheck
/*
* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY
*/

/**
 * base64 encoder and decoder
 * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js
 */
// Base64 encoding table
const b64 = new Array(64);

// Base64 decoding table
const s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (let i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

export function b64Encode(buffer, start, end) {
	let parts: string[] = null;
  const chunk = [];
  let i = 0, // output index
    j = 0, // goto index
    t;     // temporary
  while (start < end) {
    const b = buffer[start++];
    switch (j) {
      case 0:
        chunk[i++] = b64[b >> 2];
        t = (b & 3) << 4;
        j = 1;
        break;
      case 1:
        chunk[i++] = b64[t | b >> 4];
        t = (b & 15) << 2;
        j = 2;
        break;
      case 2:
        chunk[i++] = b64[t | b >> 6];
        chunk[i++] = b64[b & 63];
        j = 0;
        break;
    }
    if (i > 8191) {
      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (j) {
    chunk[i++] = b64[t];
    chunk[i++] = 61;
    if (j === 1)
      chunk[i++] = 61;
  }
  if (parts) {
    if (i)
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    return parts.join("""");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
}

const invalidEncoding = ""invalid encoding"";

export function b64Decode(s) {
	const buffer = [];
	let offset = 0;
  let j = 0, // goto index
      t;     // temporary
  for (let i = 0; i < s.length;) {
    let c = s.charCodeAt(i++);
    if (c === 61 && j > 1)
        break;
    if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
    switch (j) {
      case 0:
        t = c;
        j = 1;
        break;
      case 1:
        buffer[offset++] = t << 2 | (c & 48) >> 4;
        t = c;
        j = 2;
        break;
      case 2:
        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
        t = c;
        j = 3;
        break;
      case 3:
        buffer[offset++] = (t & 3) << 6 | c;
        j = 0;
        break;
    }
  }
  if (j === 1)
      throw Error(invalidEncoding);
  return new Uint8Array(buffer);
}

function b64Test(s) {
	return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);
}

export interface InitReq extends RequestInit {
  pathPrefix?: string
}

export function replacer(key, value) {
  if(value && value.constructor === Uint8Array) {
    return b64Encode(value, 0, value.length);
  }

  return value;
}

export function fetchReq<I, O>(path, init?) {
  const {pathPrefix, ...req} = init || {}

  const url = pathPrefix ? `${pathPrefix}${path}` : path

  return fetch(url, req).then(r => r.json().then((body) => {
    if (!r.ok) { throw body; }
    return body;
  })) as Promise<O>
}

// NotifyStreamEntityArrival is a callback that will be called on streaming entity arrival
export type NotifyStreamEntityArrival<T> = (resp) => void

/**
 * fetchStreamingRequest is able to handle grpc-gateway server side streaming call
 * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call
 * all entities will be returned as an array after the call finishes.
 **/
export async function fetchStreamingRequest<S, R>(path, callback?, init?) {
  const {pathPrefix, ...req} = init || {}
  const url = pathPrefix ?`${pathPrefix}${path}` : path
  const result = await fetch(url, req)
  // needs to use the .ok to check the status of HTTP status code
  // http other than 200 will not throw an error, instead the .ok will become false.
  // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#
  if (!result.ok) {
    const resp = await result.json()
    const errMsg = resp.error && resp.error.message ? resp.error.message : """"
    throw new Error(errMsg)
  }

  if (!result.body) {
    throw new Error(""response doesnt have a body"")
  }

  await result.body
    .pipeThrough(new TextDecoderStream())
    .pipeThrough<R>(getNewLineDelimitedJSONDecodingStream<R>())
    .pipeTo(getNotifyEntityArrivalSink((e) => {
      if (callback) {
        callback(e)
      }
    }))

  // wait for the streaming to finish and return the success respond
  return
}

/**
 * JSONStringStreamController represents the transform controller that's able to transform the incoming
 * new line delimited json content stream into entities and able to push the entity to the down stream
 */
interface JSONStringStreamController<T> extends TransformStreamDefaultController {
  buf?: string
  pos?: number
  enqueue: (s) => void
}

/**
 * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities
 */
function getNewLineDelimitedJSONDecodingStream<T>() {
  return new TransformStream({
    start(controller) {
      controller.buf = ''
      controller.pos = 0
    },

    transform(chunk, controller) {
      if (controller.buf === undefined) {
        controller.buf = ''
      }
      if (controller.pos === undefined) {
        controller.pos = 0
      }
      controller.buf += chunk
      while (controller.pos < controller.buf.length) {
        if (controller.buf[controller.pos] === '\n') {
          const line = controller.buf.substring(0, controller.pos)
          const response = JSON.parse(line)
          controller.enqueue(response.result)
          controller.buf = controller.buf.substring(controller.pos + 1)
          controller.pos = 0
        } else {
          ++controller.pos
        }
      }
    }
  })

}

/**
 * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return
 * a sink that will call the callback on entity arrival
 * @param notifyCallback
 */
function getNotifyEntityArrivalSink<T>(notifyCallback) {
  return new WritableStream<T>({
    write(entity) {
      notifyCallback(entity)
    }
  })
}

type Primitive = string | boolean | number;
type RequestPayload = Record<string, unknown>;
type FlattenedRequestPayload = Record<string, Primitive | Array<Primitive>>;

/**
 * Checks if given value is a plain object
 * Logic copied and adapted from below source: 
 * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js
 * @param  {unknown} value
 * @return {boolean}
 */
function isPlainObject(value) {
  const isObject =
    Object.prototype.toString.call(value).slice(8, -1) === ""Object"";
  const isObjLike = value !== null && isObject;

  if (!isObjLike || !isObject) {
    return false;
  }

  const proto = Object.getPrototypeOf(value);

  const hasObjectConstructor =
    typeof proto === ""object"" &&
    proto.constructor === Object.prototype.constructor;

  return hasObjectConstructor;
}

/**
 * Checks if given value is of a primitive type
 * @param  {unknown} value
 * @return {boolean}
 */
function isPrimitive(value) {
  return [""string"", ""number"", ""boolean""].some(t => typeof value === t);
}

/**
 * Checks if given primitive is zero-value
 * @param  {Primitive} value
 * @return {boolean}
 */
function isZeroValuePrimitive(value) {
  return value === false || value === 0 || value === """";
}

/**
 * Flattens a deeply nested request payload and returns an object
 * with only primitive values and non-empty array of primitive values
 * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto
 * @param  {RequestPayload} requestPayload
 * @param  {String} path
 * @return {FlattenedRequestPayload>}
 */
function flattenRequestPayload<T extends RequestPayload>(
  requestPayload: <fim_suffix>,
  path = """"
) {
  return Object.keys(requestPayload).reduce(
    (acc, key) => {
      const value = requestPayload[key];
      const newPath = path ? [path, key].join(""."") : key;

      const isNonEmptyPrimitiveArray =
        Array.isArray(value) &&
        value.every(v => isPrimitive(v)) &&
        value.length > 0;

      const isNonZeroValuePrimitive =
        isPrimitive(value) && !isZeroValuePrimitive(value as Primitive);

      let objectToMerge = {};

      if (isPlainObject(value)) {
        objectToMerge = flattenRequestPayload(value as RequestPayload, newPath);
      } else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {
        objectToMerge = { [newPath]: value };
      }

      return { ...acc, ...objectToMerge };
    },
    {} as T
  ) as FlattenedRequestPayload;
}

/**
 * Renders a deeply nested request payload into a string of URL search
 * parameters by first flattening the request payload and then removing keys
 * which are already present in the URL path.
 * @param  {RequestPayload} requestPayload
 * @param  {string[]} urlPathParams
 * @return {string}
 */
export function renderURLSearchParams<T extends RequestPayload>(
  requestPayload,
  urlPathParams = []
) {
  const flattenedRequestPayload = flattenRequestPayload(requestPayload);

  const urlSearchParams = Object.keys(flattenedRequestPayload).reduce(
    (acc, key) => {
      // key should not be present in the url path as a parameter
      const value = flattenedRequestPayload[key];
      if (urlPathParams.find(f => f === key)) {
        return acc;
      }
      return Array.isArray(value)
        ? [...acc, ...value.map(m => [key, m.toString()])]
        : (acc = [...acc, [key, value.toString()]]);
    },
    [] as string[][]
  );

  return new URLSearchParams(urlSearchParams).toString();
}<fim_middle>",correct,4878
T,T,827363613ce8b25b320df2a9f97559bc4db11fc5,"<fim_prefix>/* eslint-disable */
// @ts-nocheck
/*
* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY
*/

/**
 * base64 encoder and decoder
 * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js
 */
// Base64 encoding table
const b64 = new Array(64);

// Base64 decoding table
const s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (let i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

export function b64Encode(buffer, start, end) {
	let parts: string[] = null;
  const chunk = [];
  let i = 0, // output index
    j = 0, // goto index
    t;     // temporary
  while (start < end) {
    const b = buffer[start++];
    switch (j) {
      case 0:
        chunk[i++] = b64[b >> 2];
        t = (b & 3) << 4;
        j = 1;
        break;
      case 1:
        chunk[i++] = b64[t | b >> 4];
        t = (b & 15) << 2;
        j = 2;
        break;
      case 2:
        chunk[i++] = b64[t | b >> 6];
        chunk[i++] = b64[b & 63];
        j = 0;
        break;
    }
    if (i > 8191) {
      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (j) {
    chunk[i++] = b64[t];
    chunk[i++] = 61;
    if (j === 1)
      chunk[i++] = 61;
  }
  if (parts) {
    if (i)
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    return parts.join("""");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
}

const invalidEncoding = ""invalid encoding"";

export function b64Decode(s) {
	const buffer = [];
	let offset = 0;
  let j = 0, // goto index
      t;     // temporary
  for (let i = 0; i < s.length;) {
    let c = s.charCodeAt(i++);
    if (c === 61 && j > 1)
        break;
    if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
    switch (j) {
      case 0:
        t = c;
        j = 1;
        break;
      case 1:
        buffer[offset++] = t << 2 | (c & 48) >> 4;
        t = c;
        j = 2;
        break;
      case 2:
        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
        t = c;
        j = 3;
        break;
      case 3:
        buffer[offset++] = (t & 3) << 6 | c;
        j = 0;
        break;
    }
  }
  if (j === 1)
      throw Error(invalidEncoding);
  return new Uint8Array(buffer);
}

function b64Test(s) {
	return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);
}

export interface InitReq extends RequestInit {
  pathPrefix?: string
}

export function replacer(key, value) {
  if(value && value.constructor === Uint8Array) {
    return b64Encode(value, 0, value.length);
  }

  return value;
}

export function fetchReq<I, O>(path, init?) {
  const {pathPrefix, ...req} = init || {}

  const url = pathPrefix ? `${pathPrefix}${path}` : path

  return fetch(url, req).then(r => r.json().then((body) => {
    if (!r.ok) { throw body; }
    return body;
  })) as Promise<O>
}

// NotifyStreamEntityArrival is a callback that will be called on streaming entity arrival
export type NotifyStreamEntityArrival<T> = (resp) => void

/**
 * fetchStreamingRequest is able to handle grpc-gateway server side streaming call
 * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call
 * all entities will be returned as an array after the call finishes.
 **/
export async function fetchStreamingRequest<S, R>(path, callback?, init?) {
  const {pathPrefix, ...req} = init || {}
  const url = pathPrefix ?`${pathPrefix}${path}` : path
  const result = await fetch(url, req)
  // needs to use the .ok to check the status of HTTP status code
  // http other than 200 will not throw an error, instead the .ok will become false.
  // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#
  if (!result.ok) {
    const resp = await result.json()
    const errMsg = resp.error && resp.error.message ? resp.error.message : """"
    throw new Error(errMsg)
  }

  if (!result.body) {
    throw new Error(""response doesnt have a body"")
  }

  await result.body
    .pipeThrough(new TextDecoderStream())
    .pipeThrough<R>(getNewLineDelimitedJSONDecodingStream<R>())
    .pipeTo(getNotifyEntityArrivalSink((e) => {
      if (callback) {
        callback(e)
      }
    }))

  // wait for the streaming to finish and return the success respond
  return
}

/**
 * JSONStringStreamController represents the transform controller that's able to transform the incoming
 * new line delimited json content stream into entities and able to push the entity to the down stream
 */
interface JSONStringStreamController<T> extends TransformStreamDefaultController {
  buf?: string
  pos?: number
  enqueue: (s) => void
}

/**
 * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities
 */
function getNewLineDelimitedJSONDecodingStream<T>() {
  return new TransformStream({
    start(controller) {
      controller.buf = ''
      controller.pos = 0
    },

    transform(chunk, controller) {
      if (controller.buf === undefined) {
        controller.buf = ''
      }
      if (controller.pos === undefined) {
        controller.pos = 0
      }
      controller.buf += chunk
      while (controller.pos < controller.buf.length) {
        if (controller.buf[controller.pos] === '\n') {
          const line = controller.buf.substring(0, controller.pos)
          const response = JSON.parse(line)
          controller.enqueue(response.result)
          controller.buf = controller.buf.substring(controller.pos + 1)
          controller.pos = 0
        } else {
          ++controller.pos
        }
      }
    }
  })

}

/**
 * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return
 * a sink that will call the callback on entity arrival
 * @param notifyCallback
 */
function getNotifyEntityArrivalSink<T>(notifyCallback) {
  return new WritableStream<T>({
    write(entity: <fim_suffix>) {
      notifyCallback(entity)
    }
  })
}

type Primitive = string | boolean | number;
type RequestPayload = Record<string, unknown>;
type FlattenedRequestPayload = Record<string, Primitive | Array<Primitive>>;

/**
 * Checks if given value is a plain object
 * Logic copied and adapted from below source: 
 * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js
 * @param  {unknown} value
 * @return {boolean}
 */
function isPlainObject(value) {
  const isObject =
    Object.prototype.toString.call(value).slice(8, -1) === ""Object"";
  const isObjLike = value !== null && isObject;

  if (!isObjLike || !isObject) {
    return false;
  }

  const proto = Object.getPrototypeOf(value);

  const hasObjectConstructor =
    typeof proto === ""object"" &&
    proto.constructor === Object.prototype.constructor;

  return hasObjectConstructor;
}

/**
 * Checks if given value is of a primitive type
 * @param  {unknown} value
 * @return {boolean}
 */
function isPrimitive(value) {
  return [""string"", ""number"", ""boolean""].some(t => typeof value === t);
}

/**
 * Checks if given primitive is zero-value
 * @param  {Primitive} value
 * @return {boolean}
 */
function isZeroValuePrimitive(value) {
  return value === false || value === 0 || value === """";
}

/**
 * Flattens a deeply nested request payload and returns an object
 * with only primitive values and non-empty array of primitive values
 * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto
 * @param  {RequestPayload} requestPayload
 * @param  {String} path
 * @return {FlattenedRequestPayload>}
 */
function flattenRequestPayload<T extends RequestPayload>(
  requestPayload,
  path = """"
) {
  return Object.keys(requestPayload).reduce(
    (acc, key) => {
      const value = requestPayload[key];
      const newPath = path ? [path, key].join(""."") : key;

      const isNonEmptyPrimitiveArray =
        Array.isArray(value) &&
        value.every(v => isPrimitive(v)) &&
        value.length > 0;

      const isNonZeroValuePrimitive =
        isPrimitive(value) && !isZeroValuePrimitive(value as Primitive);

      let objectToMerge = {};

      if (isPlainObject(value)) {
        objectToMerge = flattenRequestPayload(value as RequestPayload, newPath);
      } else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {
        objectToMerge = { [newPath]: value };
      }

      return { ...acc, ...objectToMerge };
    },
    {} as T
  ) as FlattenedRequestPayload;
}

/**
 * Renders a deeply nested request payload into a string of URL search
 * parameters by first flattening the request payload and then removing keys
 * which are already present in the URL path.
 * @param  {RequestPayload} requestPayload
 * @param  {string[]} urlPathParams
 * @return {string}
 */
export function renderURLSearchParams<T extends RequestPayload>(
  requestPayload,
  urlPathParams = []
) {
  const flattenedRequestPayload = flattenRequestPayload(requestPayload);

  const urlSearchParams = Object.keys(flattenedRequestPayload).reduce(
    (acc, key) => {
      // key should not be present in the url path as a parameter
      const value = flattenedRequestPayload[key];
      if (urlPathParams.find(f => f === key)) {
        return acc;
      }
      return Array.isArray(value)
        ? [...acc, ...value.map(m => [key, m.toString()])]
        : (acc = [...acc, [key, value.toString()]]);
    },
    [] as string[][]
  );

  return new URLSearchParams(urlSearchParams).toString();
}<fim_middle>",correct,4885
T,T,47dc91afa9f261374fcc8a999842718632fdfb4f,"<fim_prefix>export class ParseError extends Error {
  value: unknown;
  config: ParserConfig<any>;
  reason?: unknown;

  constructor(message, value, config, reason?) {
    let errorMessage = message;
    if (reason != null) {
      errorMessage += `\nReason:\n${String(reason)}`;
    }
    errorMessage += `\nValue:\n${JSON.stringify(value, null, 2)}`;
    super(errorMessage);
    this.value = value;
    this.config = config;
    this.reason = reason;
  }
}

export interface ParserConfig<T, TPreTransform = T> {
  /**
   * Parses the type using either a primitive value compatible with typeof
   * or a type guard function.
   */
  type: string | ((value) => value is TPreTransform);
  /** If set to true, null or undefined values will be parsed without error. */
  optional?: true;
  /**
   * Parser or a record of parsers for the enumerable fields of an object.
   *
   * If passed a record of parsers, a strict set of fields will be parsed using
   * a specific parse config for each field.
   *
   * If passed a single parser, an arbitrary set of fields will be parsed using
   * the same parse config for each field.
   *
   * If the value is not an object, this config field is ignored.
   */
  fields?:
    | {
        [K in keyof TPreTransform]: Parser<TPreTransform[K], any>;
      }
    | Parser<TPreTransform[keyof TPreTransform], any>;
  /**
   * Parser for the elements of a list.
   *
   * If the value is not an array, this config field is ignored.
   */
  elements?: TPreTransform extends unknown[] ? Parser<TPreTransform[number], any> : never;
  /**
   * Transforms the value when parsing using the provided function.
   *
   * If field or element parse configs include transforms, those transforms
   * will be applied prior to the overall transform function.
   */
  transform?: (value) => T;
}

export class Parser<T, TPreTransform = T> {
  config: ParserConfig<T, TPreTransform>;

  constructor(
    configypeof config === ""function"" ? config(this) : config;
  }

  /**
   * Parses a value using the provided config, and throws a ParseError if the
   * value could not be parsed.
   */
  parse(value): <fim_suffix> {
    const { optional, type, fields, elements, transform } = this.config;

    if (value == null) {
      if (optional != true) {
        throw new ParseError(""Required value was null, undefined, or unset"", value, this.config);
      } else {
        return value as any as T;
      }
    }

    if (typeof type === ""string"" && typeof value !== type) {
      throw new ParseError(""Value was not the expected type"", value, this.config);
    }

    if (typeof type === ""function"" && !type(value)) {
      throw new ParseError(
        ""Value was not the expected type; value did not pass type guard"",
        value,
        this.config
      );
    }

    let parsedPreTransform: any;

    if (elements && Array.isArray(value)) {
      parsedPreTransform = value.map((element) => elements.parse(element));
    } else if (fields && typeof value === ""object"" && !Array.isArray(value)) {
      parsedPreTransform = {};
      if (fields instanceof Parser) {
        for (const key in value) {
          parsedPreTransform[key] = fields.parse((value as any)[key]);
        }
      } else {
        for (const key in fields) {
          parsedPreTransform[key] = fields[key].parse((value as any)[key]);
        }
        for (const key in value) {
          if (!(key in fields)) {
            throw new ParseError(""Unexpected field in value"", value, this.config);
          }
        }
      }
    } else {
      parsedPreTransform = value;
    }

    if (transform) {
      try {
        return transform(parsedPreTransform as TPreTransform);
      } catch (transformErr) {
        throw new ParseError(
          ""Could not transform value while parsing"",
          parsedPreTransform,
          this.config,
          transformErr
        );
      }
    }

    return parsedPreTransform as T;
  }
}

export const stringParser = new Parser<string>({ type: ""string"" });
export const numberParser = new Parser<number>({ type: ""number"" });
export const booleanParser = new Parser<boolean>({ type: ""boolean"" });
export const unknownRecordParser = new Parser<Record<string, unknown>>({
  type: (value): value is Record<string, unknown> =>
    typeof value === ""object"" &&
    value != null &&
    Object.keys(value).every((key) => typeof key === ""string""),
});
export const dateStringParser = new Parser<Date, string>({
  type: ""string"",
  transform(dateString) {
    const parsedDate = new Date(dateString);
    if (parsedDate.toString() === ""Invalid Date"") {
      throw new Error(""Invalid date string"");
    }
    return parsedDate;
  },
});
export function makeEnumParser<TEnumType, TEnumObj extends Record<string, any>>(enumObj) {
  return new Parser<TEnumType>({
    type: (value): value is TEnumType => Object.values(enumObj).includes(value),
  });
}
<fim_middle>",correct,5292
TKey,TKey,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type: <fim_suffix>,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",correct,1707
TKey,TKey,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type: <fim_suffix>,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",correct,1710
TTT,TTT,ad15d5503f15235dd06d2738702575eb4dfe04e9,"<fim_prefix>export type XO = 'X' | 'O' | '';

export type Board = [[XO, XO, XO], [XO, XO, XO], [XO, XO, XO]];

export type Coordinate = {
  x: number;
  y: number;
};

export type TTT = {
  board: Board;
  lastPlay?: XO;
  winner?: XO;
  draw?: boolean;
};

export const isBoardFull = (x) => x.every((y) => y.every((z) => z));

export const newBoard = () =>
  [...Array(3)].map(() => Array(3).fill('')) as Board;

export const newTtt = (): <fim_suffix> => ({
  board: newBoard(),
});

export const getWinner = (x) => {
  const winners = new Set<XO>();

  for (let i = 0; i < 3; ++i) {
    if (x[0][i] && new Set([x[0][i], x[1][i], x[2][i]]).size === 1) {
      winners.add(x[0][i]);
    }
  }

  for (let i = 0; i < 3; ++i) {
    if (x[i][0] && new Set(x[i]).size === 1) {
      winners.add(x[i][0]);
    }
  }

  if (
    x[1][1] &&
    (new Set([x[0][0], x[1][1], x[2][2]]).size === 1 ||
      new Set([x[0][2], x[1][1], x[2][0]]).size === 1)
  ) {
    winners.add(x[1][1]);
  }

  if (!winners.size) {
    // completion check

    return isBoardFull(x) ? 'DRAW' : 'INCOMPLETE';
  }

  return winners.values().next().value as Exclude<XO, undefined>;
};

export const insertPlay = (x, c) => {
  if (x.board[c[0]][c[1]] || c[0] > 2 || c[1] > 2) return x;

  const winner = getWinner(x.board);
  if (['X', 'O', 'DRAW'].includes(winner.toUpperCase())) {
    if (winner === 'DRAW') {
      x.draw = true;
      return x;
    } else if (winner !== 'INCOMPLETE') {
      x.winner = winner;
      return x;
    }
  }

  x.lastPlay = x.lastPlay === 'X' ? 'O' : 'X';
  x.board[c[0]][c[1]] = x.lastPlay;

  const postWinner = getWinner(x.board);
  if (['X', 'O', 'DRAW'].includes(postWinner.toUpperCase())) {
    if (postWinner === 'DRAW') {
      x.draw = true;
      return x;
    } else if (postWinner !== 'INCOMPLETE') {
      x.winner = postWinner;
      return x;
    }
  }

  return x;
};
<fim_middle>",correct,2072
Terms,Terms,76a884ba965e8d7964d8852a0c0f228c1ae1d7ad,"<fim_prefix>type Language = 'en' | 'zh';

type Terms = {
  selfPick: string;
  noFlowers: string;
  flowers: string;
  commonHand: string;
  fullyConcealedHand: string;
  seatWind: string;
  roundWind: string;
  dragons: string;
  mixedOrphans: string;
  winByLastCatch: string;
  robbingKong: string;
  oneCompleteSetOfFlowers: string;
  twoCompleteSetOfFlowers: string;
  winByKong: string;
  mixedOneSuit: string;
  allInTriplets: string;
  flowerHand: string;
  smallDragon: string;
  allOneSuit: string;
  smallWind: string;
  greatDragon: string;
  greatWind: string;
  allHonors: string;
  orphans: string;
  thirteenOrphans: string;
  kaanKaanHand: string;
  winByDoubleKong: string;
  eightImmortalsCrossingTheSea: string;
  allKongs: string;
  nineGates: string;
  earthlyHand: string;
  heavenlyHand: string;
};

export default class Glossary {
  private static readonly CHINESE_MAP: Terms = {
    selfPick: '自摸',
    noFlowers: '無花',
    flowers: '正花',
    commonHand: '平糊',
    fullyConcealedHand: '門前清',
    seatWind: '門風',
    roundWind: '圈風',
    dragons: '中/發/白',
    mixedOrphans: '花幺',
    winByLastCatch: '海底撈月',
    robbingKong: '搶槓',
    oneCompleteSetOfFlowers: '一台花',
    twoCompleteSetOfFlowers: '兩台花',
    winByKong: '槓上自摸',
    mixedOneSuit: '混一色',
    allInTriplets: '對對糊',
    flowerHand: '花糊',
    smallDragon: '小三元',
    allOneSuit: '清一色',
    smallWind: '小四喜',
    greatDragon: '大三元',
    greatWind: '大四喜',
    allHonors: '字一色',
    orphans: '全幺九',
    thirteenOrphans: '十三幺',
    kaanKaanHand: '坎坎糊',
    winByDoubleKong: '槓上槓自摸',
    eightImmortalsCrossingTheSea: '八仙過海',
    allKongs: '十八羅漢',
    nineGates: '九子連環',
    earthlyHand: '地糊',
    heavenlyHand: '天糊',
  };

  private static readonly ENGLISH_MAP: Terms = {
    selfPick: 'self-pick',
    noFlowers: 'no flowers',
    flowers: 'flowers matching seat position',
    commonHand: 'common hand',
    fullyConcealedHand: 'fully concealed hand',
    seatWind: 'seat wind',
    roundWind: 'round wind',
    dragons: 'dragons',
    mixedOrphans: 'mixed orphans',
    winByLastCatch: 'win by last catch',
    robbingKong: 'robbing kong',
    oneCompleteSetOfFlowers: 'one complete set of flowers',
    twoCompleteSetOfFlowers: 'two complete set of flowers',
    winByKong: 'win by Kong',
    mixedOneSuit: 'mixed one suit',
    allInTriplets: 'all in triplets',
    flowerHand: 'flower hand',
    smallDragon: 'small dragon',
    allOneSuit: 'all one suit',
    smallWind: 'small wind',
    greatDragon: 'great dragon',
    greatWind: 'great wind',
    allHonors: 'all honors',
    orphans: 'orphans',
    thirteenOrphans: 'thirteen orphans',
    kaanKaanHand: 'kaan kaan hand',
    winByDoubleKong: 'win by double Kong',
    eightImmortalsCrossingTheSea: 'eight immortals crossing the sea',
    allKongs: 'all Kongs',
    nineGates: 'nine gates',
    earthlyHand: 'earthly hand',
    heavenlyHand: 'heavenly hand',
  };

  private static language: Language = 'en';

  public static get(): <fim_suffix> {
    if (this.language === 'en') {
      return this.ENGLISH_MAP;
    } else if (this.language === 'zh') {
      return this.CHINESE_MAP;
    } else {
      throw new Error('Language setting has not been configured appropriately.');
    }
  }

  public static setLanguage(languageInput) {
    if (languageInput === 'zh' || languageInput === 'en') {
      this.language = languageInput;
    } else {
      throw new Error('Invalid input of language setting.');
    }
  }
}
<fim_middle>",correct,2149
Thing,Thing,c638aa7811a23127f92dc64cfed37e179ef1cc7f,"<fim_prefix>export const Kind = 'Core#Thing';

/**
 * An interface describing a base metadata of a thing.
 */
export declare interface IThing {
  /**
   * The data kind. The application ignores the input with an unknown `kind`, unless it can be determined from the context.
   */
  kind?: typeof Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;
}

export class Thing {
  kind = Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;

  /**
   * Returns one in this order:
   * - displayName
   * - name
   * - 'Unnamed object'
   */
  get renderLabel() {
    return this.displayName || this.name || 'Unnamed object';
  }

  /**
   * Creates a basic description from a name.
   */
  static fromName(name): <fim_suffix> {
    const thing = new Thing({
      name,
      kind: Kind,
    });
    return thing;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IThing;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not a thing.
   */
  new(init) {
    if (!Thing.isThing(init)) {
      throw new Error(`Not a thing.`);
    }
    const { description, name, version, displayName } = init;
    this.kind = Kind;
    this.name = name;
    this.displayName = displayName;
    this.description = description;
    this.version = version;
  }

  /**
   * Checks whether the input is a definition of a server.
   */
  static isThing(input) {
    const typed = input as IThing;
    if (input && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IThing = {
      kind: Kind,
    };
    if (typeof this.name === 'string') {
      result.name = this.name;
    }
    if (typeof this.displayName === 'string') {
      result.displayName = this.displayName;
    }
    if (this.description) {
      result.description = this.description;
    }
    if (this.version) {
      result.version = this.version;
    }
    return result;
  }
}
<fim_middle>",correct,1812
Thing,Thing,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source): <fim_suffix> {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4927
Thing,Thing,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source: <fim_suffix>) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4928
Thing,Thing,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target: <fim_suffix>, source) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4929
Tile,Tile,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?): <fim_suffix> {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,815
Tile,Tile,b1ab8c4be427c0afaf3d2a41ca821482dd787a9e,"<fim_prefix>type DotNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per dot (36)
type BamNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per bam (36)
type CrakNumber = ""1"" | ""2"" | ""3"" | ""4"" | ""5"" | ""6"" | ""7"" | ""8"" | ""9""; // 4 tiles per crak (36)
type WindNumber = ""East"" | ""West"" | ""South"" | ""North""; // 4 tiles per wind (16)
type DragonNumber = ""White"" | ""Green"" | ""Red""; // 4 tiles per wind (12)
type FlowerNumber = ""Rose"" | ""Lily"" | ""Tulip"" | ""Juniper""; // 2 tiles per flower (8)

export type Number = DotNumber | BamNumber | CrakNumber | WindNumber | DragonNumber | FlowerNumber;

export enum Suit {
  Dot = ""DOT"",
  Bam = ""BAM"",
  Crak = ""CRAK"",
  Wind = ""WIND"",
  Dragon = ""DRAGON"",
  Flower = ""FLOWER"",
}

export default class Tile {
  x: number;
  y: number;
  z: number;
  number: Number;
  suit: Suit;
  static dotNumbers: DotNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static bamNumbers: BamNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static crakNumbers: CrakNumber[] = [""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9""];
  static windNumbers: WindNumber[] = [""East"", ""West"", ""South"", ""North""];
  static dragonNumbers: DragonNumber[] = [""White"", ""Green"", ""Red""];
  static flowerNumbers: FlowerNumber[] = [""Rose"", ""Lily"", ""Tulip"", ""Juniper""];

  constructor(number, suit) {
    this.number = number;
    this.suit = suit;
    this.x = -10
    this.y = -10
    this.z = -10
  }

  place({ z, x, y }) {
    this.z = z
    this.x = x
    this.y = y
  }

  get tileCells() {
    return [
      {
        z: this.z,
        x: this.x,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y,
      },
      {
        z: this.z,
        x: this.x,
        y: this.y + 1,
      },
      {
        z: this.z,
        x: this.x + 1,
        y: this.y + 1,
      },
    ];
  }

  get id() {
    return `${this.suit}_${this.number}_${this.x}_${this.y}_${this.z}`;
  }

  tileIsAdjacent(tile: <fim_suffix>) {
    const t1Cells = this.tileCells;
    const t2Cells = tile.tileCells;

    let isAdjacent = false;

    t1Cells.forEach((t1) => {
      t2Cells.forEach((t2) => {
        // tile is above or below
        if ((t1.z === t2.z - 1 || t1.z === t2.z + 1) && t1.x === t2.x && t1.y === t2.y) {
          isAdjacent = true;
        }

        // tile is to the left or the right
        if (t1.z === t2.z && t1.y === t2.y && (t1.x === t2.x - 1 || t1.x === t2.x + 1)) {
          isAdjacent = true;
        }
      });
    });

    return isAdjacent;
  }
}
<fim_middle>",correct,1117
Time,Time,c6f7caaa0590e6613ea1d397ac2df028f848091b,"<fim_prefix>interface Time {
  hours: number
  minutes: number
}

export const parseTime = (time) => {
  const values = (time || '').split(':')
  if (values.length >= 2) {
    let hours = Number.parseInt(values[0], 10)
    const minutes = Number.parseInt(values[1], 10)
    const timeUpper = time.toUpperCase()
    if (timeUpper.includes('AM') && hours === 12) {
      hours = 0
    } else if (timeUpper.includes('PM') && hours !== 12) {
      hours += 12
    }
    return {
      hours,
      minutes,
    }
  }

  return null
}

export const compareTime = (time1, time2) => {
  const value1 = parseTime(time1)
  if (!value1) return -1
  const value2 = parseTime(time2)
  if (!value2) return -1
  const minutes1 = value1.minutes + value1.hours * 60
  const minutes2 = value2.minutes + value2.hours * 60
  if (minutes1 === minutes2) {
    return 0
  }
  return minutes1 > minutes2 ? 1 : -1
}

export const padTime = (time) => {
  return `${time}`.padStart(2, '0')
}
export const formatTime = (time: <fim_suffix>) => {
  return `${padTime(time.hours)}:${padTime(time.minutes)}`
}

export const nextTime = (time, step) => {
  const timeValue = parseTime(time)
  if (!timeValue) return ''

  const stepValue = parseTime(step)
  if (!stepValue) return ''

  const next = {
    hours: timeValue.hours,
    minutes: timeValue.minutes,
  }
  next.minutes += stepValue.minutes
  next.hours += stepValue.hours
  next.hours += Math.floor(next.minutes / 60)
  next.minutes = next.minutes % 60
  return formatTime(next)
}
<fim_middle>",correct,1940
Tokens,Tokens,4e0101374b9ed16a03bd794fbb67ac927c7f589a,"<fim_prefix>function buildParenthesizedExpression(token) {
    if (!Array.isArray(token)) {
        throw Error(""accident token type"");
    }
    const inner_expression = buildExpression(token);
    if (!inner_expression) {
        throw Error(""empty expression"");
    }
    const current_expression: Expression = {
        type: ""ParenthesizedExpression"",
        expression: inner_expression,
    };
    return current_expression;
}
function buildNumericLiteralExpression(token) {
    if (typeof token !== ""number"") {
        throw Error(""accident token type"");
    }
    const current_expression: Expression = {
        type: ""NumericLiteral"",
        value: token,
    };
    return current_expression;
}
export default function calculate(s) {
    const tokens = tokenize(s);

    const ast = buildExpression(tokens);

    return evaluate(ast);
}
export function evaluate(ast) {
    if (ast.type === ""NumericLiteral"") {
        return ast.value;
    }
    if (ast.type === ""UnaryExpression"") {
        if (ast.operator === ""-"") {
            return -1 * evaluate(ast.argument);
        }
    }
    if (ast.type === ""BinaryExpression"") {
        if (ast.operator === ""-"") {
            return evaluate(ast.left) - evaluate(ast.right);
        }
        if (ast.operator === ""*"") {
            return evaluate(ast.left) * evaluate(ast.right);
        }
        if (ast.operator === ""+"") {
            return evaluate(ast.left) + evaluate(ast.right);
        }

        if (ast.operator === ""/"") {
            const num1 = evaluate(ast.left);
            const num2 = evaluate(ast.right);
            const sign = Math.sign(num2) * Math.sign(num1);
            return sign * Math.floor(Math.abs(num1) / Math.abs(num2));
            //整数除法
        }
    }
    if (ast.type === ""ParenthesizedExpression"") {
        return evaluate(ast.expression);
    }
    throw Error(""not support expression"");
}
type Token = Tokens extends (infer P)[] ? P : never;

type Tokens = Array<string | number | Tokens>;
function getTokenType(token) {
    const tokentype: TokenType = typeof token === ""number""
        ? TokenType[""number""]
        : typeof token === ""string""
        ? TokenType[""operator""]
        : Array.isArray(token)
        ? TokenType[""parentheses""]
        : TokenType[""unknown""];
    return tokentype;
}
export function tokenize(s): <fim_suffix> {
    const tokens: Tokens = [];
    const stack: Tokens[] = [tokens];
    for (let i = 0; i < s.length; i++) {
        const value = s[i];
        if (/\d/.test(value)) {
            //只处理整数
            const digits: string[] = [value];

            while (/\d/.test(s[i + 1])) {
                digits.push(s[i + 1]);
                i++;
            }

            const num = Number(digits.join(""""));
            stack[stack.length - 1].push(num);
        }
        if ([""+"", ""-"", ""/"", ""*""].includes(value)) {
            stack[stack.length - 1].push(value);
        }
        if (value === ""("") {
            stack.push([]);
        }
        if (value === "")"") {
            if (stack.length <= 0) throw Error(""parentheses mismatch"");
            const last = stack[stack.length - 1];
            stack.pop();
            stack[stack.length - 1].push(last);
        }
    }
    if (stack.length !== 1) throw Error(""parentheses mismatch"");
    return tokens;
}
export function buildExpression(tokens) {
    if (tokens.length === 0) {
        throw Error(""empty expression"");
    }
    let state = State.initial;
    const pendingtype: ExpressionType[] = [];
    const pendingoperator: ExpressionOperator[] = [];

    const pendingleft: Expression[] = [];
    for (const token of tokens) {
        const tokentype: TokenType = getTokenType(token);
        if (tokentype === TokenType.unknown) throw Error(""unknown token"");
        state = transform[state][tokentype] ?? State.unknown;
        if (state === State.unknown) throw Error(""unknown state"");
        if (state === State.unary) {
            pendingtype.push(""UnaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
        if ([State.parentheses, State.number].includes(state)) {
            const current_expression: Expression = State.number === state
                ? buildNumericLiteralExpression(token)
                : buildParenthesizedExpression(token);
            if (pendingtype.length === 0 && pendingoperator.length === 0) {
                pendingleft.push(current_expression);
            } else {
                const type = pendingtype[pendingtype.length - 1];
                pendingtype.pop();
                const operator = pendingoperator[pendingoperator.length - 1];
                pendingoperator.pop();
                if (type === ""BinaryExpression"") {
                    //优先级更高

                    const left = pendingleft[pendingleft.length - 1];

                    if (
                        left.type === ""BinaryExpression"" &&
                        [""*"", ""/""].includes(operator) &&
                        [""+"", ""-""].includes(left.operator)
                    ) {
                        left.right = {
                            type: ""BinaryExpression"",
                            operator: operator as BinaryExpression[""operator""],
                            left: left.right,
                            right: current_expression,
                        };
                    } else {
                        pendingleft.pop();
                        pendingleft.push({
                            operator: operator as BinaryExpression[""operator""],
                            type: ""BinaryExpression"",
                            left,
                            right: current_expression,
                        });
                    }
                }
                if (type === ""UnaryExpression"") {
                    pendingleft.push({
                        operator: operator as UnaryExpression[""operator""],
                        type: ""UnaryExpression"",
                        argument: current_expression,
                    });
                }
            }
        }

        if (state === State.binary) {
            pendingtype.push(""BinaryExpression"");
            if (typeof token === ""string"") {
                pendingoperator.push(token as ExpressionOperator);
            } else {
                throw Error(""accident token type"");
            }
        }
    }
    if (valid_end_states.includes(state) && pendingleft.length) {
        return pendingleft[0];
    } else {
        throw new Error(""unexpected end state or empty expression"");
    }
}
const enum State {
    ""initial"",
    ""unary"",
    ""parentheses"",
    ""number"",
    ""binary"",
    ""unknown"",
}
const valid_end_states = [State[""parentheses""], State[""number""]];
const enum TokenType {
    ""number"",
    ""operator"",
    ""parentheses"",
    ""unknown"",
}
const transform: Record<State, Record<TokenType, State>> = {
    [State.initial]: {
        [TokenType.operator]: State.unary,
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.unary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.binary]: {
        [TokenType.number]: State.number,
        [TokenType.parentheses]: State.parentheses,
    },
    [State.parentheses]: {
        [TokenType.operator]: State.binary,
    },
    [State.number]: {
        [TokenType.operator]: State.binary,
    },
} as Record<State, Record<TokenType, State>>;
type ExpressionType = Expression[""type""];

type ExpressionOperator =
    | UnaryExpression[""operator""]
    | BinaryExpression[""operator""];
type Expression =
    | BinaryExpression
    | NumericLiteral
    | UnaryExpression
    | ParenthesizedExpression;
interface ParenthesizedExpression {
    type: ""ParenthesizedExpression"";
    expression: Expression;
}
interface NumericLiteral {
    type: ""NumericLiteral"";
    value: number;
}
interface UnaryExpression {
    type: ""UnaryExpression"";
    operator: ""void"" | ""throw"" | ""delete"" | ""!"" | ""+"" | ""-"" | ""~"" | ""typeof"";
    argument: Expression;
}
interface BinaryExpression {
    type: ""BinaryExpression"";
    operator:
        | ""+""
        | ""-""
        | ""/""
        | ""%""
        | ""*""
        | ""**""
        | ""&""
        | ""|""
        | "">>""
        | "">>>""
        | ""<<""
        | ""^""
        | ""==""
        | ""===""
        | ""!=""
        | ""!==""
        | ""in""
        | ""instanceof""
        | "">""
        | ""<""
        | "">=""
        | ""<=""
        | ""|>"";
    left: Expression;
    right: Expression;
}
<fim_middle>",correct,3744
Triangle,Triangle,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle: <fim_suffix>,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3644
Triangle,Triangle,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle: <fim_suffix>,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3654
Triangle,Triangle,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
) => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle: <fim_suffix>) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3655
Triangle,Triangle,719d8ef7e693a43b35201b8bfe890e01809031ca,"<fim_prefix>const DEFAULT_AVERAGE_DIVISOR = 2

interface Point {
	x: number
	y: number
}

// Corners 1 and 3 form the hypotenuse
export interface Triangle {
	corner1: Point
	corner2: Point
	corner3: Point
}

export const makeTriangle = (
	x1,
	y1,
	x2,
	y2,
	x3,
	y3
): <fim_suffix> => {
	return {
		corner1: { x: x1, y: y1 },
		corner2: { x: x2, y: y2 },
		corner3: { x: x3, y: y3 },
	}
}

export const copyTriangle = (triangle) => {
	return makeTriangle(
		triangle.corner1.x,
		triangle.corner1.y,
		triangle.corner2.x,
		triangle.corner2.y,
		triangle.corner3.x,
		triangle.corner3.y
	)
}

const getHypotenuseMidpoint = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => ({
	x: average(triangle.corner1.x, triangle.corner3.x, averageDivisor),
	y: average(triangle.corner1.y, triangle.corner3.y, averageDivisor),
})

export const lerp = (point1, point2, percent) => {
	return {
		x: lerp1D(point1.x, point2.x, percent),
		y: lerp1D(point1.y, point2.y, percent),
	}
}

const lerp1D = (x1, x2, percent) =>
	x1 + (x2 - x1) * percent

const average = (
	x1,
	x2,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => (x1 + x2) / averageDivisor

export const splitTriangle = (
	triangle,
	averageDivisor = DEFAULT_AVERAGE_DIVISOR
) => {
	const midpoint = getHypotenuseMidpoint(triangle, averageDivisor)

	const triangle1 = {
		corner1: triangle.corner1,
		corner2: midpoint,
		corner3: triangle.corner2,
	}

	const triangle2 = {
		corner1: triangle.corner2,
		corner2: midpoint,
		corner3: triangle.corner3,
	}

	return [triangle1, triangle2]
}
<fim_middle>",correct,3656
Type,Type,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing): <fim_suffix> {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4925
Type,Type,fcdbbcb545071af17a684020e478305f1e8d06c9,"<fim_prefix>export type AlmostAnything = string | number | symbol | Record<any, any> | Array<any> | Object

export function isObject(item): item is Object {
	return item && item !== null && typeof item === ""object"" && !Array.isArray(item)
}

export function deepMerge<Thing extends Object>(target, source) {
	let output = Object.assign({}, target)
	if ((isObject(target) && isObject(source)) || (Array.isArray(target) && Array.isArray(source))) {
		for (const key in source) {
			if (isObject(source[key])) {
				if (!(key in target)) {
					Object.assign(output, { [key]: source[key] })
				} else {
					output[key] = deepMerge(target[key], source[key])
				}
			} else {
				Object.assign(output, { [key]: source[key] })
			}
		}
	}
	// if it was originally an array, return an array
	if (Array.isArray(target) && Array.isArray(source)) {
		return Object.values(output) as any as Thing
	}

	return output
}

// a deep clone of anything
export function deepClone<Type = AlmostAnything>(thing: <fim_suffix>) {
	if (thing instanceof Date) {
		return new Date(thing.getTime()) as any as Type
	}
	if (thing instanceof RegExp) {
		return new RegExp(thing) as any as Type
	}
	// must be an object
	if (isObject(thing)) {
		const cloned: Type = Object.create(thing as Object)
		for (const key in thing) {
			if ((thing as Object).hasOwnProperty(key)) {
				cloned[key] = deepClone(thing[key])
			}
		}
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an array, return an array
		if (Array.isArray(thing)) {
			return Object.values(cloned) as any as Type
		}
		// if it was originally an object, return an object
		return cloned
	}
	return thing
}

export function isEqual(a, b) {
	if (a === b) {
		return true
	}
	if (a instanceof Date && b instanceof Date) {
		return a.getTime() === b.getTime()
	}
	if (a instanceof RegExp && b instanceof RegExp) {
		return a.toString() === b.toString()
	}
	if (Array.isArray(a) && Array.isArray(b)) {
		if (a.length !== b.length) {
			return false
		}
		for (let i = 0; i < a.length; i++) {
			if (!isEqual(a[i], b[i])) {
				return false
			}
		}
		return true
	}
	if (isObject(a) && isObject(b)) {
		const aKeys = Object.keys(a)
		const bKeys = Object.keys(b)
		if (aKeys.length !== bKeys.length) {
			return false
		}
		for (const key of aKeys) {
			if (!isEqual(a[key], b[key])) {
				return false
			}
		}
		return true
	}
	return false
}

export const convertToString = (input) =>
	typeof input === ""object"" ? JSON.stringify(input) : typeof input === ""function"" ? input.toString() : String(input)
export const hash = function (input) {
	/* Simple hash function. */
	let a = 1,
		c = 0,
		h,
		o
	if (input) {
		a = 0
		/*jshint plusplus:false bitwise:false*/
		for (h = input.length - 1; h >= 0; h--) {
			o = input.charCodeAt(h)
			a = ((a << 6) & 268435455) + o + (o << 14)
			c = a & 266338304
			a = c !== 0 ? a ^ (c >> 21) : a
		}
	}
	return String(a)
}

export const convertStringToType = (inp) => {
	try {
		// try to parse it as JSON (array or object)
		return JSON.parse(inp)
	} catch (e) {
		// if that fails, try...

		// ...as a number
		const num = Number(inp)
		if (!isNaN(num)) {
			return num
		}
		// ...as a boolean
		if (inp === ""true"") {
			return true
		}
		if (inp === ""false"") {
			return false
		}
		// ...as a string
		return inp
	}
}

export const genUID = () => Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)

export const isAsyncFunction = (fn) => typeof fn === ""function"" && fn.constructor.name === ""AsyncFunction""
<fim_middle>",correct,4926
TypeDef,TypeDef,8dd4eba467cc4f8c283713bdfc23d3b71e87f31d,"<fim_prefix>export type BasePostMessageCallbackProps<T> = {
  onMessage?: (message) => void
  onInvalidMessageError?: (message, error) => void
}

// This is an internal error. Thrown when we are decoding a post message's
// metadata and we encourntered a missing field or an invalid value. This
// likely means there has been a change to the definition of a post message
// that we do not know about.
export class PostMessageFieldDecodeError extends Error {
  public messageType: string
  public field: string
  public expectedType: TypeDef
  public gotValue: unknown

  constructor(messageType, field, expectedType: <fim_suffix>, gotValue) {
    super(`Unable to decode '${field}' from '${messageType}'`)

    this.messageType = messageType
    this.field = field
    this.expectedType = expectedType
    this.gotValue = gotValue

    Object.setPrototypeOf(this, PostMessageFieldDecodeError.prototype)
  }
}

// This is an internal error. Thrown when we get a post message we don't konw
// about. This likely means there is a new post message that this package needs
// to define.
export class PostMessageUnknownTypeError extends Error {
  public postMessageType: string

  constructor(postMessageType) {
    super(`Unknown post message: ${postMessageType}`)

    this.postMessageType = postMessageType

    Object.setPrototypeOf(this, PostMessageUnknownTypeError.prototype)
  }
}

export type MessageEventData = {
  mx?: boolean
  metadata?: Metadata
  type?: string
}

export type Value = string | number
export type NestedValue = Record<string, Value>
export type TypeDef = string | Array<string> | Record<string, string>
export type Metadata = Record<string, Value | NestedValue>

export function assertMessageProp(
  container,
  postMessageType,
  field,
  expectedType,
) {
  const value = container[field]

  const valueIsDefined = typeof value !== ""undefined""
  const valueIsString = typeof value === ""string""
  const valueIsNumber = typeof value === ""number""
  const valueIsObject = typeof value === ""object"" && !Array.isArray(value)

  const typeIsString = expectedType === ""string""
  const typeIsNumber = expectedType === ""number""
  const typeIsArray = expectedType instanceof Array
  const typeIsObject = typeof expectedType === ""object"" && !Array.isArray(expectedType)

  if (!valueIsDefined) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsString && !valueIsString) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsNumber && !valueIsNumber) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsArray && !(valueIsString && expectedType.includes(value))) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && !valueIsObject) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && valueIsObject) {
    Object.keys(expectedType).forEach((field) => {
      assertMessageProp(value, postMessageType, field, expectedType[field])
    })
  }
}
<fim_middle>",correct,2991
U,U,a3c87e22c30072055cfbcdaba851bef6a0244dc3,"<fim_prefix>// /**
//  * DTOs must extends this class
//  */
export class DTOMapper {
  dtoMapperProfile () {
    return undefined;
  };
}

/**
 * DTO Mapper Option Type
 * @param T - Type of class
 */
export interface IDtoMapperOption<T> {
  mapToClass?: IDtoMapperToClass<T>;
  mapToPath?: IDtoMapperToPath;
}

// Mapping to class type
export interface IDtoMapperToClass<T> {
  mapFromKey: string;
  dtoClass: new () => T;
}
// mapping to path type
export interface IDtoMapperToPath {
  mapFromKey: string;
  valueFromPath: string;
}

/**
 * 
 * Map source object to destination class
 * 
 * @param {T} source - Source object to map from
 * @param {U} destination - Destination class to map to
 * @returns {U} An object of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);
/**
 * 
 * Map source object to destination class
 * 
 * @param {T[]} source  - Source array of objects to map from
 * @param {U} destination - Destination class to which map each object from the source
 * @returns {U[]} An array of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);

export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
) {
  if ( Array.isArray( source ) ) {
    return source.map( s => {
      return mapper( s, new destination() );
    } );
  }
  return mapper( source, new destination() );
}

// Mapper to map source to destination
function mapper<T, U extends DTOMapper> ( source, destination ): <fim_suffix> {
  Object.keys( destination ).forEach( key => {
    destination[ key as keyof U ] = <any>source[ key as keyof T ];
    if ( destination.dtoMapperProfile()?.length ) {
      destination.dtoMapperProfile()?.forEach( option => {
        // To class mapping (recursively)
        if ( option.mapToClass?.mapFromKey === key ) {
          if ( source[ key as keyof T ] ) {
            if ( Array.isArray( source[ key as keyof T ] ) ) {
              const result = Array.from( source[ key as keyof T ] as any ).map( el => {
                return mapper( el, new option.mapToClass!.dtoClass() );
              } );
              destination[ key as keyof U ] = result as any;
            } else {
              const result = mapper( source[ key as keyof T ], new option.mapToClass.dtoClass() );
              destination[ key as keyof U ] = result as any;
            }
          }
          // To value mapping
        } else if ( option.mapToPath?.mapFromKey === key ) {
          let sourceVal: any;
          if ( Array.isArray( option.mapToPath.valueFromPath.split( '.' ) ) ) {
            const paths = option.mapToPath.valueFromPath.split( '.' );
            paths.forEach( p => {
              if ( !sourceVal ) {
                sourceVal = source[ p as keyof T ];
              } else {
                sourceVal = sourceVal[ p ];
              }
            } );
          } else {
            sourceVal = <any>source[ option.mapToPath.valueFromPath as keyof T ];
          }

          destination[ key as keyof U ] = sourceVal;
        }
      } );
    }
  } );
  return destination;
}<fim_middle>",correct,2928
U,U,a3c87e22c30072055cfbcdaba851bef6a0244dc3,"<fim_prefix>// /**
//  * DTOs must extends this class
//  */
export class DTOMapper {
  dtoMapperProfile () {
    return undefined;
  };
}

/**
 * DTO Mapper Option Type
 * @param T - Type of class
 */
export interface IDtoMapperOption<T> {
  mapToClass?: IDtoMapperToClass<T>;
  mapToPath?: IDtoMapperToPath;
}

// Mapping to class type
export interface IDtoMapperToClass<T> {
  mapFromKey: string;
  dtoClass: new () => T;
}
// mapping to path type
export interface IDtoMapperToPath {
  mapFromKey: string;
  valueFromPath: string;
}

/**
 * 
 * Map source object to destination class
 * 
 * @param {T} source - Source object to map from
 * @param {U} destination - Destination class to map to
 * @returns {U} An object of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);
/**
 * 
 * Map source object to destination class
 * 
 * @param {T[]} source  - Source array of objects to map from
 * @param {U} destination - Destination class to which map each object from the source
 * @returns {U[]} An array of type U
 */
export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
);

export function dtoMapper<T, U extends DTOMapper> (
  source,
  destination
) {
  if ( Array.isArray( source ) ) {
    return source.map( s => {
      return mapper( s, new destination() );
    } );
  }
  return mapper( source, new destination() );
}

// Mapper to map source to destination
function mapper<T, U extends DTOMapper> ( source, destination: <fim_suffix> ) {
  Object.keys( destination ).forEach( key => {
    destination[ key as keyof U ] = <any>source[ key as keyof T ];
    if ( destination.dtoMapperProfile()?.length ) {
      destination.dtoMapperProfile()?.forEach( option => {
        // To class mapping (recursively)
        if ( option.mapToClass?.mapFromKey === key ) {
          if ( source[ key as keyof T ] ) {
            if ( Array.isArray( source[ key as keyof T ] ) ) {
              const result = Array.from( source[ key as keyof T ] as any ).map( el => {
                return mapper( el, new option.mapToClass!.dtoClass() );
              } );
              destination[ key as keyof U ] = result as any;
            } else {
              const result = mapper( source[ key as keyof T ], new option.mapToClass.dtoClass() );
              destination[ key as keyof U ] = result as any;
            }
          }
          // To value mapping
        } else if ( option.mapToPath?.mapFromKey === key ) {
          let sourceVal: any;
          if ( Array.isArray( option.mapToPath.valueFromPath.split( '.' ) ) ) {
            const paths = option.mapToPath.valueFromPath.split( '.' );
            paths.forEach( p => {
              if ( !sourceVal ) {
                sourceVal = source[ p as keyof T ];
              } else {
                sourceVal = sourceVal[ p ];
              }
            } );
          } else {
            sourceVal = <any>source[ option.mapToPath.valueFromPath as keyof T ];
          }

          destination[ key as keyof U ] = sourceVal;
        }
      } );
    }
  } );
  return destination;
}<fim_middle>",correct,2929
User,User,bb8faf8f1fabd1682a5c59c52cae3e16456eff95,"<fim_prefix>// This file was autogenerated. Please do not change.
// All changes will be overwrited on commit.
export interface IUser {
    admin?: boolean;
    date_password?: string;
    email?: string;
    enabled?: boolean;
    id?: string;
    username?: string;
}

export default class User {
    readonly _admin: boolean | undefined;

    get admin() {
        return this._admin;
    }

    readonly _date_password: string | undefined;

    get datePassword() {
        return this._date_password;
    }

    readonly _email: string | undefined;

    get email() {
        return this._email;
    }

    readonly _enabled: boolean | undefined;

    get enabled() {
        return this._enabled;
    }

    readonly _id: string | undefined;

    get id() {
        return this._id;
    }

    readonly _username: string | undefined;

    get username() {
        return this._username;
    }

    constructor(props) {
        if (typeof props.admin === 'boolean') {
            this._admin = props.admin;
        }
        if (typeof props.date_password === 'string') {
            this._date_password = props.date_password.trim();
        }
        if (typeof props.email === 'string') {
            this._email = props.email.trim();
        }
        if (typeof props.enabled === 'boolean') {
            this._enabled = props.enabled;
        }
        if (typeof props.id === 'string') {
            this._id = props.id.trim();
        }
        if (typeof props.username === 'string') {
            this._username = props.username.trim();
        }
    }

    serialize() {
        const data: IUser = {};
        if (typeof this._admin !== 'undefined') {
            data.admin = this._admin;
        }
        if (typeof this._date_password !== 'undefined') {
            data.date_password = this._date_password;
        }
        if (typeof this._email !== 'undefined') {
            data.email = this._email;
        }
        if (typeof this._enabled !== 'undefined') {
            data.enabled = this._enabled;
        }
        if (typeof this._id !== 'undefined') {
            data.id = this._id;
        }
        if (typeof this._username !== 'undefined') {
            data.username = this._username;
        }
        return data;
    }

    validate() {
        const validate = {
            id: !this._id
                ? true
                : typeof this._id === 'string' && !this._id
                ? true
                : this._id,
            username: !this._username
                ? true
                : typeof this._username === 'string' && !this._username
                ? true
                : this._username,
            email: !this._email
                ? true
                : typeof this._email === 'string' && !this._email
                ? true
                : this._email,
            date_password: !this._date_password
                ? true
                : typeof this._date_password === 'string' &&
                  !this._date_password
                ? true
                : this._date_password,
            enabled: !this._enabled ? true : typeof this._enabled === 'boolean',
            admin: !this._admin ? true : typeof this._admin === 'boolean',
        };
        const isError: string[] = [];
        Object.keys(validate).forEach((key) => {
            if (!(validate as any)[key]) {
                isError.push(key);
            }
        });
        return isError;
    }

    update(props): <fim_suffix> {
        return new User({...this.serialize(), ...props});
    }
}
<fim_middle>",correct,841
V,V,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value): <fim_suffix> {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1776
V,V,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value): <fim_suffix> {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1779
V,V,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value): <fim_suffix> {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1782
V,V,84e7170332337373aec4d4c491e926c95ead7088,"<fim_prefix>// TODO: Replace it with the null coalescing operator when we get it

export function nullCoalesce(...items) {
  for (const item of items) {
    if (item != null) {
      return item;
    }
  }
  return null;
}

export function emptyIfNull(s) {
  if (s == null) {
    return '';
  } else {
    return '' + s;
  }
}

export function nullIfEmpty(s) {
  if (s == null) {
    return null;
  } else if (!s.length) {
    return null;
  } else {
    return s;
  }
}

export type RecursivePartial<T> = {
  [P in keyof T]?: RecursivePartial<T[P]>;
};

export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;

export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export class ExtendedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value): <fim_suffix> {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}

export class ExtendedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value
   * @param key - used to identify value
   * @param value - default key value
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    super.set(key, value);
    return value;
  }
}


/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedWeakMap<K extends object, V> extends WeakMap<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

/** Return key value, if it does not exist call value accessor
 * Added for clarity on purpose
 * https://github.com/SBRG/kg-prototypes/pull/1387#discussion_r756414705
 */
export class LazyLoadedMap<K, V> extends Map<K, V> {
  /**
   * Return key value if it exists in the map
   * otherwise use default value accessor
   * @param key - used to identify value
   * @param value - value or function to calculate it
   */
  getSet(key, value) {
    if (this.has(key)) {
      return super.get(key);
    }
    const loadedValue = value instanceof Function ? value() : value;
    super.set(key, loadedValue);
    return loadedValue;
  }
}

export const frozenEmptyObject = Object.freeze({});
<fim_middle>",correct,1785
Value,Value,3b28605856ba363437dc8c991572f8f009158f06,"<fim_prefix>interface NestedRecord<V = any> {
  [k: string | number]: NestedRecord<V> | V
}

export function assignNestedKeys<Object = NestedRecord, Value = any>(
  obj,
  keys,
  value: <fim_suffix>,
) {
  let temp: Record<string, any> = obj
  keys.forEach((k, index) => {
    if (index === keys.length - 1) {
      if (temp && typeof temp === ""object"") {
        temp[k] = value
      }
    } else if (temp && typeof temp === ""object"") {
      if (!temp[k]) {
        temp[k] = {}
      }
      temp = temp[k]
    }
  })
}

export function walkObjectDeep<Value, T = Record<string, any>>(
  obj,
  callback,
  shouldSkipPaths?,
) {
  function recurse(object, parentKeys = []) {
    Object.entries(object).forEach(([key, value]) => {
      if (
        (!shouldSkipPaths ||
          (shouldSkipPaths && !shouldSkipPaths([...parentKeys, key]))) &&
        value !== undefined &&
        value !== null
      ) {
        if (typeof value === ""object"" && Object.keys(value).length > 0) {
          recurse(value, [...parentKeys, key])
        } else {
          callback([...parentKeys, key], value, object)
        }
      }
    })
  }
  recurse(obj)
}

function getCssValue(keys, value) {
  if (typeof value === ""number"") {
    if (
      [""lineHeight"", ""fontWeight"", ""opacity"", ""zIndex""].some((prop) =>
        keys.includes(prop),
      )
    ) {
      // CSS property that are unitless
      return value
    }
    const lastKey = keys[keys.length - 1]
    if (lastKey.toLowerCase().includes(""opacity"")) {
      // opacity values are unitless
      return value
    }
    return `${value}px`
  }
  return value
}

export function cssVarsParser<T extends Record<string, any>>(
  theme,
  options?,
) {
  const { prefix, basePrefix = """", shouldSkipGeneratingVar } = options || {}
  const css = {} as NestedRecord<string>
  const vars = {} as NestedRecord<string>
  const parsedTheme = {} as T

  walkObjectDeep(
    theme,
    (keys, value) => {
      if (typeof value === ""string"" || typeof value === ""number"") {
        if (typeof value === ""string"" && /var\(\s*--/.test(value)) {
          // for CSS variable, apply prefix or remove basePrefix from the variable
          if (!basePrefix && prefix) {
            // eslint-disable-next-line no-param-reassign
            value = value.replace(/var\(\s*--/g, `var(--${prefix}-`)
          } else {
            // eslint-disable-next-line no-param-reassign
            value = prefix
              ? value.replace(
                  new RegExp(`var\\(\\s*--${basePrefix}`, ""g""),
                  `var(--${prefix}`,
                ) // removing spaces
              : value.replace(
                  new RegExp(`var\\(\\s*--${basePrefix}-`, ""g""),
                  ""var(--"",
                )
          }
        }

        if (
          shouldSkipGeneratingVar == null ||
          shouldSkipGeneratingVar(keys, value)
        ) {
          // only create css & var if `shouldSkipGeneratingVar` return false
          const cssVar = `--${prefix ? `${prefix}-` : """"}${keys.join(""-"")}`
          Object.assign(css, { [cssVar]: getCssValue(keys, value) })

          assignNestedKeys(vars, keys, `var(${cssVar})`)
        }
      }
      assignNestedKeys(parsedTheme, keys, value)
    },
    (keys) => keys[0] === ""vars"", // skip 'vars/*' paths
  )

  return { css, vars, parsedTheme }
}
<fim_middle>",correct,589
ValueType,ValueType,251dc8a6bd0853f15cfeabfb12becc4052d3fe54,"<fim_prefix>type ValueType = string | number;

const isE = (number) => {
  const str = String(number);

  return !Number.isNaN(Number(str)) && str.includes('e');
};

export const trimNumber = (numStr) => {
  let str = numStr.trim();

  if (str === '' || str === '0') {
    return {
      negative: false,
      negativeStr: '',
      trimStr: '',
      integerStr: '0',
      decimalStr: '',
      fullStr: str,
    };
  }

  let negative = str.startsWith('-');

  if (negative) {
    str = str.slice(1);
  }

  str = str
    // Remove decimal 0. `1.000` => `1.`, `1.100` => `1.1`
    .replace(/(\.\d*[^0])0*$/, '$1')
    // Remove useless decimal. `1.` => `1`
    .replace(/\.0*$/, '')
    // Remove integer 0. `0001` => `1`, 000.1' => `.1`
    .replace(/^0+/, '');

  if (str.startsWith('.')) {
    str = `0${str}`;
  }

  const trimStr = str || '0';
  const splitNumber = trimStr.split('.');

  const integerStr = splitNumber[0] || '0';
  const decimalStr = splitNumber[1] || '0';

  if (integerStr === '0' && decimalStr === '0') {
    negative = false;
  }

  const negativeStr = negative ? '-' : '';

  return {
    negative,
    negativeStr,
    trimStr,
    integerStr,
    decimalStr,
    fullStr: `${negativeStr}${trimStr}`,
  };
};

const validateNumber = (num) => {
  if (typeof num === 'number') {
    return !Number.isNaN(num);
  }

  // Empty
  if (!num) {
    return false;
  }

  return (
    // Normal type: 11.28
    /^\s*-?\d+(\.\d+)?\s*$/.test(num) ||
    // Pre-number: 1.
    /^\s*-?\d+\.\s*$/.test(num) ||
    // Post-number: .1
    /^\s*-?\.\d+\s*$/.test(num)
  );
};

const getNumberPrecision = (number) => {
  const numStr = String(number);

  if (isE(number)) {
    let precision = Number(numStr.slice(numStr.indexOf('e-') + 2));

    const decimalMatch = numStr.match(/\.(\d+)/);
    if (decimalMatch?.[1]) {
      precision += decimalMatch[1].length;
    }
    return precision;
  }

  return numStr.includes('.') && validateNumber(numStr)
    ? numStr.length - numStr.indexOf('.') - 1
    : 0;
};

const maxPrecision = (pre, cur: <fim_suffix>) =>
  Math.max(getNumberPrecision(pre), getNumberPrecision(cur));

const add = (pre, cur) => {
  const preValue = Number(pre);
  const curValue = Number(cur);

  const totalValue = preValue + curValue;
  if (totalValue > Number.MAX_SAFE_INTEGER || totalValue < Number.MIN_SAFE_INTEGER) {
    return bigIntDecimalAdd(pre, cur);
  }
  return totalValue.toFixed(maxPrecision(pre, cur));
};

const makeBigIntDecimal = (value) => {
  // We need convert back to Number since it require `toFixed` to handle this
  if (isE(value)) {
    value = Number(value);
  }

  value = typeof value === 'string' ? value : num2str(value);

  if (validateNumber(value)) {
    const trimRet = trimNumber(value);
    const numbers = trimRet.trimStr.split('.');
    const decimalStr = numbers[1] || '0';

    return {
      value: value,
      negative: trimRet.negative,
      integer: BigInt(numbers[0]),
      decimal: BigInt(decimalStr),
      decimalLen: decimalStr.length,
    };
  }
  return null;
};

type BigIntDecimalType = {
  value: string;
  negative: boolean;
  integer: BigInt;
  decimal: BigInt;
  decimalLen: number;
};

const bigIntDecimalAdd = (pre, cur) => {
  const preValue = makeBigIntDecimal(pre) as BigIntDecimalType;
  const curValue = makeBigIntDecimal(cur) as BigIntDecimalType;

  if (!preValue || !curValue) return '';

  const maxDecimalLength = Math.max(
    preValue.decimal.toString().padStart(preValue.decimalLen, '0').length,
    curValue.decimal.toString().padStart(curValue.decimalLen, '0').length,
  );
  const preDecimal = BigInt(
    `${preValue.negative ? '-' : ''}${preValue.integer.toString()}${preValue.decimal
      .toString()
      .padStart(preValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );
  const curDecimal = BigInt(
    `${curValue.negative ? '-' : ''}${curValue.integer.toString()}${curValue.decimal
      .toString()
      .padStart(curValue.decimalLen, '0')
      .padEnd(maxDecimalLength, '0')}`,
  );

  const valueStr = (preDecimal + curDecimal).toString();

  // We need fill string length back to `maxDecimalLength` to avoid parser failed
  const { negativeStr, trimStr } = trimNumber(valueStr);
  const hydrateValueStr = `${negativeStr}${trimStr.padStart(maxDecimalLength + 1, '0')}`;

  return trimNumber(
    `${hydrateValueStr.slice(0, -maxDecimalLength)}.${hydrateValueStr.slice(-maxDecimalLength)}`,
  ).fullStr;
};

export const num2str = (value) => {
  let numIn = value.toString();
  if (value < Number.MAX_SAFE_INTEGER && value > Number.MIN_SAFE_INTEGER) return numIn;
  let sign = ''; // To remember the number sign
  if (numIn.charAt(0) === '-') {
    numIn = numIn.substring(1);
    sign = '-';
  }
  let str = numIn.split(/[eE]/g); // Split numberic string at e or E

  if (str.length < 2) return sign + numIn; // Not an Exponent Number? Exit with orginal Num back

  const power = Number(str[1]); // Get Exponent (Power) (could be + or -)
  if (!power || power === 0) return sign + str[0]; // If 0 exponents (i.e. 0|-0|+0) then That's any easy one

  const deciSp = (1.1).toLocaleString().substring(1, 2); // Get Deciaml Separator
  str = str[0].split(deciSp); // Split the Base Number into LH and RH at the decimal point

  let baseRH = str[1] || ''; // RH Base part. Make sure we have a RH fraction else """"
  let baseLH = str[0]; // LH base part.

  if (power > 0) {
    // ------- Positive Exponents (Process the RH Base Part)
    if (power > baseRH.length) baseRH += '0'.repeat(power - baseRH.length); // Pad with ""0"" at RH
    baseRH = baseRH.slice(0, power) + deciSp + baseRH.slice(power); // Insert decSep at the correct place into RH base
    if (baseRH.charAt(baseRH.length - 1) === deciSp) baseRH = baseRH.slice(0, -1); // If decSep at RH end? => remove it
  } else {
    // ------- Negative Exponents (Process the LH Base Part)
    const num = Math.abs(power) - baseLH.length; // Delta necessary 0's
    if (num > 0) baseLH = '0'.repeat(num) + baseLH; // Pad with ""0"" at LH
    baseLH = baseLH.slice(0, power) + deciSp + baseLH.slice(power); // Insert ""."" at the correct place into LH base
    if (baseLH.charAt(0) === deciSp) baseLH = '0' + baseLH; // If decSep at LH most? => add ""0""
  }
  return sign + baseLH + baseRH; // Return the long number (with sign)
};

export default add;
<fim_middle>",correct,4638
Variable,Variable,4b26b14a08d5cdfff6183540cb79049b3ed5038a,"<fim_prefix>/* eslint-disable no-constant-condition */

const EOF = '~EOF~'

class Parser {
  private pos = 0

  constructor(private input) {}

  next() {
    if (this.pos >= this.input.length) {
      return EOF
    }
    return this.input[this.pos++]
  }

  backup() {
    this.pos--
  }

  parseTemplate() {
    if (this.next() != '/') {
      throw new Error('binding URL should start with a slash')
    }
    
    return {
      segments: this.parseSegments(),
      verb: this.parseVerb(),
    }
  }

  private parseSegments() {
    let segments: Segment[] = []
    segments.push(this.parseSegment())

    while (true) {
      let r = this.next()
      switch (r) {
        case '/':
          segments.push(this.parseSegment())
          continue

        case ':':
        case '}':
          this.backup()
          return segments

        case EOF:
          return segments

        default:
          throw new Error(`unexpected ${r} in segments`)
      }
    }
  }

  private parseSegment() {
    let content = ''
    while (true) {
      let r = this.next()
      switch (r) {
        case EOF:
          if (!content.length) {
            throw new Error(`unexpected EOF in segment`)
          }
          return { content }

        case '{':
          return { content, variable: this.parseVariable() }

        case ':':
        case '/':
        case '}':
          this.backup()
          if (!content.length) {
            throw new Error(`unexpected ${r} in segment`)
          }
          return { content }

        default:
          content += r
      }
    }
  }

  private parseVariable(): <fim_suffix> {
    let v: Variable = {
      name: '',
    }
    while (true) {
      let r = this.next()
      switch (r) {
        case '}':
          if (!v.name.length) {
            throw new Error(`empty variable name`)
          }
          return v

        case '=':
          v.parts = this.parseSegments().map(segment => {
            if (!segment.content.length) {
              throw new Error(`unexpected empty segment`)
            }
            return segment.content
          })
          break

        case EOF:
          throw new Error(`unexpected EOF in variable ${v.name}`)

        default:
          v.name += r
      }
    }
  }

  private parseVerb() {
    let r = this.next()
    switch (r) {
      case ':':
        break

      case EOF:
        return ''

      default:
        throw new Error(`unexpected ${r} in verb`)
    }

    let verb = ''
    while (true) {
      let r = this.next()
      if (r === EOF) {
        if (!verb.length) {
          throw new Error(`empty verb`)
        }
        return verb
      }
      verb += r
    }
  }
}

interface Binding {
  segments: Segment[]
  verb: string
}

interface Segment {
  content: string
  variable?: Variable
}

interface Variable {
  name: string
  parts?: string[]
}

export function buildURL(template, params) {
  let parser = new Parser(template)
  let binding = parser.parseTemplate()

  let parts = binding.segments.map(segment => {
    if (segment.variable) {
      if (!params[segment.variable.name]) {
        throw new Error(`input parameter ${segment.variable.name} is required`)
      }

      return params[segment.variable.name]
    }
    return segment.content
  })
  let verb = binding.verb ? `:${binding.verb}` : ''
  return '/' + parts.join('/') + verb
}
<fim_middle>",correct,925
Variable,Variable,b6c4e1fb10e5beed8368e9e86826f11e965be6f5,"<fim_prefix>const DFG_VERSION = '0.18.1';

export enum QueryDetail {
  LABEL = 'LABEL',
  SKELETON = 'SKELETON',
  SUMMARY = 'SUMMARY',
  FULL = 'FULL',
}

export enum VariableType {
  POINT2 = 'RoME.Point2',
  POSE2 = 'RoME.Pose2',
}

export type Variable = {
  label: string;
  dataEntry: string;
  nstime: string;
  variableType: string;
  dataEntryType: string;
  ppeDict: string;
  solverDataDict: string;
  smallData: string;
  solvable: number;
  tags: string;
  timestamp: string;
  _version: string;
};

export function Variable(
  label,
  type,
  tags = ['VARIABLE'],
  timestamp = new Date().toISOString(),
): <fim_suffix> {
  const solverDataDict = {
    default: {
      vecval: [
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
        0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
      ],
      dimval: 3,
      vecbw: [0.0, 0.0, 0.0],
      dimbw: 3,
      BayesNetOutVertIDs: [],
      dimIDs: [0, 1, 2],
      dims: 3,
      eliminated: false,
      BayesNetVertID: '_null',
      separator: [],
      variableType: type,
      initialized: false,
      infoPerCoord: [0.0, 0.0, 0.0],
      ismargin: false,
      dontmargin: false,
      solveInProgress: 0,
      solvedCount: 0,
      solveKey: 'default',
    },
  };
  const result: Variable = {
    label,
    dataEntry: '{}',
    nstime: '0',
    variableType: type,
    dataEntryType: '{}',
    ppeDict: '{}',
    solverDataDict: JSON.stringify(solverDataDict),
    smallData: '{}',
    solvable: 1,
    tags: JSON.stringify(tags),
    timestamp,
    _version: DFG_VERSION,
  };
  return result;
}
<fim_middle>",correct,1023
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b: <fim_suffix>)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1185
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false): <fim_suffix>
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1195
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b): <fim_suffix>
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1202
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b: <fim_suffix>)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1203
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b): <fim_suffix>
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1205
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j): <fim_suffix>
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1208
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i): <fim_suffix>
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1211
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v: <fim_suffix>)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1219
Vector,Vector,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb): <fim_suffix>
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1222
Vector,Vector,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2): <fim_suffix> {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3403
Vector,Vector,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2: <fim_suffix>) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3407
Vector,Vector,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1: <fim_suffix>, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3408
Vector,Vector,d5ff2fa2b6826801f70c82d95dcdfcf780c62790,"<fim_prefix>const OCCUPIED_SEAT = '#';
const EMPTY_SEAT = 'L';
const FLOOR = '.';

interface Position {
  x: number,
  y: number
}

interface Vector {
  x: number,
  y: number
}

type AdjacentSeatFinder = (input, position, direction) => string;

export function getAdjacentSeat(input, position, direction: <fim_suffix>) {
  const adjacentLineIndex = position.y + direction.y;
  const adjacentColumnIndex = position.x + direction.x;
  
  const newPosition = { 
    x: position.x + direction.x,
    y: position.y + direction.y
  }

  if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length){
    return FLOOR;
  }

  return input[adjacentLineIndex][adjacentColumnIndex];
}


export function getFirstSeatAtDirection(input, position, direction) {
  let seat: string = FLOOR;

  let newPosition = position;
  while(true) {
    newPosition = { 
      x: newPosition.x + direction.x,
      y: newPosition.y + direction.y
    }

    if(newPosition.y < 0 || newPosition.y >= input.length || newPosition.x < 0 || newPosition.x >= input[newPosition.y].length) break;

    const place = input[newPosition.y][newPosition.x];

    if (place !== FLOOR) {
      seat = place;
      break;
    }
  }

  return seat;
}

export function computeRound(input, adjacentSeatFinder, maximumAdjacentOccupiedSeats) {
  return input.map((line, lineIndex) => {
    return line
      .split('')
      .map((seat, seatIndex) => {
        if (seat === FLOOR) {
          return seat;
        }

        let numberOfAdjacentOccupiedSeat = 0;
        for (let iLine = -1; iLine <= 1; iLine++) {
          for (let iColumn = -1; iColumn <= 1; iColumn ++) {
            if(iLine === 0 && iColumn === 0) continue;

            const position = { x: seatIndex, y: lineIndex};
            const direction = { x: iColumn, y: iLine }
            const adjacentSeat = adjacentSeatFinder(input, position, direction);

            if (adjacentSeat === OCCUPIED_SEAT) {
              numberOfAdjacentOccupiedSeat++;
            }
          }
        }

        if (numberOfAdjacentOccupiedSeat === 0) {
          return OCCUPIED_SEAT;
        } else if (numberOfAdjacentOccupiedSeat >= maximumAdjacentOccupiedSeats) {
          return EMPTY_SEAT;
        } else {
          return seat;
        }
      })
      .join('');
  })
}

export function countNumberOfOccupiedSeatsAfterStabilization(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getAdjacentSeat, 4);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}

export function countNumberOfOccupiedSeatsAfterStabilizationWithRayCast(input) {
  let lastMap: string[] = [];
  let newMap: string[] = input;

  while(JSON.stringify(lastMap) !== JSON.stringify(newMap)) {
    lastMap = [...newMap];
    newMap = computeRound(lastMap, getFirstSeatAtDirection, 5);
  }

  return newMap
    .join('')
    .split('')
    .filter(seat => seat === OCCUPIED_SEAT)
    .length;
}
<fim_middle>",correct,4861
Vertex,Vertex,eaa92966cbe116f28e1b5c9c0f4b724a32bab041,"<fim_prefix>type Vertex = string;
type Weight = number;
type Graph = Record<string, Record<string, Weight>>;

/**
 * If a target is not provided, finds the single-source shortest path distance from the source vertex with positive or negative edge weights
 * (but with no negative weight cycles).
 * Else, it returns the shortest path as well as its distance from source vertex to target vertex.
 * In the case of negative weight cycles, if target is defined, then negative infinity and empty array path will be returned,
 * else, all distances from A will be returned with negative infinity.
 *
 * @param {Graph} graph Vertex with its fields being the neighboring vertices and value being the weight from vertex to neighboring vertices
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target Ending vertex in graph
 * @return {Record<string, number> | [number, Array<Vertex>]} An object mapping of the distance from the source vertex or an array containing the distance
 * and an array containing the path from source to target vertex
 */
function bellmanFord(
  graph,
  source,
  target?,
) {
  const vertices = Object.keys(graph);
  // if graph is empty, immediately return
  if (vertices.length === 0) {
    return target ? [0, []] : {};
  }

  if (!vertices.includes(source) || (target && !vertices.includes(target))) {
    return target ? [-Infinity, []] : {};
  }

  const distances = getDistances(vertices, source);
  const predecessor = getPredecessor(vertices);

  // requires only n - 1 iteration
  for (let i = 0; i < vertices.length - 1; i++) {
    for (let startVertex of vertices) {
      const neighbors = graph[startVertex];
      for (let endVertex in neighbors) {
        const weight = graph[startVertex][endVertex];
        // relaxation
        if (distances[startVertex] + weight < distances[endVertex]) {
          distances[endVertex] = distances[startVertex] + weight;
          predecessor[endVertex] = startVertex;
        }
      }
    }
  }

  // checks for any negative weight cycles. If true returns all distances as -Infinity as a sign negative weight cycles
  for (let startVertex of vertices) {
    const neighbors = graph[startVertex];
    for (let endVertex in neighbors) {
      const weight = graph[startVertex][endVertex];
      // if relaxation occurs here, negative weight cycles detected
      if (distances[startVertex] + weight < distances[endVertex]) {
        return target ? [-Infinity, []] : negativeWeightCycles(vertices);
      }
    }
  }

  if (!target) {
    return distances;
  }

  const shortestDistance = distances[target];
  const path = getPath(predecessor, source, target);
  return [shortestDistance, path];
}

/**
 * Returns an Object mapping of nodes to distance with values all being negative infinity to represent a negative weight cycle being present.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, number>} An object mapping of nodes with values being negative infinity
 */
function negativeWeightCycles(vertices) {
  return vertices.reduce((acc, curr) => {
    acc[curr] = -Infinity;
    return acc;
  }, {} as Record<string, number>);
}

/**
 * Initializes the distance mapping from source to rest of the vertices.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @param {Vertex} source Starting vertex in graph
 * @return {Record<string, number>} An object mapping of source to rest of vertices
 */
function getDistances(
  vertices,
  source,
) {
  const distances = vertices.reduce((acc, curr) => {
    acc[curr] = Infinity;
    return acc;
  }, {} as Record<string, number>);
  distances[source] = 0;
  return distances;
}

/**
 * Returns an array denoting the path from start vertex to end vertex.
 *
 * @param {Object} predecessor Mapping of child vertex pointing to parent vertex
 * @param {Vertex} source Starting vertex in graph
 * @param {Vertex} target End vertex in graph
 * @return {Array<String>} An array containing the path from source to target vertex
 */
function getPath(
  predecessor,
  source,
  target: <fim_suffix>,
) {
  const path = [target];
  while (target && target !== source) {
    const next = predecessor[target];
    target = next ?? source; // if next is undefined, it reaches source
    path.push(target);
  }
  return path.reverse();
}

/**
 * Generates a default object mapping of child vertex pointing to parent vertex which will be defaulted to undefined initially.
 *
 * @param {Array<Vertex>} vertices An array of all vertices in the graph
 * @return {Record<string, Vertex | undefined>} An object mapping of child vertex pointing to parent vertex
 */
function getPredecessor(
  vertices,
) {
  const predecessor = {} as Record<string, Vertex | undefined>;
  for (let vertex of vertices) {
    predecessor[vertex] = undefined;
  }
  return predecessor;
}

export default bellmanFord;
<fim_middle>",correct,4126
WebApi,WebApi,784e0b27e79a2fe98c745e477d0f8c518b8f59ac,"<fim_prefix>export const Kind = 'Core#WebApi';

/**
 * @deprecated This was used in the old version of ARC.
 */
export interface ILegacyRestApi {
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   */
  data: string;
  /**
   * The AMF parser version used to parse this document.
   */
  amfVersion?: string;
}

export interface IWebApi {
  kind: typeof Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path: string;
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;
}

export class WebApi {
  kind = Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId = '';
  /**
   * Version name of the API
   */
  version = '';
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path = '';
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;

  /**
   * Checks whether the object represents a legacy way of storing the web API data.
   */
  get isLegacy() {
    return !!this.data;
  }

  /**
   * Checks whether the object is the legacy schema for web API (formally known as RestAPI)
   */
  static isLegacy(api) {
    const legacy = api as ILegacyRestApi;
    if (legacy.data) {
      return true;
    }
    return false;
  }

  static fromLegacy(api): <fim_suffix> {
    const { version, amfVersion, data, indexId } = api;
    const init: IWebApi = {
      kind: Kind,
      version,
      path: '',
      indexId,
    };
    if (amfVersion) {
      init.amfVersion = amfVersion;
    }
    if (data) {
      init.data = data;
    }
    return new WebApi(init);
  }

  /**
   * Creates an identifier of this web API object.
   * @param indexId The id of the corresponding index item. This is usually the base URI of the API.
   * @param version The version name of this web API.
   * @returns The unique and reversible identifier of this web API.
   */
  static createId(indexId, version) {
    return `${indexId}|${version}`;
  }

  constructor(input?) {
    let init: IWebApi;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        version: '',
        path: '',
        indexId: '',
      };
    }
    this.new(init);
  }

  new(init) {
    const { version, data, amfVersion, path, main, mime, vendor, indexId } = init;
    if (indexId) {
      this.indexId = indexId;
    } else {
      this.indexId = '';
    }
    if (version) {
      this.version = version;
    } else {
      this.version = '';
    }
    if (data) {
      this.data = data;
    } else {
      this.data = undefined;
    }
    if (amfVersion) {
      this.amfVersion = amfVersion;
    } else {
      this.amfVersion = undefined;
    }
    if (path) {
      this.path = path;
    } else {
      this.path = '';
    }
    if (main) {
      this.main = main;
    } else {
      this.main = undefined
    }
    if (mime) {
      this.mime = mime;
    } else {
      this.mime = mime;
    }
    if (vendor) {
      this.vendor = vendor;
    } else {
      this.vendor = undefined;
    }
  }

  toJSON() {
    const result: IWebApi = {
      kind: Kind,
      version: this.version,
      path: this.path,
      indexId: this.indexId,
    };
    if (this.data) {
      result.data = this.data;
    }
    if (this.amfVersion) {
      result.amfVersion = this.amfVersion;
    }
    if (this.main) {
      result.main = this.main;
    }
    if (this.mime) {
      result.mime = this.mime;
    }
    if (this.vendor) {
      result.vendor = this.vendor;
    }
    return result;
  }
}
<fim_middle>",correct,2777
Workflow,Workflow,6b2e48994d25dfb77d9f951487af828409217c22,"<fim_prefix>/* Types */

type Tx<T> = () => Promise<T>;
type Cx = () => Promise<unknown>;

export class ReadOnly<T> {
  constructor(public tx) {}
}

export class Mutating<T> {
  constructor(public tx, public cx) {}
}

export class Pivot<T> {
  constructor(public tx) {}
}

type Step<T> = ReadOnly<T> | Mutating<T> | Pivot<T>;

export type Workflow = Generator<Step<any>, void, any>;

/* Constructors */

export const readOnly = <T>(tx) => new ReadOnly<T>(tx);

export const mutating = <T>(tx, cx) =>
  new Mutating<T>(tx, cx);

export const pivot = <T>(tx) => new Pivot<T>(tx);

/* Workflow executor */

export async function run(workflow: <fim_suffix>) {
  // a list of compensating functions
  let cxs: Cx[] = [];
  // a number of pivot operations happened during the workflow
  let nPivots: number = 0;
  // should the workflow be unrolled
  let unrollReason: unknown;

  let next: IteratorResult<Step<unknown>>;
  let res: unknown;

  try {
    next = workflow.next();
  } catch (e) {
    unrollReason = e;
  }

  while (!unrollReason && !next!.done) {
    const flow = next!.value;

    try {
      // execute async operation
      res = await flow.tx();
    } catch (e1) {
      // async exception caught
      try {
        // try rethrowing into workflow -- this acquires a next workflow step;
        // compensating operation is not added, because the atomic forward
        // operation didn't succeed, so nothing to compensate
        next = workflow.throw(e1);
        continue;
      } catch (e2) {
        // rethrowing didn't succeed, unroll
        unrollReason = e2;
        break;
      }
    }

    // async operation succeeds, register its aftereffects
    if (flow instanceof Mutating) {
      cxs.push(flow.cx);
    } else if (flow instanceof Pivot) {
      nPivots++;
    }

    // try acquiring next workflow step
    try {
      next = workflow.next(res);
      continue;
    } catch (e) {
      // caught a sync exception that is not caught inside workflow, unroll
      unrollReason = e;
      break;
    }
  }

  // unroll if error happened
  if (unrollReason) {
    // workflow is not revertible if there were completed pivot operations
    if (nPivots) {
      throw unrollReason;
    }

    for (const cx of cxs.reverse()) {
      // compensating function error means the state is unknown
      // this can only be handled by a caller, so no try-catch
      await cx();
    }
    throw unrollReason;
  }
}
<fim_middle>",correct,3730
any,any,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON(): <fim_suffix> {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,70
any,any,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params: <fim_suffix> = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,71
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional: <fim_suffix>) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,81
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val): <fim_suffix> {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,92
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val): <fim_suffix> {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,98
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val: <fim_suffix>) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,99
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val: <fim_suffix>) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,102
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val): <fim_suffix> {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,104
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val): <fim_suffix> {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,107
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = ''): <fim_suffix> {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,110
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val: <fim_suffix>, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,114
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p: <fim_suffix>) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,115
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,116
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ: <fim_suffix>) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,117
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p: <fim_suffix>) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,118
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ): <fim_suffix> {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,119
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val: <fim_suffix>, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,123
any,any,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ: <fim_suffix>, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,124
any,any,ed707857103d58beb481bd7cdef24308b16ff916,"<fim_prefix>type Node_Type = Node_;
export class Node_{
	public data:any;
	public children: Node_Type[];
	public parent: Node_ | null;
	constructor(data){
		this.data = data;
		this.children = [];
		this.parent = null;
	}
}
export default class tree {
	public static head: Node_ = new Node_('head');
	public static path:string[][] | string[] = [];
	public static rootNode = '';
    
	static append(parent=undefined, data: <fim_suffix>){
		const node = new Node_(data);
		if (!parent){
			this.head?.children.push(node);
			return;
		} else {
			const stack = [...this.head?.children] as Node_[];
			let prevIdx = null;
			while (stack?.length){
				const shiftItem = stack.shift();
				prevIdx = shiftItem;
				const children = shiftItem?.children;
				if (shiftItem?.data?.data === parent.data){
					node.parent = prevIdx as Node_;
					shiftItem?.children.push(node);
					return;
				} else {
					children?.forEach((node)=>{
						stack.push(node);
					});
				}
			}
		}
	}
	static getTree(){
		return this.head;
	}
	static async getPath(){
		// let rootNode = ;
		const rootNode = this.getRoot();
		const stack = [...this.head.children];
		let path_:string[] = [];
		while (stack.length){
			const shiftItem = stack.shift();
			path_.push(shiftItem?.data.data);
			const children = shiftItem?.children;
			if (shiftItem?.data.type === 'item'){
				(this.path as string[][]).push([...path_ as string[]]);
				if (shiftItem.parent){
					while (
						path_[path_.length - 1] !== rootNode?.data.data
					){
						path_.pop();
					}
				} else {
					path_ = [];
				}
			} else if (!shiftItem?.children.length){
				(this.path as string[][]).push([...path_ as string[]]);
				path_.pop();
				if (shiftItem?.parent){
					while (
						path_[path_.length - 1] !== rootNode?.data.data
					){
						path_.pop();
					}
				} else {
					path_ = [];
				}
			}
			for (let i=children?.length as number-1; i>=0; i--){
				stack.unshift(children?.[i] as Node_);
			}
		}
		return this.path;
	}
	private static getRoot(){
		const stack = [...tree.head.children];
		while (stack.length){
			const shiftItem = stack.shift();
			if (shiftItem?.data.type === 'parent'){
				return shiftItem;
			} else {
				const children = shiftItem?.children;
				for (let i=children?.length as number-1; i>=0; i--){
					stack.unshift(children?.[i] as Node_);
				}
			}
		}
		return undefined;
	}
	static clearTree(){
		this.head = new Node_('head');
		this.path = [];
		this.rootNode = '';
		return true;
	}
}

/**
 * a {
 *  b{
 *      d
 *   }
 *  c{
 *   }
 * }
 * 
 * 
 * 
 * 
 */
<fim_middle>",correct,167
any,any,ed707857103d58beb481bd7cdef24308b16ff916,"<fim_prefix>type Node_Type = Node_;
export class Node_{
	public data:any;
	public children: Node_Type[];
	public parent: Node_ | null;
	constructor(data: <fim_suffix>){
		this.data = data;
		this.children = [];
		this.parent = null;
	}
}
export default class tree {
	public static head: Node_ = new Node_('head');
	public static path:string[][] | string[] = [];
	public static rootNode = '';
    
	static append(parent=undefined, data){
		const node = new Node_(data);
		if (!parent){
			this.head?.children.push(node);
			return;
		} else {
			const stack = [...this.head?.children] as Node_[];
			let prevIdx = null;
			while (stack?.length){
				const shiftItem = stack.shift();
				prevIdx = shiftItem;
				const children = shiftItem?.children;
				if (shiftItem?.data?.data === parent.data){
					node.parent = prevIdx as Node_;
					shiftItem?.children.push(node);
					return;
				} else {
					children?.forEach((node)=>{
						stack.push(node);
					});
				}
			}
		}
	}
	static getTree(){
		return this.head;
	}
	static async getPath(){
		// let rootNode = ;
		const rootNode = this.getRoot();
		const stack = [...this.head.children];
		let path_:string[] = [];
		while (stack.length){
			const shiftItem = stack.shift();
			path_.push(shiftItem?.data.data);
			const children = shiftItem?.children;
			if (shiftItem?.data.type === 'item'){
				(this.path as string[][]).push([...path_ as string[]]);
				if (shiftItem.parent){
					while (
						path_[path_.length - 1] !== rootNode?.data.data
					){
						path_.pop();
					}
				} else {
					path_ = [];
				}
			} else if (!shiftItem?.children.length){
				(this.path as string[][]).push([...path_ as string[]]);
				path_.pop();
				if (shiftItem?.parent){
					while (
						path_[path_.length - 1] !== rootNode?.data.data
					){
						path_.pop();
					}
				} else {
					path_ = [];
				}
			}
			for (let i=children?.length as number-1; i>=0; i--){
				stack.unshift(children?.[i] as Node_);
			}
		}
		return this.path;
	}
	private static getRoot(){
		const stack = [...tree.head.children];
		while (stack.length){
			const shiftItem = stack.shift();
			if (shiftItem?.data.type === 'parent'){
				return shiftItem;
			} else {
				const children = shiftItem?.children;
				for (let i=children?.length as number-1; i>=0; i--){
					stack.unshift(children?.[i] as Node_);
				}
			}
		}
		return undefined;
	}
	static clearTree(){
		this.head = new Node_('head');
		this.path = [];
		this.rootNode = '';
		return true;
	}
}

/**
 * a {
 *  b{
 *      d
 *   }
 *  c{
 *   }
 * }
 * 
 * 
 * 
 * 
 */
<fim_middle>",correct,169
any,any,181ec44034d7ff44d9293788b657b1a2036d874b,"<fim_prefix>type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance) {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance, schema, location) {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance: <fim_suffix>) {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
<fim_middle>",correct,228
any,any,181ec44034d7ff44d9293788b657b1a2036d874b,"<fim_prefix>type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance: <fim_suffix>) {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance, schema, location) {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance) {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
<fim_middle>",correct,234
any,any,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f: <fim_suffix>) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,344
any,any,361d89bb4743deb2ef0a6d1cd847cd5a2c9cb7db,"<fim_prefix>export interface WorkerMessage {
  type: string;
  id: number;
}

export function isWorkerMessage(value: <fim_suffix>): value is WorkerMessage {
  return (
    value && typeof value.type === ""string"" && typeof value.id === ""number""
  );
}

export interface StatusRequest extends WorkerMessage {
  type: ""status-req"";
}

export function isStatusRequest(value): value is StatusRequest {
  return isWorkerMessage(value) && value.type === ""status-req"";
}

export interface StatusResponse extends WorkerMessage {
  type: ""status-resp"";
  status: ""stopped"" | ""waiting"" | ""running"" | ""partial"";
  memorySize: number;
  debugging: boolean;
}

export function isStatusResponse(value): value is StatusResponse {
  return (
    value &&
    value.type === ""status-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.status === ""string"" &&
    (value.status === ""stopped"" ||
      value.status === ""waiting"" ||
      value.status === ""running"" ||
      value.status === ""partial"") &&
    typeof value.memorySize === ""number"" &&
    typeof value.debugging === ""boolean""
  );
}

export interface ErrorMessage extends WorkerMessage {
  type: ""error"";
  err: string;
}

export function isErrorMessage(value): value is ErrorMessage {
  return value && value.type === ""error"" && typeof value.err === ""string"";
}

export interface OutputMessage extends WorkerMessage {
  type: ""output"";
  content: string;
}

export function isOutputMessage(value): value is OutputMessage {
  return (
    value &&
    value.type === ""output"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface InputMessage extends WorkerMessage {
  type: ""input"";
  content: string;
}

export function isInputMessage(value): value is InputMessage {
  return (
    value &&
    value.type === ""input"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface StartMessage extends WorkerMessage {
  type: ""start"";
}

export function isStartMessage(value): value is StartMessage {
  return isWorkerMessage(value) && value.type === ""start"";
}

export interface MemoryMessage extends WorkerMessage {
  type: ""memory"";
  memory: ArrayBuffer;
}

export interface StartedMessage extends WorkerMessage {
  type: ""started"";
  heap: number;
}

export function isStartedMessage(value): value is StartedMessage {
  return value && value.type === ""started"" && typeof value.heap === ""number"";
}

export function isMemoryMessage(value): value is MemoryMessage {
  return (
    value &&
    value.type === ""memory"" &&
    typeof value.memory === ""object"" &&
    value.memory instanceof ArrayBuffer
  );
}

export interface PrintRequest extends WorkerMessage {
  type: ""print-req"";
  ptr: number;
}

export function isPrintRequest(value): value is PrintRequest {
  return (
    value &&
    value.type === ""print-req"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number""
  );
}

export interface PrintResponse extends WorkerMessage {
  type: ""print-resp"";
  content: string;
}

export function isPrintResponse(value): value is PrintResponse {
  return (
    value &&
    value.type === ""print-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.content === ""string""
  );
}

export interface HeapRequest extends WorkerMessage {
  type: ""heap-req"";
  ptr: number;
}

export function isHeapRequest(value): value is HeapRequest {
  return value && value.type === ""heap-req"" && typeof value.ptr === ""number"";
}

export interface HeapResponse extends WorkerMessage {
  type: ""heap-resp"";
  ptr: number;
  size: number;
  free: number;
  next: number;
  entries: ArrayBuffer;
}

export function isHeapResponse(value): value is HeapResponse {
  return (
    value &&
    value.type === ""heap-resp"" &&
    typeof value.ptr === ""number"" &&
    typeof value.size === ""number"" &&
    typeof value.free === ""number"" &&
    typeof value.next === ""number"" &&
    typeof value.entries === ""object"" &&
    value.entries instanceof ArrayBuffer
  );
}

export interface GcRequest extends WorkerMessage {
  type: ""gc-req"";
  collect: boolean;
}

export function isGcRequest(value): value is GcRequest {
  return (
    value &&
    typeof value.id === ""number"" &&
    value.type === ""gc-req"" &&
    typeof value.collect === ""boolean""
  );
}

export interface GcResponse extends WorkerMessage {
  type: ""gc-resp"";
  output: string;
  isCollecting: boolean;
  collectionCount: number;
  collected: number;
  notCollected: number;
  totalCollected: number;
  totalNotCollected: number;
}

export function isGcResponse(value): value is GcResponse {
  return (
    value &&
    value.type == ""gc-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.output === ""string"" &&
    typeof value.collectionCount === ""number"" &&
    typeof value.collected === ""number"" &&
    typeof value.notCollected === ""number"" &&
    typeof value.totalCollected === ""number"" &&
    typeof value.totalNotCollected === ""number""
  );
}

export interface EnableDebug extends WorkerMessage {
  type: ""enable-debug"";
  enabled: boolean;
}

export function isEnableDebug(value): value is EnableDebug {
  return (
    value &&
    value.type === ""enable-debug"" &&
    typeof value.id === ""number"" &&
    typeof value.enabled === ""boolean""
  );
}

export interface DebugBreak extends WorkerMessage {
  type: ""debug-break"";
  ptr: number;
  env: number;
  expr: string;
}

export function isDebugBreak(value): value is DebugBreak {
  return (
    value &&
    value.type === ""debug-break"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number"" &&
    typeof value.env === ""number"" &&
    typeof value.expr === ""string""
  );
}

export interface DebugStep extends WorkerMessage {
  type: ""debug-step"";
  resultStep: boolean;
}

export function isDebugStep(value): value is DebugStep {
  return (
    value &&
    value.type === ""debug-step"" &&
    typeof value.id === ""number"" &&
    typeof value.resultStep === ""boolean""
  );
}

export interface EnvRequest extends WorkerMessage {
  type: ""env-req"";
  env: number;
}

export function isEnvRequest(value): value is EnvRequest {
  return (
    value &&
    value.type === ""env-req"" &&
    typeof value.id === ""number"" &&
    typeof value.env === ""number""
  );
}

export interface EnvEntry {
  name: string;
  value: string;
}

export function isEnvEntry(value): value is EnvEntry {
  return (
    value && typeof value.name === ""string"" && typeof value.value === ""string""
  );
}

export interface EnvResponse extends WorkerMessage {
  type: ""env-resp"";
  ptr: number;
  next: number;
  entries: EnvEntry[];
}

export function isEnvResponse(value): value is EnvResponse {
  return (
    value &&
    value.type === ""env-resp"" &&
    typeof value.id === ""number"" &&
    typeof value.ptr === ""number"" &&
    typeof value.next === ""number"" &&
    Array.isArray(value.entries) &&
    (value.entries as any[]).every(isEnvEntry)
  );
}
<fim_middle>",correct,612
any,any,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors) {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error: <fim_suffix>, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,634
any,any,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc: <fim_suffix>) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",correct,832
any,any,4dc1c64fd20c06b5dceaa99125c0a14b4492067c,"<fim_prefix>interface CustomDescriptor {
  [propsname: string]: any;
}

type DesType = 'class' | 'method';

function getOwnKeys(object: <fim_suffix>) {
  const symbolKeys = Object.getOwnPropertySymbols(object).map((item) =>
    item.toString()
  );

  return Object.getOwnPropertyNames(object).concat(symbolKeys);
}

function getOwnPropertyDescriptors(obj) {
  let descs: CustomDescriptor = {};

  getOwnKeys(obj).forEach((key) => {
    return (descs[key] = Object.getOwnPropertyDescriptor(obj, key));
  });

  return descs;
}

function autoClass(fn, klass, ...rest) {
  const descs = getOwnPropertyDescriptors(klass.prototype);

  const keys = getOwnKeys(descs);

  keys.forEach((key) => {
    let desc = descs[key];

    if (typeof desc.value === 'function' && key !== 'constructor') {
      const descriptor: PropertyDescriptor = fn(
        klass.prototype,
        key,
        desc,
        ...rest
      );

      Object.defineProperty(klass.prototype, key, descriptor);
    }
  });
}

function handleDescriptor(fn, desType, args) {
  if (desType === 'class') {
    autoClass.apply(undefined, [fn, args[0], ...args.splice(1)]);
  } else {
    return fn.apply(undefined, [...args]);
  }
}

function isDescriptor(desc) {
  if (!desc || !desc.hasOwnProperty) {
    return false;
  }

  const keys = ['value', 'initializer', 'get', 'set'];

  for (let i = 0, l = keys.length; i < l; i++) {
    if (desc.hasOwnProperty(keys[i])) {
      return true;
    }
  }

  return false;
}

function hasParameters(target) {
  return typeof target !== 'function' && !isDescriptor(target);
}

export default function adaption(fn) {
  if (typeof fn !== 'function') {
    new TypeError('params has function');
  }

  return function (...args) {
    if (!hasParameters(args[args.length - 1])) {
      return handleDescriptor(fn, args.length === 1 ? 'class' : 'method', args);
    } else {
      return function () {
        const toArgs = Array.prototype.slice.call(arguments);

        return handleDescriptor(
          fn,
          toArgs.length === 1 ? 'class' : 'method',
          toArgs.concat(args)
        );
      };
    }
  };
}
<fim_middle>",correct,840
any,any,6e34ee34cc517dccc475aec8a5d776702984ed04,"<fim_prefix>interface Destination {
  destination: string;
  format: string;
}

interface StyleDictionaryConfig {
  platforms: {
    [key: string]: {
      buildPath: string;
      files: Destination[];
      prefix?: string;
      transformGroup?: string;
      transforms?: string[];
    };
  };
  source?: string[];
  tokens?: any;
}

export const errorMessagesMap = {
  incorrectFileFormat:
    ""The source file isn't in the properties/ folder. Please move its location and try again."",
};

/**
 * A function that returns a config object for style dictionary
 * to parse and convert to tokens
 *
 * @param {string} location a path to a json file in the root properties folder
 */
export function getStyleDictionaryConfig(
  location,
  useFigmaApi,
  tokens?: <fim_suffix>
) {
  const arr = location.split(""/"");

  if (arr.length < 3 || arr[0] !== ""properties"") {
    throw new Error(errorMessagesMap.incorrectFileFormat);
  }

  const filename = arr[arr.length - 1];
  const sansFilename = arr.slice(0, -1);

  const path = sansFilename.reduce((acc, next) => `${acc}/${next}`);

  const buildPath = `dist/${path.replace(""properties/"", """")}/`;
  const [filenameSansExtension] = filename.split(""."");
  const inputData = useFigmaApi
    ? { tokens }
    : { source: [`${path}/${filename}`] };

  return {
    ...inputData,
    platforms: {
      scss: {
        buildPath,
        transformGroup: ""scss"",
        files: [
          {
            format: ""scss/map-deep"",
            destination: `scss/${filenameSansExtension}.map.deep.scss`,
          },
        ],
      },
      ts: {
        buildPath,
        transformGroup: ""js"",
        files: [
          {
            format: ""javascript/es6"",
            destination: `js/${filenameSansExtension}.js`,
          },
          {
            format: ""typescript/es6-declarations"",
            destination: `js/${filenameSansExtension}.d.ts`,
          },
          {
            format: ""javascript/module"",
            destination: `js/${filenameSansExtension}.module.js`,
          },
          {
            format: ""typescript/module-declarations"",
            destination: `js/${filenameSansExtension}.module.d.ts`,
          },
        ],
      },
      json: {
        transformGroup: ""react-native"",
        buildPath,
        files: [
          {
            destination: `json/${filenameSansExtension}.json`,
            format: ""json/flat"",
          },
          {
            destination: `json/${filenameSansExtension}.nested.json`,
            format: ""json/nested"",
          },
        ],
      },
    },
  };
}
<fim_middle>",correct,918
any,any,9232371dfa21a47ce397b18f5fd76f02d4b0d2b1,"<fim_prefix>type WithEvents = {
  addEventListener(type, callbackfn);
  removeEventListener(type, callbackfn);
}

export const isAsyncIterable = (v): v is AsyncIterable<any> => Symbol.asyncIterator in Object(v);

export const isIterable = (v): v is Iterable<any> => Symbol.iterator in Object(v);

export const eventsToIterable = <V>(eventSource, eventType) => {
  const pullQueue: any[] = [];
  const pushQueue: any[] = [];
  let done = false;
  const pushValue = async (args) => {
    if (pullQueue.length !== 0) {
      const resolver = pullQueue.shift();
      resolver(...args);
    } else {
      pushQueue.push(args);
    }
  };

  const pullValue = () => {
    return new Promise<V>((resolve) => {
      if (pushQueue.length !== 0) {
        const args = pushQueue.shift();
        // @ts-ignore
        resolve(...args);
      } else {
        pullQueue.push(resolve);
      }
    });
  };

  const handler = (...args) => {
    pushValue(args);
  };

  eventSource.addEventListener(eventType, handler);
  const r = {
    next: async () => {
      if (done) return {done: true, value: undefined};
      return {
        done: false,
        value: await pullValue()
      };
    },
    return: async () => {
      done = true;
      eventSource.removeEventListener(eventType, handler);
      return {done: true, value: undefined};
    },
    throw: async (error: <fim_suffix>) => {
      done = true;
      return {
        done: true,
        value: Promise.reject(error)
      };
    }
  };
  return r;
};<fim_middle>",correct,949
any,any,9232371dfa21a47ce397b18f5fd76f02d4b0d2b1,"<fim_prefix>type WithEvents = {
  addEventListener(type, callbackfn);
  removeEventListener(type, callbackfn);
}

export const isAsyncIterable = (v): v is AsyncIterable<any> => Symbol.asyncIterator in Object(v);

export const isIterable = (v): v is Iterable<any> => Symbol.iterator in Object(v);

export const eventsToIterable = <V>(eventSource, eventType) => {
  const pullQueue: any[] = [];
  const pushQueue: any[] = [];
  let done = false;
  const pushValue = async (args) => {
    if (pullQueue.length !== 0) {
      const resolver = pullQueue.shift();
      resolver(...args);
    } else {
      pushQueue.push(args);
    }
  };

  const pullValue = () => {
    return new Promise<V>((resolve) => {
      if (pushQueue.length !== 0) {
        const args = pushQueue.shift();
        // @ts-ignore
        resolve(...args);
      } else {
        pullQueue.push(resolve);
      }
    });
  };

  const handler = (...args: <fim_suffix>) => {
    pushValue(args);
  };

  eventSource.addEventListener(eventType, handler);
  const r = {
    next: async () => {
      if (done) return {done: true, value: undefined};
      return {
        done: false,
        value: await pullValue()
      };
    },
    return: async () => {
      done = true;
      eventSource.removeEventListener(eventType, handler);
      return {done: true, value: undefined};
    },
    throw: async (error) => {
      done = true;
      return {
        done: true,
        value: Promise.reject(error)
      };
    }
  };
  return r;
};<fim_middle>",correct,952
any,any,9232371dfa21a47ce397b18f5fd76f02d4b0d2b1,"<fim_prefix>type WithEvents = {
  addEventListener(type, callbackfn);
  removeEventListener(type, callbackfn);
}

export const isAsyncIterable = (v): v is AsyncIterable<any> => Symbol.asyncIterator in Object(v);

export const isIterable = (v: <fim_suffix>): v is Iterable<any> => Symbol.iterator in Object(v);

export const eventsToIterable = <V>(eventSource, eventType) => {
  const pullQueue: any[] = [];
  const pushQueue: any[] = [];
  let done = false;
  const pushValue = async (args) => {
    if (pullQueue.length !== 0) {
      const resolver = pullQueue.shift();
      resolver(...args);
    } else {
      pushQueue.push(args);
    }
  };

  const pullValue = () => {
    return new Promise<V>((resolve) => {
      if (pushQueue.length !== 0) {
        const args = pushQueue.shift();
        // @ts-ignore
        resolve(...args);
      } else {
        pullQueue.push(resolve);
      }
    });
  };

  const handler = (...args) => {
    pushValue(args);
  };

  eventSource.addEventListener(eventType, handler);
  const r = {
    next: async () => {
      if (done) return {done: true, value: undefined};
      return {
        done: false,
        value: await pullValue()
      };
    },
    return: async () => {
      done = true;
      eventSource.removeEventListener(eventType, handler);
      return {done: true, value: undefined};
    },
    throw: async (error) => {
      done = true;
      return {
        done: true,
        value: Promise.reject(error)
      };
    }
  };
  return r;
};<fim_middle>",correct,958
any,any,9232371dfa21a47ce397b18f5fd76f02d4b0d2b1,"<fim_prefix>type WithEvents = {
  addEventListener(type, callbackfn);
  removeEventListener(type, callbackfn);
}

export const isAsyncIterable = (v: <fim_suffix>): v is AsyncIterable<any> => Symbol.asyncIterator in Object(v);

export const isIterable = (v): v is Iterable<any> => Symbol.iterator in Object(v);

export const eventsToIterable = <V>(eventSource, eventType) => {
  const pullQueue: any[] = [];
  const pushQueue: any[] = [];
  let done = false;
  const pushValue = async (args) => {
    if (pullQueue.length !== 0) {
      const resolver = pullQueue.shift();
      resolver(...args);
    } else {
      pushQueue.push(args);
    }
  };

  const pullValue = () => {
    return new Promise<V>((resolve) => {
      if (pushQueue.length !== 0) {
        const args = pushQueue.shift();
        // @ts-ignore
        resolve(...args);
      } else {
        pullQueue.push(resolve);
      }
    });
  };

  const handler = (...args) => {
    pushValue(args);
  };

  eventSource.addEventListener(eventType, handler);
  const r = {
    next: async () => {
      if (done) return {done: true, value: undefined};
      return {
        done: false,
        value: await pullValue()
      };
    },
    return: async () => {
      done = true;
      eventSource.removeEventListener(eventType, handler);
      return {done: true, value: undefined};
    },
    throw: async (error) => {
      done = true;
      return {
        done: true,
        value: Promise.reject(error)
      };
    }
  };
  return r;
};<fim_middle>",correct,959
any,any,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b: <fim_suffix>) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1042
any,any,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj: <fim_suffix>) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1044
any,any,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj: <fim_suffix>) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1048
any,any,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj: <fim_suffix>, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1050
any,any,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj: <fim_suffix>, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1052
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val): <fim_suffix> {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1078
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val): <fim_suffix> {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1084
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val: <fim_suffix>) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1088
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val): <fim_suffix> {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1090
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val): <fim_suffix> {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1093
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = ''): <fim_suffix> {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1096
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val: <fim_suffix>, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1100
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p: <fim_suffix>) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1101
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1102
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ: <fim_suffix>) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1103
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p: <fim_suffix>) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1104
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ): <fim_suffix> {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1105
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val: <fim_suffix>, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1109
any,any,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ: <fim_suffix>, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1110
any,any,a82baefa18a0fd725d357639aed4d06750499589,"<fim_prefix>/**
 * @function getReferenceKey
 *
 * @description
 * get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join('.') || '.'
}

/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */
function getCutoff(array, value) {
  const { length } = array

  for (let index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1
    }
  }

  return 0
}

type StandardReplacer = (key, value) => any
type CircularReplacer = (key, value, referenceKey) => any

/**
 * @function createReplacer
 *
 * @description
 * create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */
function createReplacer(
  replacer?,
  circularReplacer?,
) {
  const hasReplacer = typeof replacer === 'function'
  const hasCircularReplacer = typeof circularReplacer === 'function'

  const cache: any[] = []
  const keys: string[] = []

  return function replace(this, key, value: <fim_suffix>) {
    if (typeof value === 'object') {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this)

        if (thisCutoff === 0) {
          cache[cache.length] = this
        } else {
          cache.splice(thisCutoff)
          keys.splice(thisCutoff)
        }

        keys[keys.length] = key

        const valueCutoff = getCutoff(cache, value)

        if (valueCutoff !== 0) {
          return hasCircularReplacer
            ? circularReplacer.call(
                this,
                key,
                value,
                getReferenceKey(keys, valueCutoff),
              )
            : `[ref=${getReferenceKey(keys, valueCutoff)}]`
        }
      } else {
        cache[0] = value
        keys[0] = key
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value
  }
}

/**
 * @function stringify
 *
 * @description
 * strinigifer that handles circular values
 * Forked from https://github.com/planttheidea/fast-stringify
 *
 * @param value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */
export function serialize(
  value,
  replacer?,
  indent?,
  circularReplacer?,
) {
  return JSON.stringify(
    value,
    createReplacer(replacer, circularReplacer),
    indent ?? undefined,
  )
}
<fim_middle>",correct,1277
any,any,a82baefa18a0fd725d357639aed4d06750499589,"<fim_prefix>/**
 * @function getReferenceKey
 *
 * @description
 * get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join('.') || '.'
}

/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */
function getCutoff(array, value) {
  const { length } = array

  for (let index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1
    }
  }

  return 0
}

type StandardReplacer = (key, value) => any
type CircularReplacer = (key, value: <fim_suffix>, referenceKey) => any

/**
 * @function createReplacer
 *
 * @description
 * create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */
function createReplacer(
  replacer?,
  circularReplacer?,
) {
  const hasReplacer = typeof replacer === 'function'
  const hasCircularReplacer = typeof circularReplacer === 'function'

  const cache: any[] = []
  const keys: string[] = []

  return function replace(this, key, value) {
    if (typeof value === 'object') {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this)

        if (thisCutoff === 0) {
          cache[cache.length] = this
        } else {
          cache.splice(thisCutoff)
          keys.splice(thisCutoff)
        }

        keys[keys.length] = key

        const valueCutoff = getCutoff(cache, value)

        if (valueCutoff !== 0) {
          return hasCircularReplacer
            ? circularReplacer.call(
                this,
                key,
                value,
                getReferenceKey(keys, valueCutoff),
              )
            : `[ref=${getReferenceKey(keys, valueCutoff)}]`
        }
      } else {
        cache[0] = value
        keys[0] = key
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value
  }
}

/**
 * @function stringify
 *
 * @description
 * strinigifer that handles circular values
 * Forked from https://github.com/planttheidea/fast-stringify
 *
 * @param value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */
export function serialize(
  value,
  replacer?,
  indent?,
  circularReplacer?,
) {
  return JSON.stringify(
    value,
    createReplacer(replacer, circularReplacer),
    indent ?? undefined,
  )
}
<fim_middle>",correct,1284
any,any,a82baefa18a0fd725d357639aed4d06750499589,"<fim_prefix>/**
 * @function getReferenceKey
 *
 * @description
 * get the reference key for the circular value
 *
 * @param keys the keys to build the reference key from
 * @param cutoff the maximum number of keys to include
 * @returns the reference key
 */
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join('.') || '.'
}

/**
 * @function getCutoff
 *
 * @description
 * faster `Array.prototype.indexOf` implementation build for slicing / splicing
 *
 * @param array the array to match the value in
 * @param value the value to match
 * @returns the matching index, or -1
 */
function getCutoff(array, value: <fim_suffix>) {
  const { length } = array

  for (let index = 0; index < length; ++index) {
    if (array[index] === value) {
      return index + 1
    }
  }

  return 0
}

type StandardReplacer = (key, value) => any
type CircularReplacer = (key, value, referenceKey) => any

/**
 * @function createReplacer
 *
 * @description
 * create a replacer method that handles circular values
 *
 * @param [replacer] a custom replacer to use for non-circular values
 * @param [circularReplacer] a custom replacer to use for circular methods
 * @returns the value to stringify
 */
function createReplacer(
  replacer?,
  circularReplacer?,
) {
  const hasReplacer = typeof replacer === 'function'
  const hasCircularReplacer = typeof circularReplacer === 'function'

  const cache: any[] = []
  const keys: string[] = []

  return function replace(this, key, value) {
    if (typeof value === 'object') {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this)

        if (thisCutoff === 0) {
          cache[cache.length] = this
        } else {
          cache.splice(thisCutoff)
          keys.splice(thisCutoff)
        }

        keys[keys.length] = key

        const valueCutoff = getCutoff(cache, value)

        if (valueCutoff !== 0) {
          return hasCircularReplacer
            ? circularReplacer.call(
                this,
                key,
                value,
                getReferenceKey(keys, valueCutoff),
              )
            : `[ref=${getReferenceKey(keys, valueCutoff)}]`
        }
      } else {
        cache[0] = value
        keys[0] = key
      }
    }

    return hasReplacer ? replacer.call(this, key, value) : value
  }
}

/**
 * @function stringify
 *
 * @description
 * strinigifer that handles circular values
 * Forked from https://github.com/planttheidea/fast-stringify
 *
 * @param value to stringify
 * @param [replacer] a custom replacer function for handling standard values
 * @param [indent] the number of spaces to indent the output by
 * @param [circularReplacer] a custom replacer function for handling circular values
 * @returns the stringified output
 */
export function serialize(
  value,
  replacer?,
  indent?,
  circularReplacer?,
) {
  return JSON.stringify(
    value,
    createReplacer(replacer, circularReplacer),
    indent ?? undefined,
  )
}
<fim_middle>",correct,1288
any,any,5b82a1ed5e883233d9103395a1da4ecb4296ec2e,"<fim_prefix>/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

type Operator = '<truthy>'|'='|'*='|'|='|'^='|'$='|'~=';
export type ParsedComponentAttribute = {
  jsonPath: string[],
  op: Operator,
  value: any,
  caseSensitive: boolean,
};

export type ParsedComponentSelector = {
  name: string,
  attributes: ParsedComponentAttribute[],
};

export function checkComponentAttribute(obj, attr) {
  for (const token of attr.jsonPath) {
    if (obj !== undefined && obj !== null)
      obj = obj[token];
  }
  return matchesAttribute(obj, attr);
}

export function matchesAttribute(value: <fim_suffix>, attr) {
  const objValue = typeof value === 'string' && !attr.caseSensitive ? value.toUpperCase() : value;
  const attrValue = typeof attr.value === 'string' && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;

  if (attr.op === '<truthy>')
    return !!objValue;
  if (attr.op === '=') {
    if (attrValue instanceof RegExp)
      return typeof objValue === 'string' && !!objValue.match(attrValue);
    return objValue === attrValue;
  }
  if (typeof objValue !== 'string' || typeof attrValue !== 'string')
    return false;
  if (attr.op === '*=')
    return objValue.includes(attrValue);
  if (attr.op === '^=')
    return objValue.startsWith(attrValue);
  if (attr.op === '$=')
    return objValue.endsWith(attrValue);
  if (attr.op === '|=')
    return objValue === attrValue || objValue.startsWith(attrValue + '-');
  if (attr.op === '~=')
    return objValue.split(' ').includes(attrValue);
  return false;
}

export function parseComponentSelector(selector) {
  let wp = 0;
  let EOL = selector.length === 0;

  const next = () => selector[wp] || '';
  const eat1 = () => {
    const result = next();
    ++wp;
    EOL = wp >= selector.length;
    return result;
  };

  const syntaxError = (stage) => {
    if (EOL)
      throw new Error(`Unexpected end of selector while parsing selector \`${selector}\``);
    throw new Error(`Error while parsing selector \`${selector}\` - unexpected symbol ""${next()}"" at position ${wp}` + (stage ? ' during ' + stage : ''));
  };

  function skipSpaces() {
    while (!EOL && /\s/.test(next()))
      eat1();
  }

  function readIdentifier() {
    let result = '';
    skipSpaces();
    while (!EOL && /[-$0-9A-Z_]/i.test(next()))
      result += eat1();
    return result;
  }

  function readQuotedString(quote) {
    let result = eat1();
    if (result !== quote)
      syntaxError('parsing quoted string');
    while (!EOL && next() !== quote) {
      if (next() === '\\')
        eat1();
      result += eat1();
    }
    if (next() !== quote)
      syntaxError('parsing quoted string');
    result += eat1();
    return result;
  }

  function readRegularExpression() {
    if (eat1() !== '/')
      syntaxError('parsing regular expression');
    let source = '';
    let inClass = false;
    // https://262.ecma-international.org/11.0/#sec-literals-regular-expression-literals
    while (!EOL) {
      if (next() === '\\') {
        source += eat1();
        if (EOL)
          syntaxError('parsing regular expressiion');
      } else if (inClass && next() === ']') {
        inClass = false;
      } else if (!inClass && next() === '[') {
        inClass = true;
      } else if (!inClass && next() === '/') {
        break;
      }
      source += eat1();
    }
    if (eat1() !== '/')
      syntaxError('parsing regular expression');
    let flags = '';
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
    while (!EOL && next().match(/[dgimsuy]/))
      flags += eat1();
    try {
      return new RegExp(source, flags);
    } catch (e) {
      throw new Error(`Error while parsing selector \`${selector}\`: ${e.message}`);
    }
  }

  function readAttributeToken() {
    let token = '';
    skipSpaces();
    if (next() === `'` || next() === `""`)
      token = readQuotedString(next()).slice(1, -1);
    else
      token = readIdentifier();
    if (!token)
      syntaxError('parsing property path');
    return token;
  }

  function readOperator() {
    skipSpaces();
    let op = '';
    if (!EOL)
      op += eat1();
    if (!EOL && (op !== '='))
      op += eat1();
    if (!['=', '*=', '^=', '$=', '|=', '~='].includes(op))
      syntaxError('parsing operator');
    return (op as Operator);
  }

  function readAttribute() {
    // skip leading [
    eat1();

    // read attribute name:
    // foo.bar
    // 'foo'  . ""ba zz""
    const jsonPath = [];
    jsonPath.push(readAttributeToken());
    skipSpaces();
    while (next() === '.') {
      eat1();
      jsonPath.push(readAttributeToken());
      skipSpaces();
    }
    // check property is truthy: [enabled]
    if (next() === ']') {
      eat1();
      return { jsonPath, op: '<truthy>', value: null, caseSensitive: false };
    }

    const operator = readOperator();

    let value = undefined;
    let caseSensitive = true;
    skipSpaces();
    if (next() === '/') {
      if (operator !== '=')
        throw new Error(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with regular expression`);
      value = readRegularExpression();
    } else if (next() === `'` || next() === `""`) {
      value = readQuotedString(next()).slice(1, -1);
      skipSpaces();
      if (next() === 'i' || next() === 'I') {
        caseSensitive = false;
        eat1();
      } else if (next() === 's' || next() === 'S') {
        caseSensitive = true;
        eat1();
      }
    } else {
      value = '';
      while (!EOL && !/\s/.test(next()) && next() !== ']')
        value += eat1();
      if (value === 'true') {
        value = true;
      } else if (value === 'false') {
        value = false;
      } else {
        value = +value;
        if (isNaN(value))
          syntaxError('parsing attribute value');
      }
    }
    skipSpaces();
    if (next() !== ']')
      syntaxError('parsing attribute value');

    eat1();
    if (operator !== '=' && typeof value !== 'string')
      throw new Error(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);
    return { jsonPath, op: operator, value, caseSensitive };
  }

  const result: ParsedComponentSelector = {
    name: '',
    attributes: [],
  };
  result.name = readIdentifier();
  skipSpaces();
  while (next() === '[') {
    result.attributes.push(readAttribute());
    skipSpaces();
  }
  if (!EOL)
    syntaxError(undefined);
  if (!result.name && !result.attributes.length)
    throw new Error(`Error while parsing selector \`${selector}\` - selector cannot be empty`);
  return result;
}
<fim_middle>",correct,1954
any,any,5b82a1ed5e883233d9103395a1da4ecb4296ec2e,"<fim_prefix>/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

type Operator = '<truthy>'|'='|'*='|'|='|'^='|'$='|'~=';
export type ParsedComponentAttribute = {
  jsonPath: string[],
  op: Operator,
  value: any,
  caseSensitive: boolean,
};

export type ParsedComponentSelector = {
  name: string,
  attributes: ParsedComponentAttribute[],
};

export function checkComponentAttribute(obj: <fim_suffix>, attr) {
  for (const token of attr.jsonPath) {
    if (obj !== undefined && obj !== null)
      obj = obj[token];
  }
  return matchesAttribute(obj, attr);
}

export function matchesAttribute(value, attr) {
  const objValue = typeof value === 'string' && !attr.caseSensitive ? value.toUpperCase() : value;
  const attrValue = typeof attr.value === 'string' && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;

  if (attr.op === '<truthy>')
    return !!objValue;
  if (attr.op === '=') {
    if (attrValue instanceof RegExp)
      return typeof objValue === 'string' && !!objValue.match(attrValue);
    return objValue === attrValue;
  }
  if (typeof objValue !== 'string' || typeof attrValue !== 'string')
    return false;
  if (attr.op === '*=')
    return objValue.includes(attrValue);
  if (attr.op === '^=')
    return objValue.startsWith(attrValue);
  if (attr.op === '$=')
    return objValue.endsWith(attrValue);
  if (attr.op === '|=')
    return objValue === attrValue || objValue.startsWith(attrValue + '-');
  if (attr.op === '~=')
    return objValue.split(' ').includes(attrValue);
  return false;
}

export function parseComponentSelector(selector) {
  let wp = 0;
  let EOL = selector.length === 0;

  const next = () => selector[wp] || '';
  const eat1 = () => {
    const result = next();
    ++wp;
    EOL = wp >= selector.length;
    return result;
  };

  const syntaxError = (stage) => {
    if (EOL)
      throw new Error(`Unexpected end of selector while parsing selector \`${selector}\``);
    throw new Error(`Error while parsing selector \`${selector}\` - unexpected symbol ""${next()}"" at position ${wp}` + (stage ? ' during ' + stage : ''));
  };

  function skipSpaces() {
    while (!EOL && /\s/.test(next()))
      eat1();
  }

  function readIdentifier() {
    let result = '';
    skipSpaces();
    while (!EOL && /[-$0-9A-Z_]/i.test(next()))
      result += eat1();
    return result;
  }

  function readQuotedString(quote) {
    let result = eat1();
    if (result !== quote)
      syntaxError('parsing quoted string');
    while (!EOL && next() !== quote) {
      if (next() === '\\')
        eat1();
      result += eat1();
    }
    if (next() !== quote)
      syntaxError('parsing quoted string');
    result += eat1();
    return result;
  }

  function readRegularExpression() {
    if (eat1() !== '/')
      syntaxError('parsing regular expression');
    let source = '';
    let inClass = false;
    // https://262.ecma-international.org/11.0/#sec-literals-regular-expression-literals
    while (!EOL) {
      if (next() === '\\') {
        source += eat1();
        if (EOL)
          syntaxError('parsing regular expressiion');
      } else if (inClass && next() === ']') {
        inClass = false;
      } else if (!inClass && next() === '[') {
        inClass = true;
      } else if (!inClass && next() === '/') {
        break;
      }
      source += eat1();
    }
    if (eat1() !== '/')
      syntaxError('parsing regular expression');
    let flags = '';
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
    while (!EOL && next().match(/[dgimsuy]/))
      flags += eat1();
    try {
      return new RegExp(source, flags);
    } catch (e) {
      throw new Error(`Error while parsing selector \`${selector}\`: ${e.message}`);
    }
  }

  function readAttributeToken() {
    let token = '';
    skipSpaces();
    if (next() === `'` || next() === `""`)
      token = readQuotedString(next()).slice(1, -1);
    else
      token = readIdentifier();
    if (!token)
      syntaxError('parsing property path');
    return token;
  }

  function readOperator() {
    skipSpaces();
    let op = '';
    if (!EOL)
      op += eat1();
    if (!EOL && (op !== '='))
      op += eat1();
    if (!['=', '*=', '^=', '$=', '|=', '~='].includes(op))
      syntaxError('parsing operator');
    return (op as Operator);
  }

  function readAttribute() {
    // skip leading [
    eat1();

    // read attribute name:
    // foo.bar
    // 'foo'  . ""ba zz""
    const jsonPath = [];
    jsonPath.push(readAttributeToken());
    skipSpaces();
    while (next() === '.') {
      eat1();
      jsonPath.push(readAttributeToken());
      skipSpaces();
    }
    // check property is truthy: [enabled]
    if (next() === ']') {
      eat1();
      return { jsonPath, op: '<truthy>', value: null, caseSensitive: false };
    }

    const operator = readOperator();

    let value = undefined;
    let caseSensitive = true;
    skipSpaces();
    if (next() === '/') {
      if (operator !== '=')
        throw new Error(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with regular expression`);
      value = readRegularExpression();
    } else if (next() === `'` || next() === `""`) {
      value = readQuotedString(next()).slice(1, -1);
      skipSpaces();
      if (next() === 'i' || next() === 'I') {
        caseSensitive = false;
        eat1();
      } else if (next() === 's' || next() === 'S') {
        caseSensitive = true;
        eat1();
      }
    } else {
      value = '';
      while (!EOL && !/\s/.test(next()) && next() !== ']')
        value += eat1();
      if (value === 'true') {
        value = true;
      } else if (value === 'false') {
        value = false;
      } else {
        value = +value;
        if (isNaN(value))
          syntaxError('parsing attribute value');
      }
    }
    skipSpaces();
    if (next() !== ']')
      syntaxError('parsing attribute value');

    eat1();
    if (operator !== '=' && typeof value !== 'string')
      throw new Error(`Error while parsing selector \`${selector}\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);
    return { jsonPath, op: operator, value, caseSensitive };
  }

  const result: ParsedComponentSelector = {
    name: '',
    attributes: [],
  };
  result.name = readIdentifier();
  skipSpaces();
  while (next() === '[') {
    result.attributes.push(readAttribute());
    skipSpaces();
  }
  if (!EOL)
    syntaxError(undefined);
  if (!result.name && !result.attributes.length)
    throw new Error(`Error while parsing selector \`${selector}\` - selector cannot be empty`);
  return result;
}
<fim_middle>",correct,1956
any,any,6fdc98bd63b2f0126ccecd3c15165b64dbd193ea,"<fim_prefix>/*!
 * @license
 * Copyright 2016 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export class TaskDetailsCloudModel {

    id: string;
    name: string;
    appName: string;
    assignee: string;
    appVersion: string;
    createdDate: Date;
    claimedDate: Date;
    formKey: any;
    category: any;
    description: string;
    dueDate: Date;
    lastModified: Date;
    lastModifiedTo: Date;
    lastModifiedFrom: Date;
    owner: any;
    parentTaskId: number;
    priority: number;
    processDefinitionId: string;
    processInstanceId: string;
    serviceType: any;
    status: string;
    standAlone: boolean;
    serviceName: string;
    serviceFullName: string;
    serviceVersion: string;

        constructor(obj?: <fim_suffix>) {
          if (obj) {
              this.id = obj.id || null;
              this.name = obj.name || null;
              this.appName = obj.appName || null;
              this.assignee = obj.assignee || null;
              this.appVersion = obj.appVersion || null;
              this.createdDate = obj.createdDate || null;
              this.claimedDate = obj.claimedDate || null;
              this.formKey = obj.formKey || null;
              this.description = obj.description || null;
              this.dueDate = obj.dueDate || null;
              this.lastModified = obj.lastModified || null;
              this.lastModifiedTo = obj.lastModifiedTo || null;
              this.lastModifiedFrom = obj.lastModifiedFrom || null;
              this.owner = obj.owner || null;
              this.parentTaskId = obj.parentTaskId || null;
              this.priority = obj.priority || null;
              this.processDefinitionId = obj.processDefinitionId || null;
              this.processInstanceId = obj.processInstanceId || null;
              this.serviceType = obj.serviceType || null;
              this.status = obj.status || null;
              this.standAlone = obj.standAlone || null;
              this.serviceName = obj.serviceName || null;
              this.serviceName = obj.serviceName || null;
              this.serviceFullName = obj.serviceFullName || null;
              this.serviceVersion = obj.serviceVersion || null;
          }
        }
  }

export interface StartTaskCloudResponseModel {
    entry: TaskDetailsCloudModel;
}
<fim_middle>",correct,2000
any,any,9eb078d7d68852e0860617c539c62b7d3a9f0a9a,"<fim_prefix>/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key) => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current,
    index,
    path,
    value,
    destroyArrays,
) => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state, key, value: <fim_suffix>) => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
<fim_middle>",correct,2053
any,any,9eb078d7d68852e0860617c539c62b7d3a9f0a9a,"<fim_prefix>/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key) => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current,
    index,
    path,
    value: <fim_suffix>,
    destroyArrays,
) => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state, key, value) => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
<fim_middle>",correct,2058
any,any,686a3d979188052d4bcd90ff093e101c4deafa40,"<fim_prefix>/**
 * @description LRU 缓存 - 不使用 Map
 * @author 双越老师
 */

interface IListNode {
    value: any
    key: string // 存储 key ，方便删除（否则删除时就需要遍历 this.data )
    prev?: IListNode
    next?: IListNode
}

export default class LRUCache {
    private length: number
    private data: { [key: string]: IListNode } = {}
    private dataLength: number = 0
    private listHead: IListNode | null = null
    private listTail: IListNode | null = null

    constructor(length) {
        if (length < 1) throw new Error('invalid length')
        this.length = length
    }

    private moveToTail(curNode) {
        const tail = this.listTail
        if (tail === curNode) return

        // -------------- 1. 让 prevNode nextNode 断绝与 curNode 的关系 --------------
        const prevNode = curNode.prev
        const nextNode = curNode.next
        if (prevNode) {
            if (nextNode) {
                prevNode.next = nextNode
            } else {
                delete prevNode.next
            }
        }
        if (nextNode) {
            if (prevNode) {
                nextNode.prev = prevNode
            } else {
                delete nextNode.prev
            }

            if (this.listHead === curNode) this.listHead = nextNode
        }

        // -------------- 2. 让 curNode 断绝与 prevNode nextNode 的关系 --------------
        delete curNode.prev
        delete curNode.next

        // -------------- 3. 在 list 末尾重新建立 curNode 的新关系 --------------
        if (tail) {
            tail.next = curNode
            curNode.prev = tail
        }
        this.listTail = curNode
    }

    private tryClean() {
        while (this.dataLength > this.length) {
            const head = this.listHead
            if (head == null) throw new Error('head is null')
            const headNext = head.next
            if (headNext == null) throw new Error('headNext is null')

            // 1. 断绝 head 和 next 的关系
            delete headNext.prev
            delete head.next

            // 2. 重新赋值 listHead
            this.listHead = headNext

            // 3. 清理 data ，重新计数
            delete this.data[head.key]
            this.dataLength = this.dataLength - 1
        }
    }

    get(key) {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) return null

        if (this.listTail === curNode) {
            // 本身在末尾（最新鲜的位置），直接返回 value
            return curNode.value
        }

        // curNode 移动到末尾
        this.moveToTail(curNode)

        return curNode.value
    }

    set(key, value: <fim_suffix>) {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) {
            // 新增数据
            const newNode: IListNode = { key, value }
            // 移动到末尾
            this.moveToTail(newNode)

            data[key] = newNode
            this.dataLength++

            if (this.dataLength === 1) this.listHead = newNode
        } else {
            // 修改现有数据
            curNode.value = value
            // 移动到末尾
            this.moveToTail(curNode)
        }

        // 尝试清理长度
        this.tryClean()
    }
}

// const lruCache = new LRUCache(2)
// lruCache.set('1', 1) // {1=1}
// lruCache.set('2', 2) // {1=1, 2=2}
// console.info(lruCache.get('1')) // 1 {2=2, 1=1}
// lruCache.set('3', 3) // {1=1, 3=3}
// console.info(lruCache.get('2')) // null
// lruCache.set('4', 4) // {3=3, 4=4}
// console.info(lruCache.get('1')) // null
// console.info(lruCache.get('3')) // 3 {4=4, 3=3}
// console.info(lruCache.get('4')) // 4 {3=3, 4=4}
<fim_middle>",correct,2098
any,any,686a3d979188052d4bcd90ff093e101c4deafa40,"<fim_prefix>/**
 * @description LRU 缓存 - 不使用 Map
 * @author 双越老师
 */

interface IListNode {
    value: any
    key: string // 存储 key ，方便删除（否则删除时就需要遍历 this.data )
    prev?: IListNode
    next?: IListNode
}

export default class LRUCache {
    private length: number
    private data: { [key: string]: IListNode } = {}
    private dataLength: number = 0
    private listHead: IListNode | null = null
    private listTail: IListNode | null = null

    constructor(length) {
        if (length < 1) throw new Error('invalid length')
        this.length = length
    }

    private moveToTail(curNode) {
        const tail = this.listTail
        if (tail === curNode) return

        // -------------- 1. 让 prevNode nextNode 断绝与 curNode 的关系 --------------
        const prevNode = curNode.prev
        const nextNode = curNode.next
        if (prevNode) {
            if (nextNode) {
                prevNode.next = nextNode
            } else {
                delete prevNode.next
            }
        }
        if (nextNode) {
            if (prevNode) {
                nextNode.prev = prevNode
            } else {
                delete nextNode.prev
            }

            if (this.listHead === curNode) this.listHead = nextNode
        }

        // -------------- 2. 让 curNode 断绝与 prevNode nextNode 的关系 --------------
        delete curNode.prev
        delete curNode.next

        // -------------- 3. 在 list 末尾重新建立 curNode 的新关系 --------------
        if (tail) {
            tail.next = curNode
            curNode.prev = tail
        }
        this.listTail = curNode
    }

    private tryClean() {
        while (this.dataLength > this.length) {
            const head = this.listHead
            if (head == null) throw new Error('head is null')
            const headNext = head.next
            if (headNext == null) throw new Error('headNext is null')

            // 1. 断绝 head 和 next 的关系
            delete headNext.prev
            delete head.next

            // 2. 重新赋值 listHead
            this.listHead = headNext

            // 3. 清理 data ，重新计数
            delete this.data[head.key]
            this.dataLength = this.dataLength - 1
        }
    }

    get(key): <fim_suffix> {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) return null

        if (this.listTail === curNode) {
            // 本身在末尾（最新鲜的位置），直接返回 value
            return curNode.value
        }

        // curNode 移动到末尾
        this.moveToTail(curNode)

        return curNode.value
    }

    set(key, value) {
        const data = this.data
        const curNode = data[key]

        if (curNode == null) {
            // 新增数据
            const newNode: IListNode = { key, value }
            // 移动到末尾
            this.moveToTail(newNode)

            data[key] = newNode
            this.dataLength++

            if (this.dataLength === 1) this.listHead = newNode
        } else {
            // 修改现有数据
            curNode.value = value
            // 移动到末尾
            this.moveToTail(curNode)
        }

        // 尝试清理长度
        this.tryClean()
    }
}

// const lruCache = new LRUCache(2)
// lruCache.set('1', 1) // {1=1}
// lruCache.set('2', 2) // {1=1, 2=2}
// console.info(lruCache.get('1')) // 1 {2=2, 1=1}
// lruCache.set('3', 3) // {1=1, 3=3}
// console.info(lruCache.get('2')) // null
// lruCache.set('4', 4) // {3=3, 4=4}
// console.info(lruCache.get('1')) // null
// console.info(lruCache.get('3')) // 3 {4=4, 3=3}
// console.info(lruCache.get('4')) // 4 {3=3, 4=4}
<fim_middle>",correct,2100
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val): <fim_suffix> {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2409
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val: <fim_suffix>) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2410
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val): <fim_suffix> {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2415
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val: <fim_suffix>) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2416
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val): <fim_suffix> {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2418
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val: <fim_suffix>) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2419
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val): <fim_suffix> {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2421
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val): <fim_suffix> {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2424
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = ''): <fim_suffix> {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2427
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: <fim_suffix>, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2431
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: <fim_suffix>) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2432
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2433
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: <fim_suffix>) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2434
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ): <fim_suffix> {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2436
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val: <fim_suffix>, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2440
any,any,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ: <fim_suffix>, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2441
any,any,67153e5b35f0b672d7742a020b28194aa27c93e2,"<fim_prefix>/**
 * @hidden
 */
export type JsonVisitor = (value) => any;

/**
 * @hidden
 */
export class JsonTree {
  public static visit(
    data,
    visitor,
    depth = 0,
  ) {
    if (depth > 1000) {
      throw new Error(
        'Tree depth exceeded maximum of 1000, verify the data is not self-referential',
      );
    }

    if (data == null) {
      return;
    } else if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        JsonTree.visit(item, visitor, depth + 1);
        const newValue = visitor(item);

        if (newValue !== undefined) {
          data[i] = newValue;
        }
      }
    } else if (typeof data === 'object') {
      const keys = Object.keys(data);
      for (const key of keys) {
        JsonTree.visit(data[key], visitor, depth + 1);
        const newValue = visitor(data[key]);
        if (newValue !== undefined) {
          data[key] = newValue;
        }
      }
    }
  }

  public static async asyncVisit(
    data: <fim_suffix>,
    visitor,
    depth = 0,
  ) {
    if (depth > 1000) {
      throw new Error(
        'Tree depth exceeded maximum of 1000, verify the data is not self-referential',
      );
    }

    if (data == null) {
      return;
    } else if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        await JsonTree.asyncVisit(item, visitor, depth + 1);
        await visitor(item);
      }
    } else if (typeof data === 'object') {
      const keys = Object.keys(data);
      for (const key of keys) {
        await JsonTree.asyncVisit(data[key], visitor, depth + 1);
        await visitor(data[key]);
      }
    }
  }
}
<fim_middle>",correct,2449
any,any,67153e5b35f0b672d7742a020b28194aa27c93e2,"<fim_prefix>/**
 * @hidden
 */
export type JsonVisitor = (value: <fim_suffix>) => any;

/**
 * @hidden
 */
export class JsonTree {
  public static visit(
    data,
    visitor,
    depth = 0,
  ) {
    if (depth > 1000) {
      throw new Error(
        'Tree depth exceeded maximum of 1000, verify the data is not self-referential',
      );
    }

    if (data == null) {
      return;
    } else if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        JsonTree.visit(item, visitor, depth + 1);
        const newValue = visitor(item);

        if (newValue !== undefined) {
          data[i] = newValue;
        }
      }
    } else if (typeof data === 'object') {
      const keys = Object.keys(data);
      for (const key of keys) {
        JsonTree.visit(data[key], visitor, depth + 1);
        const newValue = visitor(data[key]);
        if (newValue !== undefined) {
          data[key] = newValue;
        }
      }
    }
  }

  public static async asyncVisit(
    data,
    visitor,
    depth = 0,
  ) {
    if (depth > 1000) {
      throw new Error(
        'Tree depth exceeded maximum of 1000, verify the data is not self-referential',
      );
    }

    if (data == null) {
      return;
    } else if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        const item = data[i];
        await JsonTree.asyncVisit(item, visitor, depth + 1);
        await visitor(item);
      }
    } else if (typeof data === 'object') {
      const keys = Object.keys(data);
      for (const key of keys) {
        await JsonTree.asyncVisit(data[key], visitor, depth + 1);
        await visitor(data[key]);
      }
    }
  }
}
<fim_middle>",correct,2454
any,any,8c770ae92e7ff909e219b25309a1ff0b791e0a69,"<fim_prefix>type PromiseExecutor<TValue> = (
  resolve,
  reject
) => void;

type CancelablePromiseState = {
  isCanceled: boolean;
  onCancelList: Array<(...args) => any>;
};

function createInternalCancelablePromise<TValue>(
  promise,
  initialState
) {
  const state = initialState;

  return {
    then(onfulfilled, onrejected) {
      return createInternalCancelablePromise(
        promise.then(
          createCallback(onfulfilled, state, promise),
          createCallback(onrejected, state, promise)
        ),
        state
      );
    },
    catch(onrejected) {
      return createInternalCancelablePromise(
        promise.catch(createCallback(onrejected, state, promise)),
        state
      );
    },
    finally(onfinally) {
      if (onfinally) {
        state.onCancelList.push(onfinally);
      }

      return createInternalCancelablePromise<TValue>(
        promise.finally(
          createCallback(
            onfinally &&
              (() => {
                state.onCancelList = [];

                return onfinally();
              }),
            state,
            promise
          )
        ),
        state
      );
    },
    cancel() {
      state.isCanceled = true;
      const callbacks = state.onCancelList;
      state.onCancelList = [];

      callbacks.forEach((callback) => {
        callback();
      });
    },
    isCanceled() {
      return state.isCanceled === true;
    },
  };
}

export type CancelablePromise<TValue> = {
  then<TResultFulfilled = TValue, TResultRejected = never>(
    onfulfilled?,
    onrejected?
  );
  catch<TResult = never>(
    onrejected?
  );
  finally(
    onfinally?
  );
  cancel();
  isCanceled();
};

export function createCancelablePromise<TValue>(
  executor
) {
  return createInternalCancelablePromise(
    new Promise<TValue>((resolve, reject) => {
      return executor(resolve, reject);
    }),
    { isCanceled: false, onCancelList: [] }
  );
}

createCancelablePromise.resolve = <TValue>(
  value?
) => cancelable(Promise.resolve(value));

createCancelablePromise.reject = (reason?: <fim_suffix>) =>
  cancelable(Promise.reject(reason));

export function cancelable<TValue>(promise) {
  return createInternalCancelablePromise(promise, {
    isCanceled: false,
    onCancelList: [],
  });
}

function createCallback(
  onResult,
  state,
  fallback
) {
  if (!onResult) {
    return fallback;
  }

  return function callback(arg?) {
    if (state.isCanceled) {
      return arg;
    }

    return onResult(arg);
  };
}
<fim_middle>",correct,2660
any,any,58fd562dee02d3cc21d41395810b0dfbcec7482a,"<fim_prefix>/** An object or array to listen for changes in within an ApiModelBase. */
type CachedCollection = { [key: string]: any; } | any[];

/**
 * Base class for all other models in the API. This model covers functionality
 * for parent-child (or owner-child) relationships, and notifying the owning
 * model when anything in the child has changed.
 */
export default abstract class ApiModelBase {
  private _watchedProps?: string[];
  private _proxy: any;

  protected constructor(public owner?) {
    this._proxy = new Proxy(this, {
      set(target, property, value: <fim_suffix>) {
        const prev: any = target[property];
        const ref = Reflect.set(target, property, value);
        if (property === 'owner') target._onOwnerChange(prev);
        if (target._watchedProps?.includes(property)) target.onChange();
        return ref;
      },
      deleteProperty(target, property) {
        const prev: any = target[property];
        const ref = Reflect.deleteProperty(target, property);
        if (property === 'owner') target._onOwnerChange(prev);
        if (target._watchedProps?.includes(property)) target.onChange();
        return ref;
      }
    });

    return this._proxy;
  }

  //#region Public Methods

  /**
   * Returns a deep copy of this model with the same public properties (except
   * for its owner). Internal or private values are not guaranteed to be
   * preserved.
   */
  abstract clone();

  /**
   * Determines whether this model is equivalent to another object.
   * 
   * @param other Object to compare this model
   */
  abstract equals(other);

  /**
   * Notifies this model and its owner that one of its values has been changed.
   */
  onChange() {
    this.owner?.onChange();
  }

  /**
   * Verifies that this model is valid. If it isn't, a detailed exception is
   * thrown to explain what is wrong. If nothing is wrong, no exception is
   * thrown.
   * 
   * @throws If this model is invalid
   */
  validate() {};

  //#endregion Public Methods

  //#region Protected Methods

  /**
   * Returns the owner to use for collections that this model contains.
   */
  protected _getCollectionOwner() {
    return this._proxy;
  }

  /**
   * Returns a proxy that listens for changes in CachedCollections.
   * 
   * @param collection CachedCollection to get proxy for
   */
  protected _getCollectionProxy<T extends CachedCollection>(
    collection, 
    onChange?TS doesn't know about _isProxy
    if (collection._isProxy) return collection;

    // can't use `this` within the Proxy traps
    const getOwner = () => this._getCollectionOwner();

    return new Proxy(collection, {
      set(target, property, value) {
        const previous = target[property];
        const ref = Reflect.set(target, property, value);
        if (property !== ""owner"") {
          const owner = getOwner();
          onChange?.(owner, target, property, previous, value);
          if (value instanceof ApiModelBase) value.owner = owner;
          owner?.onChange();
        }
        return ref;
      },
      get(target, property) {
        if (property === ""_isProxy"") return true;
        return Reflect.get(target, property);
      },
      deleteProperty(target, property) {
        const previous = target[property];
        const ref = Reflect.deleteProperty(target, property);
        if (property !== ""owner"") {
          const owner = getOwner();
          onChange?.(owner, target, property, previous);
          owner?.onChange();
        }
        return ref;
      }
    });
  }

  /**
   * Called when an object sets this one as its owner.
   * 
   * @param child The child that was added
   */
  protected _onChildAdd(child) {}

  /**
   * Called when an object removed this one as its owner.
   * 
   * @param child The child that was removed
   */
  protected _onChildRemove(child) {}

  /**
   * Called after setting the owner of this model.
   * 
   * @param previousOwner The previous owner of this model
   */
  protected _onOwnerChange(previousOwner) {
    if (previousOwner === this.owner) return;
    previousOwner?._onChildRemove(this);
    this.owner?._onChildAdd(this);
  }

  /**
   * Watches the properties with the given names for changes. When they change,
   * this model is uncached.
   * 
   * @param propNames Names of props that should be watched for changes
   */
  protected _watchProps(...propNames) {
    (this._watchedProps ??= []).push(...propNames);
  }

  //#endregion Protected Methods
}
<fim_middle>",correct,2853
any,any,a3e1dd02d438bd56221d60dc4674790870208976,"<fim_prefix>interface RecursiveTypeCheckOverload {
   (obj, againstObj)
}

//TODO Improve error handling messages and overall code structure/algorithm

export const RecursiveTypeCheck: RecursiveTypeCheckOverload = (obj, againstObj) => {
   for(const key in againstObj) {
      //* In case type should be an array 
      if(key.startsWith('[]') || key.startsWith('_[]')) {
         //* In case is optional: checking if is even defined
         if(key.startsWith('_')) {
            const keyNoArr = key.replace('_[]', '')
            if(!obj[keyNoArr]) continue
         }
         const keyNoArr = key.replace(`${key.startsWith('_') ? '_[]' : '[]'}`, '')

         //* In case is not defined and obligatory
         if(!obj[keyNoArr]) return {
            checks: false,
            err: `The key '${keyNoArr}' is missing!`
         }
         
         //* In case is not array check type
         if(!Array.isArray(obj[keyNoArr])) return {
            checks: false,
            err: `The key '${keyNoArr}' is not an array!`
         }
         
         //* In case is array get deeper
         const arrCheck = Array.from(obj[keyNoArr]).map((value: <fim_suffix>) => 
            RecursiveTypeCheck(value, againstObj[key]))
         for(const optionCheck of arrCheck) {
            if(!optionCheck.checks) return optionCheck
         }
      } 
      //* In case type should be an object
      else if(key.startsWith('{}') || key.startsWith('_{}')) {
         //* In case is optional: checking if is even defined
         if(key.startsWith('_')) {
            const keyNoObj = key.replace('_{}', '')
            if(!obj[keyNoObj]) continue
         }
         const keyNoObj = key.replace(`${key.startsWith('_') ? '_{}' : '{}'}`, '')

         //* In case is not defined and obligatory
         if(!obj[keyNoObj]) return {
            checks: false,
            err: `The key '${keyNoObj}' is missing!`
         }
         
         //* In case is not object check type
         if(!(typeof obj[keyNoObj] === 'object')) return {
            checks: false,
            err: `The key '${keyNoObj}' is not an object!`
         }
         
         //* In case object may contain any key and value
         if(againstObj[key] === ""?"") continue

         //* In case is object get deeper
         for(const checkObjChild in obj[keyNoObj]) {
            const objectCheck = RecursiveTypeCheck(obj[keyNoObj][checkObjChild], againstObj[key])
            if(!objectCheck.checks) return objectCheck
         }
      }
      //* Checking if key is optional
      else if(key.startsWith('_')) {
         const keyNoUnder = key.replace('_', '')
         //* Checking if value is even defined
         if(!obj[keyNoUnder]) continue
         
         //* In case is not object check type
         if(typeof obj[keyNoUnder] !== typeof againstObj[key]) return {
            checks: false,
            err: `The key '${keyNoUnder}' is not of type '${typeof againstObj[key]}'!`
         }

         //* In case is object get deeper
         if(typeof obj[keyNoUnder] === 'object') {
            const checkObject = RecursiveTypeCheck(obj[keyNoUnder], againstObj[key])
            if(!checkObject.checks) return checkObject
         }
      } 
      //* In case key is not optional and doesn't exist
      else if(!obj[key]) return {
         checks: false,
         err: `The key '${key}' is missing inside your dyarn config file!`
      }
      //* Checking if key is of the right type
      else if(typeof obj[key] !== typeof againstObj[key]) {
         return {
            checks: false,
            err: `The key '${key}' is not of type '${typeof againstObj[key]}'`
         }
      }
      //* Get deeper in case it's an object
      else if(typeof obj[key] === 'object') {
         if(againstObj[key] === ""?"") continue
         const recursiveRes = RecursiveTypeCheck(obj[key], againstObj[key])
         if(!recursiveRes.checks) return recursiveRes
      }
      
   }
   return { checks: true }
}<fim_middle>",correct,2956
any,any,8d8e0680708b7322d95d0440ee9a53c1c5f7ec52,"<fim_prefix>// injectable
export interface IValidator {
	validate(value);
}

export interface IPropScheme {
	prop: string;
	optional?: boolean;
	types?: Required<IValidator>;
	options?: IPropScheme[];
}

export function validate(obj: <fim_suffix>, scheme) {
	if (typeof obj !== ""object"" || obj === null) {
		return new Error(`Expecting input to be object`);
	}
	const errors: string[] = scheme
		.map((property) => {
			if (property.optional && obj[property.prop] === undefined) {
				return undefined;
			}
			if (property.types !== undefined) {
				const err: Error | undefined = property.types.validate(
					obj[property.prop]
				);
				if (err instanceof Error) {
					return err.message;
				} else {
					return undefined;
				}
			} else if (property.options instanceof Array) {
				if (
					typeof obj[property.prop] !== ""object"" ||
					obj[property.prop] === null
				) {
					return `Property ""${property.prop}"" should be an object, because it's enum`;
				}
				const target: any = obj[property.prop];
				const options: string[] = [];
				try {
					property.options.forEach((prop) => {
						if (prop.types === undefined) {
							throw new Error(
								`Invalid option description for option ""${prop.prop}"" of option ""${property.prop}""`
							);
						}
						if (target[prop.prop] !== undefined) {
							options.push(prop.prop);
							const err: Error | undefined = prop.types.validate(
								target[prop.prop]
							);
							if (err instanceof Error) {
								throw new Error(
									`Fail to validate option ""${prop.prop}"" of option ""${property.prop}"" due: ${err.message}`
								);
							}
						}
					});
				} catch (err) {
					return err instanceof Error
						? err.message
						: `Unknown error: ${err}`;
				}
				if (options.length > 1) {
					return `Enum should have only one definition or nothing. Found values for: ${options.join(
						"", ""
					)}`;
				}
				return undefined;
			} else {
				return `Invalid map definition for property ${property.prop}`;
			}
		})
		.filter((err) => err !== undefined) as string[];
	return errors.length > 0 ? new Error(errors.join(""\n"")) : undefined;
}
<fim_middle>",correct,2982
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional: <fim_suffix>) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3052
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val): <fim_suffix> {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3063
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val: <fim_suffix>) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3064
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val): <fim_suffix> {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3069
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val): <fim_suffix> {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3075
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val): <fim_suffix> {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3078
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = ''): <fim_suffix> {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3081
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val: <fim_suffix>, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3085
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p: <fim_suffix>) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3086
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ): <fim_suffix> {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3087
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ: <fim_suffix>) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3088
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ): <fim_suffix> {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3090
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val: <fim_suffix>, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3094
any,any,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ: <fim_suffix>, val, key = '') {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3095
any,any,94257ef30c23f4cdedaf7f7b70d7116f9f5c08c6,"<fim_prefix>
export class MyError extends Error {
	code: string;
	inner?: any;

	constructor(code, message?, inner?) {
		super(message || code);
		this.code = code;
		this.inner = inner;
	}
}

export const getLineAndColumn = (string, offset) => {
	let line = 1;
	let column = 1;
	for (let j = 0; j < offset; j++) {
		column += 1;
		if (string.charCodeAt(j) === 10) {
			line += 1;
			column = 1;
		}
	}
	return [line, column] as const;
}

export const getLinesRange = (
	string, 
	options = {}) => {
	options = Object.assign({ prefixLineNumbers: false, radius: 2 }, options);
	if (options.firstLine === undefined) {
		if (options.centerLine === undefined) {
			if (options.highlight) {
				options.centerLine = options.highlight.line;
			}
			else {
				throw new Error('no lines selected');
			}
		}
		if (options.radius === undefined) {
			options.radius = 2;
		}
		options.firstLine = options.centerLine - options.radius;
		if (options.lastLine === undefined) {
			options.lastLine = options.centerLine + options.radius;
		}
	}
	if (options.firstLine <= 0) {
		options.firstLine = 1;
	}
	let current = 0;
	let currentLine = 1;
	let selected: string[] = [];
	while (true) {
		const next = string.indexOf('\n', current);
		if (next === -1) {
			selected.push(string.substring(current));
			break;
		}
		if (options.firstLine <= currentLine) {
			selected.push(string.substring(current, next));
			if (currentLine == options.lastLine) {
				break;
			}
		}
		currentLine += 1;
		current = next + 1;
	}
	if (options.process) {
		selected = selected.map((text, index) => options.process!(text, options.firstLine! + index));
	}
	let prefixWidth = 0;
	if (options.prefixLineNumbers) {
		const width = ('' + (options.firstLine + selected.length)).length;
		prefixWidth = width + 2;
		selected = selected.map((text, index) => `${('' + (options.firstLine! + index)).padStart(width)}: ${text}`);
	}
	if (options.highlight) {
		const index = Math.max(options.highlight.line - options.firstLine, 0);
		const insert = options.highlight.column
			? '^'.padStart(prefixWidth + options.highlight.column) 
			: `${' '.repeat(prefixWidth)}${'^'.repeat(38)}`
		;
		selected.splice(index + 1, 0, insert);
	}
	return selected;
}

export interface ParserErrorPoint {
	offset: number;
	comment?: string;
}

export class ParserError extends MyError {
	path: string | undefined
	content: string;
	points: ParserErrorPoint[];

	constructor(code, message, path, content, points?, inner?: <fim_suffix>) {
		super(code, message, inner);
		this.path = path;
		this.content = content;
		this.points = points || [];

		// Make 'content' string not enumerable to hide it from debug printing,
		// as it would be annoying (too long to read, only beginning visible).
		Object.defineProperty(this, 'content', { enumerable: false });
	}

	override toString() {
		return [this.message, ...this.points.map(p => {
			const [line, column] = getLineAndColumn(this.content, p.offset);
			return (
				(this.path 
					? `${this.path}:${line}:${column} ${p.comment || ''}` 
					: (p.comment 
						? `${p.comment}\n` 
						: '\n'
					)
				) +
				getLinesRange(this.content, {
					prefixLineNumbers: true, 
					highlight: { line, column },
					process: (line => line.replace(/ /g, '·').replace(/\t/g, '▹')),
				}).join('\n')
			);
		})].join('\n');
	}
}

<fim_middle>",correct,3129
any,any,94257ef30c23f4cdedaf7f7b70d7116f9f5c08c6,"<fim_prefix>
export class MyError extends Error {
	code: string;
	inner?: any;

	constructor(code, message?, inner?: <fim_suffix>) {
		super(message || code);
		this.code = code;
		this.inner = inner;
	}
}

export const getLineAndColumn = (string, offset) => {
	let line = 1;
	let column = 1;
	for (let j = 0; j < offset; j++) {
		column += 1;
		if (string.charCodeAt(j) === 10) {
			line += 1;
			column = 1;
		}
	}
	return [line, column] as const;
}

export const getLinesRange = (
	string, 
	options = {}) => {
	options = Object.assign({ prefixLineNumbers: false, radius: 2 }, options);
	if (options.firstLine === undefined) {
		if (options.centerLine === undefined) {
			if (options.highlight) {
				options.centerLine = options.highlight.line;
			}
			else {
				throw new Error('no lines selected');
			}
		}
		if (options.radius === undefined) {
			options.radius = 2;
		}
		options.firstLine = options.centerLine - options.radius;
		if (options.lastLine === undefined) {
			options.lastLine = options.centerLine + options.radius;
		}
	}
	if (options.firstLine <= 0) {
		options.firstLine = 1;
	}
	let current = 0;
	let currentLine = 1;
	let selected: string[] = [];
	while (true) {
		const next = string.indexOf('\n', current);
		if (next === -1) {
			selected.push(string.substring(current));
			break;
		}
		if (options.firstLine <= currentLine) {
			selected.push(string.substring(current, next));
			if (currentLine == options.lastLine) {
				break;
			}
		}
		currentLine += 1;
		current = next + 1;
	}
	if (options.process) {
		selected = selected.map((text, index) => options.process!(text, options.firstLine! + index));
	}
	let prefixWidth = 0;
	if (options.prefixLineNumbers) {
		const width = ('' + (options.firstLine + selected.length)).length;
		prefixWidth = width + 2;
		selected = selected.map((text, index) => `${('' + (options.firstLine! + index)).padStart(width)}: ${text}`);
	}
	if (options.highlight) {
		const index = Math.max(options.highlight.line - options.firstLine, 0);
		const insert = options.highlight.column
			? '^'.padStart(prefixWidth + options.highlight.column) 
			: `${' '.repeat(prefixWidth)}${'^'.repeat(38)}`
		;
		selected.splice(index + 1, 0, insert);
	}
	return selected;
}

export interface ParserErrorPoint {
	offset: number;
	comment?: string;
}

export class ParserError extends MyError {
	path: string | undefined
	content: string;
	points: ParserErrorPoint[];

	constructor(code, message, path, content, points?, inner?) {
		super(code, message, inner);
		this.path = path;
		this.content = content;
		this.points = points || [];

		// Make 'content' string not enumerable to hide it from debug printing,
		// as it would be annoying (too long to read, only beginning visible).
		Object.defineProperty(this, 'content', { enumerable: false });
	}

	override toString() {
		return [this.message, ...this.points.map(p => {
			const [line, column] = getLineAndColumn(this.content, p.offset);
			return (
				(this.path 
					? `${this.path}:${line}:${column} ${p.comment || ''}` 
					: (p.comment 
						? `${p.comment}\n` 
						: '\n'
					)
				) +
				getLinesRange(this.content, {
					prefixLineNumbers: true, 
					highlight: { line, column },
					process: (line => line.replace(/ /g, '·').replace(/\t/g, '▹')),
				}).join('\n')
			);
		})].join('\n');
	}
}

<fim_middle>",correct,3139
any,any,b8b1d3ef8fde25053af894e390905d52bb752905,"<fim_prefix>export interface IResult {
  code: number;
  data: any
  msg: string,
  total: number
}

export enum Order {
  DESC = 'desc',
  ASC = 'asc'
}

export class Page<T> {
  page: number;
  offset: number;
  start: number;
  total: number;
  list: T[];

  static of(page, size) {
    const p = new Page()
    p.page = page;
    p.offset = size
    p.start = (page - 1) * size
    return p
  }

  paging(list) {
    this.list = list.filter((o, i) => i >= this.start && i < this.start + this.offset)
    return this
  }

  withTotal(total) {
    this.total = total
    return this
  }
}

export const buildResult = (data: <fim_suffix>, code) => {
  const result: IResult = {
    code,
    msg: null,
    total: 0,
    data: null
  }
  if (Array.isArray(data)) {
    result.total = data.length
  } else {
    if (typeof data === 'string') {
      result.msg = data
    }
    result.total = 1
    if (data instanceof Page) {
      result.total = data.total
      data = data.list
    }
  }
  result.data = data
  return result
}

export const returnSuccess = <T>(data) => {
  return buildResult(data, 200)
}

export interface User {
  id: number;
  username: string;
  mobile: string;
  email: string;
  name: string;
  enabled: number;
}

export interface Permission {
  id: number;
  parent: number;
  authority: string;
  displayName: string;
  icon: string;
  uri: string;
  enabled: number;
  permissions?: Array<Permission>;
}

export interface Log {
  id: number;
  operationName: string;
  username: string;
  operationTime: string;
}<fim_middle>",correct,3237
bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration(): <fim_suffix> {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,615
bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd(): <fim_suffix> {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration() {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,616
bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart(): <fim_suffix> {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration() {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,617
bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?, c?: <fim_suffix>) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration() {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,618
bigint,bigint,368c9ed9f5a063927a82043fbb475cd54531d039,"<fim_prefix>export interface TimeRangeString {
    start: string;
    end: string;
    offset?: string;
}

export class TimeRange {
    private start: bigint;
    private end: bigint;
    private offset: bigint | undefined;

    /**
     * Constructor.
     * @param start Range start time
     * @param end Range end time
     * @param offset Time offset, if this is defined the start and end time should be relative to this value
     */
    constructor(start, end, offset?);
    /**
     * Constructor.
     * @param timeRangeString string object returned by this.toString()
     */
    constructor(timeRangeString);
    /**
     * Constructor.
     * Default TimeRange with 0 for values
     */
    constructor();
    constructor(a?, b?: <fim_suffix>, c?) {
        if (typeof a === 'bigint' && typeof b === 'bigint') {
            this.start = a;
            this.end = b;
            this.offset = c;
        } else if (typeof a === 'object') {
            const timeRangeString: TimeRangeString = a;
            const { start, end, offset } = timeRangeString;
            this.start = BigInt(start);
            this.end = BigInt(end);
            this.offset = offset ? BigInt(offset) : undefined;
        } else {
            this.start = BigInt(0);
            this.end = BigInt(0);
            this.offset = undefined;
        }
    }

    /**
     * Get the range start time.
     * If an offset is present the return value is start + offset.
     */
    public getStart() {
        if (this.offset !== undefined) {
            return this.start + this.offset;
        }
        return this.start;
    }

    /**
     * Get the range end time.
     * If an offset is present the return value is end + offset.
     */
    public getEnd() {
        if (this.offset !== undefined) {
            return this.end + this.offset;
        }
        return this.end;
    }

    /**
     * Get range duration
     */
    public getDuration() {
        return this.end - this.start;
    }

    /**
     * Return the time offset
     */
    public getOffset() {
        return this.offset;
    }

    /**
     * Create a string object that can be JSON.stringified
     */
    public toString() {
        return {
            start: this.start.toString(),
            end: this.end.toString(),
            offset: this.offset?.toString()
        };
    }
}
<fim_middle>",correct,619
boolean,boolean,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit: <fim_suffix>
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,6
boolean,boolean,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit: <fim_suffix>
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,10
boolean,boolean,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit: <fim_suffix>) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,18
boolean,boolean,5015731de39d782d56f8a1e23bb6486643ab39bb,"<fim_prefix>interface IRowGenerateData {
	
	emailNotification: boolean | null;
	boxName: string;
	boxSensor: string;
	boxExposure: string;
	thresholdValue: string | number;
	date: Date;
	actions: string;
}




export function GetData(rowscount?, last?, hasNullValues?: <fim_suffix>) {
	const data: IRowGenerateData[] = new Array();

	if (rowscount === undefined) {
		rowscount = 100;
	}

	let startIndex = 0;

	if (last) {
		startIndex = rowscount;
		rowscount = last - rowscount;
	}

	const boxNames =
		[
			'PGKN FS02 - Rumphorst', 'BalkonBox Mindener Str.', 'BalkonBox Mindener Str.', 'Hoersterstr. 17', 'SteffenDroste', 'OC-WETTER', 'Fühlerbüchse', 'PGKN FS01 - Schule', 'KiTa Glühwürmchen', 'Westfälisches Pferdemuseum Münster', 'Hawerkamp 31', 'Martin', 'Botanischer Garten', 'Noise Sensor', 'CYBER Box', 'fancyBox3000', 'wullewup', 'Deipen4_A'
		];

	const boxSensors =
		[
			'Temperatur', 'rel. Luftfeuchte', 'Luftdruck', 'Beleuchtungsstärke', 'UV-Intensität', 'PM10', 'PM2.5'
		];

	const exposure =
		[
			'outdoor', 'indoor'
		];

	const actions =
		[
			'more than', 'less than'
		];

	const thresholdValues =
		[
			'2.25', '1.5', '3.0', '3.3', '4.5', '3.6', '3.8', '2.5', '5.0', '1.75', '3.25', '4.0'
		];

	for (let i = 0; i < rowscount; i++) {
		const row = {} as IRowGenerateData;

		const exposureindex = Math.floor(Math.random() * 2);
		const actionindex = Math.floor(Math.random() * actions.length);
		const thresholdValue = parseFloat(thresholdValues[exposureindex]);
		
		
		row.emailNotification = exposureindex % 2 === 0;

		if (hasNullValues === true) {
			if (exposureindex % 2 !== 0) {
				const random = Math.floor(Math.random() * rowscount);
				row.emailNotification = i % random === 0 ? null : false;
			}
		}

		row.boxName = boxNames[Math.floor(Math.random() * boxNames.length)];
		row.boxSensor = boxSensors[Math.floor(Math.random() * boxSensors.length)];
		row.boxExposure = exposure[exposureindex];
		row.actions = actions[actionindex];
		row.thresholdValue = thresholdValue;
		
		const date = new Date();
		date.setFullYear(2016, Math.floor(Math.random() * 11), Math.floor(Math.random() * 27));
		date.setHours(0, 0, 0, 0);
		row.date = date;

		data[i] = row;
	}

	return data;
}<fim_middle>",correct,41
boolean,boolean,357ad94655b55a5de65645b359f819f4f0054ef6,"<fim_prefix>
export const MAGIC_METHOD_REG = /^@magic\:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
export const MAGIC_METHOD = ""@magic:"";
export const SPLITTER = ""|"";
export const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
export const FUNC_START_CHARACTER = ""("";
export const FUNC_END_CHARACTER = "")"";

export interface PipeParam {
    type: string;
    value?: string;
    args?: string[];
    func?: string;    
}

export interface PipeObject {
    [key: string]: PipeParam[];
}

export interface MagicMethodResult {
    originalMethod: string;
    method: string;
    args: string[];
    pipes: PipeParam[];
    keys: PipeObject;
}

export default class MagicMethod {

    static make (str, ...args) {
        return `${MAGIC_METHOD}${str} ${args.join(SPLITTER)}`;
    }

    static check(str): <fim_suffix> {
        return str.match(MAGIC_METHOD_REG) !== null;
    }

    static parse (str)  {
        const matches = str.match(MAGIC_METHOD_REG);
    
        if (!matches) {
            return undefined;
        }    


        const result = matches[0].split(""@magic:"")[1].split(SPLITTER).map(item => item.trim());

        let [ initializer, ...pipes ] = result;
        const [ method, ...args ] = initializer.split("" "");

        const pipeList = pipes.map(it => {
            return this.parsePipe(it);
        }).filter(it => it.value);

        const pipeObjects: PipeObject = {
            'function': [],
            'keyword': [],
            'value': []
        };
        
        pipeList.forEach(pipe => {
            if (pipe.type === ""function"") {
                pipeObjects.function.push(pipe);
            } else if (pipe.type === ""keyword"") {
                pipeObjects.keyword.push(pipe);
            } else {
                pipeObjects.value.push(pipe);
            }
        });

        return {
            originalMethod: str,
            method,
            args,
            pipes: pipeList,
            keys: pipeObjects
        };
    }

    static parsePipe(it) {
        const result = it.match(FUNC_REGEXP);

        if (!result) {
            return {
                type: ""value"",
                value: it
            };
        }

        const [value] = result;

        if (value.includes(FUNC_START_CHARACTER)) {

            const [func, rest] = value.split(FUNC_START_CHARACTER)
            const [args] = rest.split(FUNC_END_CHARACTER);        
            return {
                type: ""function"",
                value,
                func,
                args: args.split("","").map(it => it.trim()).filter(Boolean)
            }
        } 

        return {
            type: ""keyword"",
            value: result[0]
        }
    }
}<fim_middle>",correct,54
boolean,boolean,1d39ec473347edb072e37f629ad2a9736fad5a7a,"<fim_prefix>export const Kind = 'Core#ResponseAuthorization';

export interface IResponseAuthorization {
  kind: typeof Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method: string;
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;
}

export class ResponseAuthorization {
  kind = Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method = 'unknown';
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;

  /**
   * @param input The response authorization definition used to restore the state.
   */
  constructor(input?) {
    let init: IResponseAuthorization;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        method: 'unknown',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new response authorization clearing anything that is so far defined.
   * 
   * Note, this throws an error when the object is not a response authorization.
   */
  new(init) {
    if (!ResponseAuthorization.isResponseAuthorization(init)) {
      throw new Error(`Not a response authorization.`);
    }
    const { method, state, headers, challengeHeader } = init;
    this.kind = Kind;
    this.method = method;
    this.state = state;
    this.headers = headers;
    this.challengeHeader = challengeHeader;
  }

  /**
   * Checks whether the input is a definition of a response authorization.
   */
  static isResponseAuthorization(input): <fim_suffix> {
    const typed = input as IResponseAuthorization;
    if (!input || !typed.method) {
      return false;
    }
    return true;
  }

  toJSON() {
    const result: IResponseAuthorization = {
      kind: Kind,
      method: this.method,
    };
    if (typeof this.state === 'number') {
      result.state = this.state;
    }
    if (this.headers) {
      result.headers = this.headers;
    }
    if (this.challengeHeader) {
      result.challengeHeader = this.challengeHeader;
    }
    return result;
  }
}
<fim_middle>",correct,75
boolean,boolean,199614470a268c39f9858a815b099f3ff800bdcc,"<fim_prefix>export interface Eq<T> {
  /* Compares the other object to this one. */
  equals(other);
}
/**
 * A base object to derive other election objects identifiable by object_id
 */
export interface ElectionObjectBase extends Eq<ElectionObjectBase> {
  /** The object_id, should be a unique string. */
  objectId: string;
}

/**
 * A ordered base object to derive other election objects.
 */
export interface OrderedObjectBase extends ElectionObjectBase {
  /**
   * Used for ordering in a ballot to ensure various encryption primitives are deterministic.
   * The sequence order must be unique and should be representative of how the items are represented
   * on a template ballot in an external system.  The sequence order is not required to be in the order
   * in which they are displayed to a voter.  Any acceptable range of integer values may be provided.
   */
  sequenceOrder: number;
}

/** Sort an array of {@link OrderedObjectBase} in sequence order. Original is unchanged. */
export function sortedArrayOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(unsorted) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.sequenceOrder - b.sequenceOrder);
}

/** Sort an array of {@link ElectionObjectBase} in lexical objectId order. Original is unchanged. */
export function sortedArrayOfAnyElectionObjects<T extends ElectionObjectBase>(
  unsorted
) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.objectId.localeCompare(b.objectId));
}

/**
 * Given an array of {@link OrderedObjectBase} objects, first sorts them
 * by their sequence order, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(a, b) {
  const sortedA = sortedArrayOfOrderedElectionObjects(a);
  const sortedB = sortedArrayOfOrderedElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}
/**
 * Given an array of any {@link ElectionObjectBase} objects, first sorts them
 * by their objectId strings, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfAnyElectionObjects<
  T extends ElectionObjectBase
>(a, b) {
  const sortedA = sortedArrayOfAnyElectionObjects(a);
  const sortedB = sortedArrayOfAnyElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}

/**
 * Given two arrays of a type that supports equals(), ({@link Eq}),
 * returns whether their contents are indeed equal. Arrays that might
 * include undefined are also supported.
 */
export function matchingArraysWithEquals<T extends Eq<T>>(
  a,
  b
) {
  // having some fun here with union types!
  if (a === undefined && b === undefined) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  } else {
    for (let i = 0; i < a.length; i++) {
      if (!objEqualsOrUndefEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}

/** Helper function: compares objects for equality, but also deals with `undefined` values.  */
export function objEqualsOrUndefEquals<T extends Eq<T>>(
  a,
  b
): <fim_suffix> {
  const aUndef = a === undefined;
  const bUndef = b === undefined;

  if (aUndef && bUndef) {
    return true;
  }

  if (aUndef || bUndef || !a.equals(b)) {
    return false;
  }

  return true;
}
<fim_middle>",correct,148
boolean,boolean,199614470a268c39f9858a815b099f3ff800bdcc,"<fim_prefix>export interface Eq<T> {
  /* Compares the other object to this one. */
  equals(other);
}
/**
 * A base object to derive other election objects identifiable by object_id
 */
export interface ElectionObjectBase extends Eq<ElectionObjectBase> {
  /** The object_id, should be a unique string. */
  objectId: string;
}

/**
 * A ordered base object to derive other election objects.
 */
export interface OrderedObjectBase extends ElectionObjectBase {
  /**
   * Used for ordering in a ballot to ensure various encryption primitives are deterministic.
   * The sequence order must be unique and should be representative of how the items are represented
   * on a template ballot in an external system.  The sequence order is not required to be in the order
   * in which they are displayed to a voter.  Any acceptable range of integer values may be provided.
   */
  sequenceOrder: number;
}

/** Sort an array of {@link OrderedObjectBase} in sequence order. Original is unchanged. */
export function sortedArrayOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(unsorted) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.sequenceOrder - b.sequenceOrder);
}

/** Sort an array of {@link ElectionObjectBase} in lexical objectId order. Original is unchanged. */
export function sortedArrayOfAnyElectionObjects<T extends ElectionObjectBase>(
  unsorted
) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.objectId.localeCompare(b.objectId));
}

/**
 * Given an array of {@link OrderedObjectBase} objects, first sorts them
 * by their sequence order, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(a, b) {
  const sortedA = sortedArrayOfOrderedElectionObjects(a);
  const sortedB = sortedArrayOfOrderedElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}
/**
 * Given an array of any {@link ElectionObjectBase} objects, first sorts them
 * by their objectId strings, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfAnyElectionObjects<
  T extends ElectionObjectBase
>(a, b) {
  const sortedA = sortedArrayOfAnyElectionObjects(a);
  const sortedB = sortedArrayOfAnyElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}

/**
 * Given two arrays of a type that supports equals(), ({@link Eq}),
 * returns whether their contents are indeed equal. Arrays that might
 * include undefined are also supported.
 */
export function matchingArraysWithEquals<T extends Eq<T>>(
  a,
  b
): <fim_suffix> {
  // having some fun here with union types!
  if (a === undefined && b === undefined) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  } else {
    for (let i = 0; i < a.length; i++) {
      if (!objEqualsOrUndefEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}

/** Helper function: compares objects for equality, but also deals with `undefined` values.  */
export function objEqualsOrUndefEquals<T extends Eq<T>>(
  a,
  b
) {
  const aUndef = a === undefined;
  const bUndef = b === undefined;

  if (aUndef && bUndef) {
    return true;
  }

  if (aUndef || bUndef || !a.equals(b)) {
    return false;
  }

  return true;
}
<fim_middle>",correct,151
boolean,boolean,199614470a268c39f9858a815b099f3ff800bdcc,"<fim_prefix>export interface Eq<T> {
  /* Compares the other object to this one. */
  equals(other);
}
/**
 * A base object to derive other election objects identifiable by object_id
 */
export interface ElectionObjectBase extends Eq<ElectionObjectBase> {
  /** The object_id, should be a unique string. */
  objectId: string;
}

/**
 * A ordered base object to derive other election objects.
 */
export interface OrderedObjectBase extends ElectionObjectBase {
  /**
   * Used for ordering in a ballot to ensure various encryption primitives are deterministic.
   * The sequence order must be unique and should be representative of how the items are represented
   * on a template ballot in an external system.  The sequence order is not required to be in the order
   * in which they are displayed to a voter.  Any acceptable range of integer values may be provided.
   */
  sequenceOrder: number;
}

/** Sort an array of {@link OrderedObjectBase} in sequence order. Original is unchanged. */
export function sortedArrayOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(unsorted) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.sequenceOrder - b.sequenceOrder);
}

/** Sort an array of {@link ElectionObjectBase} in lexical objectId order. Original is unchanged. */
export function sortedArrayOfAnyElectionObjects<T extends ElectionObjectBase>(
  unsorted
) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.objectId.localeCompare(b.objectId));
}

/**
 * Given an array of {@link OrderedObjectBase} objects, first sorts them
 * by their sequence order, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(a, b) {
  const sortedA = sortedArrayOfOrderedElectionObjects(a);
  const sortedB = sortedArrayOfOrderedElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}
/**
 * Given an array of any {@link ElectionObjectBase} objects, first sorts them
 * by their objectId strings, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfAnyElectionObjects<
  T extends ElectionObjectBase
>(a, b): <fim_suffix> {
  const sortedA = sortedArrayOfAnyElectionObjects(a);
  const sortedB = sortedArrayOfAnyElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}

/**
 * Given two arrays of a type that supports equals(), ({@link Eq}),
 * returns whether their contents are indeed equal. Arrays that might
 * include undefined are also supported.
 */
export function matchingArraysWithEquals<T extends Eq<T>>(
  a,
  b
) {
  // having some fun here with union types!
  if (a === undefined && b === undefined) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  } else {
    for (let i = 0; i < a.length; i++) {
      if (!objEqualsOrUndefEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}

/** Helper function: compares objects for equality, but also deals with `undefined` values.  */
export function objEqualsOrUndefEquals<T extends Eq<T>>(
  a,
  b
) {
  const aUndef = a === undefined;
  const bUndef = b === undefined;

  if (aUndef && bUndef) {
    return true;
  }

  if (aUndef || bUndef || !a.equals(b)) {
    return false;
  }

  return true;
}
<fim_middle>",correct,154
boolean,boolean,199614470a268c39f9858a815b099f3ff800bdcc,"<fim_prefix>export interface Eq<T> {
  /* Compares the other object to this one. */
  equals(other);
}
/**
 * A base object to derive other election objects identifiable by object_id
 */
export interface ElectionObjectBase extends Eq<ElectionObjectBase> {
  /** The object_id, should be a unique string. */
  objectId: string;
}

/**
 * A ordered base object to derive other election objects.
 */
export interface OrderedObjectBase extends ElectionObjectBase {
  /**
   * Used for ordering in a ballot to ensure various encryption primitives are deterministic.
   * The sequence order must be unique and should be representative of how the items are represented
   * on a template ballot in an external system.  The sequence order is not required to be in the order
   * in which they are displayed to a voter.  Any acceptable range of integer values may be provided.
   */
  sequenceOrder: number;
}

/** Sort an array of {@link OrderedObjectBase} in sequence order. Original is unchanged. */
export function sortedArrayOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(unsorted) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.sequenceOrder - b.sequenceOrder);
}

/** Sort an array of {@link ElectionObjectBase} in lexical objectId order. Original is unchanged. */
export function sortedArrayOfAnyElectionObjects<T extends ElectionObjectBase>(
  unsorted
) {
  const inputCopy = Array.from(unsorted);
  return inputCopy.sort((a, b) => a.objectId.localeCompare(b.objectId));
}

/**
 * Given an array of {@link OrderedObjectBase} objects, first sorts them
 * by their sequence order, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfOrderedElectionObjects<
  T extends OrderedObjectBase
>(a, b): <fim_suffix> {
  const sortedA = sortedArrayOfOrderedElectionObjects(a);
  const sortedB = sortedArrayOfOrderedElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}
/**
 * Given an array of any {@link ElectionObjectBase} objects, first sorts them
 * by their objectId strings, then does pairwise comparison for equality.
 * The inputs are not mutated.
 */
export function matchingArraysOfAnyElectionObjects<
  T extends ElectionObjectBase
>(a, b) {
  const sortedA = sortedArrayOfAnyElectionObjects(a);
  const sortedB = sortedArrayOfAnyElectionObjects(b);
  if (sortedA.length !== sortedB.length) {
    return false;
  }
  for (let i = 0; i < sortedA.length; i++) {
    if (!sortedA[i].equals(sortedB[i])) {
      return false;
    }
  }
  return true;
}

/**
 * Given two arrays of a type that supports equals(), ({@link Eq}),
 * returns whether their contents are indeed equal. Arrays that might
 * include undefined are also supported.
 */
export function matchingArraysWithEquals<T extends Eq<T>>(
  a,
  b
) {
  // having some fun here with union types!
  if (a === undefined && b === undefined) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if (a.length !== b.length) {
    return false;
  } else {
    for (let i = 0; i < a.length; i++) {
      if (!objEqualsOrUndefEquals(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
}

/** Helper function: compares objects for equality, but also deals with `undefined` values.  */
export function objEqualsOrUndefEquals<T extends Eq<T>>(
  a,
  b
) {
  const aUndef = a === undefined;
  const bUndef = b === undefined;

  if (aUndef && bUndef) {
    return true;
  }

  if (aUndef || bUndef || !a.equals(b)) {
    return false;
  }

  return true;
}
<fim_middle>",correct,157
boolean,boolean,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement: <fim_suffix>) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,271
boolean,boolean,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index ) : <fim_suffix> {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,289
boolean,boolean,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality: <fim_suffix> = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,470
boolean,boolean,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue (): <fim_suffix> {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,514
boolean,boolean,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true): <fim_suffix> {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,518
boolean,boolean,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull: <fim_suffix> = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,519
boolean,boolean,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors: <fim_suffix>) {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,638
boolean,boolean,2fdae3b2fd744628f3655d3b63661a27b1e3bdbd,"<fim_prefix>export interface ModuleOptionsConfig {
  enabledDefault?: boolean;
  headerIP?: string;
}

export interface ModuleOptions {
  url: string;
  environment: string;
  instanceId: string;
  config: ModuleOptionsConfig;
}

export interface UnleashFlagStrategy {
  name: string;
  parameters: { [p: string]: string };
}

export interface UnleashFlagsData {
  name: string;
  description: string;
  enabled: boolean;
  strategies: UnleashFlagStrategy[];
}

export interface NuxtFeatureOptionsContext {
  ip?: string;
}

export class UnleashFlags {
  // eslint-disable-next-line no-useless-constructor
  private constructor (private features, private config, private context) {}

  public static create ({
    features,
    config,
    context
  }) {
    return new UnleashFlags(features, config, context)
  }

  isEnabled (name): <fim_suffix> {
    if (!this.exists(name)) {
      return this.config.enabledDefault
    }
    return this.features.some(f => f.name === name && f.enabled)
  }

  exists (name) {
    return this.features.some(f => f.name === name)
  }

  isAllowIP (name) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const ips = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (
        this.context.ip !== undefined &&
        this.context.ip.length > 0 &&
        ips.includes(this.context.ip)
      ) {
        return true
      }
    }
    return false
  }

  isAllowUser (name, user) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const users = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (user.length > 0 && users.includes(user)) {
        return true
      }
    }
    return false
  }

  private getFeature (
    name,
    strategyName = 'userWithId'
  ) {
    const feature = this.features.find(
      f => f.name === name
    )
    if (!feature) {
      return {
        feature: undefined,
        strategies: undefined
      }
    }
    const strategies = feature.strategies.filter(
      f => f.name === strategyName
    )
    if (!strategies) {
      return {
        feature,
        strategies: undefined
      }
    }
    return {
      feature,
      strategies
    }
  }
}
<fim_middle>",correct,654
boolean,boolean,b54738c443e9096be67646dd7f26ce561c458c70,"<fim_prefix>interface ParsedDate {
	year: number,
	month: number,
	day: number,
	hour: number,
	minute: number,
	second: number,
	millisecond: number,
}

function parseDate(timezone, date) {
	let year = 0;
	let month = 0;
	let day = 1;
	let hour = 0;
	let minute = 0;
	let second = 0;
	let millisecond = 0;

	timezone.formatToParts(date).forEach((x) => {
		switch (x.type) {
            case ""year"":
                year = +x.value;
                break;
            case ""month"":
                month = (+x.value) - 1;
                break;
            case ""day"":
                day = +x.value;
                break;
            case ""hour"":
                hour = +x.value;
                break;
            case ""minute"":
                minute = +x.value;
                break;
            case ""second"":
                second = +x.value;
                break;
            case ""fractionalSecond"" as any:
                millisecond = +x.value;
                break;
		}
	});

	if (hour === 24) {
		hour = 0;
	}

	return { year, month, day, hour, minute, second, millisecond };
}


function toUTCDate(timezone, date) {
	const { year, month, day, hour, minute, second, millisecond } = parseDate(timezone, date);
	return Date.UTC(year, month, day, hour, minute, second, millisecond);
}


export class Timezone {
	private _utc: Intl.DateTimeFormat;
	private _dtf: Intl.DateTimeFormat;

	public readonly name: string | undefined;

    /**
     * Use this method to create an instance of this class.
     *
     * @see {@link https://www.amcharts.com/docs/v5/getting-started/#New_element_syntax} for more info
     * @param   timezone  IANA timezone
     * @return            Instantiated object
     */
	static new<C extends typeof Timezone, T extends InstanceType<C>>(this, timezone) {
		return (new this(timezone, true)) as T;
	}

	constructor(timezone, isReal: <fim_suffix>) {
		if (!isReal) {
			throw new Error(""You cannot use `new Class()`, instead use `Class.new()`"");
		}

		this.name = timezone;

		this._utc = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: ""UTC"",
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);

		this._dtf = new Intl.DateTimeFormat(""UTC"", {
			hour12: false,
			timeZone: timezone,
			year: ""numeric"",
			month: ""2-digit"",
			day: ""2-digit"",
			hour: ""2-digit"",
			minute: ""2-digit"",
			second: ""2-digit"",
			fractionalSecondDigits: 3,
		} as any);
	}

	convertLocal(date) {
		const offset = this.offsetUTC(date);
		const userOffset = date.getTimezoneOffset();
		const output = new Date(date);
		output.setUTCMinutes(output.getUTCMinutes() - (offset - userOffset));
		return output;
	}

	offsetUTC(date) {
		const utc = toUTCDate(this._utc, date);
		const dtf = toUTCDate(this._dtf, date);
		return (utc - dtf) / 60000;
	}

    parseDate(date) {
        return parseDate(this._dtf, date)
    }
}
<fim_middle>",correct,695
boolean,boolean,7c6b66273a2e2ae0cf4af96fca68877ec089846c,"<fim_prefix>type Placeholder = undefined | string | Function
interface Options {
  placeholder?: Placeholder
  freeze?: boolean
}

type Result = string | number | Function
type TextObject = Record<string, Result | object>
type TextPath = string
type Texts = TextObject[] | []
type TextFnArguments = string[] | number[]

const ALLOWED_TYPES = ['string', 'number']
const ERROR_TEXTS = Object.freeze({
  not_set: '[t-getter.js] There is no texts objects'
})

export default function GetText(
  texts,
  { placeholder = undefined, freeze = true } = {}
) {
  if (!texts?.length) throw new Error(ERROR_TEXTS.not_set)
  texts = texts.map((o) => (freeze ? Object.freeze(o) : o))
  let placeholderOpt: any = placeholder

  function placeholderFn(options) {
    return typeof placeholderOpt == 'function'
      ? placeholderOpt(options)
      : placeholderOpt
  }

  function checkAllowedTypes(val): <fim_suffix> {
    return ALLOWED_TYPES.includes(typeof val)
  }

  function getTextValue({
    index,
    prop,
    args
  }) {
    const path = prop.split('.')
    let textObject: any = texts[index]

    let i = 0
    while (i < path.length) {
      let value: TextObject | Result = textObject[path[i]]
      if (value == null) break
      if (typeof value == 'function') value = value(...args)
      textObject = value
      i++
    }
    return textObject
  }

  function t(prop, ...args) {
    if (!texts.length) throw new Error(ERROR_TEXTS.not_set)

    let result: any = undefined
    let index = 0
    while (index < texts.length) {
      const value = getTextValue({ index, prop, args })
      if (checkAllowedTypes(value)) {
        result = value
        break
      }
      index++
    }

    if (!checkAllowedTypes(result)) return placeholderFn({ prop, args })

    return result
  }

  return t
}
<fim_middle>",correct,711
boolean,boolean,bbb3c6df82171fa90d0040776b93e6265574820e,"<fim_prefix>export enum AllianceColor {
    BLUE, RED
}

export enum StoneType {
    SKYSTONE, STONE
}

export enum ScoringResult {
    SCORED, FAILED, DID_NOT_TRY
}

// OK FTC state-of-the-art mobile phone control system
export enum DisconnectStatus {
    NO_DISCONNECT, PARTIAL, TOTAL
}

export class MatchEntry {
    matchCode: string;
    teamNumber: number;
    alliance: AllianceColor;
    auto: AutonomousPerformance;
    teleOp: TeleOpPerformance;
    endgame: EndgamePerformance;
    disconnect: DisconnectStatus;
    remarks?: string;

    constructor(matchCode, teamNumber, alliance,
        auto, teleOp, endgame,
        disconnect, remarks?) {
        this.matchCode = matchCode;
        this.teamNumber = teamNumber;
        this.alliance = alliance;
        this.auto = auto;
        this.teleOp = teleOp;
        this.endgame = endgame;
        this.disconnect = disconnect;
        this.remarks = remarks;

        this.validateAutonomous();
        this.validateMetadata();
    }

    public validateMetadata() {
        if (!isValidMatchCode(this.matchCode)) {
            throw new Error(`Match code ""${this.matchCode}"" is invalid`);
        }
        if (isNaN(this.teamNumber)) {
            throw new Error(`Invalid team number`);
        }
        if (this.teamNumber < 1 || Math.floor(this.teamNumber) !== this.teamNumber) {
            throw new Error(`Team number ${this.teamNumber} is invalid`);
        }
        if (this.disconnect === DisconnectStatus.TOTAL && this.getTotalScore() > 0) {
            throw new Error('A totally disconnected team cannot score points');
        }
    }

    public validateAutonomous() {
        if (this.auto.cyclesAttempted < this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous cyclesAttempted < num of deliveredStones`);
        }
        if (this.auto.stonesOnFoundation > this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous stonesOnFoundation > num of deliveredStones`);
        }
    }

    getAutonomousScore() {
        let score = 0;
        // 4.5.2.1
        if (this.auto.movedFoundation === ScoringResult.SCORED) {
            score += 10;
        }
        // 4.5.2.2
        for (let i = 0; i < this.auto.deliveredStones.length; i++) {
            const stone = this.auto.deliveredStones[i];
            if (stone === StoneType.SKYSTONE && i < 2) {
                score += 10;
            } else if (stone != undefined) {
                score += 2;
            }
        }
        // 4.5.2.3
        if (this.auto.parked === ScoringResult.SCORED) {
            score += 5;
        }
        // 4.5.2.4
        score += this.auto.stonesOnFoundation * 4;
        return score;
    }

    getTeleOpScore() {
        let score = 0;
        // 4.5.3.1
        score += this.teleOp.allianceStonesDelivered;
        // 4.5.3.2
        score += this.teleOp.stonesPerLevel.reduce((a, b) => a + b, 0);
        // 4.5.3.3
        score += this.teleOp.stonesPerLevel.length * 2;
        return score;
    }

    getEndgameScore() {
        let score = 0;
        // 4.5.4.1
        if (this.endgame.capstoneLevel !== undefined) {
            score += 5 + this.endgame.capstoneLevel;
        }
        // 4.5.4.2
        if (this.endgame.movedFoundation === ScoringResult.SCORED) {
            score += 15;
        }
        // 4.5.4.3
        if (this.endgame.parked === ScoringResult.SCORED) {
            score += 5;
        }
        return score;
    }

    getTotalScore() {
        return this.getAutonomousScore() + this.getTeleOpScore() + this.getEndgameScore();
    }
}

export interface AutonomousPerformance {
    deliveredStones: StoneType[];
    cyclesAttempted: number;
    stonesOnFoundation: number;
    parked: ScoringResult;
    movedFoundation: ScoringResult;
}

export interface TeleOpPerformance {
    allianceStonesDelivered: number;
    neutralStonesDelivered: number;
    stonesPerLevel: number[];
}

export interface EndgamePerformance {
    movedFoundation: ScoringResult;
    capstoneLevel?: number;
    parked: ScoringResult;
}

export type MatchEntrySet = MatchEntry[];

export function isValidMatchCode(matchCode): <fim_suffix> {
    const matchResult = matchCode.match(/^([QF][1-9][0-9]*)|(SF[12]-[1-9][0-9]*)$/);
    return matchResult !== null && matchResult[0] === matchCode;
}
<fim_middle>",correct,852
boolean,boolean,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value: <fim_suffix>) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,906
boolean,boolean,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(): <fim_suffix> {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,907
boolean,boolean,6e34ee34cc517dccc475aec8a5d776702984ed04,"<fim_prefix>interface Destination {
  destination: string;
  format: string;
}

interface StyleDictionaryConfig {
  platforms: {
    [key: string]: {
      buildPath: string;
      files: Destination[];
      prefix?: string;
      transformGroup?: string;
      transforms?: string[];
    };
  };
  source?: string[];
  tokens?: any;
}

export const errorMessagesMap = {
  incorrectFileFormat:
    ""The source file isn't in the properties/ folder. Please move its location and try again."",
};

/**
 * A function that returns a config object for style dictionary
 * to parse and convert to tokens
 *
 * @param {string} location a path to a json file in the root properties folder
 */
export function getStyleDictionaryConfig(
  location,
  useFigmaApi: <fim_suffix>,
  tokens?
) {
  const arr = location.split(""/"");

  if (arr.length < 3 || arr[0] !== ""properties"") {
    throw new Error(errorMessagesMap.incorrectFileFormat);
  }

  const filename = arr[arr.length - 1];
  const sansFilename = arr.slice(0, -1);

  const path = sansFilename.reduce((acc, next) => `${acc}/${next}`);

  const buildPath = `dist/${path.replace(""properties/"", """")}/`;
  const [filenameSansExtension] = filename.split(""."");
  const inputData = useFigmaApi
    ? { tokens }
    : { source: [`${path}/${filename}`] };

  return {
    ...inputData,
    platforms: {
      scss: {
        buildPath,
        transformGroup: ""scss"",
        files: [
          {
            format: ""scss/map-deep"",
            destination: `scss/${filenameSansExtension}.map.deep.scss`,
          },
        ],
      },
      ts: {
        buildPath,
        transformGroup: ""js"",
        files: [
          {
            format: ""javascript/es6"",
            destination: `js/${filenameSansExtension}.js`,
          },
          {
            format: ""typescript/es6-declarations"",
            destination: `js/${filenameSansExtension}.d.ts`,
          },
          {
            format: ""javascript/module"",
            destination: `js/${filenameSansExtension}.module.js`,
          },
          {
            format: ""typescript/module-declarations"",
            destination: `js/${filenameSansExtension}.module.d.ts`,
          },
        ],
      },
      json: {
        transformGroup: ""react-native"",
        buildPath,
        files: [
          {
            destination: `json/${filenameSansExtension}.json`,
            format: ""json/flat"",
          },
          {
            destination: `json/${filenameSansExtension}.nested.json`,
            format: ""json/nested"",
          },
        ],
      },
    },
  };
}
<fim_middle>",correct,919
boolean,boolean,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className): <fim_suffix> {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,981
boolean,boolean,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className): <fim_suffix> {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,983
boolean,boolean,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
): <fim_suffix> {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1028
boolean,boolean,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?: <fim_suffix>,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1030
boolean,boolean,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj) {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
): <fim_suffix> => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1033
boolean,boolean,ac2f2620a73cd8792597b3c5d3baa98411d6543c,"<fim_prefix>function keys(obj, hasKeyvar keys = [];
    for (var key in obj) {
        if (hasKey(obj, key)) {
            keys.push(key);
        }
    }
    return keys.concat(
        (Object.getOwnPropertySymbols(obj) as Array<any>).filter(
            symbol =>
                (Object.getOwnPropertyDescriptor(obj, symbol) as PropertyDescriptor)
                    .enumerable,
        ),
    );
}

function hasKey(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}

function hasDefinedKey(obj, key) {
    return hasKey(obj, key) && obj[key] !== undefined;
}


function isDomNode(obj): <fim_suffix> {
    return (
        obj !== null &&
        typeof obj === 'object' &&
        typeof obj.nodeType === 'number' &&
        typeof obj.nodeName === 'string' &&
        typeof obj.isEqualNode === 'function'
    );
}


function isA(typeName, value) {
    return Object.prototype.toString.apply(value) === '[object ' + typeName + ']';
}

function isAsymmetric(obj) {
    return !!obj && isA('Function', obj.asymmetricMatch);
}

function asymmetricMatch(a, b) {
    var asymmetricA = isAsymmetric(a),
        asymmetricB = isAsymmetric(b);

    if (asymmetricA && asymmetricB) {
        return undefined;
    }

    if (asymmetricA) {
        return a.asymmetricMatch(b);
    }

    if (asymmetricB) {
        return b.asymmetricMatch(a);
    }
}


type Tester = (a, b) => boolean | undefined;


/**
 * 深比對物件
 * @param a
 * @param b
 * @param aStack
 * @param bStack
 * @param customTesters
 * @param hasKey
 */
const eq = (
    a,
    b,
    aStack,
    bStack,
    customTesters,
    hasKey,
) => {

    customTesters = customTesters || [];

    var result = true;

    var asymmetricResult = asymmetricMatch(a, b);
    if (asymmetricResult !== undefined) {
        return asymmetricResult;
    }

    for (var i = 0; i < customTesters.length; i++) {
        var customTesterResult = customTesters[i](a, b);
        if (customTesterResult !== undefined) {
            return customTesterResult;
        }
    }

    if (a instanceof Error && b instanceof Error) {
        return a.message == b.message;
    }

    if (Object.is(a, b)) {
        return true;
    }
    // A strict comparison is necessary because `null == undefined`.
    if (a === null || b === null) {
        return a === b;
    }
    var className = Object.prototype.toString.call(a);
    if (className != Object.prototype.toString.call(b)) {
        return false;
    }
    switch (className) {
        case '[object Boolean]':
        case '[object String]':
        case '[object Number]':
            if (typeof a !== typeof b) {
                // One is a primitive, one a `new Primitive()`
                return false;
            } else if (typeof a !== 'object' && typeof b !== 'object') {
                // both are proper primitives
                return Object.is(a, b);
            } else {
                // both are `new Primitive()`s
                return Object.is(a.valueOf(), b.valueOf());
            }
        case '[object Date]':
            // Coerce dates to numeric primitive values. Dates are compared by their
            // millisecond representations. Note that invalid dates with millisecond representations
            // of `NaN` are not equivalent.
            return +a == +b;
        // RegExps are compared by their source patterns and flags.
        case '[object RegExp]':
            return a.source === b.source && a.flags === b.flags;
    }
    if (typeof a !== 'object' || typeof b !== 'object') {
        return false;
    }

    // Use DOM3 method isEqualNode (IE>=9)
    if (isDomNode(a) && isDomNode(b)) {
        return a.isEqualNode(b);
    }

    // Used to detect circular references.
    var length = aStack.length;
    while (length--) {
        // Linear search. Performance is inversely proportional to the number of
        // unique nested structures.
        // circular references at same depth are equal
        // circular reference is not equal to non-circular one
        if (aStack[length] === a) {
            return bStack[length] === b;
        } else if (bStack[length] === b) {
            return false;
        }
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    // Recursively compare objects and arrays.
    // Compare array lengths to determine if a deep comparison is necessary.
    if (className == '[object Array]' && a.length !== b.length) {
        return false;
    }

    // Deep compare objects.
    var aKeys = keys(a, hasKey),
        key;
    var size = aKeys.length;

    // Ensure that both objects contain the same number of properties before comparing deep equality.
    if (keys(b, hasKey).length !== size) {
        return false;
    }

    while (size--) {
        key = aKeys[size];

        // Deep compare each member
        result =
            hasKey(b, key) &&
            eq(a[key], b[key], aStack, bStack, customTesters, hasKey);

        if (!result) {
            return false;
        }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();

    return result;

};


/**
 * 深度比較 (toStrictEqual)
 * @param a
 * @param b
 * @param isStrictCheck 嚴格(default: false, 開啟則會檢查不可為將物件中的 undefined 視為不同)
 * @param options
 */
function deepCompare(
    a,
    b,
    isStrictCheck?,
    options?,
) {
    const customTesters = options?.customTesters || [];
    return eq(a, b, [], [], customTesters, isStrictCheck ? hasKey : hasDefinedKey);
}

export default deepCompare;
<fim_middle>",correct,1047
boolean,boolean,d7888589a5edea554ef38b5038cfe5db0eca64de,"<fim_prefix>type StateType = [number, number, TURN]

type ResultType = [
    mouseResult: [result: RESULT_FLAG, move: number],
    catResult: [result: RESULT_FLAG, move: number],
]

enum TURN {
  MOUSE_TURN = 0,
  CAT_TURN = 1,
}

enum RESULT_FLAG {
  UNKNOWN = 0,
  MOUSE_WIN = 1,
  CAT_WIN = 2,
}

const MAX_MOVES = 1000
const DIRS = [[-1, 0], [1, 0], [0, -1], [0, 1]]

/**
 * 拓扑排序
 * @desc 时间复杂度 O(M²N²(M+N))  空间复杂度 O(M²N²)
 * @param grid
 * @param catJump
 * @param mouseJump
 * @returns
 */
export function canMouseWin(
  grid,
  catJump,
  mouseJump,
): <fim_suffix> {
  const rows = grid.length
  const cols = grid[0].length
  let startMouse = -1
  let startCat = -1
  let food = -1
  const getPosKey = (row, col) => row * cols + col
  const getPos = (key) => [(key / cols) >> 0, key % cols]

  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      const c = grid[i][j]
      if (c === 'M')
        startMouse = getPosKey(i, j)
      else if (c === 'C')
        startCat = getPosKey(i, j)
      else if (c === 'F')
        food = getPosKey(i, j)
    }
  }

  const total = rows * cols
  const degrees: [mouse: number, cat: number][][]
  = new Array(total).fill(0).map(() => new Array(total).fill(0).map(() => [0, 0]))

  // 计算每个状态的度
  for (let mouse = 0; mouse < total; mouse++) {
    const [mouseRow, mouseCol] = getPos(mouse)
    if (grid[mouseRow][mouseCol] === '#') continue

    for (let cat = 0; cat < total; cat++) {
      const [catRow, catCol] = getPos(cat)
      if (grid[catRow][catCol] === '#') continue

      degrees[mouse][cat][TURN.MOUSE_TURN]++
      degrees[mouse][cat][TURN.CAT_TURN]++

      for (const dir of DIRS) {
        for (
          let row = mouseRow + dir[0], col = mouseCol + dir[1], jump = 1;
          row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] !== '#' && jump <= mouseJump;
          row += dir[0], col += dir[1], jump++
        ) {
          const nextMouse = getPosKey(row, col)
          const nextCat = getPosKey(catRow, catCol)
          degrees[nextMouse][nextCat][TURN.MOUSE_TURN]++
        }

        for (
          let row = catRow + dir[0], col = catCol + dir[1], jump = 1;
          row >= 0 && row < rows && col >= 0 && col < cols && grid[row][col] !== '#' && jump <= catJump;
          row += dir[0], col += dir[1], jump++
        ) {
          const nextMouse = getPosKey(mouseRow, mouseCol)
          const nextCat = getPosKey(row, col)
          degrees[nextMouse][nextCat][TURN.CAT_TURN]++
        }
      }
    }
  }

  const results: ResultType[][]
  = new Array(total).fill(0)
    .map(() => new Array(total).fill(0)
      .map(() => [[RESULT_FLAG.UNKNOWN, 0], [RESULT_FLAG.UNKNOWN, 0]]),
    )
  const queue: StateType[] = []

  // 猫和老鼠在同一个单元格，猫获胜
  for (let pos = 0; pos < total; pos++) {
    const [row, col] = getPos(pos)
    if (grid[row][col] === '#') continue

    results[pos][pos][TURN.MOUSE_TURN][0] = RESULT_FLAG.CAT_WIN
    results[pos][pos][TURN.MOUSE_TURN][1] = 0
    results[pos][pos][TURN.CAT_TURN][0] = RESULT_FLAG.CAT_WIN
    results[pos][pos][TURN.CAT_TURN][1] = 0
    queue.push([pos, pos, TURN.MOUSE_TURN])
    queue.push([pos, pos, TURN.CAT_TURN])
  }

  // 猫和食物在同一个单元格，猫获胜
  for (let mouse = 0; mouse < total; mouse++) {
    const [mouseRow, mouseCol] = getPos(mouse)
    if (grid[mouseRow][mouseCol] === '#' || mouse === food) continue

    results[mouse][food][TURN.MOUSE_TURN][0] = RESULT_FLAG.CAT_WIN
    results[mouse][food][TURN.MOUSE_TURN][1] = 0
    results[mouse][food][TURN.CAT_TURN][0] = RESULT_FLAG.CAT_WIN
    results[mouse][food][TURN.CAT_TURN][1] = 0
    queue.push([mouse, food, TURN.MOUSE_TURN])
    queue.push([mouse, food, TURN.CAT_TURN])
  }

  // 老鼠和食物在同一个单元格且猫和食物不在同一个单元格，老鼠获胜
  for (let cat = 0; cat < total; cat++) {
    const [catRow, catCol] = getPos(cat)
    if (grid[catRow][catCol] === '#' || cat === food) continue

    results[food][cat][TURN.MOUSE_TURN][0] = RESULT_FLAG.MOUSE_WIN
    results[food][cat][TURN.MOUSE_TURN][1] = 0
    results[food][cat][TURN.CAT_TURN][0] = RESULT_FLAG.MOUSE_WIN
    results[food][cat][TURN.CAT_TURN][1] = 0
    queue.push([food, cat, TURN.MOUSE_TURN])
    queue.push([food, cat, TURN.CAT_TURN])
  }

  // 拓扑排序
  while (queue.length) {
    const [mouse, cat, turn] = queue.shift()!
    const [result, moves] = results[mouse][cat][turn]
    const prevStates = getPrevStates(mouse, cat, turn)
    for (const prevState of prevStates) {
      const [prevMouse, prevCat, prevTurn] = prevState
      if (results[prevMouse][prevCat][prevTurn][0] === RESULT_FLAG.UNKNOWN) {
        const canWin
        = (result === RESULT_FLAG.MOUSE_WIN && prevTurn === TURN.MOUSE_TURN)
        || (result === RESULT_FLAG.CAT_WIN && prevTurn === TURN.CAT_TURN)
        if (canWin) {
          results[prevMouse][prevCat][prevTurn][0] = result
          results[prevMouse][prevCat][prevTurn][1] = moves + 1
          queue.push([prevMouse, prevCat, prevTurn])
        }
        else {
          degrees[prevMouse][prevCat][prevTurn]--
          if (degrees[prevMouse][prevCat][prevTurn] === 0) {
            const loseResult = prevTurn === TURN.MOUSE_TURN ? RESULT_FLAG.CAT_WIN : RESULT_FLAG.MOUSE_WIN
            results[prevMouse][prevCat][prevTurn][0] = loseResult
            results[prevMouse][prevCat][prevTurn][1] = moves + 1
            queue.push([prevMouse, prevCat, prevTurn])
          }
        }
      }
    }
  }

  const [result, move] = results[startMouse][startCat][TURN.MOUSE_TURN]
  return result === RESULT_FLAG.MOUSE_WIN && move <= MAX_MOVES

  function getPrevStates(mouse, cat, turn) {
    const prevStates: StateType[] = []
    const [mouseRow, mouseCol] = getPos(mouse)
    const [catRow, catCol] = getPos(cat)
    const prevTurn = turn === TURN.MOUSE_TURN ? TURN.CAT_TURN : TURN.MOUSE_TURN
    const maxJump = prevTurn === TURN.MOUSE_TURN ? mouseJump : catJump
    const startRow = prevTurn === TURN.MOUSE_TURN ? mouseRow : catRow
    const startCol = prevTurn === TURN.MOUSE_TURN ? mouseCol : catCol
    prevStates.push([mouse, cat, prevTurn])

    for (const dir of DIRS) {
      for (
        let i = startRow + dir[0], j = startCol + dir[1], jump = 1;
        i >= 0 && i < rows && j >= 0 && j < cols && grid[i][j] !== '#' && jump <= maxJump;
        i += dir[0], j += dir[1], jump++
      ) {
        const prevMouseRow = prevTurn === TURN.MOUSE_TURN ? i : mouseRow
        const prevMouseCol = prevTurn === TURN.MOUSE_TURN ? j : mouseCol
        const prevCatRow = prevTurn === TURN.MOUSE_TURN ? catRow : i
        const prevCatCol = prevTurn === TURN.MOUSE_TURN ? catCol : j
        const prevMouse = getPosKey(prevMouseRow, prevMouseCol)
        const prevCat = getPosKey(prevCatRow, prevCatCol)
        prevStates.push([prevMouse, prevCat, prevTurn])
      }
    }

    return prevStates
  }
}
<fim_middle>",correct,1174
boolean,boolean,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition: <fim_suffix>, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1183
boolean,boolean,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd: <fim_suffix> = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message)
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1196
boolean,boolean,b31a5e2a1789d50d26c605d881b979a28beb80a4,"<fim_prefix>type Vec3 = [number, number, number] | Float32Array | Float64Array;

/**
 * Find the two closest points on two 3D lines.
 * Return true if two lines are parallel.
 *
 * @param out1 Output - The closest point on line 1.
 * @param out2 Output - The closest point on line 2.
 * @param p1x X of a point on line 1.
 * @param p1y Y of a point on line 1.
 * @param p1z Z of a point on line 1.
 * @param n1x X of the unit vector of the direction of line 1.
 * @param n1y Y of the unit vector of the direction of line 1.
 * @param n1z Z of the unit vector of the direction of line 1.
 * @param p2x X of a point on line 2.
 * @param p2y Y of a point on line 2.
 * @param p2z Z of a point on line 2.
 * @param n2x X of the unit vector of the direction of line 2.
 * @param n2y Y of the unit vector of the direction of line 2.
 * @param n2z Z of the unit vector of the direction of line 2.
 */
export default function closestPointsBetweenTwoLines(
    out1, out2,
    p1x, p1y, p1z,
    n1x, n1y, n1z,
    p2x, p2y, p2z,
    n2x, n2y, n2z
): <fim_suffix> {
    let d = n1x ** 2 * n2y ** 2
        + n1x ** 2 * n2z ** 2
        - 2 * n1x * n1y * n2x * n2y
        - 2 * n1x * n1z * n2x * n2z
        + n1y ** 2 * n2x ** 2
        + n1y ** 2 * n2z ** 2
        - 2 * n1y * n1z * n2y * n2z
        + n1z ** 2 * n2x ** 2
        + n1z ** 2 * n2y ** 2;
    let parallel = false;
    let t1 = (
        n1x * n2x * n2y * p1y
        - n1x * n2x * n2y * p2y
        + n1x * n2x * n2z * p1z
        - n1x * n2x * n2z * p2z
        - n1x * n2y ** 2 * p1x
        + n1x * n2y ** 2 * p2x
        - n1x * n2z ** 2 * p1x
        + n1x * n2z ** 2 * p2x
        - n1y * n2x ** 2 * p1y
        + n1y * n2x ** 2 * p2y
        + n1y * n2x * n2y * p1x
        - n1y * n2x * n2y * p2x
        + n1y * n2y * n2z * p1z
        - n1y * n2y * n2z * p2z
        - n1y * n2z ** 2 * p1y
        + n1y * n2z ** 2 * p2y
        - n1z * n2x ** 2 * p1z
        + n1z * n2x ** 2 * p2z
        + n1z * n2x * n2z * p1x
        - n1z * n2x * n2z * p2x
        - n1z * n2y ** 2 * p1z
        + n1z * n2y ** 2 * p2z
        + n1z * n2y * n2z * p1y
        - n1z * n2y * n2z * p2y) / d;
    if (!isFinite(t1)) {
        parallel = true;
        t1 = 0;
    }
    let o1x = p1x + n1x * t1;
    let o1y = p1y + n1y * t1;
    let o1z = p1z + n1z * t1;
    if (out1) {
        out1[0] = o1x;
        out1[1] = o1y;
        out1[2] = o1z;
    }
    if (out2) {
        let t3 = (
            -n1x * n2y * p1z
            + n1x * n2y * p2z
            + n1x * n2z * p1y
            - n1x * n2z * p2y
            + n1y * n2x * p1z
            - n1y * n2x * p2z
            - n1y * n2z * p1x
            + n1y * n2z * p2x
            - n1z * n2x * p1y
            + n1z * n2x * p2y
            + n1z * n2y * p1x
            - n1z * n2y * p2x) / d;
        if (isFinite(t3)) {
            let n3x = n1y * n2z - n1z * n2y;
            let n3y = -n1x * n2z + n1z * n2x;
            let n3z = n1x * n2y - n1y * n2x;
            out2[0] = o1x + n3x * t3;
            out2[1] = o1y + n3y * t3;
            out2[2] = o1z + n3z * t3;
        } else {
            parallel = true;
            let n3x = n1y * (p1z - p2z) - n1z * (p1y - p2y);
            let n3y = -n1x * (p1z - p2z) + n1z * (p1x - p2x);
            let n3z = n1x * (p1y - p2y) - n1y * (p1x - p2x);
            out2[0] = o1x + n1y * n3z - n1z * n3y;
            out2[1] = o1y + -n1x * n3z + n1z * n3x;
            out2[2] = o1z + n1x * n3y - n1y * n3x;
        }
    }
    return parallel;
}<fim_middle>",correct,1234
boolean,boolean,39850647fe41aa810255752b914cdd87b3e420dc,"<fim_prefix>export const Kind = 'Core#License';

export interface ILicense {
  kind: typeof Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;
}

export class License {
  kind = Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;

  static fromUrl(url, name?) {
    return new License({
      kind: Kind,
      url,
      name,
    });
  }

  static fromContent(content, name?) {
    return new License({
      kind: Kind,
      content,
      name,
    });
  }

  /**
   * @param input The license definition used to restore the state.
   */
  constructor(input?) {
    let init: ILicense;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new license clearing anything that is so far defined.
   * 
   * Note, this throws an error when the license is not a license object.
   */
  new(init) {
    if (!License.isLicense(init)) {
      throw new Error(`Not a license.`);
    }
    const { url, content, name } = init;
    this.kind = Kind;
    this.name = name;
    this.content = content;
    this.url = url;
  }

  /**
   * Checks whether the input is a definition of a license.
   */
  static isLicense(input): <fim_suffix> {
    const typed = input as ILicense;
    if (typed && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: ILicense = {
      kind: Kind,
    };
    if (this.name) {
      result.name = this.name;
    }
    if (this.url) {
      result.url = this.url;
    }
    if (this.content) {
      result.content = this.content;
    }
    return result;
  }
}
<fim_middle>",correct,1622
boolean,boolean,7dcce9f5e37251d3f89b7355ec3aa54c011fbc21,"<fim_prefix>/**
 * this file is not done yet.
 */
export type CancelablePromisify<T extends (...args) => any> = T extends (
    ...args
) => Promise<infer R>
    ? (...args) => CancelablePromise<R>
    : (...args) => CancelablePromise<ReturnType<T>>

// export type CancelablePromise<T> = Promise<T> & { cancel: () => void }

export type Executor<T> = (
    resolve,
    reject
) => void

export class CancelablePromise<T> extends Promise<T> {
    protected _canceled = false

    constructor(executor) {
        super((resolve, reject) => {
            executor(
                value => {
                    if (this._canceled) {
                        return
                    }
                    resolve(value)
                },
                reason => {
                    if (this._canceled) {
                        return
                    }
                    reject(reason)
                }
            )
        })
    }

    cancel() {
        this._canceled = true
    }

    public get isCanceled(): <fim_suffix> {
        return this._canceled
    }
}

export class DelayedCancelablePromise<T> extends CancelablePromise<T> {
    private _handle: number | undefined
    private _canceler: (handle) => void

    constructor(
        fn,
        dispatcher,
        canceler
    ) {
        super(async (resolve, reject) => {
            this._handle = dispatcher(() => {
                try {
                    const result = fn()
                    if (result instanceof Promise) {
                        result.then(resolve, reject)
                    } else {
                        resolve(result)
                    }
                } catch (e) {
                    reject(e)
                }
            })
        })
        this._canceler = canceler
    }

    cancel() {
        if (this._handle) {
            this._canceler(this._handle)
            this._handle = undefined
        }

        super.cancel()
    }
}
<fim_middle>",correct,1693
boolean,boolean,7dd6b62e84ab1daa79934e50b59d91cb5cc3ea92,"<fim_prefix>export type Type = string | number | symbol;

export type Constructor<T> = new (...args) => T;

export type Factory<T> = (...args) => T;

export enum BindingType {
    value = 'value',
    constructor = 'constructor',
    factory = 'factory',
}

export type ConstructorBinding<T> = {
    type: BindingType.constructor | `${BindingType.constructor}`;
    value: Constructor<T>;
    singleton?: boolean;
};

export type FactoryBinding<T> = {
    type: BindingType.factory | `${BindingType.factory}`;
    value: Factory<T>;
    singleton?: boolean;
};

export type ValueBinding<T> = {
    type?: BindingType.value | `${BindingType.value}`;
    value: T;
};

export type InjectionBinding<T> =
    | ConstructorBinding<T>
    | FactoryBinding<T>
    | ValueBinding<T>;

export type InjectionType<T> = T extends ConstructorBinding<infer U>
    ? U
    : T extends FactoryBinding<infer U>
    ? U
    : T extends ValueBinding<infer U>
    ? U
    : never;

export type InjectionParams<T extends InjectionBinding<any>> =
    T extends ConstructorBinding<any>
        ? ConstructorParameters<T['value']>
        : T extends FactoryBinding<any>
        ? Parameters<T['value']>
        : T extends ValueBinding<any>
        ? never
        : never;

export type InjectionValue<T extends InjectionBinding<any>> = T['value'];

export interface DefaultBindings {
    [index: string]: InjectionBinding<any>;
}

/**
 * An Inversion of Control Container.
 *
 * Values, constructors, and factories can be bound to a Type.
 *
 * Then, given a Type, they can be retrieved later.
 */
export class Container<
    T extends {
        [index: string]: InjectionBinding<any>;
    } = {
        [index: string]: InjectionBinding<any>;
    },
> {
    bindings: T = {} as any;
    protected instances: Record<keyof T, any> = {} as any;

    constructor(bindings = {} as any) {
        this.bindings = bindings;
    }

    /**
     * Binds a value to a Type
     * @param type - a Type to bind
     * @param value - a value to bind
     */
    bindValue<TKey extends keyof T, TValue extends InjectionType<T[TKey]>>(
        type,
        value,
    ) {
        this.bindings[type] = {
            type: BindingType.value,
            value,
        } as any;
    }

    /**
     * Binds a constructor to a Type
     * @param type - a Type to bind
     * @param constructor - a constructor to bind
     */
    bindConstructor<
        TKey extends keyof T,
        TConstructor extends Constructor<InjectionType<T[TKey]>>,
    >(type, constructor, singleton?) {
        this.bindings[type] = {
            type: BindingType.constructor,
            value: constructor,
            singleton,
        } as any;
    }

    /**
     * Binds a factory to a Type
     * @param type - a Type to bind
     * @param factory - a factory to bind
     */
    bindFactory<
        TKey extends keyof T,
        TFactory extends Factory<InjectionType<T[TKey]>>,
    >(type, factory, singleton?: <fim_suffix>) {
        this.bindings[type] = {
            type: BindingType.factory,
            value: factory,
            singleton,
        } as any;
    }

    /**
     * Gets a value for a given Type.
     *
     * If the value is a value, it is returned.
     * If the value is a constructor, a new object is created.
     * If the value is a factory, the factory is run.
     *
     * Args are passed to constructors and factories.
     *
     * This can be used as a default parameter value for other functions.
     *
     * @param type - a bound Type
     * @param args - zero or more args to pass if the bound value is a function or constructor
     */
    get<TKey extends keyof T>(
        type,
        ...args
    ) {
        let binding = this.bindings[type];
        if (!binding) {
            throw `No binding associated with: ${type.toString()}`;
        }
        const value: InjectionValue<T[TKey]> = binding.value;
        switch (binding.type) {
            case BindingType.constructor:
            case 'constructor':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = new value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return new value(...args);
                }
            case BindingType.factory:
            case 'factory':
                if (binding.singleton) {
                    const instance = this.instances[type];
                    if (instance) {
                        return instance;
                    } else {
                        // @ts-ignore TODO: Fix this
                        const instance = value(...args);
                        this.instances[type] = instance;
                        return instance;
                    }
                } else {
                    // @ts-ignore TODO: Fix this
                    return value(...args);
                }
            case BindingType.value:
            case 'value':
            default:
                return binding.value;
        }
    }

    private static default: Container<DefaultBindings> | undefined;

    /**
     * Gets the default Container
     */
    static getDefault() {
        let container = this.default;
        if (!container) {
            container = new Container();
            this.default = container;
        }
        return container;
    }

    /**
     * Sets the default Container
     * @param container - a Container object
     */
    static setDefault<TContainer extends Container<DefaultBindings>>(
        container,
    ) {
        Container.default = container;
    }
}

/**
 * Gets a value fron a specified Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param container - a Container to use
 * @param args - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<
    TContainer extends Container,
    TKey extends keyof TContainer['bindings'],
>(
    container,
    type,
    ...args
);

/**
 * Gets a value fron the default Container by Type
 *
 * This can be used as a default parameter value for other functions.
 *
 * @param type - a bound Type
 * @param [args] - zero or more args to pass if the bound value is a function or constructor
 */
export function inject<TKey extends keyof DefaultBindings>(
    type,
    ...args
);

export function inject<T>(a, b, ...args) {
    if (a instanceof Container) {
        // @ts-ignore TODO: Fix this
        return a.get(b, ...args);
    } else {
        const container = Container.getDefault();
        return container.get(a, ...[b, ...args]);
    }
}
<fim_middle>",correct,1716
boolean,boolean,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority): <fim_suffix> {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1738
boolean,boolean,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key): <fim_suffix> {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1744
boolean,boolean,8432c37532d90458c6cbb23b64c49fcf8e55c8b7,"<fim_prefix>//
// Tokenizer for the Aqua language.
//

export enum TokenType {
    EOF,
    PLUS,
    MINUS,
    NUMBER,
    SEMICOLON,
    CONST,
    LET,
    ASSIGNMENT,
    IDENTIFIER,
    OPEN_PAREN,
    CLOSE_PAREN,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_BRACE,
    CLOSE_BRACE,
    FUNCTION,
    COMMA,
    RETURN,
    IF,
    ELSE,
    WHILE,
    FOR,    
    AND,
    OR,
    EQ,
    NE,
    LTE,
    LT,
    GTE,
    GT,
    MULTIPLY,
    DIVIDE,
    NOT,
    DOT,
    TXN,
    GTXN,
    ARG,
    ADDR,
    GLOBAL,
    ONCOMPLETE,
    TYPEENUM,
    STRING,
};

//
// Maps TokenType to the name of each type of token.
//
export const TOKEN_NAME = [
    ""end-of-file"",
    ""+"",
    ""-"",
    ""number"",
    ""semicolon"",
    ""const"",
    ""let"",
    ""="",
    ""identifier"",
    ""("",
    "")"",
    ""{"",
    ""}"",
    ""["",
    ""]"",
    ""function"",
    "","",
    ""return"",
    ""if"",
    ""else"",
    ""while"",
    ""for"",
    ""&&"",
    ""||"",
    ""=="",
    ""!="",
    ""<="",
    ""<"",
    "">="",
    "">"",
    ""*"",
    ""/"",
    ""!"",
    ""."",
    ""txn"",
    ""gtxn"",
    ""arg"",
    ""addr"",
    ""global"",
    ""OnComplete"",
    ""TypeEnum"",
    ""string literal"",
];

//
// A lookup table for single character operators.
//
const SINGLE_CHARACTER_OPERATORS = {
    ""+"": TokenType.PLUS,
    ""-"": TokenType.MINUS,
    "";"": TokenType.SEMICOLON,
    ""="": TokenType.ASSIGNMENT,
    ""("": TokenType.OPEN_PAREN,
    "")"": TokenType.CLOSE_PAREN,
    ""{"": TokenType.OPEN_BRACKET,
    ""}"": TokenType.CLOSE_BRACKET,
    ""["": TokenType.OPEN_BRACE,
    ""]"": TokenType.CLOSE_BRACE,
    "","": TokenType.COMMA,
    ""<"": TokenType.LT,
    "">"": TokenType.GT,
    ""*"": TokenType.MULTIPLY,
    ""/"": TokenType.DIVIDE,
    ""!"": TokenType.NOT,
    ""."": TokenType.DOT,
}

//
// A lookup table for two character operators.
//
const TWO_CHARACTER_OPERATORS = {
    ""&"": {
        ""&"": TokenType.AND,
    },
    ""|"": {
        ""|"": TokenType.OR,
    },
    ""="": {
        ""="": TokenType.EQ,
    },
    ""!"": {
        ""="": TokenType.NE,
    },
    ""<"": {
        ""="": TokenType.LTE,
    },
    "">"": {
        ""="": TokenType.GTE,
    },
}

//
// Maps a string of characters to a TokenType.
//
export const KEYWORDS = {
    const: TokenType.CONST,
    let: TokenType.LET,
    function: TokenType.FUNCTION,
    return: TokenType.RETURN,
    if: TokenType.IF,
    else: TokenType.ELSE,
    for: TokenType.FOR,
    while: TokenType.WHILE,
    txn: TokenType.TXN,
    gtxn: TokenType.GTXN,
    arg: TokenType.ARG,
    addr: TokenType.ADDR,
    global: TokenType.GLOBAL,
    OnComplete: TokenType.ONCOMPLETE,
    TypeEnum: TokenType.TYPEENUM,
};

//
// Represents a token.
//
export interface IToken {
    //
    // Specifies the type of token.
    //
    readonly type: TokenType;

    //
    // The value of the token, for tokens that have a value.
    //
    readonly value?: any;

    //
    // Line number where the token starts.
    //
    readonly line: number;

    //
    // Column number where the token starts.
    //
    readonly column: number;

    //
    // The string value of the token.
    //
    // TODO: This should only be read from the source code buffer when necessary.
    //
    readonly string: string;
}

//
// Interface for reporting errors.
//
export interface IError {
    //
    // The error message.
    //
    msg: string;

    //
    // 1-based line number where the error occurred.
    //
    line: number;

    //
    // 0-based column number where the error occurred.
    //
    column: number;
}

//
// Interface to a source code tokenizer for the Aqua language.
//
export interface ITokenizer {
    //
    // Scans the next token and makes it the current token.
    //
    readNext();

    //
    // Returns the current token.
    //
    getCurrent();

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd();

    //
    // Gets the current line number in the input.
    //
    getLine();

    //
    // Gets the current column number in the input.
    //
    getColumn();    
}

//
// Defines a handler for errors.
//
export type OnErrorFn = (err) => void;

//
// A source code tokenizer for the Aqua language.
//
export class Tokenizer implements ITokenizer {

    //
    // The source code being tokenized.
    //
    private code: string;

    //
    // The current position in the code to read the next token.
    //
    private curPosition: number;

    //
    // Tracks the current line number within the input.
    //
    private curLine: number;

    //
    // Tracks the current column number within the input.
    //
    private curColumn: number;

    //
    // The position in the code where the current token starts.
    //
    private curTokenStart?: number;

    //
    // The line in the code where the current token starts.
    //
    private curTokenLine?: number;

    //
    // The column in the code where the current token starts.
    //
    private curTokenColumn?: number;

    //
    // The most recently scannned token.
    //
    private curToken?: IToken;

    //
    // A simple interface that allows the tokenizer to report an error and continue scanning.
    //
    private onError?: OnErrorFn;

    constructor(code, onError?) {
        this.code = code;
        this.curPosition = 0;
        this.curLine = 1;
        this.curColumn = 0;
        this.onError = onError;
    }

    //
    // Scans the next token and makes it the current token.
    // This must be called at least once to ""prime"" the tokenizer before trying to look at the
    // ""current token"".
    //
    readNext() {

        while (true) {
            this.skipWhitespace();

            if (this.isAtEnd()) {
                this.setCurrent({ 
                    type: TokenType.EOF,
                    line: this.curLine,
                    column: this.curColumn,
                    string: ""end of file"",
                });
                return;
            }

            this.curTokenStart = this.curPosition;
            this.curTokenLine = this.curLine;
            this.curTokenColumn = this.curColumn;

            const ch = this.advance();

            if (ch === ""/"" && this.peek() === ""/"") {
                // Single line comment.
                this.skipToNewLine();
                continue;
            }

            const twoCharacterTokenLookup = (TWO_CHARACTER_OPERATORS as any)[ch];
            if (twoCharacterTokenLookup !== undefined) {
                const nextCh = this.peek();
                const twoCharacterTokenType = nextCh !== undefined && twoCharacterTokenLookup[nextCh] || undefined;
                if (twoCharacterTokenType !== undefined) {
                    this.advance();
                    this.setCurrent({
                        type: twoCharacterTokenType,
                        line: this.curTokenLine,
                        column: this.curTokenColumn,
                        string: ch + nextCh,   
                    });
                    return;
                }      
            }          

            const singleCharacterTokenType: TokenType = (SINGLE_CHARACTER_OPERATORS as any)[ch];
            if (singleCharacterTokenType !== undefined) {
                this.setCurrent({ 
                    type: singleCharacterTokenType,
                    line: this.curTokenLine,
                    column: this.curTokenColumn,
                    string: ch,
                }); 
                return;
            }

            if (ch === ""\"""") {
                this.stringLiteral();
                return;
            }

            if (this.isDigit(ch)) {
                this.readNumber();
                return;
            }

            if (this.isAlpha(ch)) {
                this.readIdentifer();
                return;
            }

            // Report error, then continue scanning at the next character.

            this.raiseError({
                msg: `Encountered unexpected character ""${ch}""`,
                line: this.curTokenLine,
                column: this.curTokenColumn,
            });
        }    
    }

    //
    // Raises an error.
    //
    private raiseError(err) {
        if (this.onError) {
            this.onError(err);
        }
    }

    //
    // Returns the current token.
    //
    getCurrent() {
        return this.curToken;
    }

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd() {
        return this.curPosition >= this.code.length;
    }

    //
    // Gets the current line number in the input.
    //
    getLine() {
        return this.curLine;
    }

    //
    // Gets the current column number in the input.
    //
    getColumn() {
        return this.curColumn;
    }

    //
    // Sets the current token.
    //
    private setCurrent(token) {
        this.curToken = token;
    }

    //
    // Return the current character and then advance the current position by one place.
    //
    private advance() {
        const ch = this.code[this.curPosition];
        if (ch === ""\n"") {
            this.curLine += 1;
            this.curColumn = 0;
        }
        else {
            this.curColumn += 1;
        }
        this.curPosition += 1;
        return ch;
    }

    //
    // Look at the next character in the input without advancing the position.
    // Returns undefined when there is no more input to look at.
    //
    private peek() {
        if (this.isAtEnd()) {
            return undefined;
        }
        return this.code[this.curPosition];
    }

    //
    // Skips whitespace characters in the code.
    //
    private skipWhitespace() {
        while (true) {
            const ch = this.peek();
            if (ch === "" "" || ch === ""\t"" || ch === ""\r"" || ch === ""\n"") {
                this.advance();
            }
            else {                
                break;
            }
        } 
    }

    //
    // Skips to the next new line.
    //
    private skipToNewLine() {
        while (true) {
            const ch = this.peek();
            if (ch === ""\n"") {
                break;
            }
            if (ch === undefined) {
                break;
            }
            this.advance();
        } 
    }

    //
    // https://stackoverflow.com/a/38370808/25868
    //
    private readonly charCodeZero = ""0"".charCodeAt(0);
    private readonly charCodeNine = ""9"".charCodeAt(0);    
    private readonly charCodea = ""a"".charCodeAt(0);
    private readonly charCodez = ""z"".charCodeAt(0);
    private readonly charCodeA = ""A"".charCodeAt(0);
    private readonly charCodeZ = ""Z"".charCodeAt(0);
    private readonly charCode_ = ""_"".charCodeAt(0);

    //
    // Returns true if the specified charater is a digit.
    //
    private isDigit(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodeZero  && charCode <= this.charCodeNine;
    }

    //
    // Reads the subsequent digits of a number token.
    //
    private readNumber() {
        while (this.isDigit(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);

        this.setCurrent({ 
            type: TokenType.NUMBER, 
            value: parseFloat(stringValue),
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: stringValue,
        }); 
    }

    //
    // Returns true if the specified charater is a alphabetical character..
    //
    private isAlpha(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodea && charCode <= this.charCodez
            || charCode >= this.charCodeA && charCode <= this.charCodeZ
            || charCode === this.charCode_;
    }

    //
    // Returns true if the specified charater is a alphabetical or numerical character.
    //
    private isAlphaNumeric(ch): <fim_suffix> {
        return this.isAlpha(ch) || this.isDigit(ch);
    }

    //
    // Reads the subsequent digits of an identifier or keyword token.
    //
    private readIdentifer() {
        while (this.isAlphaNumeric(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);
        const tokenType = (KEYWORDS as any)[stringValue];
        if (tokenType === undefined) {
            this.setCurrent({ 
                type: TokenType.IDENTIFIER, 
                value: stringValue,
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
        else {
            this.setCurrent({ 
                type: tokenType, 
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
    }

    //
    // Reads the characters of a string literal.
    //
    private stringLiteral() {
        while (true) {
            const ch = this.peek();
            if (ch === undefined) {
                // End of file!
                this.raiseError({
                    msg: ""Unterminated string literal."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            if (ch === ""\n"") {
                // End of file!
                this.raiseError({
                    msg: ""String literal was terminated by a new line."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            this.advance();
            if (ch === ""\"""") {
                break; // End of string literal.
            }
        }

        const value = this.code.substring(this.curTokenStart! + 1, this.curPosition - 1);

        this.setCurrent({ 
            type: TokenType.STRING, 
            value: value,
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: value,
        }); 
    }
}<fim_middle>",correct,1750
boolean,boolean,8432c37532d90458c6cbb23b64c49fcf8e55c8b7,"<fim_prefix>//
// Tokenizer for the Aqua language.
//

export enum TokenType {
    EOF,
    PLUS,
    MINUS,
    NUMBER,
    SEMICOLON,
    CONST,
    LET,
    ASSIGNMENT,
    IDENTIFIER,
    OPEN_PAREN,
    CLOSE_PAREN,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_BRACE,
    CLOSE_BRACE,
    FUNCTION,
    COMMA,
    RETURN,
    IF,
    ELSE,
    WHILE,
    FOR,    
    AND,
    OR,
    EQ,
    NE,
    LTE,
    LT,
    GTE,
    GT,
    MULTIPLY,
    DIVIDE,
    NOT,
    DOT,
    TXN,
    GTXN,
    ARG,
    ADDR,
    GLOBAL,
    ONCOMPLETE,
    TYPEENUM,
    STRING,
};

//
// Maps TokenType to the name of each type of token.
//
export const TOKEN_NAME = [
    ""end-of-file"",
    ""+"",
    ""-"",
    ""number"",
    ""semicolon"",
    ""const"",
    ""let"",
    ""="",
    ""identifier"",
    ""("",
    "")"",
    ""{"",
    ""}"",
    ""["",
    ""]"",
    ""function"",
    "","",
    ""return"",
    ""if"",
    ""else"",
    ""while"",
    ""for"",
    ""&&"",
    ""||"",
    ""=="",
    ""!="",
    ""<="",
    ""<"",
    "">="",
    "">"",
    ""*"",
    ""/"",
    ""!"",
    ""."",
    ""txn"",
    ""gtxn"",
    ""arg"",
    ""addr"",
    ""global"",
    ""OnComplete"",
    ""TypeEnum"",
    ""string literal"",
];

//
// A lookup table for single character operators.
//
const SINGLE_CHARACTER_OPERATORS = {
    ""+"": TokenType.PLUS,
    ""-"": TokenType.MINUS,
    "";"": TokenType.SEMICOLON,
    ""="": TokenType.ASSIGNMENT,
    ""("": TokenType.OPEN_PAREN,
    "")"": TokenType.CLOSE_PAREN,
    ""{"": TokenType.OPEN_BRACKET,
    ""}"": TokenType.CLOSE_BRACKET,
    ""["": TokenType.OPEN_BRACE,
    ""]"": TokenType.CLOSE_BRACE,
    "","": TokenType.COMMA,
    ""<"": TokenType.LT,
    "">"": TokenType.GT,
    ""*"": TokenType.MULTIPLY,
    ""/"": TokenType.DIVIDE,
    ""!"": TokenType.NOT,
    ""."": TokenType.DOT,
}

//
// A lookup table for two character operators.
//
const TWO_CHARACTER_OPERATORS = {
    ""&"": {
        ""&"": TokenType.AND,
    },
    ""|"": {
        ""|"": TokenType.OR,
    },
    ""="": {
        ""="": TokenType.EQ,
    },
    ""!"": {
        ""="": TokenType.NE,
    },
    ""<"": {
        ""="": TokenType.LTE,
    },
    "">"": {
        ""="": TokenType.GTE,
    },
}

//
// Maps a string of characters to a TokenType.
//
export const KEYWORDS = {
    const: TokenType.CONST,
    let: TokenType.LET,
    function: TokenType.FUNCTION,
    return: TokenType.RETURN,
    if: TokenType.IF,
    else: TokenType.ELSE,
    for: TokenType.FOR,
    while: TokenType.WHILE,
    txn: TokenType.TXN,
    gtxn: TokenType.GTXN,
    arg: TokenType.ARG,
    addr: TokenType.ADDR,
    global: TokenType.GLOBAL,
    OnComplete: TokenType.ONCOMPLETE,
    TypeEnum: TokenType.TYPEENUM,
};

//
// Represents a token.
//
export interface IToken {
    //
    // Specifies the type of token.
    //
    readonly type: TokenType;

    //
    // The value of the token, for tokens that have a value.
    //
    readonly value?: any;

    //
    // Line number where the token starts.
    //
    readonly line: number;

    //
    // Column number where the token starts.
    //
    readonly column: number;

    //
    // The string value of the token.
    //
    // TODO: This should only be read from the source code buffer when necessary.
    //
    readonly string: string;
}

//
// Interface for reporting errors.
//
export interface IError {
    //
    // The error message.
    //
    msg: string;

    //
    // 1-based line number where the error occurred.
    //
    line: number;

    //
    // 0-based column number where the error occurred.
    //
    column: number;
}

//
// Interface to a source code tokenizer for the Aqua language.
//
export interface ITokenizer {
    //
    // Scans the next token and makes it the current token.
    //
    readNext();

    //
    // Returns the current token.
    //
    getCurrent();

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd();

    //
    // Gets the current line number in the input.
    //
    getLine();

    //
    // Gets the current column number in the input.
    //
    getColumn();    
}

//
// Defines a handler for errors.
//
export type OnErrorFn = (err) => void;

//
// A source code tokenizer for the Aqua language.
//
export class Tokenizer implements ITokenizer {

    //
    // The source code being tokenized.
    //
    private code: string;

    //
    // The current position in the code to read the next token.
    //
    private curPosition: number;

    //
    // Tracks the current line number within the input.
    //
    private curLine: number;

    //
    // Tracks the current column number within the input.
    //
    private curColumn: number;

    //
    // The position in the code where the current token starts.
    //
    private curTokenStart?: number;

    //
    // The line in the code where the current token starts.
    //
    private curTokenLine?: number;

    //
    // The column in the code where the current token starts.
    //
    private curTokenColumn?: number;

    //
    // The most recently scannned token.
    //
    private curToken?: IToken;

    //
    // A simple interface that allows the tokenizer to report an error and continue scanning.
    //
    private onError?: OnErrorFn;

    constructor(code, onError?) {
        this.code = code;
        this.curPosition = 0;
        this.curLine = 1;
        this.curColumn = 0;
        this.onError = onError;
    }

    //
    // Scans the next token and makes it the current token.
    // This must be called at least once to ""prime"" the tokenizer before trying to look at the
    // ""current token"".
    //
    readNext() {

        while (true) {
            this.skipWhitespace();

            if (this.isAtEnd()) {
                this.setCurrent({ 
                    type: TokenType.EOF,
                    line: this.curLine,
                    column: this.curColumn,
                    string: ""end of file"",
                });
                return;
            }

            this.curTokenStart = this.curPosition;
            this.curTokenLine = this.curLine;
            this.curTokenColumn = this.curColumn;

            const ch = this.advance();

            if (ch === ""/"" && this.peek() === ""/"") {
                // Single line comment.
                this.skipToNewLine();
                continue;
            }

            const twoCharacterTokenLookup = (TWO_CHARACTER_OPERATORS as any)[ch];
            if (twoCharacterTokenLookup !== undefined) {
                const nextCh = this.peek();
                const twoCharacterTokenType = nextCh !== undefined && twoCharacterTokenLookup[nextCh] || undefined;
                if (twoCharacterTokenType !== undefined) {
                    this.advance();
                    this.setCurrent({
                        type: twoCharacterTokenType,
                        line: this.curTokenLine,
                        column: this.curTokenColumn,
                        string: ch + nextCh,   
                    });
                    return;
                }      
            }          

            const singleCharacterTokenType: TokenType = (SINGLE_CHARACTER_OPERATORS as any)[ch];
            if (singleCharacterTokenType !== undefined) {
                this.setCurrent({ 
                    type: singleCharacterTokenType,
                    line: this.curTokenLine,
                    column: this.curTokenColumn,
                    string: ch,
                }); 
                return;
            }

            if (ch === ""\"""") {
                this.stringLiteral();
                return;
            }

            if (this.isDigit(ch)) {
                this.readNumber();
                return;
            }

            if (this.isAlpha(ch)) {
                this.readIdentifer();
                return;
            }

            // Report error, then continue scanning at the next character.

            this.raiseError({
                msg: `Encountered unexpected character ""${ch}""`,
                line: this.curTokenLine,
                column: this.curTokenColumn,
            });
        }    
    }

    //
    // Raises an error.
    //
    private raiseError(err) {
        if (this.onError) {
            this.onError(err);
        }
    }

    //
    // Returns the current token.
    //
    getCurrent() {
        return this.curToken;
    }

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd() {
        return this.curPosition >= this.code.length;
    }

    //
    // Gets the current line number in the input.
    //
    getLine() {
        return this.curLine;
    }

    //
    // Gets the current column number in the input.
    //
    getColumn() {
        return this.curColumn;
    }

    //
    // Sets the current token.
    //
    private setCurrent(token) {
        this.curToken = token;
    }

    //
    // Return the current character and then advance the current position by one place.
    //
    private advance() {
        const ch = this.code[this.curPosition];
        if (ch === ""\n"") {
            this.curLine += 1;
            this.curColumn = 0;
        }
        else {
            this.curColumn += 1;
        }
        this.curPosition += 1;
        return ch;
    }

    //
    // Look at the next character in the input without advancing the position.
    // Returns undefined when there is no more input to look at.
    //
    private peek() {
        if (this.isAtEnd()) {
            return undefined;
        }
        return this.code[this.curPosition];
    }

    //
    // Skips whitespace characters in the code.
    //
    private skipWhitespace() {
        while (true) {
            const ch = this.peek();
            if (ch === "" "" || ch === ""\t"" || ch === ""\r"" || ch === ""\n"") {
                this.advance();
            }
            else {                
                break;
            }
        } 
    }

    //
    // Skips to the next new line.
    //
    private skipToNewLine() {
        while (true) {
            const ch = this.peek();
            if (ch === ""\n"") {
                break;
            }
            if (ch === undefined) {
                break;
            }
            this.advance();
        } 
    }

    //
    // https://stackoverflow.com/a/38370808/25868
    //
    private readonly charCodeZero = ""0"".charCodeAt(0);
    private readonly charCodeNine = ""9"".charCodeAt(0);    
    private readonly charCodea = ""a"".charCodeAt(0);
    private readonly charCodez = ""z"".charCodeAt(0);
    private readonly charCodeA = ""A"".charCodeAt(0);
    private readonly charCodeZ = ""Z"".charCodeAt(0);
    private readonly charCode_ = ""_"".charCodeAt(0);

    //
    // Returns true if the specified charater is a digit.
    //
    private isDigit(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodeZero  && charCode <= this.charCodeNine;
    }

    //
    // Reads the subsequent digits of a number token.
    //
    private readNumber() {
        while (this.isDigit(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);

        this.setCurrent({ 
            type: TokenType.NUMBER, 
            value: parseFloat(stringValue),
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: stringValue,
        }); 
    }

    //
    // Returns true if the specified charater is a alphabetical character..
    //
    private isAlpha(ch): <fim_suffix> {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodea && charCode <= this.charCodez
            || charCode >= this.charCodeA && charCode <= this.charCodeZ
            || charCode === this.charCode_;
    }

    //
    // Returns true if the specified charater is a alphabetical or numerical character.
    //
    private isAlphaNumeric(ch) {
        return this.isAlpha(ch) || this.isDigit(ch);
    }

    //
    // Reads the subsequent digits of an identifier or keyword token.
    //
    private readIdentifer() {
        while (this.isAlphaNumeric(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);
        const tokenType = (KEYWORDS as any)[stringValue];
        if (tokenType === undefined) {
            this.setCurrent({ 
                type: TokenType.IDENTIFIER, 
                value: stringValue,
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
        else {
            this.setCurrent({ 
                type: tokenType, 
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
    }

    //
    // Reads the characters of a string literal.
    //
    private stringLiteral() {
        while (true) {
            const ch = this.peek();
            if (ch === undefined) {
                // End of file!
                this.raiseError({
                    msg: ""Unterminated string literal."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            if (ch === ""\n"") {
                // End of file!
                this.raiseError({
                    msg: ""String literal was terminated by a new line."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            this.advance();
            if (ch === ""\"""") {
                break; // End of string literal.
            }
        }

        const value = this.code.substring(this.curTokenStart! + 1, this.curPosition - 1);

        this.setCurrent({ 
            type: TokenType.STRING, 
            value: value,
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: value,
        }); 
    }
}<fim_middle>",correct,1752
boolean,boolean,8432c37532d90458c6cbb23b64c49fcf8e55c8b7,"<fim_prefix>//
// Tokenizer for the Aqua language.
//

export enum TokenType {
    EOF,
    PLUS,
    MINUS,
    NUMBER,
    SEMICOLON,
    CONST,
    LET,
    ASSIGNMENT,
    IDENTIFIER,
    OPEN_PAREN,
    CLOSE_PAREN,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_BRACE,
    CLOSE_BRACE,
    FUNCTION,
    COMMA,
    RETURN,
    IF,
    ELSE,
    WHILE,
    FOR,    
    AND,
    OR,
    EQ,
    NE,
    LTE,
    LT,
    GTE,
    GT,
    MULTIPLY,
    DIVIDE,
    NOT,
    DOT,
    TXN,
    GTXN,
    ARG,
    ADDR,
    GLOBAL,
    ONCOMPLETE,
    TYPEENUM,
    STRING,
};

//
// Maps TokenType to the name of each type of token.
//
export const TOKEN_NAME = [
    ""end-of-file"",
    ""+"",
    ""-"",
    ""number"",
    ""semicolon"",
    ""const"",
    ""let"",
    ""="",
    ""identifier"",
    ""("",
    "")"",
    ""{"",
    ""}"",
    ""["",
    ""]"",
    ""function"",
    "","",
    ""return"",
    ""if"",
    ""else"",
    ""while"",
    ""for"",
    ""&&"",
    ""||"",
    ""=="",
    ""!="",
    ""<="",
    ""<"",
    "">="",
    "">"",
    ""*"",
    ""/"",
    ""!"",
    ""."",
    ""txn"",
    ""gtxn"",
    ""arg"",
    ""addr"",
    ""global"",
    ""OnComplete"",
    ""TypeEnum"",
    ""string literal"",
];

//
// A lookup table for single character operators.
//
const SINGLE_CHARACTER_OPERATORS = {
    ""+"": TokenType.PLUS,
    ""-"": TokenType.MINUS,
    "";"": TokenType.SEMICOLON,
    ""="": TokenType.ASSIGNMENT,
    ""("": TokenType.OPEN_PAREN,
    "")"": TokenType.CLOSE_PAREN,
    ""{"": TokenType.OPEN_BRACKET,
    ""}"": TokenType.CLOSE_BRACKET,
    ""["": TokenType.OPEN_BRACE,
    ""]"": TokenType.CLOSE_BRACE,
    "","": TokenType.COMMA,
    ""<"": TokenType.LT,
    "">"": TokenType.GT,
    ""*"": TokenType.MULTIPLY,
    ""/"": TokenType.DIVIDE,
    ""!"": TokenType.NOT,
    ""."": TokenType.DOT,
}

//
// A lookup table for two character operators.
//
const TWO_CHARACTER_OPERATORS = {
    ""&"": {
        ""&"": TokenType.AND,
    },
    ""|"": {
        ""|"": TokenType.OR,
    },
    ""="": {
        ""="": TokenType.EQ,
    },
    ""!"": {
        ""="": TokenType.NE,
    },
    ""<"": {
        ""="": TokenType.LTE,
    },
    "">"": {
        ""="": TokenType.GTE,
    },
}

//
// Maps a string of characters to a TokenType.
//
export const KEYWORDS = {
    const: TokenType.CONST,
    let: TokenType.LET,
    function: TokenType.FUNCTION,
    return: TokenType.RETURN,
    if: TokenType.IF,
    else: TokenType.ELSE,
    for: TokenType.FOR,
    while: TokenType.WHILE,
    txn: TokenType.TXN,
    gtxn: TokenType.GTXN,
    arg: TokenType.ARG,
    addr: TokenType.ADDR,
    global: TokenType.GLOBAL,
    OnComplete: TokenType.ONCOMPLETE,
    TypeEnum: TokenType.TYPEENUM,
};

//
// Represents a token.
//
export interface IToken {
    //
    // Specifies the type of token.
    //
    readonly type: TokenType;

    //
    // The value of the token, for tokens that have a value.
    //
    readonly value?: any;

    //
    // Line number where the token starts.
    //
    readonly line: number;

    //
    // Column number where the token starts.
    //
    readonly column: number;

    //
    // The string value of the token.
    //
    // TODO: This should only be read from the source code buffer when necessary.
    //
    readonly string: string;
}

//
// Interface for reporting errors.
//
export interface IError {
    //
    // The error message.
    //
    msg: string;

    //
    // 1-based line number where the error occurred.
    //
    line: number;

    //
    // 0-based column number where the error occurred.
    //
    column: number;
}

//
// Interface to a source code tokenizer for the Aqua language.
//
export interface ITokenizer {
    //
    // Scans the next token and makes it the current token.
    //
    readNext();

    //
    // Returns the current token.
    //
    getCurrent();

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd();

    //
    // Gets the current line number in the input.
    //
    getLine();

    //
    // Gets the current column number in the input.
    //
    getColumn();    
}

//
// Defines a handler for errors.
//
export type OnErrorFn = (err) => void;

//
// A source code tokenizer for the Aqua language.
//
export class Tokenizer implements ITokenizer {

    //
    // The source code being tokenized.
    //
    private code: string;

    //
    // The current position in the code to read the next token.
    //
    private curPosition: number;

    //
    // Tracks the current line number within the input.
    //
    private curLine: number;

    //
    // Tracks the current column number within the input.
    //
    private curColumn: number;

    //
    // The position in the code where the current token starts.
    //
    private curTokenStart?: number;

    //
    // The line in the code where the current token starts.
    //
    private curTokenLine?: number;

    //
    // The column in the code where the current token starts.
    //
    private curTokenColumn?: number;

    //
    // The most recently scannned token.
    //
    private curToken?: IToken;

    //
    // A simple interface that allows the tokenizer to report an error and continue scanning.
    //
    private onError?: OnErrorFn;

    constructor(code, onError?) {
        this.code = code;
        this.curPosition = 0;
        this.curLine = 1;
        this.curColumn = 0;
        this.onError = onError;
    }

    //
    // Scans the next token and makes it the current token.
    // This must be called at least once to ""prime"" the tokenizer before trying to look at the
    // ""current token"".
    //
    readNext() {

        while (true) {
            this.skipWhitespace();

            if (this.isAtEnd()) {
                this.setCurrent({ 
                    type: TokenType.EOF,
                    line: this.curLine,
                    column: this.curColumn,
                    string: ""end of file"",
                });
                return;
            }

            this.curTokenStart = this.curPosition;
            this.curTokenLine = this.curLine;
            this.curTokenColumn = this.curColumn;

            const ch = this.advance();

            if (ch === ""/"" && this.peek() === ""/"") {
                // Single line comment.
                this.skipToNewLine();
                continue;
            }

            const twoCharacterTokenLookup = (TWO_CHARACTER_OPERATORS as any)[ch];
            if (twoCharacterTokenLookup !== undefined) {
                const nextCh = this.peek();
                const twoCharacterTokenType = nextCh !== undefined && twoCharacterTokenLookup[nextCh] || undefined;
                if (twoCharacterTokenType !== undefined) {
                    this.advance();
                    this.setCurrent({
                        type: twoCharacterTokenType,
                        line: this.curTokenLine,
                        column: this.curTokenColumn,
                        string: ch + nextCh,   
                    });
                    return;
                }      
            }          

            const singleCharacterTokenType: TokenType = (SINGLE_CHARACTER_OPERATORS as any)[ch];
            if (singleCharacterTokenType !== undefined) {
                this.setCurrent({ 
                    type: singleCharacterTokenType,
                    line: this.curTokenLine,
                    column: this.curTokenColumn,
                    string: ch,
                }); 
                return;
            }

            if (ch === ""\"""") {
                this.stringLiteral();
                return;
            }

            if (this.isDigit(ch)) {
                this.readNumber();
                return;
            }

            if (this.isAlpha(ch)) {
                this.readIdentifer();
                return;
            }

            // Report error, then continue scanning at the next character.

            this.raiseError({
                msg: `Encountered unexpected character ""${ch}""`,
                line: this.curTokenLine,
                column: this.curTokenColumn,
            });
        }    
    }

    //
    // Raises an error.
    //
    private raiseError(err) {
        if (this.onError) {
            this.onError(err);
        }
    }

    //
    // Returns the current token.
    //
    getCurrent() {
        return this.curToken;
    }

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd() {
        return this.curPosition >= this.code.length;
    }

    //
    // Gets the current line number in the input.
    //
    getLine() {
        return this.curLine;
    }

    //
    // Gets the current column number in the input.
    //
    getColumn() {
        return this.curColumn;
    }

    //
    // Sets the current token.
    //
    private setCurrent(token) {
        this.curToken = token;
    }

    //
    // Return the current character and then advance the current position by one place.
    //
    private advance() {
        const ch = this.code[this.curPosition];
        if (ch === ""\n"") {
            this.curLine += 1;
            this.curColumn = 0;
        }
        else {
            this.curColumn += 1;
        }
        this.curPosition += 1;
        return ch;
    }

    //
    // Look at the next character in the input without advancing the position.
    // Returns undefined when there is no more input to look at.
    //
    private peek() {
        if (this.isAtEnd()) {
            return undefined;
        }
        return this.code[this.curPosition];
    }

    //
    // Skips whitespace characters in the code.
    //
    private skipWhitespace() {
        while (true) {
            const ch = this.peek();
            if (ch === "" "" || ch === ""\t"" || ch === ""\r"" || ch === ""\n"") {
                this.advance();
            }
            else {                
                break;
            }
        } 
    }

    //
    // Skips to the next new line.
    //
    private skipToNewLine() {
        while (true) {
            const ch = this.peek();
            if (ch === ""\n"") {
                break;
            }
            if (ch === undefined) {
                break;
            }
            this.advance();
        } 
    }

    //
    // https://stackoverflow.com/a/38370808/25868
    //
    private readonly charCodeZero = ""0"".charCodeAt(0);
    private readonly charCodeNine = ""9"".charCodeAt(0);    
    private readonly charCodea = ""a"".charCodeAt(0);
    private readonly charCodez = ""z"".charCodeAt(0);
    private readonly charCodeA = ""A"".charCodeAt(0);
    private readonly charCodeZ = ""Z"".charCodeAt(0);
    private readonly charCode_ = ""_"".charCodeAt(0);

    //
    // Returns true if the specified charater is a digit.
    //
    private isDigit(ch): <fim_suffix> {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodeZero  && charCode <= this.charCodeNine;
    }

    //
    // Reads the subsequent digits of a number token.
    //
    private readNumber() {
        while (this.isDigit(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);

        this.setCurrent({ 
            type: TokenType.NUMBER, 
            value: parseFloat(stringValue),
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: stringValue,
        }); 
    }

    //
    // Returns true if the specified charater is a alphabetical character..
    //
    private isAlpha(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodea && charCode <= this.charCodez
            || charCode >= this.charCodeA && charCode <= this.charCodeZ
            || charCode === this.charCode_;
    }

    //
    // Returns true if the specified charater is a alphabetical or numerical character.
    //
    private isAlphaNumeric(ch) {
        return this.isAlpha(ch) || this.isDigit(ch);
    }

    //
    // Reads the subsequent digits of an identifier or keyword token.
    //
    private readIdentifer() {
        while (this.isAlphaNumeric(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);
        const tokenType = (KEYWORDS as any)[stringValue];
        if (tokenType === undefined) {
            this.setCurrent({ 
                type: TokenType.IDENTIFIER, 
                value: stringValue,
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
        else {
            this.setCurrent({ 
                type: tokenType, 
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
    }

    //
    // Reads the characters of a string literal.
    //
    private stringLiteral() {
        while (true) {
            const ch = this.peek();
            if (ch === undefined) {
                // End of file!
                this.raiseError({
                    msg: ""Unterminated string literal."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            if (ch === ""\n"") {
                // End of file!
                this.raiseError({
                    msg: ""String literal was terminated by a new line."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            this.advance();
            if (ch === ""\"""") {
                break; // End of string literal.
            }
        }

        const value = this.code.substring(this.curTokenStart! + 1, this.curPosition - 1);

        this.setCurrent({ 
            type: TokenType.STRING, 
            value: value,
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: value,
        }); 
    }
}<fim_middle>",correct,1755
boolean,boolean,8432c37532d90458c6cbb23b64c49fcf8e55c8b7,"<fim_prefix>//
// Tokenizer for the Aqua language.
//

export enum TokenType {
    EOF,
    PLUS,
    MINUS,
    NUMBER,
    SEMICOLON,
    CONST,
    LET,
    ASSIGNMENT,
    IDENTIFIER,
    OPEN_PAREN,
    CLOSE_PAREN,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_BRACE,
    CLOSE_BRACE,
    FUNCTION,
    COMMA,
    RETURN,
    IF,
    ELSE,
    WHILE,
    FOR,    
    AND,
    OR,
    EQ,
    NE,
    LTE,
    LT,
    GTE,
    GT,
    MULTIPLY,
    DIVIDE,
    NOT,
    DOT,
    TXN,
    GTXN,
    ARG,
    ADDR,
    GLOBAL,
    ONCOMPLETE,
    TYPEENUM,
    STRING,
};

//
// Maps TokenType to the name of each type of token.
//
export const TOKEN_NAME = [
    ""end-of-file"",
    ""+"",
    ""-"",
    ""number"",
    ""semicolon"",
    ""const"",
    ""let"",
    ""="",
    ""identifier"",
    ""("",
    "")"",
    ""{"",
    ""}"",
    ""["",
    ""]"",
    ""function"",
    "","",
    ""return"",
    ""if"",
    ""else"",
    ""while"",
    ""for"",
    ""&&"",
    ""||"",
    ""=="",
    ""!="",
    ""<="",
    ""<"",
    "">="",
    "">"",
    ""*"",
    ""/"",
    ""!"",
    ""."",
    ""txn"",
    ""gtxn"",
    ""arg"",
    ""addr"",
    ""global"",
    ""OnComplete"",
    ""TypeEnum"",
    ""string literal"",
];

//
// A lookup table for single character operators.
//
const SINGLE_CHARACTER_OPERATORS = {
    ""+"": TokenType.PLUS,
    ""-"": TokenType.MINUS,
    "";"": TokenType.SEMICOLON,
    ""="": TokenType.ASSIGNMENT,
    ""("": TokenType.OPEN_PAREN,
    "")"": TokenType.CLOSE_PAREN,
    ""{"": TokenType.OPEN_BRACKET,
    ""}"": TokenType.CLOSE_BRACKET,
    ""["": TokenType.OPEN_BRACE,
    ""]"": TokenType.CLOSE_BRACE,
    "","": TokenType.COMMA,
    ""<"": TokenType.LT,
    "">"": TokenType.GT,
    ""*"": TokenType.MULTIPLY,
    ""/"": TokenType.DIVIDE,
    ""!"": TokenType.NOT,
    ""."": TokenType.DOT,
}

//
// A lookup table for two character operators.
//
const TWO_CHARACTER_OPERATORS = {
    ""&"": {
        ""&"": TokenType.AND,
    },
    ""|"": {
        ""|"": TokenType.OR,
    },
    ""="": {
        ""="": TokenType.EQ,
    },
    ""!"": {
        ""="": TokenType.NE,
    },
    ""<"": {
        ""="": TokenType.LTE,
    },
    "">"": {
        ""="": TokenType.GTE,
    },
}

//
// Maps a string of characters to a TokenType.
//
export const KEYWORDS = {
    const: TokenType.CONST,
    let: TokenType.LET,
    function: TokenType.FUNCTION,
    return: TokenType.RETURN,
    if: TokenType.IF,
    else: TokenType.ELSE,
    for: TokenType.FOR,
    while: TokenType.WHILE,
    txn: TokenType.TXN,
    gtxn: TokenType.GTXN,
    arg: TokenType.ARG,
    addr: TokenType.ADDR,
    global: TokenType.GLOBAL,
    OnComplete: TokenType.ONCOMPLETE,
    TypeEnum: TokenType.TYPEENUM,
};

//
// Represents a token.
//
export interface IToken {
    //
    // Specifies the type of token.
    //
    readonly type: TokenType;

    //
    // The value of the token, for tokens that have a value.
    //
    readonly value?: any;

    //
    // Line number where the token starts.
    //
    readonly line: number;

    //
    // Column number where the token starts.
    //
    readonly column: number;

    //
    // The string value of the token.
    //
    // TODO: This should only be read from the source code buffer when necessary.
    //
    readonly string: string;
}

//
// Interface for reporting errors.
//
export interface IError {
    //
    // The error message.
    //
    msg: string;

    //
    // 1-based line number where the error occurred.
    //
    line: number;

    //
    // 0-based column number where the error occurred.
    //
    column: number;
}

//
// Interface to a source code tokenizer for the Aqua language.
//
export interface ITokenizer {
    //
    // Scans the next token and makes it the current token.
    //
    readNext();

    //
    // Returns the current token.
    //
    getCurrent();

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd();

    //
    // Gets the current line number in the input.
    //
    getLine();

    //
    // Gets the current column number in the input.
    //
    getColumn();    
}

//
// Defines a handler for errors.
//
export type OnErrorFn = (err) => void;

//
// A source code tokenizer for the Aqua language.
//
export class Tokenizer implements ITokenizer {

    //
    // The source code being tokenized.
    //
    private code: string;

    //
    // The current position in the code to read the next token.
    //
    private curPosition: number;

    //
    // Tracks the current line number within the input.
    //
    private curLine: number;

    //
    // Tracks the current column number within the input.
    //
    private curColumn: number;

    //
    // The position in the code where the current token starts.
    //
    private curTokenStart?: number;

    //
    // The line in the code where the current token starts.
    //
    private curTokenLine?: number;

    //
    // The column in the code where the current token starts.
    //
    private curTokenColumn?: number;

    //
    // The most recently scannned token.
    //
    private curToken?: IToken;

    //
    // A simple interface that allows the tokenizer to report an error and continue scanning.
    //
    private onError?: OnErrorFn;

    constructor(code, onError?) {
        this.code = code;
        this.curPosition = 0;
        this.curLine = 1;
        this.curColumn = 0;
        this.onError = onError;
    }

    //
    // Scans the next token and makes it the current token.
    // This must be called at least once to ""prime"" the tokenizer before trying to look at the
    // ""current token"".
    //
    readNext() {

        while (true) {
            this.skipWhitespace();

            if (this.isAtEnd()) {
                this.setCurrent({ 
                    type: TokenType.EOF,
                    line: this.curLine,
                    column: this.curColumn,
                    string: ""end of file"",
                });
                return;
            }

            this.curTokenStart = this.curPosition;
            this.curTokenLine = this.curLine;
            this.curTokenColumn = this.curColumn;

            const ch = this.advance();

            if (ch === ""/"" && this.peek() === ""/"") {
                // Single line comment.
                this.skipToNewLine();
                continue;
            }

            const twoCharacterTokenLookup = (TWO_CHARACTER_OPERATORS as any)[ch];
            if (twoCharacterTokenLookup !== undefined) {
                const nextCh = this.peek();
                const twoCharacterTokenType = nextCh !== undefined && twoCharacterTokenLookup[nextCh] || undefined;
                if (twoCharacterTokenType !== undefined) {
                    this.advance();
                    this.setCurrent({
                        type: twoCharacterTokenType,
                        line: this.curTokenLine,
                        column: this.curTokenColumn,
                        string: ch + nextCh,   
                    });
                    return;
                }      
            }          

            const singleCharacterTokenType: TokenType = (SINGLE_CHARACTER_OPERATORS as any)[ch];
            if (singleCharacterTokenType !== undefined) {
                this.setCurrent({ 
                    type: singleCharacterTokenType,
                    line: this.curTokenLine,
                    column: this.curTokenColumn,
                    string: ch,
                }); 
                return;
            }

            if (ch === ""\"""") {
                this.stringLiteral();
                return;
            }

            if (this.isDigit(ch)) {
                this.readNumber();
                return;
            }

            if (this.isAlpha(ch)) {
                this.readIdentifer();
                return;
            }

            // Report error, then continue scanning at the next character.

            this.raiseError({
                msg: `Encountered unexpected character ""${ch}""`,
                line: this.curTokenLine,
                column: this.curTokenColumn,
            });
        }    
    }

    //
    // Raises an error.
    //
    private raiseError(err) {
        if (this.onError) {
            this.onError(err);
        }
    }

    //
    // Returns the current token.
    //
    getCurrent() {
        return this.curToken;
    }

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd(): <fim_suffix> {
        return this.curPosition >= this.code.length;
    }

    //
    // Gets the current line number in the input.
    //
    getLine() {
        return this.curLine;
    }

    //
    // Gets the current column number in the input.
    //
    getColumn() {
        return this.curColumn;
    }

    //
    // Sets the current token.
    //
    private setCurrent(token) {
        this.curToken = token;
    }

    //
    // Return the current character and then advance the current position by one place.
    //
    private advance() {
        const ch = this.code[this.curPosition];
        if (ch === ""\n"") {
            this.curLine += 1;
            this.curColumn = 0;
        }
        else {
            this.curColumn += 1;
        }
        this.curPosition += 1;
        return ch;
    }

    //
    // Look at the next character in the input without advancing the position.
    // Returns undefined when there is no more input to look at.
    //
    private peek() {
        if (this.isAtEnd()) {
            return undefined;
        }
        return this.code[this.curPosition];
    }

    //
    // Skips whitespace characters in the code.
    //
    private skipWhitespace() {
        while (true) {
            const ch = this.peek();
            if (ch === "" "" || ch === ""\t"" || ch === ""\r"" || ch === ""\n"") {
                this.advance();
            }
            else {                
                break;
            }
        } 
    }

    //
    // Skips to the next new line.
    //
    private skipToNewLine() {
        while (true) {
            const ch = this.peek();
            if (ch === ""\n"") {
                break;
            }
            if (ch === undefined) {
                break;
            }
            this.advance();
        } 
    }

    //
    // https://stackoverflow.com/a/38370808/25868
    //
    private readonly charCodeZero = ""0"".charCodeAt(0);
    private readonly charCodeNine = ""9"".charCodeAt(0);    
    private readonly charCodea = ""a"".charCodeAt(0);
    private readonly charCodez = ""z"".charCodeAt(0);
    private readonly charCodeA = ""A"".charCodeAt(0);
    private readonly charCodeZ = ""Z"".charCodeAt(0);
    private readonly charCode_ = ""_"".charCodeAt(0);

    //
    // Returns true if the specified charater is a digit.
    //
    private isDigit(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodeZero  && charCode <= this.charCodeNine;
    }

    //
    // Reads the subsequent digits of a number token.
    //
    private readNumber() {
        while (this.isDigit(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);

        this.setCurrent({ 
            type: TokenType.NUMBER, 
            value: parseFloat(stringValue),
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: stringValue,
        }); 
    }

    //
    // Returns true if the specified charater is a alphabetical character..
    //
    private isAlpha(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodea && charCode <= this.charCodez
            || charCode >= this.charCodeA && charCode <= this.charCodeZ
            || charCode === this.charCode_;
    }

    //
    // Returns true if the specified charater is a alphabetical or numerical character.
    //
    private isAlphaNumeric(ch) {
        return this.isAlpha(ch) || this.isDigit(ch);
    }

    //
    // Reads the subsequent digits of an identifier or keyword token.
    //
    private readIdentifer() {
        while (this.isAlphaNumeric(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);
        const tokenType = (KEYWORDS as any)[stringValue];
        if (tokenType === undefined) {
            this.setCurrent({ 
                type: TokenType.IDENTIFIER, 
                value: stringValue,
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
        else {
            this.setCurrent({ 
                type: tokenType, 
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
    }

    //
    // Reads the characters of a string literal.
    //
    private stringLiteral() {
        while (true) {
            const ch = this.peek();
            if (ch === undefined) {
                // End of file!
                this.raiseError({
                    msg: ""Unterminated string literal."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            if (ch === ""\n"") {
                // End of file!
                this.raiseError({
                    msg: ""String literal was terminated by a new line."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            this.advance();
            if (ch === ""\"""") {
                break; // End of string literal.
            }
        }

        const value = this.code.substring(this.curTokenStart! + 1, this.curPosition - 1);

        this.setCurrent({ 
            type: TokenType.STRING, 
            value: value,
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: value,
        }); 
    }
}<fim_middle>",correct,1764
boolean,boolean,8432c37532d90458c6cbb23b64c49fcf8e55c8b7,"<fim_prefix>//
// Tokenizer for the Aqua language.
//

export enum TokenType {
    EOF,
    PLUS,
    MINUS,
    NUMBER,
    SEMICOLON,
    CONST,
    LET,
    ASSIGNMENT,
    IDENTIFIER,
    OPEN_PAREN,
    CLOSE_PAREN,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_BRACE,
    CLOSE_BRACE,
    FUNCTION,
    COMMA,
    RETURN,
    IF,
    ELSE,
    WHILE,
    FOR,    
    AND,
    OR,
    EQ,
    NE,
    LTE,
    LT,
    GTE,
    GT,
    MULTIPLY,
    DIVIDE,
    NOT,
    DOT,
    TXN,
    GTXN,
    ARG,
    ADDR,
    GLOBAL,
    ONCOMPLETE,
    TYPEENUM,
    STRING,
};

//
// Maps TokenType to the name of each type of token.
//
export const TOKEN_NAME = [
    ""end-of-file"",
    ""+"",
    ""-"",
    ""number"",
    ""semicolon"",
    ""const"",
    ""let"",
    ""="",
    ""identifier"",
    ""("",
    "")"",
    ""{"",
    ""}"",
    ""["",
    ""]"",
    ""function"",
    "","",
    ""return"",
    ""if"",
    ""else"",
    ""while"",
    ""for"",
    ""&&"",
    ""||"",
    ""=="",
    ""!="",
    ""<="",
    ""<"",
    "">="",
    "">"",
    ""*"",
    ""/"",
    ""!"",
    ""."",
    ""txn"",
    ""gtxn"",
    ""arg"",
    ""addr"",
    ""global"",
    ""OnComplete"",
    ""TypeEnum"",
    ""string literal"",
];

//
// A lookup table for single character operators.
//
const SINGLE_CHARACTER_OPERATORS = {
    ""+"": TokenType.PLUS,
    ""-"": TokenType.MINUS,
    "";"": TokenType.SEMICOLON,
    ""="": TokenType.ASSIGNMENT,
    ""("": TokenType.OPEN_PAREN,
    "")"": TokenType.CLOSE_PAREN,
    ""{"": TokenType.OPEN_BRACKET,
    ""}"": TokenType.CLOSE_BRACKET,
    ""["": TokenType.OPEN_BRACE,
    ""]"": TokenType.CLOSE_BRACE,
    "","": TokenType.COMMA,
    ""<"": TokenType.LT,
    "">"": TokenType.GT,
    ""*"": TokenType.MULTIPLY,
    ""/"": TokenType.DIVIDE,
    ""!"": TokenType.NOT,
    ""."": TokenType.DOT,
}

//
// A lookup table for two character operators.
//
const TWO_CHARACTER_OPERATORS = {
    ""&"": {
        ""&"": TokenType.AND,
    },
    ""|"": {
        ""|"": TokenType.OR,
    },
    ""="": {
        ""="": TokenType.EQ,
    },
    ""!"": {
        ""="": TokenType.NE,
    },
    ""<"": {
        ""="": TokenType.LTE,
    },
    "">"": {
        ""="": TokenType.GTE,
    },
}

//
// Maps a string of characters to a TokenType.
//
export const KEYWORDS = {
    const: TokenType.CONST,
    let: TokenType.LET,
    function: TokenType.FUNCTION,
    return: TokenType.RETURN,
    if: TokenType.IF,
    else: TokenType.ELSE,
    for: TokenType.FOR,
    while: TokenType.WHILE,
    txn: TokenType.TXN,
    gtxn: TokenType.GTXN,
    arg: TokenType.ARG,
    addr: TokenType.ADDR,
    global: TokenType.GLOBAL,
    OnComplete: TokenType.ONCOMPLETE,
    TypeEnum: TokenType.TYPEENUM,
};

//
// Represents a token.
//
export interface IToken {
    //
    // Specifies the type of token.
    //
    readonly type: TokenType;

    //
    // The value of the token, for tokens that have a value.
    //
    readonly value?: any;

    //
    // Line number where the token starts.
    //
    readonly line: number;

    //
    // Column number where the token starts.
    //
    readonly column: number;

    //
    // The string value of the token.
    //
    // TODO: This should only be read from the source code buffer when necessary.
    //
    readonly string: string;
}

//
// Interface for reporting errors.
//
export interface IError {
    //
    // The error message.
    //
    msg: string;

    //
    // 1-based line number where the error occurred.
    //
    line: number;

    //
    // 0-based column number where the error occurred.
    //
    column: number;
}

//
// Interface to a source code tokenizer for the Aqua language.
//
export interface ITokenizer {
    //
    // Scans the next token and makes it the current token.
    //
    readNext();

    //
    // Returns the current token.
    //
    getCurrent();

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd(): <fim_suffix>;

    //
    // Gets the current line number in the input.
    //
    getLine();

    //
    // Gets the current column number in the input.
    //
    getColumn();    
}

//
// Defines a handler for errors.
//
export type OnErrorFn = (err) => void;

//
// A source code tokenizer for the Aqua language.
//
export class Tokenizer implements ITokenizer {

    //
    // The source code being tokenized.
    //
    private code: string;

    //
    // The current position in the code to read the next token.
    //
    private curPosition: number;

    //
    // Tracks the current line number within the input.
    //
    private curLine: number;

    //
    // Tracks the current column number within the input.
    //
    private curColumn: number;

    //
    // The position in the code where the current token starts.
    //
    private curTokenStart?: number;

    //
    // The line in the code where the current token starts.
    //
    private curTokenLine?: number;

    //
    // The column in the code where the current token starts.
    //
    private curTokenColumn?: number;

    //
    // The most recently scannned token.
    //
    private curToken?: IToken;

    //
    // A simple interface that allows the tokenizer to report an error and continue scanning.
    //
    private onError?: OnErrorFn;

    constructor(code, onError?) {
        this.code = code;
        this.curPosition = 0;
        this.curLine = 1;
        this.curColumn = 0;
        this.onError = onError;
    }

    //
    // Scans the next token and makes it the current token.
    // This must be called at least once to ""prime"" the tokenizer before trying to look at the
    // ""current token"".
    //
    readNext() {

        while (true) {
            this.skipWhitespace();

            if (this.isAtEnd()) {
                this.setCurrent({ 
                    type: TokenType.EOF,
                    line: this.curLine,
                    column: this.curColumn,
                    string: ""end of file"",
                });
                return;
            }

            this.curTokenStart = this.curPosition;
            this.curTokenLine = this.curLine;
            this.curTokenColumn = this.curColumn;

            const ch = this.advance();

            if (ch === ""/"" && this.peek() === ""/"") {
                // Single line comment.
                this.skipToNewLine();
                continue;
            }

            const twoCharacterTokenLookup = (TWO_CHARACTER_OPERATORS as any)[ch];
            if (twoCharacterTokenLookup !== undefined) {
                const nextCh = this.peek();
                const twoCharacterTokenType = nextCh !== undefined && twoCharacterTokenLookup[nextCh] || undefined;
                if (twoCharacterTokenType !== undefined) {
                    this.advance();
                    this.setCurrent({
                        type: twoCharacterTokenType,
                        line: this.curTokenLine,
                        column: this.curTokenColumn,
                        string: ch + nextCh,   
                    });
                    return;
                }      
            }          

            const singleCharacterTokenType: TokenType = (SINGLE_CHARACTER_OPERATORS as any)[ch];
            if (singleCharacterTokenType !== undefined) {
                this.setCurrent({ 
                    type: singleCharacterTokenType,
                    line: this.curTokenLine,
                    column: this.curTokenColumn,
                    string: ch,
                }); 
                return;
            }

            if (ch === ""\"""") {
                this.stringLiteral();
                return;
            }

            if (this.isDigit(ch)) {
                this.readNumber();
                return;
            }

            if (this.isAlpha(ch)) {
                this.readIdentifer();
                return;
            }

            // Report error, then continue scanning at the next character.

            this.raiseError({
                msg: `Encountered unexpected character ""${ch}""`,
                line: this.curTokenLine,
                column: this.curTokenColumn,
            });
        }    
    }

    //
    // Raises an error.
    //
    private raiseError(err) {
        if (this.onError) {
            this.onError(err);
        }
    }

    //
    // Returns the current token.
    //
    getCurrent() {
        return this.curToken;
    }

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd() {
        return this.curPosition >= this.code.length;
    }

    //
    // Gets the current line number in the input.
    //
    getLine() {
        return this.curLine;
    }

    //
    // Gets the current column number in the input.
    //
    getColumn() {
        return this.curColumn;
    }

    //
    // Sets the current token.
    //
    private setCurrent(token) {
        this.curToken = token;
    }

    //
    // Return the current character and then advance the current position by one place.
    //
    private advance() {
        const ch = this.code[this.curPosition];
        if (ch === ""\n"") {
            this.curLine += 1;
            this.curColumn = 0;
        }
        else {
            this.curColumn += 1;
        }
        this.curPosition += 1;
        return ch;
    }

    //
    // Look at the next character in the input without advancing the position.
    // Returns undefined when there is no more input to look at.
    //
    private peek() {
        if (this.isAtEnd()) {
            return undefined;
        }
        return this.code[this.curPosition];
    }

    //
    // Skips whitespace characters in the code.
    //
    private skipWhitespace() {
        while (true) {
            const ch = this.peek();
            if (ch === "" "" || ch === ""\t"" || ch === ""\r"" || ch === ""\n"") {
                this.advance();
            }
            else {                
                break;
            }
        } 
    }

    //
    // Skips to the next new line.
    //
    private skipToNewLine() {
        while (true) {
            const ch = this.peek();
            if (ch === ""\n"") {
                break;
            }
            if (ch === undefined) {
                break;
            }
            this.advance();
        } 
    }

    //
    // https://stackoverflow.com/a/38370808/25868
    //
    private readonly charCodeZero = ""0"".charCodeAt(0);
    private readonly charCodeNine = ""9"".charCodeAt(0);    
    private readonly charCodea = ""a"".charCodeAt(0);
    private readonly charCodez = ""z"".charCodeAt(0);
    private readonly charCodeA = ""A"".charCodeAt(0);
    private readonly charCodeZ = ""Z"".charCodeAt(0);
    private readonly charCode_ = ""_"".charCodeAt(0);

    //
    // Returns true if the specified charater is a digit.
    //
    private isDigit(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodeZero  && charCode <= this.charCodeNine;
    }

    //
    // Reads the subsequent digits of a number token.
    //
    private readNumber() {
        while (this.isDigit(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);

        this.setCurrent({ 
            type: TokenType.NUMBER, 
            value: parseFloat(stringValue),
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: stringValue,
        }); 
    }

    //
    // Returns true if the specified charater is a alphabetical character..
    //
    private isAlpha(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodea && charCode <= this.charCodez
            || charCode >= this.charCodeA && charCode <= this.charCodeZ
            || charCode === this.charCode_;
    }

    //
    // Returns true if the specified charater is a alphabetical or numerical character.
    //
    private isAlphaNumeric(ch) {
        return this.isAlpha(ch) || this.isDigit(ch);
    }

    //
    // Reads the subsequent digits of an identifier or keyword token.
    //
    private readIdentifer() {
        while (this.isAlphaNumeric(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);
        const tokenType = (KEYWORDS as any)[stringValue];
        if (tokenType === undefined) {
            this.setCurrent({ 
                type: TokenType.IDENTIFIER, 
                value: stringValue,
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
        else {
            this.setCurrent({ 
                type: tokenType, 
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
    }

    //
    // Reads the characters of a string literal.
    //
    private stringLiteral() {
        while (true) {
            const ch = this.peek();
            if (ch === undefined) {
                // End of file!
                this.raiseError({
                    msg: ""Unterminated string literal."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            if (ch === ""\n"") {
                // End of file!
                this.raiseError({
                    msg: ""String literal was terminated by a new line."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            this.advance();
            if (ch === ""\"""") {
                break; // End of string literal.
            }
        }

        const value = this.code.substring(this.curTokenStart! + 1, this.curPosition - 1);

        this.setCurrent({ 
            type: TokenType.STRING, 
            value: value,
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: value,
        }); 
    }
}<fim_middle>",correct,1773
boolean,boolean,655a54a8828579567144872dc38c7ccacc368066,"<fim_prefix>type UnicodeFraction = {character: string; ref: string; value: number}

/**
 * Copyright 2017 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export const UNICODE_FRACTIONS = [
  {character: '\u00BD', ref: '½', expanded: '1/2', value: 1 / 2},
  {character: '\u00BC', ref: '¼', expanded: '1/4', value: 1 / 4},
  {character: '\u00BE', ref: '¾', expanded: '3/4', value: 3 / 4},
  {character: '\u2153', ref: '⅓', expanded: '1/3', value: 1 / 3},
  {character: '\u2154', ref: '⅔', expanded: '2/3', value: 2 / 3},
  {character: '\u2155', ref: '⅕', expanded: '1/5', value: 1 / 5},
  {character: '\u2156', ref: '⅖', expanded: '2/5', value: 2 / 5},
  {character: '\u2157', ref: '⅗', expanded: '3/5', value: 3 / 5},
  {character: '\u2158', ref: '⅘', expanded: '4/5', value: 4 / 5},
  {character: '\u2159', ref: '⅙', expanded: '1/6', value: 1 / 6},
  {character: '\u215A', ref: '⅚', expanded: '5/6', value: 5 / 6},
  {character: '\u2150', ref: '⅐', expanded: '1/7', value: 1 / 7},
  {character: '\u215B', ref: '⅛', expanded: '1/8', value: 1 / 8},
  {character: '\u215C', ref: '⅜', expanded: '3/8', value: 3 / 8},
  {character: '\u215D', ref: '⅝', expanded: '5/8', value: 5 / 8},
  {character: '\u215E', ref: '⅞', expanded: '7/8', value: 7 / 8},
  {character: '\u2151', ref: '⅑', expanded: '1/9', value: 1 / 9},
  {character: '\u2152', ref: '⅒', expanded: '1/10', value: 1 / 10}
]

/**
 * Stores formatting options, for determining what string output should look
 * like.
 */
export class Format {
  /**
   * Returns an approximated result, but with the constraint that when it
   * changes slightly it should ""look the same"". (It should look good when
   * varying and animated.)
   */
  static readonly CONSISTENT = new Format(false, 0, 2, ', ')

  /**
   * Returns an accurate result, but favoring looking nice over being small.
   */
  static readonly EXACT = new Format(true, 0, undefined, ', ')

  /**
   * Returns an accurate result, favoring being small over looking nice.
   */
  static readonly MINIFIED = new Format(true, 0, undefined, ',')

  /**
   * Returns an approximated result, strongly favoring looking nice.
   */
  static readonly SIMPLIFIED = new Format(true, 0.0005, 3, ', ')

  /**
   * Parses the given text into a float. Works for text created by
   * [[formatFloat]].
   */
  static parseFloat(text) {
    if (text.length === 0) {
      throw new Error(`Not a number: '${text}'`)
    }
    if (text[0] === '-') {
      return -Format.parseFloat(text.substr(1))
    }
    if (text[0] === '\u221A') {
      return Math.sqrt(Format.parseFloat(text.substr(1)))
    }

    const fraction = Format.matchUnicodeFraction(e => e.character === text)
    if (fraction !== undefined) {
      return fraction.value
    }

    const result = parseFloat(text)
    if (isNaN(result)) {
      throw new Error(`Not a number: '${text}'`)
    }
    return result
  }

  /**
   * Corrects a value to a nearby simple fraction or root thereof, such as
   * sqrt(1/2), so it can be printed compactly.
   *
   * @param value  The value to round.
   * @param epsilon  The maximum offset error introduced by the rounding.
   */
  static simplifyByRounding(value, epsilon) {
    if (value < 0) {
      return -Format.simplifyByRounding(-value, epsilon)
    }

    const r = value % 1
    if (r <= epsilon || 1 - r <= epsilon) {
      return Math.round(value)
    }

    const fraction = Format.matchUnicodeFraction(e => Math.abs(e.value - value) <= epsilon)
    if (fraction !== undefined) {
      return fraction.value
    }

    const rootFraction = Format.matchUnicodeFraction(e => Math.abs(Math.sqrt(e.value) - value) <= epsilon)
    if (rootFraction !== undefined) {
      return Math.sqrt(rootFraction.value)
    }

    return value
  }

  /**
   * Returns the first element of an array matching the given predicate, or else
   * returns undefined.
   *
   * @hidden
   */
  static matchUnicodeFraction(predicate) {
    for (const each of UNICODE_FRACTIONS) {
      if (predicate(each)) return each
    }
    return undefined
  }

  public allowAbbreviation: boolean
  public maxAbbreviationError: number
  public fixedDigits: number | undefined
  public itemSeparator: string

  /**
   * @param allowAbbreviation  Should outputs be shortened, if possible?
   * @param maxAbbreviationError  How much error is abbreviating allowed to introduce?
   * @param fixedDigits  Use toFixed? How many digits?
   * @param itemSeparator  What should list items be separated by?
   */
  constructor(
    allowAbbreviation: <fim_suffix>,
    maxAbbreviationError,
    fixedDigits,
    itemSeparator
  ) {
    this.allowAbbreviation = allowAbbreviation
    this.maxAbbreviationError = maxAbbreviationError
    this.fixedDigits = fixedDigits
    this.itemSeparator = itemSeparator
  }

  formatFloat(f) {
    if (this.allowAbbreviation) {
      return this.abbreviateFloat(f, this.maxAbbreviationError, this.fixedDigits)
    }
    if (this.fixedDigits !== undefined) {
      return f.toFixed(this.fixedDigits)
    }
    return String(f)
  }

  /**
   * Returns a string representation of a float, taking advantage of unicode
   * fractions and square roots.
   *
   * @param value  The value to represent as a string.
   * @param epsilon  The maximum error introduced by using an expression.
   * @param digits  digits The number of digits to use if no expression matches.
   */
  private abbreviateFloat(value, epsilon = 0, digits = undefined) {
    if (Math.abs(value) < epsilon) return '0'
    if (value < 0) return `-${this.abbreviateFloat(-value, epsilon, digits)}`

    const fraction = Format.matchUnicodeFraction(e => Math.abs(e.value - value) <= epsilon)
    if (fraction !== undefined) {
      return fraction.character
    }

    const rootFraction = Format.matchUnicodeFraction(e => Math.abs(Math.sqrt(e.value) - value) <= epsilon)
    if (rootFraction !== undefined) {
      return `\u221A${rootFraction.character}`
    }

    if (value % 1 !== 0 && digits !== undefined) {
      return value.toFixed(digits)
    }

    return value.toString()
  }
}
<fim_middle>",correct,1798
boolean,boolean,c638aa7811a23127f92dc64cfed37e179ef1cc7f,"<fim_prefix>export const Kind = 'Core#Thing';

/**
 * An interface describing a base metadata of a thing.
 */
export declare interface IThing {
  /**
   * The data kind. The application ignores the input with an unknown `kind`, unless it can be determined from the context.
   */
  kind?: typeof Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;
}

export class Thing {
  kind = Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;

  /**
   * Returns one in this order:
   * - displayName
   * - name
   * - 'Unnamed object'
   */
  get renderLabel() {
    return this.displayName || this.name || 'Unnamed object';
  }

  /**
   * Creates a basic description from a name.
   */
  static fromName(name) {
    const thing = new Thing({
      name,
      kind: Kind,
    });
    return thing;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IThing;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not a thing.
   */
  new(init) {
    if (!Thing.isThing(init)) {
      throw new Error(`Not a thing.`);
    }
    const { description, name, version, displayName } = init;
    this.kind = Kind;
    this.name = name;
    this.displayName = displayName;
    this.description = description;
    this.version = version;
  }

  /**
   * Checks whether the input is a definition of a server.
   */
  static isThing(input): <fim_suffix> {
    const typed = input as IThing;
    if (input && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IThing = {
      kind: Kind,
    };
    if (typeof this.name === 'string') {
      result.name = this.name;
    }
    if (typeof this.displayName === 'string') {
      result.displayName = this.displayName;
    }
    if (this.description) {
      result.description = this.description;
    }
    if (this.version) {
      result.version = this.version;
    }
    return result;
  }
}
<fim_middle>",correct,1807
boolean,boolean,5bf8f0f2946da835300025c6804a609bef4277ab,"<fim_prefix>// @strict: true
// @declaration: true

type T01 = {} & string;  // string
type T02 = {} & 'a';  // 'a'
type T03 = {} & object;  // object
type T04 = {} & { x: number };  // { x: number }
type T05 = {} & null;  // never
type T06 = {} & undefined;  // never
type T07 = undefined & void;  // undefined

type T10 = string & {};  // Specially preserved
type T11 = number & {};  // Specially preserved
type T12 = bigint & {};  // Specially preserved

type ThisNode = {};
type ThatNode = {};
type ThisOrThatNode = ThisNode | ThatNode;

function f01(u) {
    let x1: {} = u;  // Error
    let x2: {} | null | undefined = u;
    let x3: {} | { x: string } | null | undefined = u;
    let x4: ThisOrThatNode | null | undefined = u;
}

function f10(x) {
    if (x) {
        x;  // {}
    }
    else {
        x;  // unknown
    }
    if (!x) {
        x;  // unknown
    }
    else {
        x;  // {}
    }
}

function f11<T>(x) {
    if (x) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (!x) {
        x;  // T
    }
    else {
        x;  // T & {}
    }
}

function f12<T extends {}>(x) {
    if (x) {
        x;  // T
    }
    else {
        x;  // T
    }
}

function f20(x) {
    if (x !== undefined) {
        x;  // {} | null
    }
    else {
        x;  // undefined
    }
    if (x !== null) {
        x;  // {} | undefined
    }
    else {
        x;  // null
    }
    if (x !== undefined && x !== null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != undefined) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
    if (x != null) {
        x;  // {}
    }
    else {
        x;  // null | undefined
    }
}

function f21<T>(x) {
    if (x !== undefined) {
        x;  // T & ({} | null)
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T & ({} | undefined)
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f22<T extends {} | undefined>(x) {
    if (x !== undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x !== null) {
        x;  // T
    }
    else {
        x;  // T
    }
    if (x !== undefined && x !== null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != undefined) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
    if (x != null) {
        x;  // T & {}
    }
    else {
        x;  // T
    }
}

function f23<T>(x) {
    if (x !== undefined) {
        x;  // T & {} | null
    }
    if (x !== null) {
        x;  // T & {} | undefined
    }
    if (x != undefined) {
        x;  // T & {}
    }
    if (x != null) {
        x;  // T & {}
    }
}

function f30(x) {
    if (typeof x === ""object"") {
        x;  // object
    }
}

function f31<T>(x) {
    if (typeof x === ""object"") {
        x;  // T & object | T & null
    }
    if (x && typeof x === ""object"") {
        x;  // T & object
    }
    if (typeof x === ""object"" && x) {
        x;  // T & object
    }
}

function f32<T extends {} | undefined>(x) {
    if (typeof x === ""object"") {
        x;  // T & object
    }
}

function possiblyNull<T>(x) {
    return !!true ? x : null;  // T | null
}

function possiblyUndefined<T>(x) {
    return !!true ? x : undefined;  // T | undefined
}

function possiblyNullOrUndefined<T>(x) {
    return possiblyUndefined(possiblyNull(x));  // T | null | undefined
}

function ensureNotNull<T>(x) {
    if (x === null) throw Error();
    return x;  // T & ({} | undefined)
}

function ensureNotUndefined<T>(x) {
    if (x === undefined) throw Error();
    return x;  // T & ({} | null)
}

function ensureNotNullOrUndefined<T>(x) {
    return ensureNotUndefined(ensureNotNull(x));  // T & {}
}

function f40(a, b) {
    let a1 = ensureNotNullOrUndefined(a);  // string
    let b1 = ensureNotNullOrUndefined(b);  // number
}

type QQ<T> = NonNullable<NonNullable<NonNullable<T>>>;

function f41<T>(a) {
    let a1 = ensureNotUndefined(ensureNotNull(a));  // T & {}
    let a2 = ensureNotNull(ensureNotUndefined(a));  // T & {}
    let a3 = ensureNotNull(ensureNotNull(a));  // T & {} | T & undefined
    let a4 = ensureNotUndefined(ensureNotUndefined(a));  // T & {} | T & null
    let a5 = ensureNotNullOrUndefined(ensureNotNullOrUndefined(a));  // T & {}
    let a6 = ensureNotNull(possiblyNullOrUndefined(a));  // T & {} | undefined
    let a7 = ensureNotUndefined(possiblyNullOrUndefined(a));  // T & {} | null
    let a8 = ensureNotNull(possiblyUndefined(a));  // T & {} | undefined
    let a9 = ensureNotUndefined(possiblyNull(a));  // T & {} | null
}

// Repro from #48468

function deepEquals<T>(a, b): <fim_suffix> {
    if (typeof a !== 'object' || typeof b !== 'object' || !a || !b) {
        return false;
    }
    if (Array.isArray(a) || Array.isArray(b)) {
        return false;
    }
    if (Object.keys(a).length !== Object.keys(b).length) { // Error here
        return false;
    }
    return true;
}

// Repro from #49386

function foo<T>(x) {
    let y = x;
    if (y !== null) {
        y;
    }
}
<fim_middle>",correct,1958
boolean,boolean,9eb078d7d68852e0860617c539c62b7d3a9f0a9a,"<fim_prefix>/**
 * Ported to TypeScript from https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/src/structure/toPath.js
 * https://github.com/final-form/final-form/blob/ad1997b70de21df336331da466523534b5bdb63c/LICENSE
 * Copyright (c) 2017 Erik Rasmussen
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Based on Underscore.js, copyright Jeremy Ashkenas,
 *
 * Structure Tester
 * https://8ypq7n41z0.codesandbox.io/
 */

type State = any;

const charCodeOfDot = ""."".charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
    // Match anything that isn't a dot or bracket.
    ""[^.[\\]]+"" +
        ""|"" +
        // Or match property names within brackets.
        ""\\[(?:"" +
        // Match a non-string expression.
        ""([^\""'][^[]*)"" +
        ""|"" +
        // Or match strings (supports escaping characters).
        ""([\""'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2"" +
        "")\\]"" +
        ""|"" +
        // Or match """" as the space between consecutive dots or empty brackets.
        ""(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))"",
    ""g"",
);

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
const stringToPath = (string) => {
    const result = [];
    if (string.charCodeAt(0) === charCodeOfDot) {
        result.push("""");
    }
    string.replace(rePropName, (match, expression, quote, subString) => {
        let key = match;
        if (quote) {
            key = subString.replace(reEscapeChar, ""$1"");
        } else if (expression) {
            key = expression.trim();
        }
        result.push(key);

        return """";
    });
    return result;
};

const keysCache: { [key: string]: string[] } = {};

const toPath = (key) => {
    if (key === null || key === undefined || !key.length) {
        return [];
    }
    if (typeof key !== ""string"") {
        throw new Error(""toPath() expects a string"");
    }

    if (keysCache[key] == null) {
        keysCache[key] = stringToPath(key);
    }
    return keysCache[key]!;
};

const setInRecursor = (
    current,
    index,
    path,
    value,
    destroyArrays: <fim_suffix>,
) => {
    if (index >= path.length) {
        // end of recursion
        return value;
    }
    const key = path[index]!;

    // determine type of key
    if (isNaN(key as any)) {
        // object set
        if (current === undefined || current === null) {
            // recurse
            const result = setInRecursor(
                undefined,
                index + 1,
                path,
                value,
                destroyArrays,
            );

            // delete or create an object
            return result === undefined ? undefined : { [key]: result };
        }
        if (Array.isArray(current)) {
            throw new Error(""Cannot set a non-numeric property on an array"");
        }
        // current exists, so make a copy of all its values, and add/update the new one
        const result = setInRecursor(
            current[key],
            index + 1,
            path,
            value,
            destroyArrays,
        );
        if (result === undefined) {
            const numKeys = Object.keys(current).length;
            if (current[key] === undefined && numKeys === 0) {
                // object was already empty
                return undefined;
            }
            if (current[key] !== undefined && numKeys <= 1) {
                // only key we had was the one we are deleting
                if (!isNaN(path[index - 1] as any) && !destroyArrays) {
                    // we are in an array, so return an empty object
                    return {};
                } else {
                    return undefined;
                }
            }
            const { [key]: _removed, ...final } = current;
            return final;
        }
        // set result in key
        return {
            ...current,
            [key]: result,
        };
    }
    // array set
    const numericKey = Number(key);
    if (current === undefined || current === null) {
        // recurse
        const result = setInRecursor(
            undefined,
            index + 1,
            path,
            value,
            destroyArrays,
        );

        // if nothing returned, delete it
        if (result === undefined) {
            return undefined;
        }

        // create an array
        const array = [];
        array[numericKey] = result;
        return array as any[];
    }
    if (!Array.isArray(current)) {
        throw new Error(""Cannot set a numeric property on an object"");
    }
    // recurse
    const existingValue = current[numericKey];
    const result = setInRecursor(
        existingValue,
        index + 1,
        path,
        value,
        destroyArrays,
    );

    // current exists, so make a copy of all its values, and add/update the new one
    const array = [...current];
    if (destroyArrays && result === undefined) {
        array.splice(numericKey, 1);
        if (array.length === 0) {
            return undefined;
        }
    } else {
        array[numericKey] = result;
    }
    return array;
};

export const setIn = (state, key, value) => {
    if (state === undefined || state === null) {
        throw new Error(`Cannot call setIn() with ${String(state)} state`);
    }
    if (key === undefined || key === null) {
        throw new Error(`Cannot call setIn() with ${String(key)} key`);
    }
    // Recursive function needs to accept and return State, but public API should
    // only deal with Objects
    return setInRecursor(state, 0, toPath(key), value, false) as any;
};
<fim_middle>",correct,2057
boolean,boolean,5516cd8e1144e5e75d37e49c3a7ed54395946de6,"<fim_prefix>export const NORTH_CODE = 'N';
export const EAST_CODE = 'E';
export const WEST_CODE = 'W';
export const SOUTH_CODE = 'S';
 
export const FORWARD_CODE = 'F';
 
export const RIGHT_CODE = 'R';
export const LEFT_CODE = 'L';

interface ShipPosition  {
  horizontal: number,
  vertical: number,
  direction: string
}

interface Position {
  horizontal: number,
  vertical: number,
}

interface ShipWithWaypoint  {
  ship: Position,
  waypoint: Position
}

const getRotatedDirection = (direction, angle, clockwise) => {
  const directions = [
    EAST_CODE,
    SOUTH_CODE,
    WEST_CODE,
    NORTH_CODE
  ];

  if (!clockwise) {
    directions.reverse();
  }

  const currentDirectionIndex = directions.indexOf(direction);
  const numberOfRotations = angle / 90;

  const newDirectionIndex = (currentDirectionIndex + numberOfRotations) % 4;

  return directions[newDirectionIndex];
}

const getDirectionVector = (direction) => {
  const directions: { [id: string]: Position; } = {}
  directions[EAST_CODE] = { horizontal: 1, vertical: 0 };
  directions[WEST_CODE] = { horizontal: -1, vertical: 0 };
  directions[NORTH_CODE] = { horizontal: 0, vertical: 1 };
  directions[SOUTH_CODE] = { horizontal: 0, vertical: -1 };

  return directions[direction];
}

const getMovedShip = (shipPosition, distance, direction) => {
  const vector = getDirectionVector(direction);

  return {
    ...shipPosition,
    horizontal: shipPosition.horizontal + (vector.horizontal * distance),
    vertical: shipPosition.vertical + (vector.vertical * distance),
  }
}

export function getNewShipPosition(shipPosition, instruction) {
  const [instructionCode, ...value] = instruction.split('');
  const instructionValue = parseInt(value.join(''));

  let newShipPosition = { ...shipPosition };

  switch (instructionCode) {
    case RIGHT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, true);
      break;
    case LEFT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, false);
      break;
    case FORWARD_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, shipPosition.direction);
      break;
    case EAST_CODE:
    case WEST_CODE:
    case NORTH_CODE:
    case SOUTH_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, instructionCode);
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

const getRotatedWaypoint = (position, angle, clockwise: <fim_suffix>) => {
  let rotatedPosition = {...position};

  const numberOfRotations = angle / 90;
  const clockwiseMultiplier = clockwise ? 1 : -1;

  for (let i = 1; i <= numberOfRotations; i++) {
    const horizontal = rotatedPosition.horizontal;
    const vertical = rotatedPosition.vertical;
    rotatedPosition.horizontal = vertical * clockwiseMultiplier;
    rotatedPosition.vertical = horizontal * (-clockwiseMultiplier);
  }

  return rotatedPosition;
}

export function getNewShipPositionWithWaypoint(shipPosition, instruction) {
  const [instructionCode, ...value] = instruction.split('');
  const intValue = parseInt(value.join(''));

  let newShipPosition = JSON.parse(JSON.stringify(shipPosition));

  switch (instructionCode) {
    case FORWARD_CODE:
      newShipPosition.ship.horizontal += shipPosition.waypoint.horizontal * intValue;
      newShipPosition.ship.vertical += shipPosition.waypoint.vertical * intValue;
      break;
    case EAST_CODE:
      newShipPosition.waypoint.horizontal += intValue;
      break;
    case WEST_CODE:
      newShipPosition.waypoint.horizontal -= intValue;
      break;
    case NORTH_CODE:
      newShipPosition.waypoint.vertical += intValue;
      break;
    case SOUTH_CODE:
      newShipPosition.waypoint.vertical -= intValue;
      break;
    case RIGHT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, true)
      break;
    case LEFT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, false)
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

export function getShipManhattanDistance(input) {
  let shipPosition = {
    horizontal: 0,
    vertical: 0,
    direction: EAST_CODE
  }

  for (let line of input) {
    shipPosition = getNewShipPosition(shipPosition, line)
  }

  return Math.abs(shipPosition.horizontal) + Math.abs(shipPosition.vertical);
}

export function getShipManhattanDistanceWithWaypoint(input) {
  let shipPositionWithWaypoint = {
    ship: {
        horizontal: 0,
        vertical: 0
    },
    waypoint: {
        horizontal: 10,
        vertical: 1
    }
  }

  for (let line of input) {
    shipPositionWithWaypoint = getNewShipPositionWithWaypoint(shipPositionWithWaypoint, line)
  }

  return Math.abs(shipPositionWithWaypoint.ship.horizontal) + Math.abs(shipPositionWithWaypoint.ship.vertical);
}
<fim_middle>",correct,2173
boolean,boolean,5516cd8e1144e5e75d37e49c3a7ed54395946de6,"<fim_prefix>export const NORTH_CODE = 'N';
export const EAST_CODE = 'E';
export const WEST_CODE = 'W';
export const SOUTH_CODE = 'S';
 
export const FORWARD_CODE = 'F';
 
export const RIGHT_CODE = 'R';
export const LEFT_CODE = 'L';

interface ShipPosition  {
  horizontal: number,
  vertical: number,
  direction: string
}

interface Position {
  horizontal: number,
  vertical: number,
}

interface ShipWithWaypoint  {
  ship: Position,
  waypoint: Position
}

const getRotatedDirection = (direction, angle, clockwise: <fim_suffix>) => {
  const directions = [
    EAST_CODE,
    SOUTH_CODE,
    WEST_CODE,
    NORTH_CODE
  ];

  if (!clockwise) {
    directions.reverse();
  }

  const currentDirectionIndex = directions.indexOf(direction);
  const numberOfRotations = angle / 90;

  const newDirectionIndex = (currentDirectionIndex + numberOfRotations) % 4;

  return directions[newDirectionIndex];
}

const getDirectionVector = (direction) => {
  const directions: { [id: string]: Position; } = {}
  directions[EAST_CODE] = { horizontal: 1, vertical: 0 };
  directions[WEST_CODE] = { horizontal: -1, vertical: 0 };
  directions[NORTH_CODE] = { horizontal: 0, vertical: 1 };
  directions[SOUTH_CODE] = { horizontal: 0, vertical: -1 };

  return directions[direction];
}

const getMovedShip = (shipPosition, distance, direction) => {
  const vector = getDirectionVector(direction);

  return {
    ...shipPosition,
    horizontal: shipPosition.horizontal + (vector.horizontal * distance),
    vertical: shipPosition.vertical + (vector.vertical * distance),
  }
}

export function getNewShipPosition(shipPosition, instruction) {
  const [instructionCode, ...value] = instruction.split('');
  const instructionValue = parseInt(value.join(''));

  let newShipPosition = { ...shipPosition };

  switch (instructionCode) {
    case RIGHT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, true);
      break;
    case LEFT_CODE:
      newShipPosition.direction = getRotatedDirection(shipPosition.direction, instructionValue, false);
      break;
    case FORWARD_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, shipPosition.direction);
      break;
    case EAST_CODE:
    case WEST_CODE:
    case NORTH_CODE:
    case SOUTH_CODE:
      newShipPosition = getMovedShip(newShipPosition, instructionValue, instructionCode);
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

const getRotatedWaypoint = (position, angle, clockwise) => {
  let rotatedPosition = {...position};

  const numberOfRotations = angle / 90;
  const clockwiseMultiplier = clockwise ? 1 : -1;

  for (let i = 1; i <= numberOfRotations; i++) {
    const horizontal = rotatedPosition.horizontal;
    const vertical = rotatedPosition.vertical;
    rotatedPosition.horizontal = vertical * clockwiseMultiplier;
    rotatedPosition.vertical = horizontal * (-clockwiseMultiplier);
  }

  return rotatedPosition;
}

export function getNewShipPositionWithWaypoint(shipPosition, instruction) {
  const [instructionCode, ...value] = instruction.split('');
  const intValue = parseInt(value.join(''));

  let newShipPosition = JSON.parse(JSON.stringify(shipPosition));

  switch (instructionCode) {
    case FORWARD_CODE:
      newShipPosition.ship.horizontal += shipPosition.waypoint.horizontal * intValue;
      newShipPosition.ship.vertical += shipPosition.waypoint.vertical * intValue;
      break;
    case EAST_CODE:
      newShipPosition.waypoint.horizontal += intValue;
      break;
    case WEST_CODE:
      newShipPosition.waypoint.horizontal -= intValue;
      break;
    case NORTH_CODE:
      newShipPosition.waypoint.vertical += intValue;
      break;
    case SOUTH_CODE:
      newShipPosition.waypoint.vertical -= intValue;
      break;
    case RIGHT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, true)
      break;
    case LEFT_CODE:
      newShipPosition.waypoint = getRotatedWaypoint(newShipPosition.waypoint, intValue, false)
      break;
    default:
      throw 'Invalid instruction';     
  }

  return newShipPosition;
}

export function getShipManhattanDistance(input) {
  let shipPosition = {
    horizontal: 0,
    vertical: 0,
    direction: EAST_CODE
  }

  for (let line of input) {
    shipPosition = getNewShipPosition(shipPosition, line)
  }

  return Math.abs(shipPosition.horizontal) + Math.abs(shipPosition.vertical);
}

export function getShipManhattanDistanceWithWaypoint(input) {
  let shipPositionWithWaypoint = {
    ship: {
        horizontal: 0,
        vertical: 0
    },
    waypoint: {
        horizontal: 10,
        vertical: 1
    }
  }

  for (let line of input) {
    shipPositionWithWaypoint = getNewShipPositionWithWaypoint(shipPositionWithWaypoint, line)
  }

  return Math.abs(shipPositionWithWaypoint.ship.horizontal) + Math.abs(shipPositionWithWaypoint.ship.vertical);
}
<fim_middle>",correct,2184
boolean,boolean,55ca1837cce770e7e7f0bda123564f098fe3a486,"<fim_prefix>export type JalaaliDate = { jy: number; jm: number; jd: number };
export type GregorianDate = { gy: number; gm: number; gd: number };

/**
 * Converts a Gregorian date to Jalaali.
 */
export function toJalaali(date);
export function toJalaali(gy, gm, gd);
export function toJalaali(
  gy,
  gm?,
  gd?,
) {
  if (gy instanceof Date) {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }
  return d2j(g2d(gy, gm!, gd!));
}

/**
 * Converts a Jalaali date to Gregorian.
 */
export function toGregorian(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd));
}

/**
 * Checks whether a Jalaali date is valid or not.
 */
export function isValidJalaaliDate(
  jy,
  jm,
  jd,
) {
  return (
    jy >= minJalaaliYear &&
    jy <= maxJalaaliYear &&
    jm >= 1 &&
    jm <= 12 &&
    jd >= 1 &&
    jd <= jalaaliMonthLength(jy, jm)
  );
}

/**
 * Is this a leap year or not?
 */
export function isLeapJalaaliYear(jy): <fim_suffix> {
  return jalCalLeap(jy) === 0;
}

/**
 * The number of days in a given month in a Jalaali year.
 */
export function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) {
    return 31;
  }
  if (jm <= 11) {
    return 30;
  }
  if (isLeapJalaaliYear(jy)) {
    return 30;
  }
  return 29;
}

/**
 * This function determines if the Jalaali (Persian) year is
 * leap (366-day long) or is the common year (365 days), and
 * finds the day in March (Gregorian calendar) of the first
 * day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @param withoutLeap when don't need leap (true or false) default is false
 * @returns
 *   leap: number of years since the last leap year (0 to 4)
 *   gy: Gregorian year of the beginning of Jalaali year
 *   march: the March day of Farvardin the 1st (1st day of jy)
 * @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
 * @see: http://www.fourmilab.ch/documents/calendar/
 */
export function jalCal(jy, withoutLeap = false) {
  validateJalaaliYear(jy);

  let jump = 0;
  let leapJ = -14;
  let jp = minJalaaliYear;
  // Find the limiting years for the Jalaali year jy.
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
      leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
    }
  }
  let n = jy - jp;

  // Find the number of leap years from AD 621 to the beginning
  // of the current Jalaali year in the Persian calendar.
  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
  if (mod(jump, 33) === 4 && jump - n === 4) {
    leapJ += 1;
  }

  const gy = jy + 621;

  // And the same in the Gregorian calendar (until the year gy).
  const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

  // Determine the Gregorian date of Farvardin the 1st.
  const march = 20 + leapJ - leapG;

  // return with gy and march when we don't need leap
  if (withoutLeap) {
    return {
      gy,
      march,
    };
  }

  // Find how many years have passed since the last leap year.
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }
  let leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }

  return {
    leap,
    gy,
    march,
  };
}

/**
 * Converts a date of the Jalaali calendar to the Julian Day number.
 *
 * @param jy Jalaali year (1 to 3100)
 * @param jm Jalaali month (1 to 12)
 * @param jd Jalaali day (1 to 29/31)
 * @returns Julian Day number
 */
export function j2d(jy, jm, jd) {
  const { gy, march } = jalCal(jy, true);
  return g2d(gy, 3, march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
}

/**
 * Converts the Julian Day number to a date in the Jalaali calendar.
 *
 * @param jdn Julian Day number
 * @returns
 *   jy: Jalaali year (1 to 3100)
 *   jm: Jalaali month (1 to 12)
 *   jd: Jalaali day (1 to 29/31)
 */
export function d2j(jdn) {
  const gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
  let jy = gy - 621;
  const r = jalCal(jy, false);
  const jdn1f = g2d(gy, 3, r.march);
  let jd;
  let jm;
  let k;

  // Find number of days that passed since 1 Farvardin.
  k = jdn - jdn1f;
  if (k >= 0) {
    if (k <= 185) {
      // The first 6 months.
      jm = 1 + div(k, 31);
      jd = mod(k, 31) + 1;
      return { jy: jy, jm: jm, jd: jd };
    } else {
      // The remaining months.
      k -= 186;
    }
  } else {
    // Previous Jalaali year.
    jy -= 1;
    k += 179;
    if (r.leap === 1) k += 1;
  }
  jm = 7 + div(k, 30);
  jd = mod(k, 30) + 1;
  return { jy: jy, jm: jm, jd: jd };
}

/**
 * Calculates the Julian Day number from Gregorian or Julian
 * calendar dates. This integer number corresponds to the noon of
 * the date (i.e. 12 hours of Universal Time).
 * The procedure was tested to be good since 1 March, -100100 (of both
 * calendars) up to a few million years into the future.
 *
 * @param gy Calendar year (years BC numbered 0, -1, -2, ...)
 * @param gm Calendar month (1 to 12)
 * @param gd Calendar day of the month (1 to 28/29/30/31)
 * @returns Julian Day number
 */
export function g2d(gy, gm, gd) {
  let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) +
    div(153 * mod(gm + 9, 12) + 2, 5) +
    gd -
    34840408;
  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
  return d;
}

/**
 * Calculates Gregorian and Julian calendar dates from the Julian Day number
 * (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
 * calendars) to some millions of years ahead of the present.
 *
 * @param jdn Julian Day number
 * @returns
 *   gy: Calendar year (years BC numbered 0, -1, -2, ...)
 *   gm: Calendar month (1 to 12)
 *   gd: Calendar day of the month M (1 to 28/29/30/31)
 */
export function d2g(jdn) {
  let j = 4 * jdn + 139361631;
  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  const i = div(mod(j, 1461), 4) * 5 + 308;
  const gd = div(mod(i, 153), 5) + 1;
  const gm = mod(div(i, 153), 12) + 1;
  const gy = div(j, 1461) - 100100 + div(8 - gm, 6);
  return { gy, gm, gd };
}

/**
 * Returns Saturday and Friday day of the current week
 * (week starts on Saturday)
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @returns Saturday and Friday of the current week
 */
export function jalaaliWeek(jy, jm, jd) {
  const dayOfWeek = jalaaliToDateObject(jy, jm, jd).getDay();

  const startDayDifference = dayOfWeek == 6 ? 0 : -(dayOfWeek + 1);
  const endDayDifference = 6 + startDayDifference;

  return {
    saturday: d2j(j2d(jy, jm, jd + startDayDifference)),
    friday: d2j(j2d(jy, jm, jd + endDayDifference)),
  };
}

/**
 * Convert Jalaali calendar dates to javascript Date object
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @param [h] hours
 * @param [m] minutes
 * @param [s] seconds
 * @param [ms] milliseconds
 * @returns Date object of the jalaali calendar dates
 */
export function jalaaliToDateObject(
  jy,
  jm,
  jd,
  h = 0,
  m = 0,
  s = 0,
  ms = 0,
) {
  const { gy, gm, gd } = toGregorian(jy, jm, jd);

  return new Date(gy, gm - 1, gd, h, m, s, ms);
}

/**
 * Checks wether the jalaali year is between min and max
 */
function validateJalaaliYear(jy) {
  if (jy < minJalaaliYear || jy > maxJalaaliYear) {
    throw new Error(`Invalid Jalaali year ${jy}`);
  }
}

/**
 * This function determines if the Jalaali (Persian) year is a leap
 * (366-day long) or is the common year (365 days), and finds the day in March
 * (Gregorian calendar) of the first day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @returns number of years since the last leap year (0 to 4)
 */
function jalCalLeap(jy) {
  validateJalaaliYear(jy);

  let jump = 0;
  let jp = minJalaaliYear;
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
    }
  }

  let n = jy - jp;
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }

  const leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    return 4;
  }
  return leap;
}

/**
 * Utility helper functions.
 */
function div(a, b) {
  return ~~(a / b);
}
function mod(a, b) {
  return a - ~~(a / b) * b;
}

/**
 * Jalaali years starting the 33-year rule.
 */
const breaks: number[] = [
  -61,
  9,
  38,
  199,
  426,
  686,
  756,
  818,
  1111,
  1181,
  1210,
  1635,
  2060,
  2097,
  2192,
  2262,
  2324,
  2394,
  2456,
  3178,
];

const minJalaaliYear = breaks[0];
const maxJalaaliYear = breaks[breaks.length - 1] - 1;
<fim_middle>",correct,2220
boolean,boolean,55ca1837cce770e7e7f0bda123564f098fe3a486,"<fim_prefix>export type JalaaliDate = { jy: number; jm: number; jd: number };
export type GregorianDate = { gy: number; gm: number; gd: number };

/**
 * Converts a Gregorian date to Jalaali.
 */
export function toJalaali(date);
export function toJalaali(gy, gm, gd);
export function toJalaali(
  gy,
  gm?,
  gd?,
) {
  if (gy instanceof Date) {
    gd = gy.getDate();
    gm = gy.getMonth() + 1;
    gy = gy.getFullYear();
  }
  return d2j(g2d(gy, gm!, gd!));
}

/**
 * Converts a Jalaali date to Gregorian.
 */
export function toGregorian(jy, jm, jd) {
  return d2g(j2d(jy, jm, jd));
}

/**
 * Checks whether a Jalaali date is valid or not.
 */
export function isValidJalaaliDate(
  jy,
  jm,
  jd,
): <fim_suffix> {
  return (
    jy >= minJalaaliYear &&
    jy <= maxJalaaliYear &&
    jm >= 1 &&
    jm <= 12 &&
    jd >= 1 &&
    jd <= jalaaliMonthLength(jy, jm)
  );
}

/**
 * Is this a leap year or not?
 */
export function isLeapJalaaliYear(jy) {
  return jalCalLeap(jy) === 0;
}

/**
 * The number of days in a given month in a Jalaali year.
 */
export function jalaaliMonthLength(jy, jm) {
  if (jm <= 6) {
    return 31;
  }
  if (jm <= 11) {
    return 30;
  }
  if (isLeapJalaaliYear(jy)) {
    return 30;
  }
  return 29;
}

/**
 * This function determines if the Jalaali (Persian) year is
 * leap (366-day long) or is the common year (365 days), and
 * finds the day in March (Gregorian calendar) of the first
 * day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @param withoutLeap when don't need leap (true or false) default is false
 * @returns
 *   leap: number of years since the last leap year (0 to 4)
 *   gy: Gregorian year of the beginning of Jalaali year
 *   march: the March day of Farvardin the 1st (1st day of jy)
 * @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm
 * @see: http://www.fourmilab.ch/documents/calendar/
 */
export function jalCal(jy, withoutLeap = false) {
  validateJalaaliYear(jy);

  let jump = 0;
  let leapJ = -14;
  let jp = minJalaaliYear;
  // Find the limiting years for the Jalaali year jy.
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
      leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);
    }
  }
  let n = jy - jp;

  // Find the number of leap years from AD 621 to the beginning
  // of the current Jalaali year in the Persian calendar.
  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);
  if (mod(jump, 33) === 4 && jump - n === 4) {
    leapJ += 1;
  }

  const gy = jy + 621;

  // And the same in the Gregorian calendar (until the year gy).
  const leapG = div(gy, 4) - div((div(gy, 100) + 1) * 3, 4) - 150;

  // Determine the Gregorian date of Farvardin the 1st.
  const march = 20 + leapJ - leapG;

  // return with gy and march when we don't need leap
  if (withoutLeap) {
    return {
      gy,
      march,
    };
  }

  // Find how many years have passed since the last leap year.
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }
  let leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    leap = 4;
  }

  return {
    leap,
    gy,
    march,
  };
}

/**
 * Converts a date of the Jalaali calendar to the Julian Day number.
 *
 * @param jy Jalaali year (1 to 3100)
 * @param jm Jalaali month (1 to 12)
 * @param jd Jalaali day (1 to 29/31)
 * @returns Julian Day number
 */
export function j2d(jy, jm, jd) {
  const { gy, march } = jalCal(jy, true);
  return g2d(gy, 3, march) + (jm - 1) * 31 - div(jm, 7) * (jm - 7) + jd - 1;
}

/**
 * Converts the Julian Day number to a date in the Jalaali calendar.
 *
 * @param jdn Julian Day number
 * @returns
 *   jy: Jalaali year (1 to 3100)
 *   jm: Jalaali month (1 to 12)
 *   jd: Jalaali day (1 to 29/31)
 */
export function d2j(jdn) {
  const gy = d2g(jdn).gy; // Calculate Gregorian year (gy).
  let jy = gy - 621;
  const r = jalCal(jy, false);
  const jdn1f = g2d(gy, 3, r.march);
  let jd;
  let jm;
  let k;

  // Find number of days that passed since 1 Farvardin.
  k = jdn - jdn1f;
  if (k >= 0) {
    if (k <= 185) {
      // The first 6 months.
      jm = 1 + div(k, 31);
      jd = mod(k, 31) + 1;
      return { jy: jy, jm: jm, jd: jd };
    } else {
      // The remaining months.
      k -= 186;
    }
  } else {
    // Previous Jalaali year.
    jy -= 1;
    k += 179;
    if (r.leap === 1) k += 1;
  }
  jm = 7 + div(k, 30);
  jd = mod(k, 30) + 1;
  return { jy: jy, jm: jm, jd: jd };
}

/**
 * Calculates the Julian Day number from Gregorian or Julian
 * calendar dates. This integer number corresponds to the noon of
 * the date (i.e. 12 hours of Universal Time).
 * The procedure was tested to be good since 1 March, -100100 (of both
 * calendars) up to a few million years into the future.
 *
 * @param gy Calendar year (years BC numbered 0, -1, -2, ...)
 * @param gm Calendar month (1 to 12)
 * @param gd Calendar day of the month (1 to 28/29/30/31)
 * @returns Julian Day number
 */
export function g2d(gy, gm, gd) {
  let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) +
    div(153 * mod(gm + 9, 12) + 2, 5) +
    gd -
    34840408;
  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;
  return d;
}

/**
 * Calculates Gregorian and Julian calendar dates from the Julian Day number
 * (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both
 * calendars) to some millions of years ahead of the present.
 *
 * @param jdn Julian Day number
 * @returns
 *   gy: Calendar year (years BC numbered 0, -1, -2, ...)
 *   gm: Calendar month (1 to 12)
 *   gd: Calendar day of the month M (1 to 28/29/30/31)
 */
export function d2g(jdn) {
  let j = 4 * jdn + 139361631;
  j = j + div(div(4 * jdn + 183187720, 146097) * 3, 4) * 4 - 3908;
  const i = div(mod(j, 1461), 4) * 5 + 308;
  const gd = div(mod(i, 153), 5) + 1;
  const gm = mod(div(i, 153), 12) + 1;
  const gy = div(j, 1461) - 100100 + div(8 - gm, 6);
  return { gy, gm, gd };
}

/**
 * Returns Saturday and Friday day of the current week
 * (week starts on Saturday)
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @returns Saturday and Friday of the current week
 */
export function jalaaliWeek(jy, jm, jd) {
  const dayOfWeek = jalaaliToDateObject(jy, jm, jd).getDay();

  const startDayDifference = dayOfWeek == 6 ? 0 : -(dayOfWeek + 1);
  const endDayDifference = 6 + startDayDifference;

  return {
    saturday: d2j(j2d(jy, jm, jd + startDayDifference)),
    friday: d2j(j2d(jy, jm, jd + endDayDifference)),
  };
}

/**
 * Convert Jalaali calendar dates to javascript Date object
 *
 * @param jy jalaali year
 * @param jm jalaali month
 * @param jd jalaali day
 * @param [h] hours
 * @param [m] minutes
 * @param [s] seconds
 * @param [ms] milliseconds
 * @returns Date object of the jalaali calendar dates
 */
export function jalaaliToDateObject(
  jy,
  jm,
  jd,
  h = 0,
  m = 0,
  s = 0,
  ms = 0,
) {
  const { gy, gm, gd } = toGregorian(jy, jm, jd);

  return new Date(gy, gm - 1, gd, h, m, s, ms);
}

/**
 * Checks wether the jalaali year is between min and max
 */
function validateJalaaliYear(jy) {
  if (jy < minJalaaliYear || jy > maxJalaaliYear) {
    throw new Error(`Invalid Jalaali year ${jy}`);
  }
}

/**
 * This function determines if the Jalaali (Persian) year is a leap
 * (366-day long) or is the common year (365 days), and finds the day in March
 * (Gregorian calendar) of the first day of the Jalaali year (jy).
 *
 * @param jy Jalaali calendar year (-61 to 3177)
 * @returns number of years since the last leap year (0 to 4)
 */
function jalCalLeap(jy) {
  validateJalaaliYear(jy);

  let jump = 0;
  let jp = minJalaaliYear;
  for (const jm of breaks) {
    jump = jm - jp;
    if (jy >= jm) {
      jp = jm;
    }
  }

  let n = jy - jp;
  if (jump - n < 6) {
    n = n - jump + div(jump + 4, 33) * 33;
  }

  const leap = mod(mod(n + 1, 33) - 1, 4);
  if (leap === -1) {
    return 4;
  }
  return leap;
}

/**
 * Utility helper functions.
 */
function div(a, b) {
  return ~~(a / b);
}
function mod(a, b) {
  return a - ~~(a / b) * b;
}

/**
 * Jalaali years starting the 33-year rule.
 */
const breaks: number[] = [
  -61,
  9,
  38,
  199,
  426,
  686,
  756,
  818,
  1111,
  1181,
  1210,
  1635,
  2060,
  2097,
  2192,
  2262,
  2324,
  2394,
  2456,
  3178,
];

const minJalaaliYear = breaks[0];
const maxJalaaliYear = breaks[breaks.length - 1] - 1;
<fim_middle>",correct,2222
boolean,boolean,27a493ada994b85fc1ed438e2a30a8ce7eab7c21,"<fim_prefix>/**
 * EventType
 */
interface EventType {
	readonly callback: Function;
	readonly once: boolean;
}

type EventsType = Record<string, EventType[]>;

const WILDCARD = '*';

/* event-emitter */
export default class EventEmitter {
	private _events: EventsType = {};

	/**
	 * 监听一个事件
	 * @param evt
	 * @param callback
	 * @param once
	 */
	on(evt, callback, once?: <fim_suffix>) {
		if (!this._events[evt]) {
			this._events[evt] = [];
		}
		this._events[evt].push({
			callback,
			once: !!once,
		});
		return this;
	}

	/**
	 * 监听一个事件一次
	 * @param evt
	 * @param callback
	 */
	once(evt, callback) {
		return this.on(evt, callback, true);
	}

	/**
	 * 触发一个事件
	 * @param evt
	 * @param args
	 */
	emit(evt, ...args) {
		const events = this._events[evt] || [];
		const wildcardEvents = this._events[WILDCARD] || [];

		// 实际的处理 emit 方法
		const doEmit = (es) => {
			let length = es.length;
			for (let i = 0; i < length; i++) {
				if (!es[i]) {
					continue;
				}
				const { callback, once } = es[i];

				if (once) {
					es.splice(i, 1);

					if (es.length === 0) {
						delete this._events[evt];
					}

					length--;
					i--;
				}

				callback.apply(this, args);
			}
		};

		doEmit(events);
		doEmit(wildcardEvents);
	}

	/**
	 * 取消监听一个事件，或者一个channel
	 * @param evt
	 * @param callback
	 */
	off(evt?, callback?) {
		if (!evt) {
			// evt 为空全部清除
			this._events = {};
		} else {
			if (!callback) {
				// evt 存在，callback 为空，清除事件所有方法
				delete this._events[evt];
			} else {
				// evt 存在，callback 存在，清除匹配的
				const events = this._events[evt] || [];

				let length = events.length;
				for (let i = 0; i < length; i++) {
					if (events[i].callback === callback) {
						events.splice(i, 1);
						length--;
						i--;
					}
				}

				if (events.length === 0) {
					delete this._events[evt];
				}
			}
		}

		return this;
	}

	/* 当前所有的事件 */
	getEvents() {
		return this._events;
	}
}
<fim_middle>",correct,2296
boolean,boolean,61811f6d5ec9421f9b4aaef6478b2aa7abe326c0,"<fim_prefix>export enum Clue {
  Absent,
  Elsewhere,
  Correct,
}

export interface CluedLetter {
  clue?: Clue;
  letter: string;
}

export function clue(word, target) {
  let elusive: string[] = [];
  target.split("""").forEach((letter, i) => {
    if (word[i] !== letter) {
      elusive.push(letter);
    }
  });
  return word.split("""").map((letter, i) => {
    let j: number;
    if (target[i] === letter) {
      return { clue: Clue.Correct, letter };
    } else if ((j = elusive.indexOf(letter)) > -1) {
      // ""use it up"" so we don't clue at it twice
      elusive[j] = """";
      return { clue: Clue.Elsewhere, letter };
    } else {
      return { clue: Clue.Absent, letter };
    }
  });
}

export function xorclue(clue1, clue2) {
  return clue1.map((cluedLetter,i) => {
    if (cluedLetter !== clue2[i]) {
      if ( cluedLetter.clue === Clue.Correct || clue2[i].clue === Clue.Correct ) {
        return { clue: Clue.Correct, letter: cluedLetter.letter };
      }
      if ( cluedLetter.clue === Clue.Elsewhere || clue2[i].clue === Clue.Elsewhere ) {
        return { clue: Clue.Elsewhere, letter: cluedLetter.letter };
      }
    }
    return { clue: Clue.Absent, letter: cluedLetter.letter };
  });
}

export function clueClass(clue, correctGuess: <fim_suffix>) {
  const suffix = (correctGuess ? ""-fin"" : """");
  if (clue === Clue.Absent) {
    return ""letter-absent"";
  } else if (clue === Clue.Elsewhere) {
    return ""letter-elsewhere"" + suffix;
  } else {
    return ""letter-correct"" + suffix;
  }
}

export function clueWord(clue) {
  if (clue === Clue.Absent) {
    return ""no"";
  } else if (clue === Clue.Elsewhere) {
    return ""elsewhere"";
  } else {
    return ""correct"";
  }
}

export function describeClue(clue) {
  return clue
    .map(({ letter, clue }) => letter.toUpperCase() + "" "" + clueWord(clue!))
    .join("", "");
}
<fim_middle>",correct,2304
boolean,boolean,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover: <fim_suffix> = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2320
boolean,boolean,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet): <fim_suffix>=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2323
boolean,boolean,63546d468176bc6f54323adf83e96b4e7d5a7cf9,"<fim_prefix>/**
 * @packageDocumentation
 * @module main
 */

/** A dataset containing all the data to be displayed. */
export interface Dataset {
    /** metadata for this dataset */
    meta: Metadata;
    /**
     * List of structures in the dataset.
     *
     * The structures can either follow the `Structure` interface, in which
     * case they will be loaded as-defined; or contain any kind of data as a
     * [[UserStructure]], in which case the [[ViewersGrid.loadStructure]]
     * callback should be set to translate from whatever is stored to a
     * [[Structure]].
     */
    structures: Structure[] | UserStructure[];
    /**
     * List of properties for the structures (`target == ""structure""`), or
     * atom-centered environments in the structures (`target == ""atom""`).
     *
     * For structure properties, the `values` array of the property should have
     * the same size as the [[Dataset.structures|structure list]].
     *
     * For atomic properties, the `values` array of the property should have
     * the same size as the [[Dataset.environments|environments list]].
     */
    properties: { [name: string]: Property };
    /**
     * List of atom-centered environments in the dataset.
     *
     * Currently, the code assumes that every atom is associated with an
     * environment. This may change in the future.
     */
    environments?: Environment[];
    /** Settings for visualization of this dataset */
    settings?: Partial<Settings>;
}

/**
 * Type definition for settings that can be saved with a dataset. THey should be
 * a simple object with string keys, scalar values, array values or nested
 * Settings objects.
 */
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface Settings
    extends Record<
        string,
        string | string[] | number | number[] | boolean | boolean[] | Settings | Settings[]
    > {}

/** Various metadata associated with a dataset */
export interface Metadata {
    /** dataset name */
    name: string;
    /** authors of the dataset */
    authors?: string[];
    /** academic references related to this dataset */
    references?: string[];
    /** description of the dataset */
    description?: string;
}

/** A single atomic structure */
export interface Structure {
    /** Number of atoms in the structure */
    size: number;
    /** Names of all atoms in the structure */
    names: string[];
    /**
     * x position (cartesian coordinate) of all atoms in the structure
     *
     * This array should have the same size as [[Structure.names]], and contain
     * values expressed in Angströms.
     */
    x: number[];
    /**
     * y position (cartesian coordinate) of all atoms in the structure
     *
     * This array should have the same size as [[Structure.names]], and contain
     * values expressed in Angströms.
     */
    y: number[];
    /**
     * z position (cartesian coordinate) of all atoms in the structure
     *
     * This array should have the same size as [[Structure.names]], and contain
     * values expressed in Angströms.
     */
    z: number[];
    /**
     * Unit cell of the system, given as `[ax ay az bx by bz cx cy cz]`, where
     * **a**, **b**, and **c** are the unit cell vectors. All values should be
     * expressed in Angströms.
     */
    cell?: number[];
}

/**
 * User-defined data to allow dynamic loading of the structures.
 *
 * The main use-case of this is making the initial loading time of chemiscope
 * faster by loading structure on-demand, from files, a database or even a
 * javascript program.
 */
export interface UserStructure {
    /** Number of atoms in the structure */
    size: number;
    /**
     * User-defined data which can be turned into a [[Structure]].
     *
     * [[ViewersGrid.loadStructure]] must be set to be able to load this
     * data.
     */
    data: unknown;
}

/** Possible types of properties: full structure property, or atomic property */
export type Target = 'structure' | 'atom';

/**
 * A single property in a dataset.
 *
 * Properties can be physical properties (energy, number of atoms, density,
 * *etc.*); values associated with the structure (such as SOAP vectors),
 * projected onto a lower dimensionality sub-space (through PCA or any other
 * algorithm); or any other value associated with every structure/environment in
 * the dataset.
 */
export interface Property {
    /** is this property associated with a full structure or a single atom? */
    target: Target;
    /**
     * values of the property
     *
     * string values should represent classification results (category ""A"", ""B""
     * or ""C""); and numeric values should be use for everything else.
     */
    values: string[] | number[];
    /** user-facing description of the property */
    description?: string;
    /** unit of the property values */
    units?: string;
}

/**
 * An atom-centered environment.
 *
 * Currently, only spherical (i.e. cutoff-based) environments are supported
 */
export interface Environment {
    /** Index of the related structure in [[Dataset.structures]] */
    structure: number;
    /** Index of the central atom in the structure, 0-based */
    center: number;
    /** Spherical cutoff radius, expressed in Angströms */
    cutoff: number;
}

/** Arbitrary javascript object, to be validated */
export type JsObject = Record<string, unknown>;

/** @hidden
 * Check that the given object, potentially comming from javascript, has all
 * required properties to be a dataset.
 */
export function validateDataset(o) {
    if (typeof o !== 'object') {
        throw Error('the dataset must be a JavaScript object');
    }

    if (!('meta' in o)) {
        throw Error('missing ""meta"" key in the dataset');
    } else if (!(typeof o.meta === 'object' && o.meta !== null)) {
        throw Error('""meta"" must be an object in the dataset');
    }
    checkMetadata(o.meta as JsObject);

    if (!('structures' in o)) {
        throw Error('missing ""structures"" key in the dataset');
    } else if (!Array.isArray(o.structures)) {
        throw Error('""structures"" must be an array in the dataset');
    }
    const [structureCount, atomsCount] = checkStructures(o.structures as JsObject[]);

    let envCount = atomsCount;
    if ('environments' in o) {
        if (!Array.isArray(o.environments)) {
            throw Error('""environments"" must be an array in the dataset');
        }

        envCount = o.environments.length;
        checkEnvironments(
            o.environments as JsObject[],
            o.structures as (Structure | UserStructure)[]
        );
    }

    if (!('properties' in o)) {
        throw Error('missing ""properties"" key in then dataset');
    } else if (!(typeof o.properties === 'object' && o.properties !== null)) {
        throw Error('""properties"" must be an object in the dataset');
    }

    checkProperties(o.properties as Record<string, JsObject>, structureCount, envCount);
}

function checkMetadata(o) {
    if (!('name' in o)) {
        throw Error('missing ""meta.name"" key in the dataset');
    } else if (typeof o.name !== 'string') {
        throw Error('""meta.name"" must be a string in the dataset');
    }

    if ('description' in o && typeof o.description !== 'string') {
        throw Error('""meta.description"" should be a string in the dataset');
    }

    if ('authors' in o) {
        if (!Array.isArray(o.authors)) {
            throw Error('""meta.authors"" must be an array in the dataset');
        }

        for (const a of o.authors) {
            if (typeof a !== 'string') {
                throw Error('""meta.authors"" must be an array of strings in the dataset');
            }
        }
    }

    if ('references' in o) {
        if (!Array.isArray(o.references)) {
            throw Error('""meta.references"" must be an array in the dataset');
        }

        for (const a of o.references) {
            if (typeof a !== 'string') {
                throw Error('""meta.references"" must be an array of strings in the dataset');
            }
        }
    }
}

function checkStructures(o) {
    let atomsCount = 0;
    for (let i = 0; i < o.length; i++) {
        const structure = o[i];
        if (
            !(
                'size' in structure &&
                typeof structure.size === 'number' &&
                isPositiveInteger(structure.size)
            )
        ) {
            throw Error(`missing 'size' for structure ${i}`);
        }
        atomsCount += structure.size;

        if ('data' in structure) {
            // user-specified structure, nothing to do
        } else {
            const message = checkStructure(structure);
            if (message !== '') {
                throw Error(`error in structure ${i}: ${message}`);
            }
        }
    }

    return [o.length, atomsCount];
}

/**
 * Check that the given object is a structure. Return a string describing the
 * issue with `s` if any, or the empty string if `s` looks like a valid
 * structure.
 */
export function checkStructure(s) {
    if (typeof s !== 'object') {
        throw Error('the structure must be a JavaScript object');
    }

    if (!('size' in s && typeof s.size === 'number' && isPositiveInteger(s.size))) {
        return 'missing ""size""';
    }

    for (const key of ['names', 'x', 'y', 'z']) {
        if (!(key in s)) {
            return `missing ""${key}""`;
        }
        const array = s[key];
        if (!Array.isArray(array)) {
            return `""${key}"" must be an array`;
        }

        if (s.size > 0 && array.length !== s.size) {
            return `wrong size for ""${key}"", expected ${s.size}, got ${array.length}`;
        }
    }

    if ('cell' in s) {
        if (!(Array.isArray(s.cell) && s.cell.length === 9)) {
            return '""cell"" must be an array of size 9';
        }
    }

    return '';
}

function checkProperties(
    properties,
    structureCount,
    envCount
) {
    for (const key in properties) {
        const property = properties[key];

        if (!('target' in property && typeof property.target === 'string')) {
            Error(`'properties['${key}'].target' should be a string`);
        }

        if (property.target !== 'atom' && property.target !== 'structure') {
            throw Error(`'properties['${key}'].target', should be 'atom' | 'structure'`);
        }

        if (!('values' in property && Array.isArray(property.values))) {
            throw Error(`'properties[""${key}""].values' should be an array`);
        }

        // check size if possible
        let expected = 0;
        if (property.target === 'atom') {
            expected = envCount;
        } else if (property.target === 'structure') {
            expected = structureCount;
        }

        if (expected > 0 && property.values.length !== expected) {
            throw Error(
                `wrong size for 'properties['${key}'].values': expected ${expected}, got ${property.values.length}`
            );
        }

        const initial = typeof property.values[0];
        if (initial !== 'string' && initial !== 'number') {
            throw Error(`'properties['${key}'].values' should contain string or number`);
        }

        for (const value of property.values) {
            if (typeof value !== initial) {
                throw Error(`'properties['${key}'].values' should be of a single type`);
            }
        }

        // check that units & description are valid
        if ('description' in property && typeof property.description !== 'string') {
            throw Error(`'properties['${key}'].description' should contain a string`);
        }

        if ('units' in property && typeof property.units !== 'string') {
            throw Error(`'properties['${key}'].units' should contain a string`);
        }
    }
}

function checkEnvironments(o, structures) {
    for (let i = 0; i < o.length; i++) {
        const env = o[i];

        if (!('structure' in env && typeof env.structure === 'number')) {
            throw Error(`missing 'structure' for environment ${i}`);
        }

        if (!isPositiveInteger(env.structure) || env.structure >= structures.length) {
            throw Error(
                `out of bounds 'structure' for environment ${i}: index is \
                ${env.structure}, we have ${structures.length} structures`
            );
        }

        if (!('center' in env && typeof env.center === 'number')) {
            throw Error(`missing 'center' for environment ${i}`);
        }

        const size = structures[env.structure].size;
        if (!isPositiveInteger(env.center) || env.center >= size) {
            throw Error(
                `out of bounds 'center' for environment ${i}: index is \
                ${env.center}, we have ${size} atoms in structure ${env.structure}`
            );
        }

        if (!('cutoff' in env && typeof env.cutoff === 'number')) {
            throw Error(`missing 'cutoff' for environment ${i}`);
        }
    }
}

function isPositiveInteger(number): <fim_suffix> {
    return Number.isInteger(number) && number >= 0;
}
<fim_middle>",correct,2357
boolean,boolean,f7f098de6ce0870153a7af6a953c190cf705eb1b,"<fim_prefix>export interface OrderedListEntry<T>
{
  prev: OrderedListEntry<T>;
  next: OrderedListEntry<T>;
  value: T;
}

export type OrderedListIndex<T> = { [key: string]: OrderedListEntry<T> };

export class OrderedList<T>
{
  head: OrderedListEntry<T>;
  tail: OrderedListEntry<T>;
  index: OrderedListIndex<T>;

  constructor()
    {
      this.clear();
    }

  isempty(): <fim_suffix>
    {
      return this.head == null;
    }

  clear()
    {
      this.head = null;
      this.tail = null;
      this.index = {};
    }

  insert(key, value)
    {
      if (this.index[key] !== undefined)
        return `memsqs: send: message uid ${key} already exists`;

      let e: OrderedListEntry<T> = { prev: this.tail, next: null, value: value };
      if (this.tail)
        this.tail.next = e;
      this.tail = e;
      if (this.head === null)
        this.head = e;
      this.index[key] = e;
      return null;
    }

  remove(key)
    {
      let e = this.index[key];
      if (e === undefined)
        return `memsqs: remove: message uid ${key} does not exist`;

      if (e === this.tail)
        this.tail = e.prev;
      else
        e.next.prev = e.prev;

      if (e === this.head)
        this.head = e.next;
      else
        e.prev.next = e.next;

      delete this.index[key];

      return null;
    }

  forEach(cb)
    {
      for (let p = this.head; p && cb(p.value); p = p.next)
        continue;
    }
}
<fim_middle>",correct,2499
boolean,boolean,ccee70850d7be59ff29044ffd01e8ec90a3de543,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

// to suit your point format, run search/replace for '[0]' and '[1]';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

type Point = [number, number];

// square distance between 2 points
const getSqDist = (p1, p2) => {
  const dx = p1[0] - p2[0];
  const dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
};

// square distance from a point to a segment
const getSqSegDist = (p, p1, p2) => {
  let [x, y] = p1;
  let dx = p2[0] - x;
  let dy = p2[1] - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      [x, y] = p2;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
};
// rest of the code doesn't care about point format

// basic distance-based simplification
const simplifyRadialDist = (points, sqTolerance) => {
  if (points.length === 0) return [];

  let prevPoint = points[0];
  const newPoints = [prevPoint];
  let point: Point | null = null;

  points.forEach((d) => {
    point = d;
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  });

  if (prevPoint !== point) newPoints.push(point as unknown as Point);

  return newPoints;
};

const simplifyDPStep = (
  points,
  first,
  last,
  sqTolerance,
  simplified,
) => {
  let maxSqDist = sqTolerance;
  let index: number | null = null;

  for (let i = first + 1; i < last; i += 1) {
    const sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if ((index as number) - first > 1) {
      simplifyDPStep(points, first, (index as number), sqTolerance, simplified);
    }
    simplified.push(points[(index as number)]);
    if (last - (index as number) > 1) {
      simplifyDPStep(points, (index as number), last, sqTolerance, simplified);
    }
  }
};

// simplification using Ramer-Douglas-Peucker algorithm
const simplifyDouglasPeucker = (points, sqTolerance) => {
  const last = points.length - 1;

  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);

  return simplified;
};

// both algorithms combined for awesome performance
export default (
  points,
  tolerance,
  highestQuality: <fim_suffix>,
) => {
  if (points.length <= 2) return points;

  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
  let simplified = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  simplified = simplifyDouglasPeucker(points, sqTolerance);
  return simplified;
};
<fim_middle>",correct,2557
boolean,boolean,3222146aea50ffa11b775aeb30ffdf9bd48830ed,"<fim_prefix>export type ZipRange = {
    from: number,
    to: number,
}

export type ZipCode = {
    list: ZipRange[],
    excludeList: ZipRange[],
}

function decodeZipList(buffer, length) {
    let result: ZipRange[] = [];
    let off = 0;
    let prevFlag = 0;
    while (off < length) {
        if (buffer[off] & 0x80) {
            let digits = buffer[off] & 0x7f;
            off++;
            let flag = buffer[off] >> 4;
            let a = buffer[off] & 0xf;
            off++;
            let b = buffer[off] >> 4;
            let c = buffer[off] & 0xf;
            off++;
            let d = buffer[off] >> 4;
            let e = buffer[off] & 0xf;
            let digitList = [a, b, c, d, e];
            off++;
            switch (flag) {
                // 3digit list
                case 0x8:
                    for (const d of digitList) {
                        if (d >= 10 && d <= 0xe) {
                            throw new Error(""d >= 10 && d <= 0xe 3digit list"");
                        }
                        if (d === 0xf) {
                            continue;
                        }
                        result.push({ from: (digits * 10 + d) * 10000, to: (digits * 10 + d + 1) * 10000 - 1});
                    }
                    break;
                // 3digit range
                case 0x9:
                    if (a !== 0xf) {
                        throw new Error(""a !== 0xf 3digit range"");
                    }
                    if (b === 0xf || c === 0xf) {
                        throw new Error(""b === 0xf || c === 0xf 3digit range"");
                    }
                    result.push({ from: (digits * 10 + b) * 10000, to: (digits * 10 + c + 1) * 10000 - 1 });
                    if (d === 0xf || e === 0xf) {
                    } else if (d !== 0xf && e !== 0xf) {
                        result.push({ from: (digits * 10 + d) * 10000, to: (digits * 10 + e + 1) * 10000 - 1 });
                    } else {
                        throw new Error(""not allowed d, e 3digit range"");
                    }
                    break;
                // 5digit list
                case 0xA:
                    if (a === 0xf || b === 0xf || c === 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf 5digit list"");
                    }
                    result.push({ from: (digits * 1000 + a * 100 + b * 10 + c) * 100, to: (digits * 1000 + a * 100 + b * 10 + c + 1) * 100 - 1 });
                    if (d === 0xf || e === 0xf) {
                    } else if (d !== 0xf && e !== 0xf) {
                        result.push({ from: (digits * 1000 + a * 100 + d * 10 + e) * 100, to: (digits * 1000 + a * 100 + d * 10 + e + 1) * 100 - 1});
                    } else {
                        throw new Error(""not allowed d, e 5digit range"");
                    }
                    break;
                // 5digit range From
                case 0xB:
                    if (a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf 5digit range"");
                    }
                    result.push({ from: (digits * 1000 + a * 100 + b * 10 + c) * 100, to: (digits * 1000 + a * 100 + b * 10 + c) * 100 });
                    break;
                // 5digit range To
                case 0xC:
                    if (prevFlag !== 0xB) {
                        throw new Error(""prevFlag !== 0xB 5digit range"");
                    }
                    if (a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf 5digit range"");
                    }
                    result[result.length - 1].to = (digits * 1000 + a * 100 + b * 10 + c + 1) * 100 - 1;
                    break;
                // 7digit range From
                case 0xD:
                case 0xF:
                    if (a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf 7digit range/list"");
                    }
                    result.push({ from: digits * 100000 + a * 10000 + b * 1000 + c * 100 + d * 10 + e, to: digits * 100000 + a * 10000 + b * 1000 + c * 100 + d * 10 + e });
                    break;
                // 7digit range To
                case 0xE:
                    if (prevFlag !== 0xD) {
                        throw new Error(""prevFlag !== 0xD 7digit range"");
                    }
                    if (a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf 7digit range"");
                    }
                    result[result.length - 1].to = digits * 100000 + a * 10000 + b * 1000 + c * 100 + d * 10 + e;
                    break;
            }
            prevFlag = flag;
        } else {
            let from = buffer[off] & 0x7f;
            off++;
            let to = buffer[off] & 0x7f;
            result.push({ from: from * 100000, to: (to + 1) * 100000 - 1 });
            off++;
            if (buffer[off] & 0x80) {
                let from2 = buffer[off] & 0x7f;
                off++;
                let to2 = buffer[off] & 0x7f;
                off++;
                result.push({ from: from2 * 100000, to: (to2 + 1) * 100000 - 1 });
            } else {
                off += 2;
            }
        }
    }
    return result;
}

export function decodeZipCode(buffer) {
    let length = buffer[0];
    let excludeListLength = buffer[1];
    return {
        excludeList: decodeZipList(buffer.slice(2), excludeListLength),
        list: decodeZipList(buffer.slice(2 + excludeListLength, 1 + length), length - 1 - excludeListLength)
    };
}

function zipRangeInclude(zipRange, compared) {
    return zipRange.some(zip => zip.from <= compared && zip.to >= compared);
}

export function zipCodeInclude(zipCode, compared): <fim_suffix> {
    return zipRangeInclude(zipCode.list, compared) && !zipRangeInclude(zipCode.excludeList, compared);
}
<fim_middle>",correct,2579
boolean,boolean,3222146aea50ffa11b775aeb30ffdf9bd48830ed,"<fim_prefix>export type ZipRange = {
    from: number,
    to: number,
}

export type ZipCode = {
    list: ZipRange[],
    excludeList: ZipRange[],
}

function decodeZipList(buffer, length) {
    let result: ZipRange[] = [];
    let off = 0;
    let prevFlag = 0;
    while (off < length) {
        if (buffer[off] & 0x80) {
            let digits = buffer[off] & 0x7f;
            off++;
            let flag = buffer[off] >> 4;
            let a = buffer[off] & 0xf;
            off++;
            let b = buffer[off] >> 4;
            let c = buffer[off] & 0xf;
            off++;
            let d = buffer[off] >> 4;
            let e = buffer[off] & 0xf;
            let digitList = [a, b, c, d, e];
            off++;
            switch (flag) {
                // 3digit list
                case 0x8:
                    for (const d of digitList) {
                        if (d >= 10 && d <= 0xe) {
                            throw new Error(""d >= 10 && d <= 0xe 3digit list"");
                        }
                        if (d === 0xf) {
                            continue;
                        }
                        result.push({ from: (digits * 10 + d) * 10000, to: (digits * 10 + d + 1) * 10000 - 1});
                    }
                    break;
                // 3digit range
                case 0x9:
                    if (a !== 0xf) {
                        throw new Error(""a !== 0xf 3digit range"");
                    }
                    if (b === 0xf || c === 0xf) {
                        throw new Error(""b === 0xf || c === 0xf 3digit range"");
                    }
                    result.push({ from: (digits * 10 + b) * 10000, to: (digits * 10 + c + 1) * 10000 - 1 });
                    if (d === 0xf || e === 0xf) {
                    } else if (d !== 0xf && e !== 0xf) {
                        result.push({ from: (digits * 10 + d) * 10000, to: (digits * 10 + e + 1) * 10000 - 1 });
                    } else {
                        throw new Error(""not allowed d, e 3digit range"");
                    }
                    break;
                // 5digit list
                case 0xA:
                    if (a === 0xf || b === 0xf || c === 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf 5digit list"");
                    }
                    result.push({ from: (digits * 1000 + a * 100 + b * 10 + c) * 100, to: (digits * 1000 + a * 100 + b * 10 + c + 1) * 100 - 1 });
                    if (d === 0xf || e === 0xf) {
                    } else if (d !== 0xf && e !== 0xf) {
                        result.push({ from: (digits * 1000 + a * 100 + d * 10 + e) * 100, to: (digits * 1000 + a * 100 + d * 10 + e + 1) * 100 - 1});
                    } else {
                        throw new Error(""not allowed d, e 5digit range"");
                    }
                    break;
                // 5digit range From
                case 0xB:
                    if (a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf 5digit range"");
                    }
                    result.push({ from: (digits * 1000 + a * 100 + b * 10 + c) * 100, to: (digits * 1000 + a * 100 + b * 10 + c) * 100 });
                    break;
                // 5digit range To
                case 0xC:
                    if (prevFlag !== 0xB) {
                        throw new Error(""prevFlag !== 0xB 5digit range"");
                    }
                    if (a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d !== 0xf || e !== 0xf 5digit range"");
                    }
                    result[result.length - 1].to = (digits * 1000 + a * 100 + b * 10 + c + 1) * 100 - 1;
                    break;
                // 7digit range From
                case 0xD:
                case 0xF:
                    if (a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf 7digit range/list"");
                    }
                    result.push({ from: digits * 100000 + a * 10000 + b * 1000 + c * 100 + d * 10 + e, to: digits * 100000 + a * 10000 + b * 1000 + c * 100 + d * 10 + e });
                    break;
                // 7digit range To
                case 0xE:
                    if (prevFlag !== 0xD) {
                        throw new Error(""prevFlag !== 0xD 7digit range"");
                    }
                    if (a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf) {
                        throw new Error(""a === 0xf || b === 0xf || c === 0xf || d === 0xf || e === 0xf 7digit range"");
                    }
                    result[result.length - 1].to = digits * 100000 + a * 10000 + b * 1000 + c * 100 + d * 10 + e;
                    break;
            }
            prevFlag = flag;
        } else {
            let from = buffer[off] & 0x7f;
            off++;
            let to = buffer[off] & 0x7f;
            result.push({ from: from * 100000, to: (to + 1) * 100000 - 1 });
            off++;
            if (buffer[off] & 0x80) {
                let from2 = buffer[off] & 0x7f;
                off++;
                let to2 = buffer[off] & 0x7f;
                off++;
                result.push({ from: from2 * 100000, to: (to2 + 1) * 100000 - 1 });
            } else {
                off += 2;
            }
        }
    }
    return result;
}

export function decodeZipCode(buffer) {
    let length = buffer[0];
    let excludeListLength = buffer[1];
    return {
        excludeList: decodeZipList(buffer.slice(2), excludeListLength),
        list: decodeZipList(buffer.slice(2 + excludeListLength, 1 + length), length - 1 - excludeListLength)
    };
}

function zipRangeInclude(zipRange, compared): <fim_suffix> {
    return zipRange.some(zip => zip.from <= compared && zip.to >= compared);
}

export function zipCodeInclude(zipCode, compared) {
    return zipRangeInclude(zipCode.list, compared) && !zipRangeInclude(zipCode.excludeList, compared);
}
<fim_middle>",correct,2582
boolean,boolean,784e0b27e79a2fe98c745e477d0f8c518b8f59ac,"<fim_prefix>export const Kind = 'Core#WebApi';

/**
 * @deprecated This was used in the old version of ARC.
 */
export interface ILegacyRestApi {
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   */
  data: string;
  /**
   * The AMF parser version used to parse this document.
   */
  amfVersion?: string;
}

export interface IWebApi {
  kind: typeof Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path: string;
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;
}

export class WebApi {
  kind = Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId = '';
  /**
   * Version name of the API
   */
  version = '';
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path = '';
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;

  /**
   * Checks whether the object represents a legacy way of storing the web API data.
   */
  get isLegacy() {
    return !!this.data;
  }

  /**
   * Checks whether the object is the legacy schema for web API (formally known as RestAPI)
   */
  static isLegacy(api): <fim_suffix> {
    const legacy = api as ILegacyRestApi;
    if (legacy.data) {
      return true;
    }
    return false;
  }

  static fromLegacy(api) {
    const { version, amfVersion, data, indexId } = api;
    const init: IWebApi = {
      kind: Kind,
      version,
      path: '',
      indexId,
    };
    if (amfVersion) {
      init.amfVersion = amfVersion;
    }
    if (data) {
      init.data = data;
    }
    return new WebApi(init);
  }

  /**
   * Creates an identifier of this web API object.
   * @param indexId The id of the corresponding index item. This is usually the base URI of the API.
   * @param version The version name of this web API.
   * @returns The unique and reversible identifier of this web API.
   */
  static createId(indexId, version) {
    return `${indexId}|${version}`;
  }

  constructor(input?) {
    let init: IWebApi;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        version: '',
        path: '',
        indexId: '',
      };
    }
    this.new(init);
  }

  new(init) {
    const { version, data, amfVersion, path, main, mime, vendor, indexId } = init;
    if (indexId) {
      this.indexId = indexId;
    } else {
      this.indexId = '';
    }
    if (version) {
      this.version = version;
    } else {
      this.version = '';
    }
    if (data) {
      this.data = data;
    } else {
      this.data = undefined;
    }
    if (amfVersion) {
      this.amfVersion = amfVersion;
    } else {
      this.amfVersion = undefined;
    }
    if (path) {
      this.path = path;
    } else {
      this.path = '';
    }
    if (main) {
      this.main = main;
    } else {
      this.main = undefined
    }
    if (mime) {
      this.mime = mime;
    } else {
      this.mime = mime;
    }
    if (vendor) {
      this.vendor = vendor;
    } else {
      this.vendor = undefined;
    }
  }

  toJSON() {
    const result: IWebApi = {
      kind: Kind,
      version: this.version,
      path: this.path,
      indexId: this.indexId,
    };
    if (this.data) {
      result.data = this.data;
    }
    if (this.amfVersion) {
      result.amfVersion = this.amfVersion;
    }
    if (this.main) {
      result.main = this.main;
    }
    if (this.mime) {
      result.mime = this.mime;
    }
    if (this.vendor) {
      result.vendor = this.vendor;
    }
    return result;
  }
}
<fim_middle>",correct,2779
boolean,boolean,784e0b27e79a2fe98c745e477d0f8c518b8f59ac,"<fim_prefix>export const Kind = 'Core#WebApi';

/**
 * @deprecated This was used in the old version of ARC.
 */
export interface ILegacyRestApi {
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   */
  data: string;
  /**
   * The AMF parser version used to parse this document.
   */
  amfVersion?: string;
}

export interface IWebApi {
  kind: typeof Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId: string;
  /**
   * Version name of the API
   */
  version: string;
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path: string;
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;
}

export class WebApi {
  kind = Kind;
  /**
   * The ID of the index item that this entry refers to.
   */
  indexId = '';
  /**
   * Version name of the API
   */
  version = '';
  /**
   * API data model. It is the output of the AMF parser run on the API.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 uses the `path` with the location of the API project.
   */
  data?: string;
  /**
   * The AMF parser version used to parse this document.
   * This is left for compatibility.
   * @deprecated This was used in the old version of ARC. v18 does not use this information.
   */
  amfVersion?: string;
  /**
   * The location of the API project. This can be any URI to get the sources of the API project.
   */
  path = '';
  /**
   * Optional information to point to the API's main file.
   */
  main?: string;
  /**
   * The API format's media type.
   */
  mime?: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor?: string;

  /**
   * Checks whether the object represents a legacy way of storing the web API data.
   */
  get isLegacy(): <fim_suffix> {
    return !!this.data;
  }

  /**
   * Checks whether the object is the legacy schema for web API (formally known as RestAPI)
   */
  static isLegacy(api) {
    const legacy = api as ILegacyRestApi;
    if (legacy.data) {
      return true;
    }
    return false;
  }

  static fromLegacy(api) {
    const { version, amfVersion, data, indexId } = api;
    const init: IWebApi = {
      kind: Kind,
      version,
      path: '',
      indexId,
    };
    if (amfVersion) {
      init.amfVersion = amfVersion;
    }
    if (data) {
      init.data = data;
    }
    return new WebApi(init);
  }

  /**
   * Creates an identifier of this web API object.
   * @param indexId The id of the corresponding index item. This is usually the base URI of the API.
   * @param version The version name of this web API.
   * @returns The unique and reversible identifier of this web API.
   */
  static createId(indexId, version) {
    return `${indexId}|${version}`;
  }

  constructor(input?) {
    let init: IWebApi;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        version: '',
        path: '',
        indexId: '',
      };
    }
    this.new(init);
  }

  new(init) {
    const { version, data, amfVersion, path, main, mime, vendor, indexId } = init;
    if (indexId) {
      this.indexId = indexId;
    } else {
      this.indexId = '';
    }
    if (version) {
      this.version = version;
    } else {
      this.version = '';
    }
    if (data) {
      this.data = data;
    } else {
      this.data = undefined;
    }
    if (amfVersion) {
      this.amfVersion = amfVersion;
    } else {
      this.amfVersion = undefined;
    }
    if (path) {
      this.path = path;
    } else {
      this.path = '';
    }
    if (main) {
      this.main = main;
    } else {
      this.main = undefined
    }
    if (mime) {
      this.mime = mime;
    } else {
      this.mime = mime;
    }
    if (vendor) {
      this.vendor = vendor;
    } else {
      this.vendor = undefined;
    }
  }

  toJSON() {
    const result: IWebApi = {
      kind: Kind,
      version: this.version,
      path: this.path,
      indexId: this.indexId,
    };
    if (this.data) {
      result.data = this.data;
    }
    if (this.amfVersion) {
      result.amfVersion = this.amfVersion;
    }
    if (this.main) {
      result.main = this.main;
    }
    if (this.mime) {
      result.mime = this.mime;
    }
    if (this.vendor) {
      result.vendor = this.vendor;
    }
    return result;
  }
}
<fim_middle>",correct,2781
boolean,boolean,78800330af23ddd8c511063991a98a67b979c2cb,"<fim_prefix>export type chooseFoodCategory =
  | 'chicken'
  | 'pork'
  | 'beef'
  | 'minced'
  | 'salmon'
  | 'pike'
  | 'mackerel'
  | 'yellowtail'
  | 'miso'
  | 'ton'
  | 'vegetable'
  | 'vermicelli';

export type fetchData = {
  result: fetchFood[];
};

export type fetchFood = {
  foodImageUrl: string;
  mediumImageUrl: string;
  nickname: string;
  pickup: number;
  rank: string;
  recipeCost: string;
  recipeDescription: string;
  recipeId: number;
  recipeIndication: string;
  recipeMaterial: string[];
  recipePublishday: string;
  recipeTitle: string;
  recipeUrl: string;
  shop: number;
  smallImageUrl: string;
};

export type dataId =
  | '0,10-277'
  | '0,10-276'
  | '0,10-275'
  | '0,10-278'
  | '0,11-70'
  | '0,11-75'
  | '0,11-72'
  | '0,11-74'
  | '0,17-159'
  | '0,17-161'
  | '0,17-169'
  | '0,17-164-1369'
  | '1,10-277'
  | '1,10-276'
  | '1,10-275'
  | '1,10-278'
  | '1,11-70'
  | '1,11-75'
  | '1,11-72'
  | '1,11-74'
  | '1,17-159'
  | '1,17-161'
  | '1,17-169'
  | '1,17-164-1369'
  | '2,10-277'
  | '2,10-276'
  | '2,10-275'
  | '2,10-278'
  | '2,11-70'
  | '2,11-75'
  | '2,11-72'
  | '2,11-74'
  | '2,17-159'
  | '2,17-161'
  | '2,17-169'
  | '2,17-164-1369'
  | '3,10-277'
  | '3,10-276'
  | '3,10-275'
  | '3,10-278'
  | '3,11-70'
  | '3,11-75'
  | '3,11-72'
  | '3,11-74'
  | '3,17-159'
  | '3,17-161'
  | '3,17-169'
  | '3,17-164-1369';

export function throwIdFromCategory(category) {
  switch (category) {
    case 'chicken':
      return '10-277';
    case 'pork':
      return '10-276';
    case 'beef':
      return '10-275';
    case 'minced':
      return '10-278';
    case 'salmon':
      return '11-70';
    case 'pike':
      return '11-75';
    case 'mackerel':
      return '11-72';
    case 'yellowtail':
      return '11-74';
    case 'miso':
      return '17-159';
    case 'ton':
      return '17-161';
    case 'vegetable':
      return '17-169';
    case 'vermicelli':
      return '17-164-1369';
  }
}

export function throwNameFromCategory(category) {
  switch (category) {
    case 'meat':
      return '肉料理';
    case 'fish':
      return '魚料理';
    case 'soup':
      return 'スープ';
    case 'chicken':
      return '鶏肉料理';
    case 'pork':
      return '豚肉料理';
    case 'beef':
      return '牛肉料理';
    case 'minced':
      return '挽き肉料理';
    case 'salmon':
      return '鮭';
    case 'pike':
      return '秋刀魚';
    case 'mackerel':
      return '鯖';
    case 'yellowtail':
      return '鰤';
    case 'miso':
      return '味噌汁';
    case 'ton':
      return '豚汁';
    case 'vegetable':
      return '野菜スープ';
    case 'vermicelli':
      return '春雨スープ';
  }
}

export function validateString(str): <fim_suffix> {
  const reg = new RegExp(/^[\u30a0-\u30ff\u3040-\u309f\u3005-\u3006\u30e0-\u9fcf]+$/);
  if (reg.test(str)) {
    return true;
  }
  return false;
}
<fim_middle>",correct,2782
boolean,boolean,cf0796b6a6d7cd2657a854a73c3e908fae288953,"<fim_prefix>declare global {
    export interface String {
        asDataUri();
        contains(str);
        endsWith(suffix);
        insert(str, index);
        padLeft(width, str?);
        padRight(width, str?);
        splitWithTail(separator, limit?);
        toKebabCase();
        trimEnd(char);
        trimStart(char);
    }

    export interface StringConstructor {
        isNullOrEmpty(str);
        isNullOrWhiteSpace(str);
        format(format, ...args);
        fromChar(ch, count);
    }
}

String.prototype.contains = function(it) {
    return this.indexOf(it) != -1;
};

String.prototype.padLeft = function(totalWidth, ch) {
    if (this.length < totalWidth) {
        return String.fromChar(ch || ' ', totalWidth - this.length) + this;
    }
    return this.substring(0, this.length);
};

String.prototype.padRight = function(totalWidth, ch?) {
    if (this.length < totalWidth) {
        return this + String.fromChar(ch || ' ', totalWidth - this.length);
    }
    return this.substring(0, this.length);
};

const trimStart = String.prototype.trimStart;
String.prototype.trimStart = <any>function(ch?) {
    if (!ch || !this.length)
        return trimStart.apply(this);

    ch = ch || ' ';
    var i = 0;
    for (; this.charAt(i) == ch && i < this.length; i++);
    return this.substring(i);
};

const trimEnd = String.prototype.trimEnd;
String.prototype.trimEnd = <any>function(ch?) {
    if (!ch || !this.length)
        return trimEnd.apply(this);

    ch = ch ? ch : ' ';
    var i = this.length - 1;
    for (; i >= 0 && this.charAt(i) == ch; i--);
    return this.substring(0, i + 1);
};

String.prototype.insert = function(str, index) {
    var length = this.length;

    if (index == length) {
        return this.substring(0, index) + str;
    }
    return this.substring(0, index) + str + this.substring(index, length);
};

String.prototype.asDataUri = function() {
    if (/^iVBOR/.test(this))
        return ""data:image/png;base64,"" + this;
    if (/^\/9j\//.test(this))
        return ""data:image/jpeg;base64,"" + this;
    if (/^R0lGOD/.test(this))
        return ""data:image/gif;base64,"" + this;
    if (/^Qk/.test(this))
        return ""data:image/bmp;base64,"" + this;
    if (/^PD94/.test(this))
        return ""data:image/svg+xml;base64,"" + this;

    return """";
};

String.prototype.toKebabCase = function() {
    if (!this || this === this.toLowerCase())
        return this;

    var _this = this;
    return Array.from(this as string).map(function(c, i) {
        var cLower = c.toLowerCase();
        if (c === cLower)
            return c;

        if (i === 0)
            return cLower;

        var cPrev = _this[i - 1];
        if (!/^[a-zA-Z]+$/.test(cPrev))
            return cLower;

        var cPrevLower = cPrev.toLowerCase();
        if (cPrev === cPrevLower)
            return ""-"" + cLower;

        if (i + 1 === _this.length)
            return cLower;

        var cNext = _this[i + 1];
        var cNextUpper = cNext.toUpperCase();
        if (cNext === cNextUpper)
            return cLower;

        return ""-"" + cLower;
    }).join("""");
}

String.prototype.splitWithTail = function(separator, limit?) {
    let pattern: RegExp, startIndex: number, m: RegExpExecArray;
    const parts: string[] = [];
    if (!limit)
        return this.split(separator);
    if (separator instanceof RegExp)
        pattern = new RegExp(separator.source, ""g"" + (separator.ignoreCase ? ""i"" : """") + (separator.multiline ? ""m"" : """"));
    else
        pattern = new RegExp(separator.replace(/([.*+?^${}()|\[\]\/\\])/g, ""\\$1""), ""g"");
    do {
        startIndex = pattern.lastIndex;
        if (m = pattern.exec(this)) {
            parts.push(this.substr(startIndex, m.index - startIndex));
        }
    } while (m && parts.length < limit - 1);
    parts.push(this.substr(pattern.lastIndex));
    return parts;
}

String.isNullOrEmpty = function(str) {
    return str == null || str.length == 0;
};
    
String.isNullOrWhiteSpace = function(str) {
    return str == null || !(/\S/.test(str));
};

const _formatRE = /(\{[^\}^\{]+\})/g;
const _format = function(format, values, useLocale: <fim_suffix>) {
    return format.replace(_formatRE,
        function (m) {
            var index = parseInt(m.substr(1), 10);
            var value = values[index];
            if (value == null)
                return '';
            if (value.format) {
                var formatSpec = null;
                var formatIndex = m.indexOf(':');
                if (formatIndex > 0) {
                    formatSpec = m.substring(formatIndex + 1, m.length - 1);
                }
                return useLocale ? value.localeFormat(formatSpec) : value.format(formatSpec);
            }
            else
                return useLocale ? (value.localeFormat ? value.localeFormat() : value.toLocaleString()) : value.toString();
        });
};

String.format = function(format, ...args) {
    return _format(format, args, /* useLocale */true);
};

String.fromChar = function(ch, count) {
    var s = ch;
    for (var i = 1; i < count; i++) {
        s += ch;
    }
    return s;
};

export default String;<fim_middle>",correct,2879
boolean,boolean,8debaa49041fffba960b6052b906718c2db42bf8,"<fim_prefix>interface FreeState {
    // consecutive_spoiler
    cs: number,
    // consecutive_code
    cc: number,
    // flags
    f: number,
    // position
    p: number,

    // prefixes that make it not free
    r: string[],
}

const INSIDE_CODE_BLOCK: number = 1 << 0;
const INSIDE_SPOILER: number = 1 << 1;
const INSIDE_INLINE_CODE: number = 1 << 2;
const INSIDE_ANY_CODE: number = INSIDE_CODE_BLOCK | INSIDE_INLINE_CODE;
const INSIDE_EMOTE: number = 1 << 3;
const ESCAPED: number = 1 << 4;

const DEFAULT_FREE_FLAGS: number = INSIDE_INLINE_CODE | INSIDE_SPOILER | INSIDE_INLINE_CODE;
const DEFAULT_PREFIXES: string[] = ['<', '\\', ':'];

export function create(prefixes = DEFAULT_PREFIXES) {
    return { cs: 0, cc: 0, f: 0, p: 0, r: prefixes };
}

const VALID_EMOTE_CHAR: RegExp = /[\w\-]/;

export function incr(self, input, new_position) {
    let c, i, { f, cc, cs, p } = self;

    input = input.slice(p, new_position);

    for(i = 0; i < input.length; i += 1) {
        if(f & ESCAPED) {
            f &= ~ESCAPED; continue;
        }

        c = input[i];

        if(c == '\\') {
            f |= ESCAPED; continue;
        }

        if(c == '`') {
            cc++;
        } else {
            // if this character is not part of a code token,
            // but there were two consecitive code tokens,
            // then it was probably a zero-length inline code span
            if(cc == 2 && !(f & INSIDE_CODE_BLOCK)) {
                f ^= INSIDE_INLINE_CODE;
            }

            cc = 0;
        }

        if(c == '|') {
            cs++;
        } else {
            cs = 0;
        }

        if(cc == 3) {
            // toggle code block flag
            f ^= INSIDE_CODE_BLOCK;

            // remove inline code flag
            f &= ~INSIDE_INLINE_CODE;
        } else {
            if(!(f & INSIDE_CODE_BLOCK)) {
                // if does not contain code block flag

                if(cc == 1) {
                    f ^= INSIDE_INLINE_CODE;
                }

                if(cs == 2) {
                    f ^= INSIDE_SPOILER;
                }
            }

            // if not in any code
            if(!(f & INSIDE_ANY_CODE)) {
                if(c == ':') {
                    f ^= INSIDE_EMOTE;
                } else if(!VALID_EMOTE_CHAR.test(c)) {
                    f &= ~INSIDE_EMOTE;
                }
            }
        }
    }

    self.p = new_position;
    self.f = f;
    self.cc = cc;
    self.cs = cs;
}

export function is_free(self, input, new_position, flags = DEFAULT_FREE_FLAGS) {
    // start of the string is trivially free
    if(new_position == 0) return true;

    // if the position is prefixed by escaped
    if(self.r.includes(input[new_position - 1])) return false;

    incr(self, input, new_position);

    // if the flags intersect
    if((self.f & flags) != 0) return false;

    return true;
}

export function is_free_simple(input, position, prefixes = DEFAULT_PREFIXES, flags = DEFAULT_FREE_FLAGS) {
    return is_free(create(prefixes), input, position, flags);
}

export function is_inside_code(input, position) {
    if(position == 0) return false;

    let f = create([]);

    incr(f, input, position);

    return !!(f.f & (INSIDE_INLINE_CODE | INSIDE_CODE_BLOCK));
}

export function is_inside_spoiler(input, position): <fim_suffix> {
    if(position == 0) return false;

    let f = create([]);
    incr(f, input, position);

    return !!(f.f & INSIDE_SPOILER);
}

export function emote_start(input, position) {
    let start = position;

    while(start > 0 && input[start] != ':') { start--; }

    let is_valid = /^:[\w\-]*$/.test(input.slice(start, position)) &&
        input.slice(0, position).match(/:/g)!.length % 2 == 1;

    return is_valid ? start : -1;
}
<fim_middle>",correct,3000
boolean,boolean,8debaa49041fffba960b6052b906718c2db42bf8,"<fim_prefix>interface FreeState {
    // consecutive_spoiler
    cs: number,
    // consecutive_code
    cc: number,
    // flags
    f: number,
    // position
    p: number,

    // prefixes that make it not free
    r: string[],
}

const INSIDE_CODE_BLOCK: number = 1 << 0;
const INSIDE_SPOILER: number = 1 << 1;
const INSIDE_INLINE_CODE: number = 1 << 2;
const INSIDE_ANY_CODE: number = INSIDE_CODE_BLOCK | INSIDE_INLINE_CODE;
const INSIDE_EMOTE: number = 1 << 3;
const ESCAPED: number = 1 << 4;

const DEFAULT_FREE_FLAGS: number = INSIDE_INLINE_CODE | INSIDE_SPOILER | INSIDE_INLINE_CODE;
const DEFAULT_PREFIXES: string[] = ['<', '\\', ':'];

export function create(prefixes = DEFAULT_PREFIXES) {
    return { cs: 0, cc: 0, f: 0, p: 0, r: prefixes };
}

const VALID_EMOTE_CHAR: RegExp = /[\w\-]/;

export function incr(self, input, new_position) {
    let c, i, { f, cc, cs, p } = self;

    input = input.slice(p, new_position);

    for(i = 0; i < input.length; i += 1) {
        if(f & ESCAPED) {
            f &= ~ESCAPED; continue;
        }

        c = input[i];

        if(c == '\\') {
            f |= ESCAPED; continue;
        }

        if(c == '`') {
            cc++;
        } else {
            // if this character is not part of a code token,
            // but there were two consecitive code tokens,
            // then it was probably a zero-length inline code span
            if(cc == 2 && !(f & INSIDE_CODE_BLOCK)) {
                f ^= INSIDE_INLINE_CODE;
            }

            cc = 0;
        }

        if(c == '|') {
            cs++;
        } else {
            cs = 0;
        }

        if(cc == 3) {
            // toggle code block flag
            f ^= INSIDE_CODE_BLOCK;

            // remove inline code flag
            f &= ~INSIDE_INLINE_CODE;
        } else {
            if(!(f & INSIDE_CODE_BLOCK)) {
                // if does not contain code block flag

                if(cc == 1) {
                    f ^= INSIDE_INLINE_CODE;
                }

                if(cs == 2) {
                    f ^= INSIDE_SPOILER;
                }
            }

            // if not in any code
            if(!(f & INSIDE_ANY_CODE)) {
                if(c == ':') {
                    f ^= INSIDE_EMOTE;
                } else if(!VALID_EMOTE_CHAR.test(c)) {
                    f &= ~INSIDE_EMOTE;
                }
            }
        }
    }

    self.p = new_position;
    self.f = f;
    self.cc = cc;
    self.cs = cs;
}

export function is_free(self, input, new_position, flags = DEFAULT_FREE_FLAGS) {
    // start of the string is trivially free
    if(new_position == 0) return true;

    // if the position is prefixed by escaped
    if(self.r.includes(input[new_position - 1])) return false;

    incr(self, input, new_position);

    // if the flags intersect
    if((self.f & flags) != 0) return false;

    return true;
}

export function is_free_simple(input, position, prefixes = DEFAULT_PREFIXES, flags = DEFAULT_FREE_FLAGS) {
    return is_free(create(prefixes), input, position, flags);
}

export function is_inside_code(input, position): <fim_suffix> {
    if(position == 0) return false;

    let f = create([]);

    incr(f, input, position);

    return !!(f.f & (INSIDE_INLINE_CODE | INSIDE_CODE_BLOCK));
}

export function is_inside_spoiler(input, position) {
    if(position == 0) return false;

    let f = create([]);
    incr(f, input, position);

    return !!(f.f & INSIDE_SPOILER);
}

export function emote_start(input, position) {
    let start = position;

    while(start > 0 && input[start] != ':') { start--; }

    let is_valid = /^:[\w\-]*$/.test(input.slice(start, position)) &&
        input.slice(0, position).match(/:/g)!.length % 2 == 1;

    return is_valid ? start : -1;
}
<fim_middle>",correct,3003
boolean,boolean,8debaa49041fffba960b6052b906718c2db42bf8,"<fim_prefix>interface FreeState {
    // consecutive_spoiler
    cs: number,
    // consecutive_code
    cc: number,
    // flags
    f: number,
    // position
    p: number,

    // prefixes that make it not free
    r: string[],
}

const INSIDE_CODE_BLOCK: number = 1 << 0;
const INSIDE_SPOILER: number = 1 << 1;
const INSIDE_INLINE_CODE: number = 1 << 2;
const INSIDE_ANY_CODE: number = INSIDE_CODE_BLOCK | INSIDE_INLINE_CODE;
const INSIDE_EMOTE: number = 1 << 3;
const ESCAPED: number = 1 << 4;

const DEFAULT_FREE_FLAGS: number = INSIDE_INLINE_CODE | INSIDE_SPOILER | INSIDE_INLINE_CODE;
const DEFAULT_PREFIXES: string[] = ['<', '\\', ':'];

export function create(prefixes = DEFAULT_PREFIXES) {
    return { cs: 0, cc: 0, f: 0, p: 0, r: prefixes };
}

const VALID_EMOTE_CHAR: RegExp = /[\w\-]/;

export function incr(self, input, new_position) {
    let c, i, { f, cc, cs, p } = self;

    input = input.slice(p, new_position);

    for(i = 0; i < input.length; i += 1) {
        if(f & ESCAPED) {
            f &= ~ESCAPED; continue;
        }

        c = input[i];

        if(c == '\\') {
            f |= ESCAPED; continue;
        }

        if(c == '`') {
            cc++;
        } else {
            // if this character is not part of a code token,
            // but there were two consecitive code tokens,
            // then it was probably a zero-length inline code span
            if(cc == 2 && !(f & INSIDE_CODE_BLOCK)) {
                f ^= INSIDE_INLINE_CODE;
            }

            cc = 0;
        }

        if(c == '|') {
            cs++;
        } else {
            cs = 0;
        }

        if(cc == 3) {
            // toggle code block flag
            f ^= INSIDE_CODE_BLOCK;

            // remove inline code flag
            f &= ~INSIDE_INLINE_CODE;
        } else {
            if(!(f & INSIDE_CODE_BLOCK)) {
                // if does not contain code block flag

                if(cc == 1) {
                    f ^= INSIDE_INLINE_CODE;
                }

                if(cs == 2) {
                    f ^= INSIDE_SPOILER;
                }
            }

            // if not in any code
            if(!(f & INSIDE_ANY_CODE)) {
                if(c == ':') {
                    f ^= INSIDE_EMOTE;
                } else if(!VALID_EMOTE_CHAR.test(c)) {
                    f &= ~INSIDE_EMOTE;
                }
            }
        }
    }

    self.p = new_position;
    self.f = f;
    self.cc = cc;
    self.cs = cs;
}

export function is_free(self, input, new_position, flags = DEFAULT_FREE_FLAGS) {
    // start of the string is trivially free
    if(new_position == 0) return true;

    // if the position is prefixed by escaped
    if(self.r.includes(input[new_position - 1])) return false;

    incr(self, input, new_position);

    // if the flags intersect
    if((self.f & flags) != 0) return false;

    return true;
}

export function is_free_simple(input, position, prefixes = DEFAULT_PREFIXES, flags = DEFAULT_FREE_FLAGS): <fim_suffix> {
    return is_free(create(prefixes), input, position, flags);
}

export function is_inside_code(input, position) {
    if(position == 0) return false;

    let f = create([]);

    incr(f, input, position);

    return !!(f.f & (INSIDE_INLINE_CODE | INSIDE_CODE_BLOCK));
}

export function is_inside_spoiler(input, position) {
    if(position == 0) return false;

    let f = create([]);
    incr(f, input, position);

    return !!(f.f & INSIDE_SPOILER);
}

export function emote_start(input, position) {
    let start = position;

    while(start > 0 && input[start] != ':') { start--; }

    let is_valid = /^:[\w\-]*$/.test(input.slice(start, position)) &&
        input.slice(0, position).match(/:/g)!.length % 2 == 1;

    return is_valid ? start : -1;
}
<fim_middle>",correct,3006
boolean,boolean,8debaa49041fffba960b6052b906718c2db42bf8,"<fim_prefix>interface FreeState {
    // consecutive_spoiler
    cs: number,
    // consecutive_code
    cc: number,
    // flags
    f: number,
    // position
    p: number,

    // prefixes that make it not free
    r: string[],
}

const INSIDE_CODE_BLOCK: number = 1 << 0;
const INSIDE_SPOILER: number = 1 << 1;
const INSIDE_INLINE_CODE: number = 1 << 2;
const INSIDE_ANY_CODE: number = INSIDE_CODE_BLOCK | INSIDE_INLINE_CODE;
const INSIDE_EMOTE: number = 1 << 3;
const ESCAPED: number = 1 << 4;

const DEFAULT_FREE_FLAGS: number = INSIDE_INLINE_CODE | INSIDE_SPOILER | INSIDE_INLINE_CODE;
const DEFAULT_PREFIXES: string[] = ['<', '\\', ':'];

export function create(prefixes = DEFAULT_PREFIXES) {
    return { cs: 0, cc: 0, f: 0, p: 0, r: prefixes };
}

const VALID_EMOTE_CHAR: RegExp = /[\w\-]/;

export function incr(self, input, new_position) {
    let c, i, { f, cc, cs, p } = self;

    input = input.slice(p, new_position);

    for(i = 0; i < input.length; i += 1) {
        if(f & ESCAPED) {
            f &= ~ESCAPED; continue;
        }

        c = input[i];

        if(c == '\\') {
            f |= ESCAPED; continue;
        }

        if(c == '`') {
            cc++;
        } else {
            // if this character is not part of a code token,
            // but there were two consecitive code tokens,
            // then it was probably a zero-length inline code span
            if(cc == 2 && !(f & INSIDE_CODE_BLOCK)) {
                f ^= INSIDE_INLINE_CODE;
            }

            cc = 0;
        }

        if(c == '|') {
            cs++;
        } else {
            cs = 0;
        }

        if(cc == 3) {
            // toggle code block flag
            f ^= INSIDE_CODE_BLOCK;

            // remove inline code flag
            f &= ~INSIDE_INLINE_CODE;
        } else {
            if(!(f & INSIDE_CODE_BLOCK)) {
                // if does not contain code block flag

                if(cc == 1) {
                    f ^= INSIDE_INLINE_CODE;
                }

                if(cs == 2) {
                    f ^= INSIDE_SPOILER;
                }
            }

            // if not in any code
            if(!(f & INSIDE_ANY_CODE)) {
                if(c == ':') {
                    f ^= INSIDE_EMOTE;
                } else if(!VALID_EMOTE_CHAR.test(c)) {
                    f &= ~INSIDE_EMOTE;
                }
            }
        }
    }

    self.p = new_position;
    self.f = f;
    self.cc = cc;
    self.cs = cs;
}

export function is_free(self, input, new_position, flags = DEFAULT_FREE_FLAGS): <fim_suffix> {
    // start of the string is trivially free
    if(new_position == 0) return true;

    // if the position is prefixed by escaped
    if(self.r.includes(input[new_position - 1])) return false;

    incr(self, input, new_position);

    // if the flags intersect
    if((self.f & flags) != 0) return false;

    return true;
}

export function is_free_simple(input, position, prefixes = DEFAULT_PREFIXES, flags = DEFAULT_FREE_FLAGS) {
    return is_free(create(prefixes), input, position, flags);
}

export function is_inside_code(input, position) {
    if(position == 0) return false;

    let f = create([]);

    incr(f, input, position);

    return !!(f.f & (INSIDE_INLINE_CODE | INSIDE_CODE_BLOCK));
}

export function is_inside_spoiler(input, position) {
    if(position == 0) return false;

    let f = create([]);
    incr(f, input, position);

    return !!(f.f & INSIDE_SPOILER);
}

export function emote_start(input, position) {
    let start = position;

    while(start > 0 && input[start] != ':') { start--; }

    let is_valid = /^:[\w\-]*$/.test(input.slice(start, position)) &&
        input.slice(0, position).match(/:/g)!.length % 2 == 1;

    return is_valid ? start : -1;
}
<fim_middle>",correct,3011
boolean,boolean,85f3bc6b4d2cdd76d832d0fd3f0c3c3a8efc8d13,"<fim_prefix>// A subset of https://en.wikipedia.org/wiki/ISO_8601

/**
 * Years are represented from the gregorian calendar only
 * as 0000 to 9999. (If anyone has to worry about after 9999
 * with this code, I am deeply sorry.) Technically 0000 -
 * 1582 are not allowed by the standard except by mutual
 * agreement between parties. This is explicitly forced
 * when validating in order to ensure we are only working
 * with data browsers can reasonably parse and get correct.
 */
const yearPattern = /(?<year>158[3-9]|159\d|1[6-9]\d{2}|[2-9]\d{3})/;
/**
 * Months are always 2-digits in a non-index format.
 * This differs from JavaScripts Date constructor for
 * example where months are 0-11 rather than ISO's 1-12.
 */
const monthPattern = /(?<month>0[1-9]|1[0-2])/;
/**
 * Days are always 2 digits.
 * 01-09, 10-19, 20-29, 30-31.
 */
const dayPattern = /(?<day>0[1-9]|[12]\d|3[01])/;
/**
 * Hours are always 2 digits and in 24 hour time.
 * 01-19, 20-23
 */
const hourPattern = /(?<hour>[01]\d|2[0-3])/;
/**
 * Minutes are alays 2 digits.
 */
const minutePattern = /(?<minute>[0-5]\d)/;
/**
 * Seconds are always 2 digits.
 * 60 is used to represent leap seconds.
 */
const secondsPattern = /(?<seconds>([0-5]\d)|60)/;
/**
 * Millisesconds are always 3 digits.
 * From 000-999.
 * The period to denote them is required if MS are present.
 */
const millisecondsPattern = /(?:\.(?<milliseconds>\d{3}))?/;

/**
 * Timezone is complex and difficult to break down further
 * since it is all one group.
 * Gist of it is timezones have 4 possible modes:
 * * Positive Offset
 * * Negative Offset
 * * 'Z' string for UTC time (+00:00)
 * * Unqualified (not present) (meaning local time.)
 *
 * With subgroups this could be made to give specific
 * outputs like `positiveOffset`, `negativeOffset`, or
 * `utcString` for determining which timezone style is
 * present.
 * However, without a use-case this effort wasn't completed
 * only validated that it could be possible.
 *
 * This pattern technically allows a bit more than standards
 * currently have. Up to +14:45 and down to -12:45. Should
 * anyone care to correct this and make it more strict, go
 * ahead just add tests to prove it when you do.
 */
const fullTimeZonePattern = /(?<offset>([+]((0\d|1[0-3])(?::(00|15|30|45))?|14(?::00)?)|([-]((0\d|1[0-1])(?::(00|15|30|45))?|12(?::00)?)|Z))?)/;

/**
 * Pattern to determine if a full calendar date is present.
 */
const fullCalendarDatePattern = yearPattern.source +
    /-/.source +
    monthPattern.source +
    /-/.source +
    dayPattern.source;

/**
 * Pattern to validate a complete date and time string.
 */
const fullIso8601DateTimePattern = /^/.source +
    yearPattern.source +
    /-?/.source +
    monthPattern.source +
    /-?/.source +
    dayPattern.source +
    /T/.source +
    hourPattern.source +
    /:?/.source +
    minutePattern.source +
    /:?/.source +
    secondsPattern.source +
    millisecondsPattern.source +
    fullTimeZonePattern.source +
    /$/.source;

const iso8601Date = new RegExp(
    `^${fullCalendarDatePattern}$`,
);
const isIso8601DateTime = new RegExp(
    fullIso8601DateTimePattern,
);

export interface DateStructure {
  year: number;
  month: number;
  day: number;
}

export interface TimeStructure {
  hour: number;
  minute: number;
  seconds: number;
  milliseconds: number;
  offset: string | undefined;
}

export type DateTimeStructure = DateStructure &
    TimeStructure;

export const parseDateTimeString = function(value) {
  const {groups} = isIso8601DateTime.exec(value) || {};

  const parseWasUnsuccessful = groups === undefined;
  if (parseWasUnsuccessful === true) {
    throw new Error(
        'Invalid date and time string given to parse',
    );
  }

  const offset = groups.offset !== '' ?
      groups.offset :
      undefined;

  return {
    year: parseInt(
        groups.year,
        10,
    ),
    month: parseInt(
        groups.month,
        10,
    ),
    day: parseInt(
        groups.day,
        10,
    ),
    hour: parseInt(
        groups.hour,
        10,
    ),
    minute: parseInt(
        groups.minute,
        10,
    ),
    seconds: parseInt(
        groups.seconds,
        10,
    ),
    milliseconds: parseInt(
        groups.milliseconds,
        10,
    ),
    offset,
  };
};

export const isValidDate = function(value) {
  return iso8601Date.test(value);
};

export const isValidDateTime = function(value): <fim_suffix> {
  return isIso8601DateTime.test(value);
};

export const parseDateString = function(value) {
  const {groups} = iso8601Date.exec(value) || {};

  const parseWasUnsuccessful = groups === undefined;
  if (parseWasUnsuccessful === true) {
    throw new Error('Invalid date string given to parse');
  }

  return {
    year: parseInt(
        groups.year,
        10,
    ),
    month: parseInt(
        groups.month,
        10,
    ),
    day: parseInt(
        groups.day,
        10,
    ),
  };
};
<fim_middle>",correct,3030
boolean,boolean,85f3bc6b4d2cdd76d832d0fd3f0c3c3a8efc8d13,"<fim_prefix>// A subset of https://en.wikipedia.org/wiki/ISO_8601

/**
 * Years are represented from the gregorian calendar only
 * as 0000 to 9999. (If anyone has to worry about after 9999
 * with this code, I am deeply sorry.) Technically 0000 -
 * 1582 are not allowed by the standard except by mutual
 * agreement between parties. This is explicitly forced
 * when validating in order to ensure we are only working
 * with data browsers can reasonably parse and get correct.
 */
const yearPattern = /(?<year>158[3-9]|159\d|1[6-9]\d{2}|[2-9]\d{3})/;
/**
 * Months are always 2-digits in a non-index format.
 * This differs from JavaScripts Date constructor for
 * example where months are 0-11 rather than ISO's 1-12.
 */
const monthPattern = /(?<month>0[1-9]|1[0-2])/;
/**
 * Days are always 2 digits.
 * 01-09, 10-19, 20-29, 30-31.
 */
const dayPattern = /(?<day>0[1-9]|[12]\d|3[01])/;
/**
 * Hours are always 2 digits and in 24 hour time.
 * 01-19, 20-23
 */
const hourPattern = /(?<hour>[01]\d|2[0-3])/;
/**
 * Minutes are alays 2 digits.
 */
const minutePattern = /(?<minute>[0-5]\d)/;
/**
 * Seconds are always 2 digits.
 * 60 is used to represent leap seconds.
 */
const secondsPattern = /(?<seconds>([0-5]\d)|60)/;
/**
 * Millisesconds are always 3 digits.
 * From 000-999.
 * The period to denote them is required if MS are present.
 */
const millisecondsPattern = /(?:\.(?<milliseconds>\d{3}))?/;

/**
 * Timezone is complex and difficult to break down further
 * since it is all one group.
 * Gist of it is timezones have 4 possible modes:
 * * Positive Offset
 * * Negative Offset
 * * 'Z' string for UTC time (+00:00)
 * * Unqualified (not present) (meaning local time.)
 *
 * With subgroups this could be made to give specific
 * outputs like `positiveOffset`, `negativeOffset`, or
 * `utcString` for determining which timezone style is
 * present.
 * However, without a use-case this effort wasn't completed
 * only validated that it could be possible.
 *
 * This pattern technically allows a bit more than standards
 * currently have. Up to +14:45 and down to -12:45. Should
 * anyone care to correct this and make it more strict, go
 * ahead just add tests to prove it when you do.
 */
const fullTimeZonePattern = /(?<offset>([+]((0\d|1[0-3])(?::(00|15|30|45))?|14(?::00)?)|([-]((0\d|1[0-1])(?::(00|15|30|45))?|12(?::00)?)|Z))?)/;

/**
 * Pattern to determine if a full calendar date is present.
 */
const fullCalendarDatePattern = yearPattern.source +
    /-/.source +
    monthPattern.source +
    /-/.source +
    dayPattern.source;

/**
 * Pattern to validate a complete date and time string.
 */
const fullIso8601DateTimePattern = /^/.source +
    yearPattern.source +
    /-?/.source +
    monthPattern.source +
    /-?/.source +
    dayPattern.source +
    /T/.source +
    hourPattern.source +
    /:?/.source +
    minutePattern.source +
    /:?/.source +
    secondsPattern.source +
    millisecondsPattern.source +
    fullTimeZonePattern.source +
    /$/.source;

const iso8601Date = new RegExp(
    `^${fullCalendarDatePattern}$`,
);
const isIso8601DateTime = new RegExp(
    fullIso8601DateTimePattern,
);

export interface DateStructure {
  year: number;
  month: number;
  day: number;
}

export interface TimeStructure {
  hour: number;
  minute: number;
  seconds: number;
  milliseconds: number;
  offset: string | undefined;
}

export type DateTimeStructure = DateStructure &
    TimeStructure;

export const parseDateTimeString = function(value) {
  const {groups} = isIso8601DateTime.exec(value) || {};

  const parseWasUnsuccessful = groups === undefined;
  if (parseWasUnsuccessful === true) {
    throw new Error(
        'Invalid date and time string given to parse',
    );
  }

  const offset = groups.offset !== '' ?
      groups.offset :
      undefined;

  return {
    year: parseInt(
        groups.year,
        10,
    ),
    month: parseInt(
        groups.month,
        10,
    ),
    day: parseInt(
        groups.day,
        10,
    ),
    hour: parseInt(
        groups.hour,
        10,
    ),
    minute: parseInt(
        groups.minute,
        10,
    ),
    seconds: parseInt(
        groups.seconds,
        10,
    ),
    milliseconds: parseInt(
        groups.milliseconds,
        10,
    ),
    offset,
  };
};

export const isValidDate = function(value): <fim_suffix> {
  return iso8601Date.test(value);
};

export const isValidDateTime = function(value) {
  return isIso8601DateTime.test(value);
};

export const parseDateString = function(value) {
  const {groups} = iso8601Date.exec(value) || {};

  const parseWasUnsuccessful = groups === undefined;
  if (parseWasUnsuccessful === true) {
    throw new Error('Invalid date string given to parse');
  }

  return {
    year: parseInt(
        groups.year,
        10,
    ),
    month: parseInt(
        groups.month,
        10,
    ),
    day: parseInt(
        groups.day,
        10,
    ),
  };
};
<fim_middle>",correct,3032
boolean,boolean,949a24da270d21c3254c7d63051b125d6fdaa38f,"<fim_prefix>/**
 * Copyright 2016 Jim Armstrong (www.algorithmist.net)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Repeating decimal to fraction
 *
 * @author Jim Armstrong (www.algorithmist.net)
 *
 * @version 1.0
 */

export type SimpleFraction =
{
  num: number,
  den: number
}

/**
 * AMYR Library, Typescript Math Toolkit.  Return a number with a simple repeating decimal, i.e. 1.454545 as a fraction
 * (optionally in reduced form).  Decimals in the repeating sequence may be presumed to be unique, i.e. 0.115115 would
 * be considered as 0.1111 as 1 is the first digit to repeat.  This likely done to keep problems tractable for students.
 *
 * Only numerator and denominator are returned.
 *
 * @param {string} n Number containing a repeating sequence after the decimal
 *
 * @param {boolean} toReduced True if result is to be converted into reduced form
 * @default false
 */
 export function repeatToFraction(n, toReduced: <fim_suffix> = false)
 {
   let result: SimpleFraction | null = null;

   // is there a repeating sequence after the decimal?
   const decimal: number = n.indexOf('.');
   if (decimal == -1) return result;

   const beforeDecimal = n.substring(0,decimal);
   const afterDecimal  = n.substring(decimal+1, n.length);
   let repeat: string  = getMinimalRepeating(afterDecimal);
   let shift           = 0;

   // do we need to skip forward to test for a repeating sequence some places after the decimal, like 5.0424242 or 2.13234234
   if (repeat == """")
   {
     let tmp: string   = afterDecimal;
     const len: number = afterDecimal.length;
     shift             = 1;

     while (tmp.length > 1)
     {
       tmp    = afterDecimal.substring(shift, len);
       repeat = getMinimalRepeating(tmp);

       if (repeat != """") break;

       shift++;
     }

     if (repeat === """") return result;
   }

   const digits: number = repeat.length + shift; // number of repeat and shift digits

   // if d = # repeat digits, s = shift factor, and x is the original number, then form the equation 10^(d+s)x -
   // (10^s)x = z, where z is  the numerical result of subtracting out the repeat sequence so, numerator = z and
   // denominator = 10^(d+s) - 10^s.  z needs to be symbolically computed since the repeat sequence may not be
   // repeated in sufficient length to get the correct result in floating-point computation.

   const s: number           = shift == 0 ? 1 : Math.pow(10,shift);
   let   denominator: number = Math.pow(10,digits) - s;
   const n1: string          = beforeDecimal + n.substr(decimal+1, digits);
   const n2: string          = beforeDecimal + n.substr(decimal+1, shift);
   let   numerator: number   = +n1 - +n2;

   // result in reduced form?
   if (toReduced)
   {
     const d: number = gcd(numerator, denominator);
     numerator       = Math.floor(numerator/d);
     denominator     = Math.floor(denominator/d);
   }

   result = {num: numerator, den: denominator};

   return result;
 }

 // utility function to extract the minimal (unique-digit) repeating sequence of at least length 1, i.e. '555555' is
 // a repeating sequence of '5', '545454' is a repeating sequence of '54, '123123123' is a repeating sequence of '123',
 // and '054605460546' is a repeating sequence of '0546'
 function getMinimalRepeating(test)
 {
   const result      = """";
   const len: number = test.length;

   if (len < 1) return result;

   let candidate: string;   // candidate sequence
   let lenC = 1;            // length of candidate sequence

   while (2*lenC <= len)
   {
     candidate  = test.substr(0,lenC);

     if (candidate == test.substr(lenC, lenC))
     {
       // candidate just got elected
       return candidate;
     }
     else
     {
       // try again
       lenC++;
     }
   }

   return result;
 }

/**
 *  Compute the greatest common divisor of two integers
 *
 * @param {number} n1 First integer
 *
 * @param {number} n2 Second integer
 */
 function gcd(n1, n2)
 {
   // since this is used internally to the problem at hand, a lot of error-checking is skipped

   // Euclid's algorithm - nothing new under the sun
   let a = Math.max(n1, n2);
   let b = Math.min(n1, n2);
   let r = 0;

   while( b > 0 )
   {
     r = a % b;
     a = b;
     b = r;
   }

   return Math.floor(a);
 }
<fim_middle>",correct,3148
boolean,boolean,2eea3cdf17dad8f71b37165f9ddfdf85c5088bdf,"<fim_prefix>// TODO check these comments:
// Assuming that polygon vertices are in clockwise order

type Vector = {
  x: number;
  y: number;
};

type Edge = {
  index: number;
  inwardNormal: Vector;
  outwardNormal: Vector;
  vertex1: Vector;
  vertex2: Vector;
};

type OffsetEdge = {
  vertex1: Vector;
  vertex2: Vector;
};

type Polygon = {
  edges: Edge[];
  offsetEdges?: OffsetEdge[];
  maxX: number;
  maxY: number;
  minX: number;
  minY: number;
  vertices: Vector[];
};

const TWO_PI = Math.PI * 2;

// See http://paulbourke.net/geometry/pointlineplane/
function inwardEdgeNormal(vertex1, vertex2) {
  // Assuming that polygon vertices are in clockwise order
  const dx = vertex2.x - vertex1.x;
  const dy = vertex2.y - vertex1.y;
  const edgeLength = Math.sqrt(dx * dx + dy * dy);

  return {
    x: -dy / edgeLength,
    y: dx / edgeLength,
  };
}

function outwardEdgeNormal(vertex1, vertex2) {
  var n = inwardEdgeNormal(vertex1, vertex2);

  return {
    x: -n.x,
    y: -n.y,
  };
}

function createPolygon(vertices) {
  const edges: Edge[] = [];
  let minX = vertices.length > 0 ? vertices[0].x : undefined;
  let minY = vertices.length > 0 ? vertices[0].y : undefined;
  let maxX = minX;
  let maxY = minY;

  for (let i = 0; i < vertices.length; i++) {
    const vertex1 = vertices[i];
    const vertex2 = vertices[(i + 1) % vertices.length];

    const outwardNormal = outwardEdgeNormal(vertex1, vertex2);

    const inwardNormal = inwardEdgeNormal(vertex1, vertex2);

    const edge: Edge = {
      vertex1,
      vertex2,
      index: i,
      outwardNormal,
      inwardNormal,
    };

    edges.push(edge);

    const x = vertices[i].x;
    const y = vertices[i].y;
    minX = Math.min(x, minX);
    minY = Math.min(y, minY);
    maxX = Math.max(x, maxX);
    maxY = Math.max(y, maxY);
  }

  const polygon: Polygon = {
    vertices,
    edges,
    minX,
    minY,
    maxX,
    maxY,
  };

  return polygon;
}

// based on http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/, edgeA => ""line a"", edgeB => ""line b""

function edgesIntersection(edgeA, edgeB) {
  const den =
    (edgeB.vertex2.y - edgeB.vertex1.y) * (edgeA.vertex2.x - edgeA.vertex1.x) -
    (edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex2.y - edgeA.vertex1.y);

  if (den == 0) {
    return null; // lines are parallel or coincident
  }

  const ua =
    ((edgeB.vertex2.x - edgeB.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeB.vertex2.y - edgeB.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  const ub =
    ((edgeA.vertex2.x - edgeA.vertex1.x) * (edgeA.vertex1.y - edgeB.vertex1.y) -
      (edgeA.vertex2.y - edgeA.vertex1.y) *
        (edgeA.vertex1.x - edgeB.vertex1.x)) /
    den;

  // Edges are not intersecting but the lines defined by them are
  const isIntersectionOutside = ua < 0 || ub < 0 || ua > 1 || ub > 1;

  return {
    x: edgeA.vertex1.x + ua * (edgeA.vertex2.x - edgeA.vertex1.x),
    y: edgeA.vertex1.y + ua * (edgeA.vertex2.y - edgeA.vertex1.y),
    isIntersectionOutside,
  };
}

function appendArc(
  arcSegments,
  vertices,
  center,
  radius,
  startVertex,
  endVertex,
  isPaddingBoundary: <fim_suffix>
) {
  var startAngle = Math.atan2(
    startVertex.y - center.y,
    startVertex.x - center.x
  );
  var endAngle = Math.atan2(endVertex.y - center.y, endVertex.x - center.x);

  if (startAngle < 0) {
    startAngle += TWO_PI;
  }

  if (endAngle < 0) {
    endAngle += TWO_PI;
  }

  const angle =
    startAngle > endAngle
      ? startAngle - endAngle
      : startAngle + TWO_PI - endAngle;
  const angleStep = (isPaddingBoundary ? -angle : TWO_PI - angle) / arcSegments;

  vertices.push(startVertex);

  for (let i = 1; i < arcSegments; ++i) {
    const angle = startAngle + angleStep * i;

    const vertex = {
      x: center.x + Math.cos(angle) * radius,
      y: center.y + Math.sin(angle) * radius,
    };

    vertices.push(vertex);
  }

  vertices.push(endVertex);
}

function createOffsetEdge(edge, dx, dy) {
  return {
    vertex1: {
      x: edge.vertex1.x + dx,
      y: edge.vertex1.y + dy,
    },
    vertex2: {
      x: edge.vertex2.x + dx,
      y: edge.vertex2.y + dy,
    },
  };
}

function createMarginPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.outwardNormal.x * offset;
    const dy = edge.outwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);

    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        false
      );
    }
  }

  const marginPolygon = createPolygon(vertices);

  marginPolygon.offsetEdges = offsetEdges;

  return marginPolygon;
}

function createPaddingPolygon(
  polygon,
  offset,
  arcSegments
) {
  const offsetEdges: OffsetEdge[] = [];

  for (let i = 0; i < polygon.edges.length; i++) {
    const edge = polygon.edges[i];
    const dx = edge.inwardNormal.x * offset;
    const dy = edge.inwardNormal.y * offset;
    offsetEdges.push(createOffsetEdge(edge, dx, dy));
  }

  const vertices: Vector[] = [];

  for (let i = 0; i < offsetEdges.length; i++) {
    const thisEdge = offsetEdges[i];
    const prevEdge =
      offsetEdges[(i + offsetEdges.length - 1) % offsetEdges.length];
    const vertex = edgesIntersection(prevEdge, thisEdge);
    if (vertex && (!vertex.isIntersectionOutside || arcSegments < 1)) {
      vertices.push({
        x: vertex.x,
        y: vertex.y,
      });
    } else {
      const arcCenter = polygon.edges[i].vertex1;

      appendArc(
        arcSegments,
        vertices,
        arcCenter,
        offset,
        prevEdge.vertex2,
        thisEdge.vertex1,
        true
      );
    }
  }

  const paddingPolygon = createPolygon(vertices);

  paddingPolygon.offsetEdges = offsetEdges;

  return paddingPolygon;
}

export default function offsetPolygon(
  vertices,
  offset,
  arcSegments = 0
) {
  const polygon = createPolygon(vertices);

  if (offset > 0) {
    return createMarginPolygon(polygon, offset, arcSegments).vertices;
  } else {
    return createPaddingPolygon(polygon, -offset, arcSegments).vertices;
  }
}
<fim_middle>",correct,3392
boolean,boolean,0545d587e8e888d3350df282e773e2290f9fb999,"<fim_prefix>export const WS = String.fromCharCode(29);
export const RS = ' ';
export const NL = '\n';
export const INDENT = String.fromCharCode(16);
export const UNINDENT = String.fromCharCode(17);

export interface SrcBuilderOptions {
  isPretty: boolean;
  isTypeScript: boolean;
  isModule: boolean;
  isJSX: boolean;
}

export class File {
  filename: string;
  imports = new Imports();
  options: SrcBuilderOptions;
  src: SrcBuilder;
  qwikModule: string;
  qrlPrefix: string;
  exports: Map<string, string> = new Map();

  get module() {
    return this.filename.substr(0, this.filename.lastIndexOf('.'));
  }
  get path() {
    return this.filename;
  }
  get contents() {
    return this.toString();
  }

  constructor(
    filename,
    options,
    qwikModule,
    qrlPrefix,
  ) {
    this.filename = filename;
    this.options = options;
    this.src = new SrcBuilder(this.options);
    this.qwikModule = qwikModule;
    this.qrlPrefix = qrlPrefix;
  }

  import(module, symbol) {
    return this.imports.get(module, symbol);
  }

  toQrl(symbol) {
    return string(this.qrlPrefix + this.module + '#' + symbol);
  }

  exportConst(name, value?) {
    this.exports.set(name, this.src.isModule ? name : 'exports.' + name);
    this.src.const(name, value, true);
  }

  toString() {
    const srcImports = new SrcBuilder(this.options);
    const imports = this.imports.imports;
    const modules = Array.from(imports.keys()).sort();
    modules.forEach((module) => {
      const symbolMap = imports.get(module)!;
      const symbols = Array.from(symbolMap.keys()).sort();
      if (removeExt(module) !== removeExt(this.qrlPrefix + this.filename)) {
        srcImports.import(module, symbols);
      }
    });
    srcImports.emit(NL);
    return srcImports.toString() + this.src.toString();
  }
}

function removeExt(filename) {
  const indx = filename.lastIndexOf('.');
  return indx == -1 ? filename : filename.substr(0, indx);
}

const spaces: string[] = [''];

export class SrcBuilder {
  isPretty: boolean;
  isTypeScript: boolean;
  isModule: boolean;
  isJSX: boolean;

  buf: string[] = [];
  wasLastNL = false;
  nestingDepth: number = 0;
  offset: number = 0;

  constructor(options) {
    this.isPretty = options.isPretty;
    this.isTypeScript = options.isTypeScript;
    this.isModule = options.isModule;
    this.isJSX = options.isJSX;
  }

  import(module, symbols) {
    if (this.isModule) {
      this.emit(
        'import',
        WS,
        '{',
        WS,
        symbols,
        WS,
        '}',
        WS,
        'from',
        WS,
        string(module),
        ';',
        NL,
      );
    } else {
      symbols.forEach((symbol) => {
        this.const(symbol, function(this) {
          this.emit(invoke('require', [string(module)]), '.', symbol);
        });
      });
    }
    this.emit(NL);
    return this;
  }

  emit(...values) {
    for (let i = 0; i < values.length; i++) {
      const value = values[i];
      if (typeof value == 'function') {
        value.call(this);
      } else if (value === null) {
        this.push('null');
      } else if (value === undefined) {
        this.push('undefined');
      } else if (typeof value == 'string') {
        this.push(value);
      } else if (typeof value == 'number') {
        this.push(String(value));
      } else if (typeof value == 'boolean') {
        this.push(String(value));
      } else if (Array.isArray(value)) {
        this.emitList(value);
      } else if (typeof value == 'object') {
        this.emit('{', NL, INDENT);
        let separator = false;
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            if (separator) {
              this.emit(',', NL);
            }
            this.emit(possiblyQuotePropertyName(key)).emit(':', WS, value[key]);
            separator = true;
          }
        }
        this.emit(NL, UNINDENT, '}');
      } else {
        throw new Error('Unexpected value: ' + value);
      }
    }
    return this;
  }

  private push(value) {
    if (value == UNINDENT) {
      this.nestingDepth--;
    } else if (value == INDENT) {
      this.nestingDepth++;
    } else {
      if (value == ')' || value == ':' || value == ']' || value == '}') {
        // clear last ',';
        let index = this.buf.length - 1;
        let ch: string = '';
        while (index > 1 && isWhitespace((ch = this.buf[index]))) {
          index--;
        }
        if (ch == ',') {
          this.buf[index] = '';
        }
      }
      if (this.isPretty && this.wasLastNL) {
        while (spaces.length <= this.nestingDepth) {
          spaces.push(spaces[spaces.length - 1] + '  ');
        }
        this.buf.push(spaces[this.nestingDepth]);
      }
      this.wasLastNL = value === NL;
      if (this.isPretty || (value !== WS && value !== NL)) {
        this.buf.push(value == WS ? ' ' : value);
      }
    }
  }

  emitList(values, sep = ',') {
    let separator = false;
    for (const value of values) {
      if (separator) {
        this.emit(sep, sep == ';' ? NL : WS);
      }
      this.emit(value);
      separator = true;
    }
    return this;
  }

  const(name, value?, exprt = false) {
    if (exprt) {
      this.emit(this.isModule ? 'export const ' : 'exports.');
    } else {
      this.emit('const ');
    }
    this.emit(name);
    if (value !== undefined) {
      this.emit(WS, '=', WS, value);
    }
    this.emit(';', NL);
    return this;
  }

  type(def) {
    if (this.isTypeScript) {
      this.emit(':', def);
    }
    return this;
  }

  typeParameters(typeParameters) {
    if (this.isTypeScript && typeParameters && typeParameters.length) {
      this.emit('<', typeParameters, '>');
    }
  }

  jsxBegin(
    symbol,
    props,
    bindings,
  ) {
    if (this.isJSX) {
      this.emit('<' + symbol);
    } else {
      this.emit(
        'h',
        '(',
        INDENT,
        NL,
        literalTagName(symbol),
        ',',
        NL,
        '{',
        NL,
        INDENT,
      );
    }
    let first = true;
    for (const key in props) {
      if (Object.prototype.hasOwnProperty.call(props, key) && !ignoreKey(key)) {
        if (first) {
          first = false;
          this.isJSX && this.emit(RS, INDENT, INDENT);
        } else {
          this.isJSX ? this.emit(NL) : this.emit(',', NL);
        }
        this.isJSX ? this.emit(key) : this.emit(possiblyQuotePropertyName(key));
        this.isJSX ? this.emit('=') : this.emit(':', WS);
        this.emit(string(props[key]));
      }
    }
    for (const key in bindings) {
      if (
        Object.prototype.hasOwnProperty.call(bindings, key) &&
        !ignoreKey(key)
      ) {
        if (first) {
          first = false;
          this.isJSX && this.emit(RS, INDENT, INDENT);
        } else {
          this.isJSX ? this.emit(NL) : this.emit(',', NL);
        }
        this.isJSX ? this.emit(key) : this.emit(possiblyQuotePropertyName(key));
        this.isJSX ? this.emit('={') : this.emit(':', WS);
        this.emit(bindings[key]);
        this.isJSX ? this.emit('}') : this.emit();
      }
    }
    if (!first) {
      this.isJSX && this.emit(UNINDENT, UNINDENT);
    }
    if (this.isJSX) {
      this.emit('>', INDENT, NL);
    } else {
      this.emit(NL, UNINDENT, '}', ',', NL);
    }
  }

  jsxEnd(symbol) {
    if (this.isJSX) {
      this.emit(UNINDENT, '</', symbol, '>', NL);
    } else {
      this.emit(UNINDENT, ')', ',', NL);
    }
  }

  jsxBeginFragment(symbol) {
    if (this.isJSX) {
      this.emit('<>', INDENT, NL);
    } else {
      this.emit('h', '(', symbol.name, ',', WS, 'null', ',', INDENT, NL);
    }
  }
  jsxEndFragment() {
    if (this.isJSX) {
      this.emit(UNINDENT, NL, '</>');
    } else {
      this.emit(UNINDENT, ')', NL);
    }
  }

  jsxTextBinding(exp) {
    if (this.isJSX) {
      this.emit('{', exp, '}', NL);
    } else {
      this.emit(exp, NL);
    }
  }

  toString() {
    return this.buf.join('');
  }
}

export class Symbol {
  name: string;
  constructor(name) {
    this.name = name;
  }
}

export class Imports {
  imports: Map<string, Map<string, Symbol>> = new Map();

  get(moduleName, symbolName) {
    let importSymbols = this.imports.get(moduleName);
    if (!importSymbols) {
      importSymbols = new Map();
      this.imports.set(moduleName, importSymbols);
    }
    let symbol = importSymbols.get(symbolName);
    if (!symbol) {
      symbol = new Symbol(symbolName);
      importSymbols.set(symbolName, symbol);
    }
    return symbol;
  }
}

function ignoreKey(key): <fim_suffix> {
  return (
    key.startsWith('$') ||
    key.startsWith('_') ||
    key == 'code' ||
    key == '' ||
    key == 'builder-id'
  );
}

export class Block {
  imports: Imports;
  constructor(imports) {
    this.imports = imports;
  }
}

function possiblyQuotePropertyName(key) {
  return /^\w[\w\d]*$/.test(key) ? key : JSON.stringify(key);
}

export function string(text) {
  return JSON.stringify(text);
}

export function invoke(
  symbol,
  args,
  typeParameters?,
) {
  return function(this) {
    this.emit(typeof symbol == 'string' ? symbol : symbol.name);
    this.typeParameters(typeParameters);
    this.emit('(', args, ')');
  };
}

export function arrowFnBlock(args, statements) {
  return function(this) {
    this.emit('(', args, ')', WS, '=>', WS);
    this.emit('{', INDENT, NL)
      .emitList(statements, ';')
      .emit(UNINDENT, NL, '}');
  };
}

export function arrowFnValue(args, expression) {
  return function(this) {
    this.emit('(', args, ')', WS, '=>', WS, expression);
  };
}

const LOWER_CASE = 'a'.charCodeAt(0) - 1;

function literalTagName(symbol) {
  if (
    typeof symbol == 'string' &&
    symbol.charCodeAt(0) > LOWER_CASE &&
    symbol.indexOf('.') === -1
  ) {
    return string(symbol);
  }
  return symbol;
}
function isWhitespace(ch) {
  return ch == '' || ch == RS || ch == NL;
}
<fim_middle>",correct,3460
boolean,boolean,0545d587e8e888d3350df282e773e2290f9fb999,"<fim_prefix>export const WS = String.fromCharCode(29);
export const RS = ' ';
export const NL = '\n';
export const INDENT = String.fromCharCode(16);
export const UNINDENT = String.fromCharCode(17);

export interface SrcBuilderOptions {
  isPretty: boolean;
  isTypeScript: boolean;
  isModule: boolean;
  isJSX: boolean;
}

export class File {
  filename: string;
  imports = new Imports();
  options: SrcBuilderOptions;
  src: SrcBuilder;
  qwikModule: string;
  qrlPrefix: string;
  exports: Map<string, string> = new Map();

  get module() {
    return this.filename.substr(0, this.filename.lastIndexOf('.'));
  }
  get path() {
    return this.filename;
  }
  get contents() {
    return this.toString();
  }

  constructor(
    filename,
    options,
    qwikModule,
    qrlPrefix,
  ) {
    this.filename = filename;
    this.options = options;
    this.src = new SrcBuilder(this.options);
    this.qwikModule = qwikModule;
    this.qrlPrefix = qrlPrefix;
  }

  import(module, symbol) {
    return this.imports.get(module, symbol);
  }

  toQrl(symbol) {
    return string(this.qrlPrefix + this.module + '#' + symbol);
  }

  exportConst(name, value?) {
    this.exports.set(name, this.src.isModule ? name : 'exports.' + name);
    this.src.const(name, value, true);
  }

  toString() {
    const srcImports = new SrcBuilder(this.options);
    const imports = this.imports.imports;
    const modules = Array.from(imports.keys()).sort();
    modules.forEach((module) => {
      const symbolMap = imports.get(module)!;
      const symbols = Array.from(symbolMap.keys()).sort();
      if (removeExt(module) !== removeExt(this.qrlPrefix + this.filename)) {
        srcImports.import(module, symbols);
      }
    });
    srcImports.emit(NL);
    return srcImports.toString() + this.src.toString();
  }
}

function removeExt(filename) {
  const indx = filename.lastIndexOf('.');
  return indx == -1 ? filename : filename.substr(0, indx);
}

const spaces: string[] = [''];

export class SrcBuilder {
  isPretty: boolean;
  isTypeScript: boolean;
  isModule: boolean;
  isJSX: boolean;

  buf: string[] = [];
  wasLastNL = false;
  nestingDepth: number = 0;
  offset: number = 0;

  constructor(options) {
    this.isPretty = options.isPretty;
    this.isTypeScript = options.isTypeScript;
    this.isModule = options.isModule;
    this.isJSX = options.isJSX;
  }

  import(module, symbols) {
    if (this.isModule) {
      this.emit(
        'import',
        WS,
        '{',
        WS,
        symbols,
        WS,
        '}',
        WS,
        'from',
        WS,
        string(module),
        ';',
        NL,
      );
    } else {
      symbols.forEach((symbol) => {
        this.const(symbol, function(this) {
          this.emit(invoke('require', [string(module)]), '.', symbol);
        });
      });
    }
    this.emit(NL);
    return this;
  }

  emit(...values) {
    for (let i = 0; i < values.length; i++) {
      const value = values[i];
      if (typeof value == 'function') {
        value.call(this);
      } else if (value === null) {
        this.push('null');
      } else if (value === undefined) {
        this.push('undefined');
      } else if (typeof value == 'string') {
        this.push(value);
      } else if (typeof value == 'number') {
        this.push(String(value));
      } else if (typeof value == 'boolean') {
        this.push(String(value));
      } else if (Array.isArray(value)) {
        this.emitList(value);
      } else if (typeof value == 'object') {
        this.emit('{', NL, INDENT);
        let separator = false;
        for (const key in value) {
          if (Object.prototype.hasOwnProperty.call(value, key)) {
            if (separator) {
              this.emit(',', NL);
            }
            this.emit(possiblyQuotePropertyName(key)).emit(':', WS, value[key]);
            separator = true;
          }
        }
        this.emit(NL, UNINDENT, '}');
      } else {
        throw new Error('Unexpected value: ' + value);
      }
    }
    return this;
  }

  private push(value) {
    if (value == UNINDENT) {
      this.nestingDepth--;
    } else if (value == INDENT) {
      this.nestingDepth++;
    } else {
      if (value == ')' || value == ':' || value == ']' || value == '}') {
        // clear last ',';
        let index = this.buf.length - 1;
        let ch: string = '';
        while (index > 1 && isWhitespace((ch = this.buf[index]))) {
          index--;
        }
        if (ch == ',') {
          this.buf[index] = '';
        }
      }
      if (this.isPretty && this.wasLastNL) {
        while (spaces.length <= this.nestingDepth) {
          spaces.push(spaces[spaces.length - 1] + '  ');
        }
        this.buf.push(spaces[this.nestingDepth]);
      }
      this.wasLastNL = value === NL;
      if (this.isPretty || (value !== WS && value !== NL)) {
        this.buf.push(value == WS ? ' ' : value);
      }
    }
  }

  emitList(values, sep = ',') {
    let separator = false;
    for (const value of values) {
      if (separator) {
        this.emit(sep, sep == ';' ? NL : WS);
      }
      this.emit(value);
      separator = true;
    }
    return this;
  }

  const(name, value?, exprt: <fim_suffix> = false) {
    if (exprt) {
      this.emit(this.isModule ? 'export const ' : 'exports.');
    } else {
      this.emit('const ');
    }
    this.emit(name);
    if (value !== undefined) {
      this.emit(WS, '=', WS, value);
    }
    this.emit(';', NL);
    return this;
  }

  type(def) {
    if (this.isTypeScript) {
      this.emit(':', def);
    }
    return this;
  }

  typeParameters(typeParameters) {
    if (this.isTypeScript && typeParameters && typeParameters.length) {
      this.emit('<', typeParameters, '>');
    }
  }

  jsxBegin(
    symbol,
    props,
    bindings,
  ) {
    if (this.isJSX) {
      this.emit('<' + symbol);
    } else {
      this.emit(
        'h',
        '(',
        INDENT,
        NL,
        literalTagName(symbol),
        ',',
        NL,
        '{',
        NL,
        INDENT,
      );
    }
    let first = true;
    for (const key in props) {
      if (Object.prototype.hasOwnProperty.call(props, key) && !ignoreKey(key)) {
        if (first) {
          first = false;
          this.isJSX && this.emit(RS, INDENT, INDENT);
        } else {
          this.isJSX ? this.emit(NL) : this.emit(',', NL);
        }
        this.isJSX ? this.emit(key) : this.emit(possiblyQuotePropertyName(key));
        this.isJSX ? this.emit('=') : this.emit(':', WS);
        this.emit(string(props[key]));
      }
    }
    for (const key in bindings) {
      if (
        Object.prototype.hasOwnProperty.call(bindings, key) &&
        !ignoreKey(key)
      ) {
        if (first) {
          first = false;
          this.isJSX && this.emit(RS, INDENT, INDENT);
        } else {
          this.isJSX ? this.emit(NL) : this.emit(',', NL);
        }
        this.isJSX ? this.emit(key) : this.emit(possiblyQuotePropertyName(key));
        this.isJSX ? this.emit('={') : this.emit(':', WS);
        this.emit(bindings[key]);
        this.isJSX ? this.emit('}') : this.emit();
      }
    }
    if (!first) {
      this.isJSX && this.emit(UNINDENT, UNINDENT);
    }
    if (this.isJSX) {
      this.emit('>', INDENT, NL);
    } else {
      this.emit(NL, UNINDENT, '}', ',', NL);
    }
  }

  jsxEnd(symbol) {
    if (this.isJSX) {
      this.emit(UNINDENT, '</', symbol, '>', NL);
    } else {
      this.emit(UNINDENT, ')', ',', NL);
    }
  }

  jsxBeginFragment(symbol) {
    if (this.isJSX) {
      this.emit('<>', INDENT, NL);
    } else {
      this.emit('h', '(', symbol.name, ',', WS, 'null', ',', INDENT, NL);
    }
  }
  jsxEndFragment() {
    if (this.isJSX) {
      this.emit(UNINDENT, NL, '</>');
    } else {
      this.emit(UNINDENT, ')', NL);
    }
  }

  jsxTextBinding(exp) {
    if (this.isJSX) {
      this.emit('{', exp, '}', NL);
    } else {
      this.emit(exp, NL);
    }
  }

  toString() {
    return this.buf.join('');
  }
}

export class Symbol {
  name: string;
  constructor(name) {
    this.name = name;
  }
}

export class Imports {
  imports: Map<string, Map<string, Symbol>> = new Map();

  get(moduleName, symbolName) {
    let importSymbols = this.imports.get(moduleName);
    if (!importSymbols) {
      importSymbols = new Map();
      this.imports.set(moduleName, importSymbols);
    }
    let symbol = importSymbols.get(symbolName);
    if (!symbol) {
      symbol = new Symbol(symbolName);
      importSymbols.set(symbolName, symbol);
    }
    return symbol;
  }
}

function ignoreKey(key) {
  return (
    key.startsWith('$') ||
    key.startsWith('_') ||
    key == 'code' ||
    key == '' ||
    key == 'builder-id'
  );
}

export class Block {
  imports: Imports;
  constructor(imports) {
    this.imports = imports;
  }
}

function possiblyQuotePropertyName(key) {
  return /^\w[\w\d]*$/.test(key) ? key : JSON.stringify(key);
}

export function string(text) {
  return JSON.stringify(text);
}

export function invoke(
  symbol,
  args,
  typeParameters?,
) {
  return function(this) {
    this.emit(typeof symbol == 'string' ? symbol : symbol.name);
    this.typeParameters(typeParameters);
    this.emit('(', args, ')');
  };
}

export function arrowFnBlock(args, statements) {
  return function(this) {
    this.emit('(', args, ')', WS, '=>', WS);
    this.emit('{', INDENT, NL)
      .emitList(statements, ';')
      .emit(UNINDENT, NL, '}');
  };
}

export function arrowFnValue(args, expression) {
  return function(this) {
    this.emit('(', args, ')', WS, '=>', WS, expression);
  };
}

const LOWER_CASE = 'a'.charCodeAt(0) - 1;

function literalTagName(symbol) {
  if (
    typeof symbol == 'string' &&
    symbol.charCodeAt(0) > LOWER_CASE &&
    symbol.indexOf('.') === -1
  ) {
    return string(symbol);
  }
  return symbol;
}
function isWhitespace(ch) {
  return ch == '' || ch == RS || ch == NL;
}
<fim_middle>",correct,3473
boolean,boolean,dadf55286f28793ab229a3f259e1af36d5c7836a,"<fim_prefix>interface Embed {
	title: string
	description: string
	url: string
	timestamp: Date
	color: number
	footer: {
		text: string
		icon_url: string
	}
	thumbnail: {
		url: string
	}
	image: {
		url: string
	}
	fields: {
		name: string
		value: string
		inline: boolean
	}[]
	author: {
		name: string
		url: string
		icon_url: string
	}
}
class Embed {
	constructor() {
		this.title = ''
		this.description = ''
		this.url = ''
		this.color = 0
		this.timestamp = new Date()
		this.footer = {
			text: '',
			icon_url: ''
		}
		this.image = {
			url: ''
		}
		this.thumbnail = {
			url: ''
		}
		this.author = {
			name: '',
			url: '',
			icon_url: ''
		}
		this.fields = []
	}
	setTitle(title) {
		this.title = title
		return this
	}
	setDescription(description) {
		this.description = description
		return this
	}
	setURL(url) {
		this.url = url
		return this
	}
	setTimestamp(timestamp) {
		this.timestamp = timestamp
		return this
	}
	setColor(color) {
		this.color = color
		return this
	}
	setFooter(text, icon) {
		this.footer.text = text
		this.footer.icon_url = icon
		return this
	}
	setThumbnail(url) {
		this.thumbnail.url = url
		return this
	}
	setImage(url) {
		this.image.url = url
		return this
	}
	setAuthor(name, url, icon) {
		this.author.name = name
		this.author.url = url
		this.author.icon_url = icon
		return this
	}
	addField(name, value, inline: <fim_suffix> = false) {
		this.fields.push({
			name,
			value,
			inline
		})
		return this
	}
	toJSON() {
		return {
			title: this.title,
			description: this.description,
			url: this.url,
			timestamp: this.timestamp,
			color: this.color,
			footer: this.footer,
			thumbnail: this.thumbnail,
			image: this.image,
			fields: this.fields,
			author: this.author
		}
	}
}
<fim_middle>",correct,3559
boolean,boolean,714b8e472bcd3cdcca43385f9d5d2554fc1780a1,"<fim_prefix>function split(input) {
    const LF = '\n';
    const CRLF = '\r\n';
    const a = [];

    let pL = 0;
    let p1 = input.indexOf(CRLF, pL);
    let p2 = input.indexOf(LF, pL);

    while (p1 !== -1 || p2 !== -1) {
        if (p1 !== -1 && p1 <= p2) {
            a.push(input.substring(pL, p1));
            pL = p1 + 2;
        } else {
            a.push(input.substring(pL, p2));
            pL = p2 + 1;
        }
        p1 = input.indexOf(CRLF, pL);
        p2 = input.indexOf(LF, pL);
    }
    if (pL < input.length) {
        a.push(input.substring(pL));
    }
    return a;
}

/**
 *
 */
export class BatchContent {
    type: number;
    stringData: string;
    stringSplit: any;
    pos: number;

    public constructor(data) {
        this.type = 0;
        this.stringData = data;
        this.stringSplit = split(data);
        this.pos = 0;
    }

    public lookLine() {
        return this.stringSplit[this.pos];
    }

    public readLine() {
        return this.stringSplit[this.pos++];
    }

    public inc() {
        this.pos++;
    }
}

export class Batch {
    changeSetErrorResponse: any;
    parts: (BatchPart | Batch)[];
    public constructor(public isChangeSet, public boundary) {
        if (this.isChangeSet) {
            this.changeSetErrorResponse = null;
        }
        this.parts = [];
    }
}

export function getBoundary(headerValue) {
    const l = headerValue.split(';');

    for (const element of l) {
        const ll = element.split('=');
        if (ll[0].trim() === 'boundary') {
            return ll[1];
        }
    }
    return '';
}

function readHeader(line) {
    const colPos = line.indexOf(':');
    if (colPos === -1) {
        throw new Error('Invalid header ""content-type"" in batch part');
    }

    const s0 = line.substring(0, colPos);
    const s1 = line.substring(colPos + 1);
    return {
        name: s0.toLowerCase(),
        value: s1.trim()
    };
}
export type BatchPart = {
    url: string;
    method: string;
    body: any;
    headers: Record<string, string>;
    contentId?: string;
};

function readAppHttp(batchContent, boundary) {
    const headers: any = {};
    const payload = [];

    let state = 0; //read url
    const rawUrl = batchContent.readLine();

    state = 1; //read header
    let line = batchContent.lookLine();

    while (line !== null && line !== undefined && line.indexOf(boundary) !== 0) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            } else {
                const h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        } else if (state === 2) {
            payload.push(line);
            batchContent.inc();
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }

    const [method, url] = rawUrl.split(' ');

    let actualBody: any;
    if (payload.length > 0) {
        try {
            actualBody = JSON.parse(payload[0]);
        } catch (e) {
            actualBody = payload[0];
        }
    }
    return {
        url: `/${url}`,
        method: method,
        headers: headers,
        body: actualBody
    };
}

function extractContent(batchContent, headers, boundary) {
    let content;
    if (!headers['content-type']) {
        throw new Error('Missing header ""content-type"" in batch part');
    } else if (headers['content-type'] === 'application/http') {
        content = readAppHttp(batchContent, boundary);
        if (headers['content-id']) {
            content.contentId = headers['content-id'];
        }
    } else if (headers['content-type'].indexOf('multipart/mixed;') > -1) {
        const changeSetBoundary = getBoundary(headers['content-type']);
        content = parseBatch(batchContent, changeSetBoundary, true);
    }
    return content;
}

function parsePart(batchContent, boundary) {
    const boundaryNext = boundary;
    const boundaryEnd = boundary + '--';
    const headers: any = {};
    let content;

    let state = 1; //read header
    let line = batchContent.lookLine();

    while (line !== null && line !== undefined && line !== boundaryNext && line !== boundaryEnd) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            } else {
                const h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        } else if (state === 2) {
            content = extractContent(batchContent, headers, boundary);
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }

    return content;
}

export function parseBatch(content, boundary, isChangeset: <fim_suffix> = false) {
    const boundaryNext = '--' + boundary;
    const boundaryEnd = '--' + boundary + '--';

    const batch = new Batch(isChangeset, boundary);

    let part;

    let line = content.readLine();
    while (line !== null && line !== undefined && line !== boundaryNext) {
        //read lines before first boundary
        line = content.readLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request');
    }
    //line is now read boundary
    line = content.lookLine(); //read line behind

    while (line !== null && line !== undefined && line !== boundaryEnd) {
        part = parsePart(content, boundaryNext);
        if (part) {
            batch.parts.push(part);
        }
        line = content.lookLine(); //now on boundary
        if (line === boundaryNext) {
            line = content.readLine(); //consume boundaryNext
        }
    }

    content.readLine(); //consume boundaryEnd
    line = content.lookLine(); //read line behind
    while (line !== null && line !== undefined && line.length === 0) {
        //read empty lines after first boundary end
        content.readLine();
        line = content.lookLine();
    }

    return batch;
}
<fim_middle>",correct,3624
boolean,boolean,714b8e472bcd3cdcca43385f9d5d2554fc1780a1,"<fim_prefix>function split(input) {
    const LF = '\n';
    const CRLF = '\r\n';
    const a = [];

    let pL = 0;
    let p1 = input.indexOf(CRLF, pL);
    let p2 = input.indexOf(LF, pL);

    while (p1 !== -1 || p2 !== -1) {
        if (p1 !== -1 && p1 <= p2) {
            a.push(input.substring(pL, p1));
            pL = p1 + 2;
        } else {
            a.push(input.substring(pL, p2));
            pL = p2 + 1;
        }
        p1 = input.indexOf(CRLF, pL);
        p2 = input.indexOf(LF, pL);
    }
    if (pL < input.length) {
        a.push(input.substring(pL));
    }
    return a;
}

/**
 *
 */
export class BatchContent {
    type: number;
    stringData: string;
    stringSplit: any;
    pos: number;

    public constructor(data) {
        this.type = 0;
        this.stringData = data;
        this.stringSplit = split(data);
        this.pos = 0;
    }

    public lookLine() {
        return this.stringSplit[this.pos];
    }

    public readLine() {
        return this.stringSplit[this.pos++];
    }

    public inc() {
        this.pos++;
    }
}

export class Batch {
    changeSetErrorResponse: any;
    parts: (BatchPart | Batch)[];
    public constructor(public isChangeSet: <fim_suffix>, public boundary) {
        if (this.isChangeSet) {
            this.changeSetErrorResponse = null;
        }
        this.parts = [];
    }
}

export function getBoundary(headerValue) {
    const l = headerValue.split(';');

    for (const element of l) {
        const ll = element.split('=');
        if (ll[0].trim() === 'boundary') {
            return ll[1];
        }
    }
    return '';
}

function readHeader(line) {
    const colPos = line.indexOf(':');
    if (colPos === -1) {
        throw new Error('Invalid header ""content-type"" in batch part');
    }

    const s0 = line.substring(0, colPos);
    const s1 = line.substring(colPos + 1);
    return {
        name: s0.toLowerCase(),
        value: s1.trim()
    };
}
export type BatchPart = {
    url: string;
    method: string;
    body: any;
    headers: Record<string, string>;
    contentId?: string;
};

function readAppHttp(batchContent, boundary) {
    const headers: any = {};
    const payload = [];

    let state = 0; //read url
    const rawUrl = batchContent.readLine();

    state = 1; //read header
    let line = batchContent.lookLine();

    while (line !== null && line !== undefined && line.indexOf(boundary) !== 0) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            } else {
                const h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        } else if (state === 2) {
            payload.push(line);
            batchContent.inc();
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }

    const [method, url] = rawUrl.split(' ');

    let actualBody: any;
    if (payload.length > 0) {
        try {
            actualBody = JSON.parse(payload[0]);
        } catch (e) {
            actualBody = payload[0];
        }
    }
    return {
        url: `/${url}`,
        method: method,
        headers: headers,
        body: actualBody
    };
}

function extractContent(batchContent, headers, boundary) {
    let content;
    if (!headers['content-type']) {
        throw new Error('Missing header ""content-type"" in batch part');
    } else if (headers['content-type'] === 'application/http') {
        content = readAppHttp(batchContent, boundary);
        if (headers['content-id']) {
            content.contentId = headers['content-id'];
        }
    } else if (headers['content-type'].indexOf('multipart/mixed;') > -1) {
        const changeSetBoundary = getBoundary(headers['content-type']);
        content = parseBatch(batchContent, changeSetBoundary, true);
    }
    return content;
}

function parsePart(batchContent, boundary) {
    const boundaryNext = boundary;
    const boundaryEnd = boundary + '--';
    const headers: any = {};
    let content;

    let state = 1; //read header
    let line = batchContent.lookLine();

    while (line !== null && line !== undefined && line !== boundaryNext && line !== boundaryEnd) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            } else {
                const h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        } else if (state === 2) {
            content = extractContent(batchContent, headers, boundary);
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }

    return content;
}

export function parseBatch(content, boundary, isChangeset = false) {
    const boundaryNext = '--' + boundary;
    const boundaryEnd = '--' + boundary + '--';

    const batch = new Batch(isChangeset, boundary);

    let part;

    let line = content.readLine();
    while (line !== null && line !== undefined && line !== boundaryNext) {
        //read lines before first boundary
        line = content.readLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request');
    }
    //line is now read boundary
    line = content.lookLine(); //read line behind

    while (line !== null && line !== undefined && line !== boundaryEnd) {
        part = parsePart(content, boundaryNext);
        if (part) {
            batch.parts.push(part);
        }
        line = content.lookLine(); //now on boundary
        if (line === boundaryNext) {
            line = content.readLine(); //consume boundaryNext
        }
    }

    content.readLine(); //consume boundaryEnd
    line = content.lookLine(); //read line behind
    while (line !== null && line !== undefined && line.length === 0) {
        //read empty lines after first boundary end
        content.readLine();
        line = content.lookLine();
    }

    return batch;
}
<fim_middle>",correct,3638
boolean,boolean,4e37dd74b59ee466274764f0564ceb399e82ef94,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:24
 * @LastEditTime: 2022-04-24 16:15:10
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/time/interface.ts
 */
// props 小时
export type hourProps = {
	active: number;
	change: Function;
	year: number;
	month: number;
	day: number;
	limit: boolean;
};

// props 分钟
export type minuteProps = {
	active: number;
	change: Function;
	year: number;
	month: number;
	day: number;
	hour: number;
	limit: boolean;
};

export type ListItem = {
	label: string;
	value: number;
};
// 小时/分 -数据列表生成
export function getTimeList(
	max,
	year,
	month,
	day,
	hour,
	minute,
	limit: <fim_suffix>
) {
	let list: Array<ListItem> = [];

	for (let i = max; i > -1; i--) {
		if (
			checkDisabled(
				max < 24,
				year,
				month,
				day,
				max > 23 ? hour : i,
				max < 24 ? minute : i
			) ||
			!limit
		) {
			let label = i < 10 ? `0${i.toString()}` : i.toString();
			list.push({
				label: label,
				value: i,
			});
		} else {
			break;
		}
	}
	return list.reverse();
}
// 时/分-禁用判定
function checkDisabled(
	ishour,
	prevYear,
	prevMonth,
	prevDay,
	prevHour,
	prevMinute
) {
	const prevTime = new Date(
		`${prevYear}/${prevMonth}/${prevDay} ${prevHour}:${prevMinute}`
	).getTime();
	const newDate = new Date();
	const year: number = newDate.getFullYear();
	let month: number = newDate.getMonth() + 1;
	let day: number = newDate.getDate();
	let hour: number = newDate.getHours();
	let minute: number = newDate.getMinutes();
	const newTime = new Date(
		`${year}/${month}/${day} ${hour}:${ishour ? 0 : minute}`
	).getTime();
	return prevTime >= newTime;
}

// 秒 -数据列表生成
export function getSecondList(max) {
	let list: Array<ListItem> = [];

	for (let i = max; i > -1; i--) {
		let label = i < 10 ? `0${i.toString()}` : i.toString();
		list.push({
			label: label,
			value: i,
		});
	}
	return list.reverse();
}
<fim_middle>",correct,3760
boolean,boolean,4e77d6fefc465d02bbfde5576d003dda41ab6508,"<fim_prefix>export type Pitch = number;

export const C = 0 as Pitch;
export const CIS = 1 as Pitch;
export const D = 2 as Pitch;
export const DIS = 3 as Pitch;
export const E = 4 as Pitch;
export const F = 5 as Pitch;
export const FIS = 6 as Pitch;
export const G = 7 as Pitch;
export const GIS = 8 as Pitch;
export const A = 9 as Pitch;
export const AIS = 10 as Pitch;
export const B = 11 as Pitch;

export const NUM_PITCHES = 12;
export const PITCHES = Array.from(Array(NUM_PITCHES).keys()) as Pitch[];

export function getPitchWithOctave(index, octave) {
    const pitch = getPitch(index);
    const octaveFixed = octave + (index / NUM_PITCHES);
    return pitch + octaveFixed;
}

export function getPitch(index) {
    switch (index % NUM_PITCHES) {
        case C:
            return ""C"";
        case CIS:
            return ""C#"";
        case D:
            return ""D"";
        case DIS:
            return ""D#"";
        case E:
            return ""E"";
        case F:
            return ""F"";
        case FIS:
            return ""F#"";
        case G:
            return ""G"";
        case GIS:
            return ""G#"";
        case A:
            return ""A"";
        case AIS:
            return ""A#"";
        case B:
            return ""B"";
        default:
            throw new Error(""Invalid pitch"");
    }
}

export function isBlack(index): <fim_suffix> {
    return [CIS, DIS, FIS, GIS, AIS].includes(index % NUM_PITCHES);
}

<fim_middle>",correct,3779
boolean,boolean,155ed385f5c8e4cb526b8f77f7864d57ba5bd325,"<fim_prefix>export const enum SCSVPrimitiveName {
  ""string"",
  ""number"",
  ""boolean"",
  ""null"",
}

export type SCSVPrimitive = {
  type: SCSVPrimitiveName;
};

export type SCSVArray = {
  type: ""array"";
  elementType: SCSVType;
};

export type SCSVTuple = {
  type: ""tuple"";
  elements: SCSVType[];
};

export type SCSVObject = {
  type: ""object"";
  valueType: SCSVType;
};

export type SCSVRecord = {
  type: ""record"";
  fields: Record<string, SCSVType>;
};

export type SCSVUnion = {
  type: ""union"";
  variants: SCSVType[]; // set of types
};

export type SCSVType =
  | SCSVPrimitive
  | SCSVArray
  | SCSVTuple
  | SCSVObject
  | SCSVRecord
  | SCSVUnion;

export const scsv = {
  string: {
    type: SCSVPrimitiveName.string,
  },
  number: {
    type: SCSVPrimitiveName.number,
  },
  boolean: {
    type: SCSVPrimitiveName.boolean,
  },
  null: {
    type: SCSVPrimitiveName.null,
  },
  array(elementType) {
    return {
      type: ""array"",
      elementType,
    };
  },
  tuple(...elements) {
    return {
      type: ""tuple"",
      elements,
    };
  },
  object(valueType) {
    return {
      type: ""object"",
      valueType,
    };
  },
  record(fields) {
    return {
      type: ""record"",
      fields,
    };
  },
  union(...variants) {
    return {
      type: ""union"",
      variants,
    };
  },
  optional(type) {
    return this.union(type, this.null);
  },
  parse(x) {
    // todo(maximsmol): tuple, record support
    let idx = 0;

    const consume = (c): <fim_suffix> => {
      if (x[idx] !== c) return false;
      ++idx;
      return true;
    };

    const parsePrimitive = () => {
      if (consume(""s"")) return this.string;
      if (consume(""n"")) return this.number;
      if (consume(""b"")) return this.boolean;
      if (consume(""N"")) return this.null;
      throw new Error(`unknown primitive: ""${x[idx]}""`);
    };

    const parseParens = () => {
      if (!consume(""("")) return parsePrimitive();
      const res = parseType();
      if (!consume("")"")) throw new Error(""expected closing parenthesis"");
      return res;
    };

    const parsePostfix = () => {
      const l = parseParens();
      if (!""[{?"".includes(x[idx] ?? ""eof"")) return l;

      let res = l;
      while (true) {
        if (consume(""["")) {
          if (!consume(""]"")) throw new Error(""expected closing bracket"");
          res = this.array(res);
        } else if (consume(""{"")) {
          if (!consume(""}"")) throw new Error(""expected closing brace"");
          res = this.object(res);
        } else if (consume(""?"")) {
          res = this.optional(res);
        } else break;
      }

      return res;
    };

    const parseUnion = () => {
      const l = parsePostfix();
      if (x[idx] !== ""|"") return l;

      const res = [l];
      while (consume(""|"")) res.push(parsePostfix());

      return this.union(...res);
    };

    const parseType = () => {
      return parseUnion();
    };

    return parseType();
  },
};

export type SCSVObjectOutput = { [key: string]: SCSVOutput };
export type SCSVOutput =
  | string
  | number
  | boolean
  | null
  | SCSVOutput[]
  | SCSVObjectOutput;

// todo(maximsmol): implement this properly
// export type JSTypeFromSCSVType<T extends SCSVType> = T extends SCSVPrimitive
//   ? T[""type""] extends SCSVPrimitiveName.string
//     ? string
//     : T[""type""] extends SCSVPrimitiveName.number
//     ? number
//     : T[""type""] extends SCSVPrimitiveName.boolean
//     ? boolean
//     : T[""type""] extends SCSVPrimitiveName.null
//     ? null
//     : never
//   : T extends SCSVArray
//   ? JSTypeFromSCSVType<T[""elementType""]>[]
//   : T extends SCSVTuple
//   ? { [K in keyof T[""elements""]]: SCSVType }
//   : T extends SCSVObject
//   ? { [key: string]: JSTypeFromSCSVType<T[""valueType""]> }
//   : T extends SCSVRecord
//   ? { [K in keyof T[""fields""]]: JSTypeFromSCSVType<T[""fields""][K]> }
//   : T extends SCSVUnion
//   ? keyof { [K in keyof T[""variants""]]: SCSVType }
//   : never;

export const isOptional = (x) =>
  x.type === ""union"" &&
  x.variants.findIndex((x) => x === scsv.null || isOptional(x)) !== -1;
<fim_middle>",correct,3798
boolean,boolean,15b8db192fc5ac36ac290289da3f8a7f39a0fb7b,"<fim_prefix>export type Board = string[][]
export const numberOfLetters = 5
export const numberOfRows = 6
export const word = 'לחמים'
export const empty = '-'

export const endOfWordToRegularLetters = {
    ם: 'מ',
    ן: 'נ',
    ץ: 'צ',
    ף: 'פ',
    ך: 'כ',
}

export const regularToEndOfWordLetters = {
    מ: 'ם',
    נ: 'ן',
    צ: 'ץ',
    פ: 'ף',
    כ: 'ך',
}

// The enum ordering is used in order to always push a better result into the dict
export enum LetterType {
    Unevaluated,
    Miss,
    Present,
    Correct,
}

export const letterTypeToBgColor = {
    [LetterType.Unevaluated]: 'hg-unevaluated',
    [LetterType.Miss]: 'bg-zinc-400',
    [LetterType.Present]: 'bg-orange-400',
    [LetterType.Correct]: 'bg-green-400',
}

export const letterTypeToEmoji = {
    [LetterType.Miss]: '⬛',
    [LetterType.Present]: '🟨',
    [LetterType.Correct]: '🟩',
}

export const keyboardLettersFromGuesses = (word, guesses) => {
    let letters = {
        א: LetterType.Unevaluated,
        ב: LetterType.Unevaluated,
        ג: LetterType.Unevaluated,
        ד: LetterType.Unevaluated,
        ה: LetterType.Unevaluated,
        ו: LetterType.Unevaluated,
        ז: LetterType.Unevaluated,
        ח: LetterType.Unevaluated,
        ט: LetterType.Unevaluated,
        י: LetterType.Unevaluated,
        כ: LetterType.Unevaluated,
        ל: LetterType.Unevaluated,
        מ: LetterType.Unevaluated,
        נ: LetterType.Unevaluated,
        ס: LetterType.Unevaluated,
        ע: LetterType.Unevaluated,
        פ: LetterType.Unevaluated,
        צ: LetterType.Unevaluated,
        ק: LetterType.Unevaluated,
        ר: LetterType.Unevaluated,
        ש: LetterType.Unevaluated,
        ת: LetterType.Unevaluated,
        ם: LetterType.Unevaluated,
        ן: LetterType.Unevaluated,
        ץ: LetterType.Unevaluated,
        ף: LetterType.Unevaluated,
        ך: LetterType.Unevaluated,
    }
    for (const i in guesses) {
        let line = guesses[i]
        let r = getCorrectAndPresent(word, line)
        for (const t in r) {
            // Using the enum ordering in order to always push a better result into the dict
            if (r[t] > letters[line[t]]) letters[line[t]] = r[t]
        }
    }
    return letters
}

export const emojiFromGuesses = (
    word,
    guesses,
    rtl = false
) => {
    let content = []
    for (let i = 0; i < guesses.length; i++) {
        if (rtl) {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .reverse()
                    .join('')
            )
        } else {
            content.push(
                getCorrectAndPresent(word, guesses[i])
                    .map((l) => letterTypeToEmoji[l])
                    .join('')
            )
        }
    }
    return content.join('\n')
}

export const wordInGuesses = (word, guesses): <fim_suffix> => {
    for (let i = 0; i < guesses.length; i++) {
        if (word === guesses[i].join('')) return true
    }
    return false
}

export const sanitizeString = (str) => {
    let r = []
    for (let i = 0; i < str.length; i++) {
        if (str[i] in endOfWordToRegularLetters) {
            r.push(endOfWordToRegularLetters[str[i]])
        } else {
            r.push(str[i])
        }
    }
    return r.join('')
}

export const getCorrectAndPresent = (
    word,
    guess
) => {
    const cleanWord = sanitizeString(word)
    const cleanGuess = guess
        .map((e) => (e === '' && empty) || e)
        .map(sanitizeString)
        .join('')

    let correctAndPresent = {
        cleanWord: Array(cleanWord.length).fill(LetterType.Unevaluated),
        cleanGuess: Array(cleanGuess.length).fill(LetterType.Unevaluated),
    }

    // For each letter of guess, check if it's correct
    for (let i = 0; i < cleanWord.length; i++) {
        if (cleanWord[i] === cleanGuess[i])
            correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[i] =
                LetterType.Correct
    }

    // Now the tricky part is to find the present
    // A letter is present iff it appears in the word somewhere that is not already present or correct
    for (let i = 0; i < cleanGuess.length; i++) {
        for (let j = 0; j < cleanWord.length; j++) {
            if (
                cleanGuess[i] === cleanWord[j] &&
                correctAndPresent.cleanGuess[i] !== LetterType.Correct &&
                correctAndPresent.cleanWord[j] !== LetterType.Correct &&
                correctAndPresent.cleanGuess[i] !== LetterType.Present &&
                correctAndPresent.cleanWord[j] !== LetterType.Present
            )
                correctAndPresent.cleanGuess[i] = correctAndPresent.cleanWord[
                    j
                ] = LetterType.Present
        }
        if (
            correctAndPresent.cleanGuess[i] === LetterType.Unevaluated &&
            cleanGuess[i] !== empty
        ) {
            // Finally, set the character to miss
            correctAndPresent.cleanGuess[i] = LetterType.Miss
        }
    }

    return correctAndPresent.cleanGuess
}
<fim_middle>",correct,3819
boolean,boolean,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes: <fim_suffix> = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3855
boolean,boolean,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle(): <fim_suffix> {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3857
boolean,boolean,e88a15592acc457cf8f0abde4fdd10eb497786eb,"<fim_prefix>type Node = string;

interface Edge {
	source: Node;
	target: Node;
}

interface Serialized {
	nodes: Node[];
	links: Edge[];
}

class GraphCycleError extends Error {
	constructor(message) {
		super(message);
		Object.setPrototypeOf(this, GraphCycleError.prototype);
	}
}

export class Graph {
	private adjacencyList: Record<Node, Node[]>;

	public constructor() {
		this.adjacencyList = {};
	}

	private adjacent(node) {
		return this.adjacencyList[node] || [];
	}

	public addNode(node) {
		this.adjacencyList[node] = this.adjacent(node);
		return this;
	}

	public removeNode(node) {
		for (const key in this.adjacencyList) {
			for (const r of this.adjacencyList[key]) {
				if (r === node) {
					this.removeEdge(r, key);
				}
			}
		}

		for (const u in this.adjacencyList) {
			for (const v in this.adjacencyList[u]) {
				if (v === node) {
					this.removeEdge(u, v);
				}
			}
		}

		delete this.adjacencyList[node];

		return this;
	}

	public nodes() {
		return Object.keys(this.adjacencyList);
	}

	public addEdge(source, target) {
		this.addNode(source);
		this.addNode(target);
		this.adjacent(source).push(target);
		return this;
	}

	public removeEdge(u, v) {
		if (this.adjacencyList[u])
			this.adjacencyList[u] = this.adjacent(u).filter((_v) => _v !== v);

		return this;
	}

	public hasEdge(source, target) {
		return this.adjacent(source).includes(target);
	}

	public depthFirstSearch(
		sourceNodes?,
		includeSourceNodes: <fim_suffix> = true,
		errorCycle = 'Cycle found',
	) {
		if (!sourceNodes) sourceNodes = this.nodes();

		if (typeof includeSourceNodes !== 'boolean') includeSourceNodes = true;

		const visited_nodes: Record<Node, boolean> = {};
		const visiting_nodes: Record<Node, boolean> = {};
		const node_list: Node[] = [];

		const dfs = (node) => {
			if (visiting_nodes[node] && errorCycle)
				throw new GraphCycleError(errorCycle);

			if (!visited_nodes[node]) {
				visited_nodes[node] = true;
				visiting_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
				visiting_nodes[node] = false;
				node_list.push(node);
			}
		};

		if (includeSourceNodes) {
			sourceNodes.forEach(dfs);
		} else {
			for (const node of sourceNodes) {
				visited_nodes[node] = true;
				this.adjacent(node).forEach(dfs);
			}
		}

		return node_list;
	}

	public hasCycle() {
		try {
			this.depthFirstSearch(undefined, true);

			return false;
		} catch (error) {
			if (
				error instanceof GraphCycleError &&
				error.name === 'GraphCycleError'
			) {
				return true;
			} else {
				throw error;
			}
		}
	}

	public topologicalSort(
		sourceNodes?,
		includeSourceNodes = true,
	) {
		return this.depthFirstSearch(sourceNodes, includeSourceNodes, false);
	}

	public toJSON() {
		const serialized: Serialized = {
			nodes: this.nodes(),
			links: [],
		};

		for (const source of serialized.nodes) {
			for (const target of this.adjacent(source)) {
				serialized.links.push({
					source,
					target,
				});
			}
		}

		return serialized;
	}
}
<fim_middle>",correct,3861
boolean,boolean,f9f62e4aba0eb7e1dbd700d9f9b7d3ae6f796b52,"<fim_prefix>export const Kind = 'Core#WebApiIndex';

/**
 * @deprecated This was used in the old version of ARC.
 */
export interface ILegacyWebApiIndex {
  /**
   * API title
   */
  title: string;
  /**
   * API media type
   * @deprecated This has been renamed to `vendor`.
   */
  type: string;
  /**
   * API order on the list
   */
  order: number;
  /**
   * List of version names stored with this API.
   */
  versions: string[];
  /**
   * The latest added version name.
   */
  latest: string;
}

export interface IWebApiIndex {
  kind: typeof Kind;
  /**
   * API title
   */
  title: string;
  /**
   * List of version names stored with this API.
   */
  versions: string[];
  /**
   * The latest added version name.
   */
  latest: string;
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor: string;
}

export class WebApiIndex {
  kind = Kind;
  /**
   * API title
   */
  title = '';
  /**
   * List of version names stored with this API.
   */
  versions: string[] = [];
  /**
   * The latest added version name.
   */
  latest = '';
  /**
   * The API vendor. E.g. RAML 1.0, OAS 3.0, ASYNC 2.0, ...
   */
  vendor = '';

  static isLegacy(api): <fim_suffix> {
    const legacy = api as ILegacyWebApiIndex;
    return !!legacy.type;
  }

  static fromLegacy(api) {
    const { title, type, versions=[], latest } = api;
    const init: IWebApiIndex = {
      kind: Kind,
      title,
      versions,
      latest,
      vendor: type,
    };
    return new WebApiIndex(init);
  }

  constructor(input?) {
    let init: IWebApiIndex;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        latest: '',
        title: '',
        vendor: '',
        versions: [],
      };
    }
    this.new(init);
  }

  new(init) {
    const { latest='', title='', vendor='', versions=[] } = init;
    this.latest = latest;
    this.versions = versions;
    this.title = title;
    this.vendor = vendor;
  }

  toJSON() {
    const result: IWebApiIndex = {
      kind: Kind,
      latest: this.latest,
      versions: this.versions,
      title: this.title,
      vendor: this.vendor,
    };
    return result;
  }
}
<fim_middle>",correct,3896
boolean,boolean,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent: <fim_suffix>) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3929
boolean,boolean,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left: <fim_suffix>) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3932
boolean,boolean,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent: <fim_suffix>);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3987
boolean,boolean,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent(): <fim_suffix>;
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3988
boolean,boolean,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?: <fim_suffix>) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3989
boolean,boolean,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent: <fim_suffix>);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent) {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3991
boolean,boolean,09d130eaf6fa6284f1fb610e8f53944921615073,"<fim_prefix>
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;

export function range(start = 0, stop, step = 1) {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}

/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {number} year
 * @returns {boolean}
 */
export function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}

export function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}

/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {number} year
 * @param {number} month
 * @returns {number[]}
 */
export function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error(""Invalid month specified"");
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}

export interface ICalendarDate {
    date: Date;
    isCurrentMonth: boolean;
    isPrevMonth: boolean;
    isNextMonth: boolean;
}

export enum WEEKDAYS {
    SUNDAY = 0,
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6
}

export class Calendar {

    private _firstWeekDay: number | WEEKDAYS;

    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }

    public get firstWeekDay() {
        return this._firstWeekDay % 7;
    }

    public set firstWeekDay(value) {
        this._firstWeekDay = value;
    }

    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns {number[]}
     *
     * @memberof Calendar
     */
    public weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }

    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param {number} year
     * @param {number} month
     * @param {extraWeek} boolean
     * @returns {ICalendarDate[]}
     *
     * @memberof Calendar
     */
    public monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1, 12, 0, 0, 0);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, ""day"", -days);
        const res = [];
        let value: ICalendarDate;

        while (true) {

            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, ""day"", 1);

            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const i of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, ""day"", 1);
                    }
                }
                break;
            }
        }
        return res;
    }

    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param {number} year
     * @param {number} month
     * @returns {ICalendarDate[][]}
     *
     * @memberof Calendar
     */
    public monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }

    public timedelta(date, interval, units) {
        const ret = new Date(date);

        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };

        switch (interval.toLowerCase()) {
            case ""year"":
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case ""quarter"":
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case ""month"":
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case ""week"":
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case ""day"":
                ret.setDate(ret.getDate() + units);
                break;
            case ""hour"":
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case ""minute"":
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case ""second"":
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error(""Invalid interval specifier"");
        }
        return ret;
    }

    private generateICalendarDate(date, year, month) {
            return {
                date,
                isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
                isNextMonth: this.isNextMonth(date, year, month),
                isPrevMonth: this.isPreviousMonth(date, year, month)
            };
        }
    private isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }

    private isNextMonth(date, year, month): <fim_suffix> {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
<fim_middle>",correct,4086
boolean,boolean,09d130eaf6fa6284f1fb610e8f53944921615073,"<fim_prefix>
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;

export function range(start = 0, stop, step = 1) {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}

/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {number} year
 * @returns {boolean}
 */
export function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}

export function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}

/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {number} year
 * @param {number} month
 * @returns {number[]}
 */
export function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error(""Invalid month specified"");
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}

export interface ICalendarDate {
    date: Date;
    isCurrentMonth: boolean;
    isPrevMonth: boolean;
    isNextMonth: boolean;
}

export enum WEEKDAYS {
    SUNDAY = 0,
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6
}

export class Calendar {

    private _firstWeekDay: number | WEEKDAYS;

    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }

    public get firstWeekDay() {
        return this._firstWeekDay % 7;
    }

    public set firstWeekDay(value) {
        this._firstWeekDay = value;
    }

    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns {number[]}
     *
     * @memberof Calendar
     */
    public weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }

    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param {number} year
     * @param {number} month
     * @param {extraWeek} boolean
     * @returns {ICalendarDate[]}
     *
     * @memberof Calendar
     */
    public monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1, 12, 0, 0, 0);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, ""day"", -days);
        const res = [];
        let value: ICalendarDate;

        while (true) {

            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, ""day"", 1);

            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const i of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, ""day"", 1);
                    }
                }
                break;
            }
        }
        return res;
    }

    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param {number} year
     * @param {number} month
     * @returns {ICalendarDate[][]}
     *
     * @memberof Calendar
     */
    public monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }

    public timedelta(date, interval, units) {
        const ret = new Date(date);

        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };

        switch (interval.toLowerCase()) {
            case ""year"":
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case ""quarter"":
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case ""month"":
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case ""week"":
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case ""day"":
                ret.setDate(ret.getDate() + units);
                break;
            case ""hour"":
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case ""minute"":
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case ""second"":
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error(""Invalid interval specifier"");
        }
        return ret;
    }

    private generateICalendarDate(date, year, month) {
            return {
                date,
                isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
                isNextMonth: this.isNextMonth(date, year, month),
                isPrevMonth: this.isPreviousMonth(date, year, month)
            };
        }
    private isPreviousMonth(date, year, month): <fim_suffix> {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }

    private isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
<fim_middle>",correct,4090
boolean,boolean,09d130eaf6fa6284f1fb610e8f53944921615073,"<fim_prefix>
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;

export function range(start = 0, stop, step = 1) {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}

/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {number} year
 * @returns {boolean}
 */
export function isLeap(year) {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}

export function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}

/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {number} year
 * @param {number} month
 * @returns {number[]}
 */
export function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error(""Invalid month specified"");
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}

export interface ICalendarDate {
    date: Date;
    isCurrentMonth: boolean;
    isPrevMonth: boolean;
    isNextMonth: boolean;
}

export enum WEEKDAYS {
    SUNDAY = 0,
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6
}

export class Calendar {

    private _firstWeekDay: number | WEEKDAYS;

    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }

    public get firstWeekDay() {
        return this._firstWeekDay % 7;
    }

    public set firstWeekDay(value) {
        this._firstWeekDay = value;
    }

    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns {number[]}
     *
     * @memberof Calendar
     */
    public weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }

    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param {number} year
     * @param {number} month
     * @param {extraWeek} boolean
     * @returns {ICalendarDate[]}
     *
     * @memberof Calendar
     */
    public monthdates(year, month, extraWeek: <fim_suffix> = false) {
        let date = new Date(year, month, 1, 12, 0, 0, 0);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, ""day"", -days);
        const res = [];
        let value: ICalendarDate;

        while (true) {

            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, ""day"", 1);

            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const i of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, ""day"", 1);
                    }
                }
                break;
            }
        }
        return res;
    }

    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param {number} year
     * @param {number} month
     * @returns {ICalendarDate[][]}
     *
     * @memberof Calendar
     */
    public monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }

    public timedelta(date, interval, units) {
        const ret = new Date(date);

        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };

        switch (interval.toLowerCase()) {
            case ""year"":
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case ""quarter"":
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case ""month"":
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case ""week"":
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case ""day"":
                ret.setDate(ret.getDate() + units);
                break;
            case ""hour"":
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case ""minute"":
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case ""second"":
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error(""Invalid interval specifier"");
        }
        return ret;
    }

    private generateICalendarDate(date, year, month) {
            return {
                date,
                isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
                isNextMonth: this.isNextMonth(date, year, month),
                isPrevMonth: this.isPreviousMonth(date, year, month)
            };
        }
    private isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }

    private isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
<fim_middle>",correct,4107
boolean,boolean,09d130eaf6fa6284f1fb610e8f53944921615073,"<fim_prefix>
const MDAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const FEBRUARY = 1;

export function range(start = 0, stop, step = 1) {
    const res = [];
    const cur = (stop === undefined) ? 0 : start;
    const max = (stop === undefined) ? start : stop;
    for (let i = cur; step < 0 ? i > max : i < max; i += step) {
        res.push(i);
    }
    return res;
}

/**
 * Returns true for leap years, false for non-leap years.
 *
 * @export
 * @param {number} year
 * @returns {boolean}
 */
export function isLeap(year): <fim_suffix> {
    return (year % 4 === 0) && ((year % 100 !== 0) || (year % 400 === 0));
}

export function weekDay(year, month, day) {
    return new Date(year, month, day).getDay();
}

/**
 * Return weekday and number of days for year, month.
 *
 * @export
 * @param {number} year
 * @param {number} month
 * @returns {number[]}
 */
export function monthRange(year, month) {
    if ((month < 0) || (month > 11)) {
        throw new Error(""Invalid month specified"");
    }
    const day = weekDay(year, month, 1);
    let nDays = MDAYS[month];
    if ((month === FEBRUARY) && (isLeap(year))) {
        nDays++;
    }
    return [day, nDays];
}

export interface ICalendarDate {
    date: Date;
    isCurrentMonth: boolean;
    isPrevMonth: boolean;
    isNextMonth: boolean;
}

export enum WEEKDAYS {
    SUNDAY = 0,
    MONDAY = 1,
    TUESDAY = 2,
    WEDNESDAY = 3,
    THURSDAY = 4,
    FRIDAY = 5,
    SATURDAY = 6
}

export class Calendar {

    private _firstWeekDay: number | WEEKDAYS;

    constructor(firstWeekDay = WEEKDAYS.SUNDAY) {
        this._firstWeekDay = firstWeekDay;
    }

    public get firstWeekDay() {
        return this._firstWeekDay % 7;
    }

    public set firstWeekDay(value) {
        this._firstWeekDay = value;
    }

    /**
     * Returns an array of weekdays for one week starting
     * with the currently set `firstWeekDay`
     *
     * this.firstWeekDay = 0 (Sunday) --> [0, 1, 2, 3, 4, 5, 6]
     * this.firstWeekDay = 1 (Monday) --> [1, 2, 3, 4, 5, 6, 0]
     *
     * @returns {number[]}
     *
     * @memberof Calendar
     */
    public weekdays() {
        const res = [];
        for (const i of range(this.firstWeekDay, this.firstWeekDay + 7)) {
            res.push(i % 7);
        }
        return res;
    }

    /**
     * Returns the date values for one month. It will always iterate throught
     * complete weeks, so it will contain dates outside the specified month.
     *
     * @param {number} year
     * @param {number} month
     * @param {extraWeek} boolean
     * @returns {ICalendarDate[]}
     *
     * @memberof Calendar
     */
    public monthdates(year, month, extraWeek = false) {
        let date = new Date(year, month, 1, 12, 0, 0, 0);
        let days = (date.getDay() - this.firstWeekDay) % 7;
        if (days < 0) {
            days = 7 - Math.abs(days);
        }
        date = this.timedelta(date, ""day"", -days);
        const res = [];
        let value: ICalendarDate;

        while (true) {

            value = this.generateICalendarDate(date, year, month);
            res.push(value);
            date = this.timedelta(date, ""day"", 1);

            if ((date.getMonth() !== month) && (date.getDay() === this.firstWeekDay)) {
                if (extraWeek && res.length <= 35) {
                    for (const i of range(0, 7)) {
                        value = this.generateICalendarDate(date, year, month);
                        res.push(value);
                        date = this.timedelta(date, ""day"", 1);
                    }
                }
                break;
            }
        }
        return res;
    }

    /**
     * Returns a matrix (array of arrays) representing a month's calendar.
     * Each row represents a full week; week entries are ICalendarDate objects.
     *
     * @param {number} year
     * @param {number} month
     * @returns {ICalendarDate[][]}
     *
     * @memberof Calendar
     */
    public monthdatescalendar(year, month, extraWeek = false) {
        const dates = this.monthdates(year, month, extraWeek);
        const res = [];
        for (const i of range(0, dates.length, 7)) {
            res.push(dates.slice(i, i + 7));
        }
        return res;
    }

    public timedelta(date, interval, units) {
        const ret = new Date(date);

        const checkRollover = () => {
            if (ret.getDate() !== date.getDate()) {
                ret.setDate(0);
            }
        };

        switch (interval.toLowerCase()) {
            case ""year"":
                ret.setFullYear(ret.getFullYear() + units);
                checkRollover();
                break;
            case ""quarter"":
                ret.setMonth(ret.getMonth() + 3 * units);
                checkRollover();
                break;
            case ""month"":
                ret.setMonth(ret.getMonth() + units);
                checkRollover();
                break;
            case ""week"":
                ret.setDate(ret.getDate() + 7 * units);
                break;
            case ""day"":
                ret.setDate(ret.getDate() + units);
                break;
            case ""hour"":
                ret.setTime(ret.getTime() + units * 3600000);
                break;
            case ""minute"":
                ret.setTime(ret.getTime() + units * 60000);
                break;
            case ""second"":
                ret.setTime(ret.getTime() + units * 1000);
                break;
            default:
                throw new Error(""Invalid interval specifier"");
        }
        return ret;
    }

    private generateICalendarDate(date, year, month) {
            return {
                date,
                isCurrentMonth: date.getFullYear() === year && date.getMonth() === month,
                isNextMonth: this.isNextMonth(date, year, month),
                isPrevMonth: this.isPreviousMonth(date, year, month)
            };
        }
    private isPreviousMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() < month;
        }
        return date.getFullYear() < year;
    }

    private isNextMonth(date, year, month) {
        if (date.getFullYear() === year) {
            return date.getMonth() > month;
        }
        return date.getFullYear() > year;
    }
}
<fim_middle>",correct,4121
boolean,boolean,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value): <fim_suffix> {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text) {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line) {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value) {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4208
boolean,boolean,5138dfd36b6faf2623d71cd5a35b381d02adc19f,"<fim_prefix>export function getHoursAndMinutes(value) {
  let digits = value.split(':').map((digit) => digit.replace(/\D/g, '') || '0');

  if (digits.length === 2) {
    return [Number.parseInt(digits[0], 10), Number.parseInt(digits[1], 10)];
  }

  const timeValue = digits[0];

  if (timeValue.length <= 2) {
    return [Number.parseInt(timeValue, 10), 0];
  }

  return [
    Number.parseInt(timeValue.substr(0, Math.floor(timeValue.length / 2)), 10),
    Number.parseInt(timeValue.substr(Math.floor(timeValue.length / 2), 2), 10),
  ];
}

type TimePeriod = 'AM' | 'PM' | null;

export function getTimePeriod(value) {
  const lowercaseValue = value.toLowerCase();

  if (lowercaseValue.includes('p')) {
    return 'PM';
  }

  if (lowercaseValue.includes('a')) {
    return 'AM';
  }

  return null;
}

export function convertTo12Hour(
  hours,
  minutes,
  timePeriod,
  padHoursWithZero: <fim_suffix> = false,
) {
  let _hours = hours;
  let _minutes = minutes;
  let _timePeriod = timePeriod;

  if (hours > 24) {
    _hours = 12;
  }

  if (timePeriod === null) {
    _timePeriod = 'AM';
  }

  if (hours >= 12 && hours < 24 && timePeriod !== 'AM') {
    _timePeriod = 'PM';
  }

  if (minutes > 59) {
    _minutes = 0;
  }

  _hours = _hours % 12;
  _hours = _hours ? _hours : 12;

  return `${
    padHoursWithZero ? addLeadingZero(_hours) : _hours
  }:${addLeadingZero(_minutes)} ${_timePeriod}`;
}

export function convertTo24Hour(
  hours,
  minutes,
  timePeriod,
) {
  let _hours = hours;
  let _minutes = minutes;

  if (hours >= 0 && hours < 12 && timePeriod === 'PM') {
    _hours += 12;
  }

  if (hours > 23 || (hours === 12 && timePeriod === 'AM')) {
    _hours = 0;
  }

  if (minutes > 59) {
    _minutes = 0;
  }

  return `${addLeadingZero(_hours)}:${addLeadingZero(_minutes)}`;
}

function addLeadingZero(value) {
  return value < 10 ? '0' + value : value.toString();
}
<fim_middle>",correct,4249
boolean,boolean,87c45d173a88a8085fea7c65e036d9547bec5542,"<fim_prefix>/* eslint-disable @typescript-eslint/no-explicit-any,no-cond-assign,no-restricted-syntax,no-continue */
type EqualFn = (a, b) => boolean;

export const compareDates = (a, b) => a.getTime() === b.getTime();

export const compareRegexps = (a, b) =>
  a.source === b.source && a.flags === b.flags;

export const compareArrays = (a, b, equal) => {
  let l = a.length;
  if (l !== b.length) return false;

  while (l-- && equal(a[l], b[l]));

  return l === -1;
};

export const compareMaps = (a, b, equal) => {
  if (a.size !== b.size) return false;
  const it = a.entries();
  let i: any;

  while (!(i = it.next()).done) {
    if (!b.has(i.value[0]) || !equal(i.value[1], b.get(i.value[0]))) return false;
  }

  return true;
};

export const compareSets = (a, b) => {
  if (a.size !== b.size) return false;
  const it = a.values();
  let i: any;

  while (!(i = it.next()).done) {
    if (!b.has(i.value)) return false;
  }

  return true;
};

export const compareDataViews = (a, b) => {
  let l = a.byteLength;
  if (l !== b.byteLength) return false;

  while (l-- && a.getInt8(l) === b.getInt8(l));

  return l === -1;
};

export const compareArrayBuffers = (a, b) => {
  let l = a.length;
  if (l !== b.length) return false;

  while (l-- && a[l] === b[l]);

  return l === -1;
};

const { hasOwnProperty } = Object.prototype;
const oKeys = Object.keys;

export const compareObjects = (
  a,
  b,
  equal
) => {
  let i;
  let len = 0;

  for (i in a) {
    if (hasOwnProperty.call(a, i)) {
      len++;

      if (!hasOwnProperty.call(b, i)) return false;

      if (!equal(a[i], b[i])) return false;
    }
  }

  return oKeys(b).length === len;
};

export const compareObjectsReact = (
  a,
  b,
  equal
): <fim_suffix> => {
  let i;
  let len = 0;

  for (i in a) {
    if (hasOwnProperty.call(a, i)) {
      len++;
      if (a.$$typeof && (i === '_owner' || i === '__v' || i === '__o')) {
        // in React and Preact these properties contain circular references
        // .$$typeof is just reasonable marker of element

        continue;
      }

      if (!hasOwnProperty.call(b, i)) return false;

      if (!equal(a[i], b[i])) return false;
    }
  }

  return oKeys(b).length === len;
};
<fim_middle>",correct,4296
boolean,boolean,87c45d173a88a8085fea7c65e036d9547bec5542,"<fim_prefix>/* eslint-disable @typescript-eslint/no-explicit-any,no-cond-assign,no-restricted-syntax,no-continue */
type EqualFn = (a, b) => boolean;

export const compareDates = (a, b) => a.getTime() === b.getTime();

export const compareRegexps = (a, b) =>
  a.source === b.source && a.flags === b.flags;

export const compareArrays = (a, b, equal) => {
  let l = a.length;
  if (l !== b.length) return false;

  while (l-- && equal(a[l], b[l]));

  return l === -1;
};

export const compareMaps = (a, b, equal) => {
  if (a.size !== b.size) return false;
  const it = a.entries();
  let i: any;

  while (!(i = it.next()).done) {
    if (!b.has(i.value[0]) || !equal(i.value[1], b.get(i.value[0]))) return false;
  }

  return true;
};

export const compareSets = (a, b) => {
  if (a.size !== b.size) return false;
  const it = a.values();
  let i: any;

  while (!(i = it.next()).done) {
    if (!b.has(i.value)) return false;
  }

  return true;
};

export const compareDataViews = (a, b) => {
  let l = a.byteLength;
  if (l !== b.byteLength) return false;

  while (l-- && a.getInt8(l) === b.getInt8(l));

  return l === -1;
};

export const compareArrayBuffers = (a, b): <fim_suffix> => {
  let l = a.length;
  if (l !== b.length) return false;

  while (l-- && a[l] === b[l]);

  return l === -1;
};

const { hasOwnProperty } = Object.prototype;
const oKeys = Object.keys;

export const compareObjects = (
  a,
  b,
  equal
) => {
  let i;
  let len = 0;

  for (i in a) {
    if (hasOwnProperty.call(a, i)) {
      len++;

      if (!hasOwnProperty.call(b, i)) return false;

      if (!equal(a[i], b[i])) return false;
    }
  }

  return oKeys(b).length === len;
};

export const compareObjectsReact = (
  a,
  b,
  equal
) => {
  let i;
  let len = 0;

  for (i in a) {
    if (hasOwnProperty.call(a, i)) {
      len++;
      if (a.$$typeof && (i === '_owner' || i === '__v' || i === '__o')) {
        // in React and Preact these properties contain circular references
        // .$$typeof is just reasonable marker of element

        continue;
      }

      if (!hasOwnProperty.call(b, i)) return false;

      if (!equal(a[i], b[i])) return false;
    }
  }

  return oKeys(b).length === len;
};
<fim_middle>",correct,4304
never,never,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,121
never,never,ac7993dc0fe3c3108bad1cc9c13811b35d016e8a,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */


// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const vulnerabilityMetadata = Convert.toVulnerabilityMetadata(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeMeta {
  id: string;
  namespace: string;
  data_source: string;
  record_source: string;
  severity: Severity;
  urls: string;
  description: string;
  cvss: string;
}

export enum Severity {
  Critical = 'Critical',
  High = 'High',
  Low = 'Low',
  Medium = 'Medium',
  Negligible = 'Negligible',
  Unknown = 'Unknown',
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toVulnerabilityMetadata(json) {
    return cast(JSON.parse(json), a(r('VulnerabilityMetadata')));
  }

  public static jsonBlobToVulnerabilityMetadata(obj) {
    return cast(obj, a(r('VulnerabilityMetadata')));
  }

  public static vulnerabilityMetadataToJson(value) {
    return JSON.stringify(uncast(value, a(r('VulnerabilityMetadata'))), null, 2);
  }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function o(props, additional) {
  return { props, additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  VulnerabilityMetadata: o(
    [
      { json: 'id', js: 'id', typ: '' },
      { json: 'namespace', js: 'namespace', typ: '' },
      { json: 'data_source', js: 'data_source', typ: '' },
      { json: 'record_source', js: 'record_source', typ: '' },
      { json: 'severity', js: 'severity', typ: r('Severity') },
      { json: 'urls', js: 'urls', typ: '' },
      { json: 'description', js: 'description', typ: '' },
      { json: 'cvss', js: 'cvss', typ: '' },
    ],
    false
  ),
  Severity: ['Critical', 'High', 'Low', 'Medium', 'Negligible', 'Unknown'],
};
<fim_middle>",correct,1107
never,never,f5bc60d854a7bd1569ddc82cc00d26f8db08da22,"<fim_prefix>// To parse this data:
//
//   import { Convert, Tuf } from ""./file"";
//
//   const tuf = Convert.toTuf(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for TUF metadata entries
 */
export interface Tuf {
    /**
     * TUF metadata
     */
    metadata: Metadata;
    /**
     * root metadata containing about the public keys used to sign the manifest
     */
    root: Root;
    /**
     * TUF specification version
     */
    spec_version?: string;
}

/**
 * TUF metadata
 */
export interface Metadata {
    /**
     * Specifies the metadata inline within the document
     */
    content?: { [key: string]: any };
    metadata: any;
}

/**
 * root metadata containing about the public keys used to sign the manifest
 */
export interface Root {
    /**
     * Specifies the metadata inline within the document
     */
    content: { [key: string]: any };
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toTuf(json) {
        return cast(JSON.parse(json), r(""Tuf""));
    }

    public static tufToJson(value) {
        return JSON.stringify(uncast(value, r(""Tuf"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Tuf"": o([
        { json: ""metadata"", js: ""metadata"", typ: r(""Metadata"") },
        { json: ""root"", js: ""root"", typ: r(""Root"") },
        { json: ""spec_version"", js: ""spec_version"", typ: u(undefined, """") },
    ], ""any""),
    ""Metadata"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, m(""any"")) },
        { json: ""metadata"", js: ""metadata"", typ: ""any"" },
    ], ""any""),
    ""Root"": o([
        { json: ""content"", js: ""content"", typ: m(""any"") },
    ], ""any""),
};
<fim_middle>",correct,2438
never,never,d837f809f84085f664347857128c9a08596b58cc,"<fim_prefix>// To parse this data:
//
//   import { Convert, HashedRekord } from ""./file"";
//
//   const hashedRekord = Convert.toHashedRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Hashed Rekord object
 */
export interface HashedRekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content?: string;
    /**
     * The public key that can verify the signature
     */
    publicKey?: PublicKey;
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content?: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toHashedRekord(json) {
        return cast(JSON.parse(json), r(""HashedRekord""));
    }

    public static hashedRekordToJson(value) {
        return JSON.stringify(uncast(value, r(""HashedRekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""HashedRekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""publicKey"", js: ""publicKey"", typ: u(undefined, r(""PublicKey"")) },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3092
never,never,6c5d24a5d99d75f367877e7cca717ee288b6d93d,"<fim_prefix>// To parse this data:
//
//   import { Convert, Intoto } from ""./file"";
//
//   const intoto = Convert.toIntoto(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for intoto object
 */
export interface Intoto {
    content: Content;
    /**
     * The public key that can verify the signature
     */
    publicKey: string;
}

export interface Content {
    /**
     * envelope
     */
    envelope?: string;
    /**
     * Specifies the hash algorithm and value encompassing the entire signed envelope
     */
    hash?: Hash;
    /**
     * Specifies the hash algorithm and value covering the payload within the DSSE envelope
     */
    payloadHash?: PayloadHash;
}

/**
 * Specifies the hash algorithm and value encompassing the entire signed envelope
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the archive
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Specifies the hash algorithm and value covering the payload within the DSSE envelope
 */
export interface PayloadHash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the envelope's payload
     */
    value: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toIntoto(json) {
        return cast(JSON.parse(json), r(""Intoto""));
    }

    public static intotoToJson(value) {
        return JSON.stringify(uncast(value, r(""Intoto"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Intoto"": o([
        { json: ""content"", js: ""content"", typ: r(""Content"") },
        { json: ""publicKey"", js: ""publicKey"", typ: """" },
    ], ""any""),
    ""Content"": o([
        { json: ""envelope"", js: ""envelope"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
        { json: ""payloadHash"", js: ""payloadHash"", typ: u(undefined, r(""PayloadHash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""PayloadHash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
};
<fim_middle>",correct,3537
never,never,86981395b1f95d3beda99682c5bde85ff62ff1af,"<fim_prefix>// To parse this data:
//
//   import { Convert, Rfc3161 } from ""./file"";
//
//   const rfc3161 = Convert.toRfc3161(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for RFC3161 entries
 */
export interface Rfc3161 {
    /**
     * Information about the tsr file associated with the entry
     */
    tsr: TSR;
}

/**
 * Information about the tsr file associated with the entry
 */
export interface TSR {
    /**
     * Specifies the tsr file content inline within the document
     */
    content: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toRfc3161(json) {
        return cast(JSON.parse(json), r(""Rfc3161""));
    }

    public static rfc3161ToJson(value) {
        return JSON.stringify(uncast(value, r(""Rfc3161"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Rfc3161"": o([
        { json: ""tsr"", js: ""tsr"", typ: r(""TSR"") },
    ], ""any""),
    ""TSR"": o([
        { json: ""content"", js: ""content"", typ: """" },
    ], ""any""),
};
<fim_middle>",correct,3616
never,never,c345024143db0e7f2d60174bc07a582029bfedc5,"<fim_prefix>// To parse this data:
//
//   import { Convert, Rekord } from ""./file"";
//
//   const rekord = Convert.toRekord(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

/**
 * Schema for Rekord object
 */
export interface Rekord {
    /**
     * Information about the content associated with the entry
     */
    data: Data;
    /**
     * Information about the detached signature associated with the entry
     */
    signature: Signature;
}

/**
 * Information about the content associated with the entry
 */
export interface Data {
    /**
     * Specifies the content inline within the document
     */
    content?: string;
    /**
     * Specifies the hash algorithm and value for the content
     */
    hash?: Hash;
}

/**
 * Specifies the hash algorithm and value for the content
 */
export interface Hash {
    /**
     * The hashing function used to compute the hash value
     */
    algorithm: Algorithm;
    /**
     * The hash value for the content
     */
    value: string;
}

/**
 * The hashing function used to compute the hash value
 */
export enum Algorithm {
    Sha256 = ""sha256"",
}

/**
 * Information about the detached signature associated with the entry
 */
export interface Signature {
    /**
     * Specifies the content of the signature inline within the document
     */
    content: string;
    /**
     * Specifies the format of the signature
     */
    format: Format;
    /**
     * The public key that can verify the signature
     */
    publicKey: PublicKey;
}

/**
 * Specifies the format of the signature
 */
export enum Format {
    Minisign = ""minisign"",
    PGP = ""pgp"",
    SSH = ""ssh"",
    X509 = ""x509"",
}

/**
 * The public key that can verify the signature
 */
export interface PublicKey {
    /**
     * Specifies the content of the public key inline within the document
     */
    content: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
    public static toRekord(json) {
        return cast(JSON.parse(json), r(""Rekord""));
    }

    public static rekordToJson(value) {
        return JSON.stringify(uncast(value, r(""Rekord"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = transform(val[key], additional, getProps, key);
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function m(additional) {
    return { props: [], additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""Rekord"": o([
        { json: ""data"", js: ""data"", typ: r(""Data"") },
        { json: ""signature"", js: ""signature"", typ: r(""Signature"") },
    ], ""any""),
    ""Data"": o([
        { json: ""content"", js: ""content"", typ: u(undefined, """") },
        { json: ""hash"", js: ""hash"", typ: u(undefined, r(""Hash"")) },
    ], ""any""),
    ""Hash"": o([
        { json: ""algorithm"", js: ""algorithm"", typ: r(""Algorithm"") },
        { json: ""value"", js: ""value"", typ: """" },
    ], ""any""),
    ""Signature"": o([
        { json: ""content"", js: ""content"", typ: """" },
        { json: ""format"", js: ""format"", typ: r(""Format"") },
        { json: ""publicKey"", js: ""publicKey"", typ: r(""PublicKey"") },
    ], ""any""),
    ""PublicKey"": o([
        { json: ""content"", js: ""content"", typ: """" },
    ], ""any""),
    ""Algorithm"": [
        ""sha256"",
    ],
    ""Format"": [
        ""minisign"",
        ""pgp"",
        ""ssh"",
        ""x509"",
    ],
};
<fim_middle>",correct,3704
never,never,24999e29aa18a7e6c16f4de040738b69ba73f9fe,"<fim_prefix>/* eslint-disable curly */
/* eslint-disable @typescript-eslint/naming-convention */
// To parse this data:
//
//   import { Convert, SwiftPackageManifest } from ""./file"";
//
//   const swiftPackageManifest = SwiftPackageManifestParser.toSwiftPackageManifest(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface SwiftPackageManifest {
    name:         string;
    targets: SwiftTarget[];
    toolsVersion: ToolsVersion;
}

export interface SwiftTarget {
    name:  string;
    path?: null | string;
    type:  TargetType;
}

export enum TargetType {
    Executable = ""executable"",
    Regular = ""regular"",
    Test = ""test"",
    System = ""system"",
    Binary = ""binary"",
    Plugin = ""plugin"",
    Snippet = ""snippet"",
}

export interface ToolsVersion {
    _version: string;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class SwiftPackageManifestParser {
    public static toSwiftPackageManifest(json) {
        return cast(JSON.parse(json), r(""SwiftPackageManifest""));
    }

    public static swiftPackageManifestToJson(value) {
        return JSON.stringify(uncast(value, r(""SwiftPackageManifest"")), null, 2);
    }
}

function invalidValue(typ, val, key = ''): <fim_suffix> {
    if (key) {
        throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
    }
    throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`, );
}

function jsonToJSProps(typ) {
    if (typ.jsonToJS === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.json] = { key: p.js, typ: p.typ });
        typ.jsonToJS = map;
    }
    return typ.jsonToJS;
}

function jsToJSONProps(typ) {
    if (typ.jsToJSON === undefined) {
        const map: any = {};
        typ.props.forEach((p) => map[p.js] = { key: p.json, typ: p.typ });
        typ.jsToJSON = map;
    }
    return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
    function transformPrimitive(typ, val) {
        if (typeof typ === typeof val) return val;
        return invalidValue(typ, val, key);
    }

    function transformUnion(typs, val) {
        // val must validate against one typ in typs
        const l = typs.length;
        for (let i = 0; i < l; i++) {
            const typ = typs[i];
            try {
                return transform(val, typ, getProps);
            } catch (_) {}
        }
        return invalidValue(typs, val);
    }

    function transformEnum(cases, val) {
        if (cases.indexOf(val) !== -1) return val;
        return invalidValue(cases, val);
    }

    function transformArray(typ, val) {
        // val must be an array with no invalid elements
        if (!Array.isArray(val)) return invalidValue(""array"", val);
        return val.map(el => transform(el, typ, getProps));
    }

    function transformDate(val) {
        if (val === null) {
            return null;
        }
        const d = new Date(val);
        if (isNaN(d.valueOf())) {
            return invalidValue(""Date"", val);
        }
        return d;
    }

    function transformObject(props, additional, val) {
        if (val === null || typeof val !== ""object"" || Array.isArray(val)) {
            return invalidValue(""object"", val);
        }
        const result: any = {};
        Object.getOwnPropertyNames(props).forEach(key => {
            const prop = props[key];
            const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
            result[prop.key] = transform(v, prop.typ, getProps, prop.key);
        });
        Object.getOwnPropertyNames(val).forEach(key => {
            if (!Object.prototype.hasOwnProperty.call(props, key)) {
                result[key] = val[key];
            }
        });
        return result;
    }

    if (typ === ""any"") return val;
    if (typ === null) {
        if (val === null) return val;
        return invalidValue(typ, val);
    }
    if (typ === false) return invalidValue(typ, val);
    while (typeof typ === ""object"" && typ.ref !== undefined) {
        typ = typeMap[typ.ref];
    }
    if (Array.isArray(typ)) return transformEnum(typ, val);
    if (typeof typ === ""object"") {
        return typ.hasOwnProperty(""unionMembers"") ? transformUnion(typ.unionMembers, val)
            : typ.hasOwnProperty(""arrayItems"")    ? transformArray(typ.arrayItems, val)
            : typ.hasOwnProperty(""props"")         ? transformObject(getProps(typ), typ.additional, val)
            : invalidValue(typ, val);
    }
    // Numbers can be parsed by Date but shouldn't be.
    if (typ === Date && typeof val !== ""number"") return transformDate(val);
    return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
    return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
    return transform(val, typ, jsToJSONProps);
}

function a(typ) {
    return { arrayItems: typ };
}

function u(...typs) {
    return { unionMembers: typs };
}

function o(props, additional) {
    return { props, additional };
}

function r(name) {
    return { ref: name };
}

const typeMap: any = {
    ""SwiftPackageManifest"": o([
        { json: ""name"", js: ""name"", typ: """" },
        { json: ""targets"", js: ""targets"", typ: a(r(""SwiftTarget"")) },
        { json: ""toolsVersion"", js: ""toolsVersion"", typ: r(""ToolsVersion"") },
    ], false),
    ""SwiftTarget"": o([
        { json: ""name"", js: ""name"", typ: """" },
        { json: ""path"", js: ""path"", typ: u(undefined, u(null, """")) },
        { json: ""type"", js: ""type"", typ: r(""TargetType"") },
    ], false),
    ""ToolsVersion"": o([
        { json: ""_version"", js: ""_version"", typ: """" },
    ], false),
    ""TargetType"": [
        ""executable"",
        ""regular"",
        ""test"",
        ""system"",
        ""binary"",
        ""plugin"",
        ""snippet"",
    ],
};
<fim_middle>",correct,4511
number,number,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day: <fim_suffix>) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,0
number,number,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay: <fim_suffix>
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,3
number,number,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth: <fim_suffix>) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,14
number,number,56013b675d2c5276fca785f74daf84664803de98,"<fim_prefix>/*
 * @Author: your name
 * @Date: 2022-04-24 10:11:23
 * @LastEditTime: 2022-04-24 16:14:52
 * @LastEditors: Please set LastEditors
 * @Description: 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
 * @FilePath: /tinkerbell-ui-react/src/packages/DaysPicker/date/interface.ts
 */
//  props 天
export interface dayProps {
    year: number;
    month: number;
    active: number;
    change: Function;
    visible: boolean;
    monthRef: any;
    show: boolean;
    limit: boolean;
}
//  props 月
export interface monthProps {
    visible: boolean;
    active: number;
    change: Function;
    year: number;
    plateChange: Function;
    limit: boolean;
}
//  props 年
export interface yearProps {
    visible: boolean;
    active: number;
    change: Function;
    plateChange: Function;
    limit: boolean;
}

// pageday-item type
export type dayItem = {
    label: string;
    value: number;
    disabled: boolean; //禁用
    prev: boolean; // 是否属于上一月份
    next: boolean; // 是否属于上一月份
    week: number; // 星期下标
    weekLabel: string; // 星期明文
};

// pageMonth-item type
export type monthItem = {
    value: number;
    label: string;
    disabled: boolean;
};

// 年份
export function getYearList(year: <fim_suffix>, limit) {
    let list: Array<monthItem> = [];

    let newYear = new Date().getFullYear();
    let maxYear = year + 9;
    for (let i = year - 3; i < maxYear; i++) {
        list.push({
            value: i,
            label: `${i}`,
            disabled: i < newYear && limit,
        });
    }
    return list;
}

// 月份
export function getMonthList(year, limit) {
    let list: Array<monthItem> = [];
    for (let i = 1; i < 13; i++) {
        list.push({
            value: i,
            label: `${i}月`,
            disabled: checkDisabledMonth(year, i) && limit,
        });
    }
    return list;
}
// 月-禁用判定
function checkDisabledMonth(prevYear, prevMonth) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/01`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    const newTime = new Date(`${year}/${month}/01`).getTime();
    return prevTime < newTime;
}

// 日期对照月份表
const monthAsDay = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; //月份

// 星期列表
export const weekList = [""一"", ""二"", ""三"", ""四"", ""五"", ""六"", ""日""];

// 日-数据列表生成type:0当前月份，1上一月，2下一月
export function getDayList(
    year,
    month,
    type,
    limit
) {
    let list: Array<dayItem> = [];
    let max: number = year % 4 === 0 && month === 2 ? 1 : 0; // 闰年判定
    max = monthAsDay[month - 1] + max; // 定位月份

    for (let i = 0; i < max; i++) {
        let value = i + 1;
        let weekParam = checkWeek(year, month, value);
        list.push({
            label: value.toString(),
            value: value,
            disabled: checkDisabled(year, month, value) && limit,
            prev: type === 1,
            next: type === 2,
            week: weekParam.value,
            weekLabel: weekParam.label,
        });
    }
    if (type !== 0) {
        return list;
    } else {
        return dayListSupply(list, year, month, limit);
    }
}
// 日-数据按周补充
function dayListSupply(
    arr,
    year,
    month,
    limit
) {
    let prevList = getDayList(
        month === 1 ? year - 1 : year,
        month === 1 ? 12 : month - 1,
        1,
        limit
    );
    let nextList = getDayList(
        month === 12 ? year + 1 : year,
        month === 12 ? 1 : month + 1,
        2,
        limit
    );
    // 上月
    for (let i = prevList.length - 1; i > 0; i--) {
        if (prevList[i].week === 7) {
            break;
        }
        arr.unshift(prevList[i]);
    }
    // 下月
    for (let i = 0; i < nextList.length - 1; i++) {
        if (arr.length === 42) {
            break;
        }
        arr.push(nextList[i]);
    }
    return arr;
}

// 日-禁用判定
export function checkDisabled(
    prevYear,
    prevMonth,
    prevDay
) {
    const prevTime = new Date(`${prevYear}/${prevMonth}/${prevDay}`).getTime();
    const newDate = new Date();
    const year: number = newDate.getFullYear();
    let month: number = newDate.getMonth() + 1;
    let day: number = newDate.getDate();
    const newTime = new Date(`${year}/${month}/${day}`).getTime();
    return prevTime < newTime;
}

// 周期-判定星期几
function checkWeek(year, month, day) {
    let weekday = [
        ""星期日"",
        ""星期一"",
        ""星期二"",
        ""星期三"",
        ""星期四"",
        ""星期五"",
        ""星期六"",
    ];
    let newDate = new Date(`${year}/${month}/${day}`);
    let mark = newDate.getDay();

    return {
        value: mark === 0 ? 7 : mark,
        label: weekday[mark],
    };
}
<fim_middle>",correct,19
number,number,d136cbb659cd7f40984bcec5a5dcf88567bffb4d,"<fim_prefix>export type BookTitle = string;

const booksToChaptersMap: { [name: string]: number } = {
  Genesis: 50,
  Exodus: 40,
  Leviticus: 27,
  Numbers: 36,
  Deuteronomy: 34,
  Joshua: 24,
  Judges: 21,
  Ruth: 4,
  '1 Samuel': 31,
  '2 Samuel': 24,
  '1 Kings': 22,
  '2 Kings': 25,
  '1 Chronicles': 29,
  '2 Chronicles': 36,
  Ezra: 10,
  Nehemiah: 13,
  Esther: 10,
  Job: 42,
  Psalms: 150,
  Proverbs: 31,
  Ecclesiastes: 12,
  'Song of Solomon': 8,
  Isaiah: 66,
  Jeremiah: 52,
  Lamentations: 5,
  Ezekial: 48,
  Daniel: 12,
  Hosea: 14,
  Joel: 3,
  Amos: 9,
  Obadiah: 1,
  Jonah: 4,
  Micah: 7,
  Nahum: 3,
  Habakkuk: 3,
  Zephaniah: 3,
  Haggai: 2,
  Zechariah: 14,
  Malachi: 4,
  Matthew: 28,
  Mark: 16,
  Luke: 24,
  John: 21,
  Acts: 28,
  Romans: 16,
  '1 Corinthians': 16,
  '2 Corinthians': 13,
  Galatians: 6,
  Ephesians: 6,
  Philippians: 4,
  Colossians: 4,
  '1 Thessalonians': 5,
  '2 Thessalonians': 3,
  '1 Timothy': 6,
  '2 Timothy': 4,
  Titus: 3,
  Philemon: 1,
  Hebrews: 13,
  James: 5,
  '1 Peter': 5,
  '2 Peter': 3,
  '1 John': 5,
  '2 John': 1,
  '3 John': 1,
  Jude: 1,
  Revelation: 22,
};

const possibleTitles: string[] = Array.from(Object.keys(booksToChaptersMap));

let i = 0;
export const hebrewScriptures: BookInfo[] = possibleTitles
  .slice(0, 39)
  .map((x) => {
    i++;
    return { id: i, title: x, chapters: booksToChaptersMap[x] };
  });

export const newTestament: BookInfo[] = possibleTitles.slice(39).map((x) => {
  i++;
  return { id: i, title: x, chapters: booksToChaptersMap[x] };
});

export const getBookTitleFromSlug = (
  bookTitle,
) => {
  if (typeof bookTitle !== 'string') {
    throw new Error(`Booktitle ${bookTitle} is not even string`);
  }

  const found = possibleTitles.find(
    (x) => bookTitle === x.replace(' ', '-').toLowerCase(),
  );

  if (found === undefined) {
    throw new Error('There is not such book title:${bookParam}');
  }

  return found;
};

export const getChapterFromSlug = (
  chapter,
  book,
): <fim_suffix> => {
  if (isNaN(Number(chapter))) {
    throw new Error(`Chapter ""${chapter}"" is not a number`);
  }
  if (!Number.isInteger(Number(chapter))) {
    throw new Error(`Chapter ""${chapter}"" is not integer`);
  }
  if (Number(chapter) > booksToChaptersMap[book]) {
    throw new Error(`Chapter ""${chapter}"" is too hight`);
  }
  if (Number(chapter) < 1) {
    throw new Error(`Chapter ""${chapter}"" is too low`);
  }
  return Number(chapter);
};

export interface BookInfo {
  id: number;
  title: string;
  chapters: number;
}
<fim_middle>",correct,34
number,number,5015731de39d782d56f8a1e23bb6486643ab39bb,"<fim_prefix>interface IRowGenerateData {
	
	emailNotification: boolean | null;
	boxName: string;
	boxSensor: string;
	boxExposure: string;
	thresholdValue: string | number;
	date: Date;
	actions: string;
}




export function GetData(rowscount?, last?: <fim_suffix>, hasNullValues?) {
	const data: IRowGenerateData[] = new Array();

	if (rowscount === undefined) {
		rowscount = 100;
	}

	let startIndex = 0;

	if (last) {
		startIndex = rowscount;
		rowscount = last - rowscount;
	}

	const boxNames =
		[
			'PGKN FS02 - Rumphorst', 'BalkonBox Mindener Str.', 'BalkonBox Mindener Str.', 'Hoersterstr. 17', 'SteffenDroste', 'OC-WETTER', 'Fühlerbüchse', 'PGKN FS01 - Schule', 'KiTa Glühwürmchen', 'Westfälisches Pferdemuseum Münster', 'Hawerkamp 31', 'Martin', 'Botanischer Garten', 'Noise Sensor', 'CYBER Box', 'fancyBox3000', 'wullewup', 'Deipen4_A'
		];

	const boxSensors =
		[
			'Temperatur', 'rel. Luftfeuchte', 'Luftdruck', 'Beleuchtungsstärke', 'UV-Intensität', 'PM10', 'PM2.5'
		];

	const exposure =
		[
			'outdoor', 'indoor'
		];

	const actions =
		[
			'more than', 'less than'
		];

	const thresholdValues =
		[
			'2.25', '1.5', '3.0', '3.3', '4.5', '3.6', '3.8', '2.5', '5.0', '1.75', '3.25', '4.0'
		];

	for (let i = 0; i < rowscount; i++) {
		const row = {} as IRowGenerateData;

		const exposureindex = Math.floor(Math.random() * 2);
		const actionindex = Math.floor(Math.random() * actions.length);
		const thresholdValue = parseFloat(thresholdValues[exposureindex]);
		
		
		row.emailNotification = exposureindex % 2 === 0;

		if (hasNullValues === true) {
			if (exposureindex % 2 !== 0) {
				const random = Math.floor(Math.random() * rowscount);
				row.emailNotification = i % random === 0 ? null : false;
			}
		}

		row.boxName = boxNames[Math.floor(Math.random() * boxNames.length)];
		row.boxSensor = boxSensors[Math.floor(Math.random() * boxSensors.length)];
		row.boxExposure = exposure[exposureindex];
		row.actions = actions[actionindex];
		row.thresholdValue = thresholdValue;
		
		const date = new Date();
		date.setFullYear(2016, Math.floor(Math.random() * 11), Math.floor(Math.random() * 27));
		date.setHours(0, 0, 0, 0);
		row.date = date;

		data[i] = row;
	}

	return data;
}<fim_middle>",correct,42
number,number,5015731de39d782d56f8a1e23bb6486643ab39bb,"<fim_prefix>interface IRowGenerateData {
	
	emailNotification: boolean | null;
	boxName: string;
	boxSensor: string;
	boxExposure: string;
	thresholdValue: string | number;
	date: Date;
	actions: string;
}




export function GetData(rowscount?: <fim_suffix>, last?, hasNullValues?) {
	const data: IRowGenerateData[] = new Array();

	if (rowscount === undefined) {
		rowscount = 100;
	}

	let startIndex = 0;

	if (last) {
		startIndex = rowscount;
		rowscount = last - rowscount;
	}

	const boxNames =
		[
			'PGKN FS02 - Rumphorst', 'BalkonBox Mindener Str.', 'BalkonBox Mindener Str.', 'Hoersterstr. 17', 'SteffenDroste', 'OC-WETTER', 'Fühlerbüchse', 'PGKN FS01 - Schule', 'KiTa Glühwürmchen', 'Westfälisches Pferdemuseum Münster', 'Hawerkamp 31', 'Martin', 'Botanischer Garten', 'Noise Sensor', 'CYBER Box', 'fancyBox3000', 'wullewup', 'Deipen4_A'
		];

	const boxSensors =
		[
			'Temperatur', 'rel. Luftfeuchte', 'Luftdruck', 'Beleuchtungsstärke', 'UV-Intensität', 'PM10', 'PM2.5'
		];

	const exposure =
		[
			'outdoor', 'indoor'
		];

	const actions =
		[
			'more than', 'less than'
		];

	const thresholdValues =
		[
			'2.25', '1.5', '3.0', '3.3', '4.5', '3.6', '3.8', '2.5', '5.0', '1.75', '3.25', '4.0'
		];

	for (let i = 0; i < rowscount; i++) {
		const row = {} as IRowGenerateData;

		const exposureindex = Math.floor(Math.random() * 2);
		const actionindex = Math.floor(Math.random() * actions.length);
		const thresholdValue = parseFloat(thresholdValues[exposureindex]);
		
		
		row.emailNotification = exposureindex % 2 === 0;

		if (hasNullValues === true) {
			if (exposureindex % 2 !== 0) {
				const random = Math.floor(Math.random() * rowscount);
				row.emailNotification = i % random === 0 ? null : false;
			}
		}

		row.boxName = boxNames[Math.floor(Math.random() * boxNames.length)];
		row.boxSensor = boxSensors[Math.floor(Math.random() * boxSensors.length)];
		row.boxExposure = exposure[exposureindex];
		row.actions = actions[actionindex];
		row.thresholdValue = thresholdValue;
		
		const date = new Date();
		date.setFullYear(2016, Math.floor(Math.random() * 11), Math.floor(Math.random() * 27));
		date.setHours(0, 0, 0, 0);
		row.date = date;

		data[i] = row;
	}

	return data;
}<fim_middle>",correct,43
number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n: <fim_suffix>) {
  return new Num(n)
}
<fim_middle>",correct,135
number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?: <fim_suffix>) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,140
number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n: <fim_suffix>) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,142
number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money: <fim_suffix>) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,143
number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index: <fim_suffix>) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,144
number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?: <fim_suffix>) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,146
number,number,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money: <fim_suffix>, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,147
number,number,31a28792b3d0181850107c86d45571774a6ca9d7,"<fim_prefix>export type Vector1D = {
  get: () => number
  set: (v) => Vector1D
  add: (v) => Vector1D
  subtract: (v) => Vector1D
  multiply: (n) => Vector1D
  setNumber: (n) => Vector1D
  addNumber: (n) => Vector1D
  subtractNumber: (n) => Vector1D
  divide: (n) => Vector1D
  magnitude: () => number
  normalize: () => Vector1D
}

export function Vector1D(value) {
  const state = { value }

  function get() {
    return state.value
  }

  function set(v) {
    state.value = v.get()
    return self
  }

  function add(v) {
    state.value += v.get()
    return self
  }

  function subtract(v) {
    state.value -= v.get()
    return self
  }

  function multiply(n) {
    state.value *= n
    return self
  }

  function divide(n) {
    state.value /= n
    return self
  }

  function setNumber(n) {
    state.value = n
    return self
  }

  function addNumber(n) {
    state.value += n
    return self
  }

  function subtractNumber(n: <fim_suffix>) {
    state.value -= n
    return self
  }

  function magnitude() {
    return get()
  }

  function normalize() {
    const m = magnitude()
    if (m !== 0) divide(m)
    return self
  }

  const self: Vector1D = {
    add,
    addNumber,
    divide,
    get,
    magnitude,
    multiply,
    normalize,
    set,
    setNumber,
    subtract,
    subtractNumber,
  }
  return Object.freeze(self)
}
<fim_middle>",correct,173
number,number,31a28792b3d0181850107c86d45571774a6ca9d7,"<fim_prefix>export type Vector1D = {
  get: () => number
  set: (v) => Vector1D
  add: (v) => Vector1D
  subtract: (v) => Vector1D
  multiply: (n) => Vector1D
  setNumber: (n) => Vector1D
  addNumber: (n) => Vector1D
  subtractNumber: (n) => Vector1D
  divide: (n) => Vector1D
  magnitude: () => number
  normalize: () => Vector1D
}

export function Vector1D(value) {
  const state = { value }

  function get() {
    return state.value
  }

  function set(v) {
    state.value = v.get()
    return self
  }

  function add(v) {
    state.value += v.get()
    return self
  }

  function subtract(v) {
    state.value -= v.get()
    return self
  }

  function multiply(n) {
    state.value *= n
    return self
  }

  function divide(n) {
    state.value /= n
    return self
  }

  function setNumber(n) {
    state.value = n
    return self
  }

  function addNumber(n: <fim_suffix>) {
    state.value += n
    return self
  }

  function subtractNumber(n) {
    state.value -= n
    return self
  }

  function magnitude() {
    return get()
  }

  function normalize() {
    const m = magnitude()
    if (m !== 0) divide(m)
    return self
  }

  const self: Vector1D = {
    add,
    addNumber,
    divide,
    get,
    magnitude,
    multiply,
    normalize,
    set,
    setNumber,
    subtract,
    subtractNumber,
  }
  return Object.freeze(self)
}
<fim_middle>",correct,175
number,number,31a28792b3d0181850107c86d45571774a6ca9d7,"<fim_prefix>export type Vector1D = {
  get: () => number
  set: (v) => Vector1D
  add: (v) => Vector1D
  subtract: (v) => Vector1D
  multiply: (n) => Vector1D
  setNumber: (n) => Vector1D
  addNumber: (n) => Vector1D
  subtractNumber: (n) => Vector1D
  divide: (n) => Vector1D
  magnitude: () => number
  normalize: () => Vector1D
}

export function Vector1D(value) {
  const state = { value }

  function get() {
    return state.value
  }

  function set(v) {
    state.value = v.get()
    return self
  }

  function add(v) {
    state.value += v.get()
    return self
  }

  function subtract(v) {
    state.value -= v.get()
    return self
  }

  function multiply(n) {
    state.value *= n
    return self
  }

  function divide(n) {
    state.value /= n
    return self
  }

  function setNumber(n: <fim_suffix>) {
    state.value = n
    return self
  }

  function addNumber(n) {
    state.value += n
    return self
  }

  function subtractNumber(n) {
    state.value -= n
    return self
  }

  function magnitude() {
    return get()
  }

  function normalize() {
    const m = magnitude()
    if (m !== 0) divide(m)
    return self
  }

  const self: Vector1D = {
    add,
    addNumber,
    divide,
    get,
    magnitude,
    multiply,
    normalize,
    set,
    setNumber,
    subtract,
    subtractNumber,
  }
  return Object.freeze(self)
}
<fim_middle>",correct,177
number,number,31a28792b3d0181850107c86d45571774a6ca9d7,"<fim_prefix>export type Vector1D = {
  get: () => number
  set: (v) => Vector1D
  add: (v) => Vector1D
  subtract: (v) => Vector1D
  multiply: (n) => Vector1D
  setNumber: (n) => Vector1D
  addNumber: (n) => Vector1D
  subtractNumber: (n) => Vector1D
  divide: (n) => Vector1D
  magnitude: () => number
  normalize: () => Vector1D
}

export function Vector1D(value) {
  const state = { value }

  function get() {
    return state.value
  }

  function set(v) {
    state.value = v.get()
    return self
  }

  function add(v) {
    state.value += v.get()
    return self
  }

  function subtract(v) {
    state.value -= v.get()
    return self
  }

  function multiply(n) {
    state.value *= n
    return self
  }

  function divide(n: <fim_suffix>) {
    state.value /= n
    return self
  }

  function setNumber(n) {
    state.value = n
    return self
  }

  function addNumber(n) {
    state.value += n
    return self
  }

  function subtractNumber(n) {
    state.value -= n
    return self
  }

  function magnitude() {
    return get()
  }

  function normalize() {
    const m = magnitude()
    if (m !== 0) divide(m)
    return self
  }

  const self: Vector1D = {
    add,
    addNumber,
    divide,
    get,
    magnitude,
    multiply,
    normalize,
    set,
    setNumber,
    subtract,
    subtractNumber,
  }
  return Object.freeze(self)
}
<fim_middle>",correct,179
number,number,31a28792b3d0181850107c86d45571774a6ca9d7,"<fim_prefix>export type Vector1D = {
  get: () => number
  set: (v) => Vector1D
  add: (v) => Vector1D
  subtract: (v) => Vector1D
  multiply: (n) => Vector1D
  setNumber: (n) => Vector1D
  addNumber: (n) => Vector1D
  subtractNumber: (n) => Vector1D
  divide: (n) => Vector1D
  magnitude: () => number
  normalize: () => Vector1D
}

export function Vector1D(value: <fim_suffix>) {
  const state = { value }

  function get() {
    return state.value
  }

  function set(v) {
    state.value = v.get()
    return self
  }

  function add(v) {
    state.value += v.get()
    return self
  }

  function subtract(v) {
    state.value -= v.get()
    return self
  }

  function multiply(n) {
    state.value *= n
    return self
  }

  function divide(n) {
    state.value /= n
    return self
  }

  function setNumber(n) {
    state.value = n
    return self
  }

  function addNumber(n) {
    state.value += n
    return self
  }

  function subtractNumber(n) {
    state.value -= n
    return self
  }

  function magnitude() {
    return get()
  }

  function normalize() {
    const m = magnitude()
    if (m !== 0) divide(m)
    return self
  }

  const self: Vector1D = {
    add,
    addNumber,
    divide,
    get,
    magnitude,
    multiply,
    normalize,
    set,
    setNumber,
    subtract,
    subtractNumber,
  }
  return Object.freeze(self)
}
<fim_middle>",correct,190
number,number,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
): <fim_suffix> => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,215
number,number,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
): <fim_suffix> => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,218
number,number,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB
): <fim_suffix> => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,221
number,number,33b7ca5e8483474f1e5fef02a305e0919a37eae4,"<fim_prefix>export type SortMethod = 'YouTube+Twitch' | 'YouTube' | 'Twitch';

const YouTubeSubscriberCountDescendingSort = <
  T extends { hasYouTube: boolean; YouTubeSubscriberCount?: number }
>(
  rowA,
  rowB
): <fim_suffix> => {
  const aExist = rowA.hasYouTube;
  const bExist = rowB.hasYouTube;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.YouTubeSubscriberCount;
  const bCount = rowB.YouTubeSubscriberCount;

  if (aCount === undefined && bCount === undefined) return 0;

  if (bCount === undefined) return -1;

  if (aCount === undefined) return 1;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

const TwitchFollowerCountDescendingSort = <
  T extends { hasTwitch: boolean; TwitchFollowerCount: number }
>(
  rowA,
  rowB
) => {
  const aExist = rowA.hasTwitch;
  const bExist = rowB.hasTwitch;

  if (!aExist && !bExist) return 0;

  if (!bExist) return -1;

  if (!aExist) return 1;

  const aCount = rowA.TwitchFollowerCount;
  const bCount = rowB.TwitchFollowerCount;

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

// TODO: Merge the logic of descending and ascending functions
export const YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return -1;

  if (bCount > aCount) return 1;

  return 0;
};

export const YouTubeSubscriberCountPlusTwitchFollowerCountAscendingSort = <
  T extends { YouTubeSubscriberCount?: number; TwitchFollowerCount?: number }
>(
  rowA,
  rowB
) => {
  const aCount =
    (rowA.YouTubeSubscriberCount ?? 0) + (rowA.TwitchFollowerCount ?? 0);
  const bCount =
    (rowB.YouTubeSubscriberCount ?? 0) + (rowB.TwitchFollowerCount ?? 0);

  if (aCount > bCount) return 1;

  if (bCount > aCount) return -1;

  return 0;
};

export const SubscriberCountDescendingSort = (sortMethod) => {
  switch (sortMethod) {
    case 'YouTube+Twitch':
      return YouTubeSubscriberCountPlusTwitchFollowerCountDescendingSort;
    case 'YouTube':
      return YouTubeSubscriberCountDescendingSort;
    case 'Twitch':
      return TwitchFollowerCountDescendingSort;
  }
};
<fim_middle>",correct,224
number,number,3f56768763456223c2ba0b091b90831e3aa1b8b3,"<fim_prefix>/**
 * 边栏放置位置
 */
export enum SidePosition {
  left = 'left',
  right = 'right',
  top = 'top',
  bottom = 'bottom'
};

/**
 * 视图区域
 */
export enum ViewZone {
  top = 'top',
  bottom = 'bottom',
  side = 'side',
  main = 'main'
}

/**
 * 视图尺寸、位置
 */
export interface ViewBounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * 获取某个显示区域的bounds
 * @param zone
 * @param width
 * @param height
 * @param sidePosition
 */
export const getViewBounds = (zone, width, height, sidePosition?, sideWidth?) => {
  return calculateViewBounds(width, height, sidePosition, sideWidth).get(zone);
};

/**
 * 根据容器的尺寸计算所有显示区域的尺寸与位置
 * TODO：需要加上隐藏边栏的属性参数判断
 * @param width
 * @param height
 * @param sidePosition
 */
export const calculateViewBounds = (width, height, sidePosition?, sideWidth?: <fim_suffix>) => {
  const position: SidePosition = sidePosition || SidePosition.left;
  const _topHeight: number = 50;
  const _bottomHeight: number = 0;
  const _sideWidth: number = sideWidth || 50;
  const _mainHeight: number = height - _topHeight - _bottomHeight;
  let topBounds: ViewBounds = {x: 0, y: 0, width: width, height: _topHeight};
  let bottomBounds: ViewBounds = {x: 0, y: (height - _bottomHeight), width: width, height: _bottomHeight};
  let sideBounds: ViewBounds = {x: 0, y: 0, width: _sideWidth, height: _mainHeight };
  let mainBounds: ViewBounds = {x: 0, y: 0, width: width, height: _mainHeight};
  switch (position) {
    case SidePosition.left:
      sideBounds.y = topBounds.height;
      mainBounds.x = sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width -= mainBounds.x;
      break;
    case SidePosition.right:
      sideBounds.y = topBounds.height;
      sideBounds.x = width - sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width = sideBounds.x;
      break;
    case SidePosition.top:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      sideBounds.y = topBounds.height;
      mainBounds.height = height - topBounds.height - sideBounds.height - bottomBounds.height;
      mainBounds.y = topBounds.height + sideBounds.height;
      break;
    case SidePosition.bottom:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      mainBounds.y = topBounds.height;
      mainBounds.height -= sideBounds.height;
      sideBounds.y = topBounds.height + mainBounds.height;
      break;
  }
  return new Map([
    [ViewZone.top, topBounds],
    [ViewZone.bottom, bottomBounds],
    [ViewZone.side, sideBounds],
    [ViewZone.main, mainBounds]
  ]);
};
<fim_middle>",correct,239
number,number,3f56768763456223c2ba0b091b90831e3aa1b8b3,"<fim_prefix>/**
 * 边栏放置位置
 */
export enum SidePosition {
  left = 'left',
  right = 'right',
  top = 'top',
  bottom = 'bottom'
};

/**
 * 视图区域
 */
export enum ViewZone {
  top = 'top',
  bottom = 'bottom',
  side = 'side',
  main = 'main'
}

/**
 * 视图尺寸、位置
 */
export interface ViewBounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * 获取某个显示区域的bounds
 * @param zone
 * @param width
 * @param height
 * @param sidePosition
 */
export const getViewBounds = (zone, width, height, sidePosition?, sideWidth?) => {
  return calculateViewBounds(width, height, sidePosition, sideWidth).get(zone);
};

/**
 * 根据容器的尺寸计算所有显示区域的尺寸与位置
 * TODO：需要加上隐藏边栏的属性参数判断
 * @param width
 * @param height
 * @param sidePosition
 */
export const calculateViewBounds = (width, height: <fim_suffix>, sidePosition?, sideWidth?) => {
  const position: SidePosition = sidePosition || SidePosition.left;
  const _topHeight: number = 50;
  const _bottomHeight: number = 0;
  const _sideWidth: number = sideWidth || 50;
  const _mainHeight: number = height - _topHeight - _bottomHeight;
  let topBounds: ViewBounds = {x: 0, y: 0, width: width, height: _topHeight};
  let bottomBounds: ViewBounds = {x: 0, y: (height - _bottomHeight), width: width, height: _bottomHeight};
  let sideBounds: ViewBounds = {x: 0, y: 0, width: _sideWidth, height: _mainHeight };
  let mainBounds: ViewBounds = {x: 0, y: 0, width: width, height: _mainHeight};
  switch (position) {
    case SidePosition.left:
      sideBounds.y = topBounds.height;
      mainBounds.x = sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width -= mainBounds.x;
      break;
    case SidePosition.right:
      sideBounds.y = topBounds.height;
      sideBounds.x = width - sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width = sideBounds.x;
      break;
    case SidePosition.top:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      sideBounds.y = topBounds.height;
      mainBounds.height = height - topBounds.height - sideBounds.height - bottomBounds.height;
      mainBounds.y = topBounds.height + sideBounds.height;
      break;
    case SidePosition.bottom:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      mainBounds.y = topBounds.height;
      mainBounds.height -= sideBounds.height;
      sideBounds.y = topBounds.height + mainBounds.height;
      break;
  }
  return new Map([
    [ViewZone.top, topBounds],
    [ViewZone.bottom, bottomBounds],
    [ViewZone.side, sideBounds],
    [ViewZone.main, mainBounds]
  ]);
};
<fim_middle>",correct,241
number,number,3f56768763456223c2ba0b091b90831e3aa1b8b3,"<fim_prefix>/**
 * 边栏放置位置
 */
export enum SidePosition {
  left = 'left',
  right = 'right',
  top = 'top',
  bottom = 'bottom'
};

/**
 * 视图区域
 */
export enum ViewZone {
  top = 'top',
  bottom = 'bottom',
  side = 'side',
  main = 'main'
}

/**
 * 视图尺寸、位置
 */
export interface ViewBounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * 获取某个显示区域的bounds
 * @param zone
 * @param width
 * @param height
 * @param sidePosition
 */
export const getViewBounds = (zone, width, height, sidePosition?, sideWidth?: <fim_suffix>) => {
  return calculateViewBounds(width, height, sidePosition, sideWidth).get(zone);
};

/**
 * 根据容器的尺寸计算所有显示区域的尺寸与位置
 * TODO：需要加上隐藏边栏的属性参数判断
 * @param width
 * @param height
 * @param sidePosition
 */
export const calculateViewBounds = (width, height, sidePosition?, sideWidth?) => {
  const position: SidePosition = sidePosition || SidePosition.left;
  const _topHeight: number = 50;
  const _bottomHeight: number = 0;
  const _sideWidth: number = sideWidth || 50;
  const _mainHeight: number = height - _topHeight - _bottomHeight;
  let topBounds: ViewBounds = {x: 0, y: 0, width: width, height: _topHeight};
  let bottomBounds: ViewBounds = {x: 0, y: (height - _bottomHeight), width: width, height: _bottomHeight};
  let sideBounds: ViewBounds = {x: 0, y: 0, width: _sideWidth, height: _mainHeight };
  let mainBounds: ViewBounds = {x: 0, y: 0, width: width, height: _mainHeight};
  switch (position) {
    case SidePosition.left:
      sideBounds.y = topBounds.height;
      mainBounds.x = sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width -= mainBounds.x;
      break;
    case SidePosition.right:
      sideBounds.y = topBounds.height;
      sideBounds.x = width - sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width = sideBounds.x;
      break;
    case SidePosition.top:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      sideBounds.y = topBounds.height;
      mainBounds.height = height - topBounds.height - sideBounds.height - bottomBounds.height;
      mainBounds.y = topBounds.height + sideBounds.height;
      break;
    case SidePosition.bottom:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      mainBounds.y = topBounds.height;
      mainBounds.height -= sideBounds.height;
      sideBounds.y = topBounds.height + mainBounds.height;
      break;
  }
  return new Map([
    [ViewZone.top, topBounds],
    [ViewZone.bottom, bottomBounds],
    [ViewZone.side, sideBounds],
    [ViewZone.main, mainBounds]
  ]);
};
<fim_middle>",correct,244
number,number,3f56768763456223c2ba0b091b90831e3aa1b8b3,"<fim_prefix>/**
 * 边栏放置位置
 */
export enum SidePosition {
  left = 'left',
  right = 'right',
  top = 'top',
  bottom = 'bottom'
};

/**
 * 视图区域
 */
export enum ViewZone {
  top = 'top',
  bottom = 'bottom',
  side = 'side',
  main = 'main'
}

/**
 * 视图尺寸、位置
 */
export interface ViewBounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * 获取某个显示区域的bounds
 * @param zone
 * @param width
 * @param height
 * @param sidePosition
 */
export const getViewBounds = (zone, width, height: <fim_suffix>, sidePosition?, sideWidth?) => {
  return calculateViewBounds(width, height, sidePosition, sideWidth).get(zone);
};

/**
 * 根据容器的尺寸计算所有显示区域的尺寸与位置
 * TODO：需要加上隐藏边栏的属性参数判断
 * @param width
 * @param height
 * @param sidePosition
 */
export const calculateViewBounds = (width, height, sidePosition?, sideWidth?) => {
  const position: SidePosition = sidePosition || SidePosition.left;
  const _topHeight: number = 50;
  const _bottomHeight: number = 0;
  const _sideWidth: number = sideWidth || 50;
  const _mainHeight: number = height - _topHeight - _bottomHeight;
  let topBounds: ViewBounds = {x: 0, y: 0, width: width, height: _topHeight};
  let bottomBounds: ViewBounds = {x: 0, y: (height - _bottomHeight), width: width, height: _bottomHeight};
  let sideBounds: ViewBounds = {x: 0, y: 0, width: _sideWidth, height: _mainHeight };
  let mainBounds: ViewBounds = {x: 0, y: 0, width: width, height: _mainHeight};
  switch (position) {
    case SidePosition.left:
      sideBounds.y = topBounds.height;
      mainBounds.x = sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width -= mainBounds.x;
      break;
    case SidePosition.right:
      sideBounds.y = topBounds.height;
      sideBounds.x = width - sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width = sideBounds.x;
      break;
    case SidePosition.top:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      sideBounds.y = topBounds.height;
      mainBounds.height = height - topBounds.height - sideBounds.height - bottomBounds.height;
      mainBounds.y = topBounds.height + sideBounds.height;
      break;
    case SidePosition.bottom:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      mainBounds.y = topBounds.height;
      mainBounds.height -= sideBounds.height;
      sideBounds.y = topBounds.height + mainBounds.height;
      break;
  }
  return new Map([
    [ViewZone.top, topBounds],
    [ViewZone.bottom, bottomBounds],
    [ViewZone.side, sideBounds],
    [ViewZone.main, mainBounds]
  ]);
};
<fim_middle>",correct,246
number,number,3f56768763456223c2ba0b091b90831e3aa1b8b3,"<fim_prefix>/**
 * 边栏放置位置
 */
export enum SidePosition {
  left = 'left',
  right = 'right',
  top = 'top',
  bottom = 'bottom'
};

/**
 * 视图区域
 */
export enum ViewZone {
  top = 'top',
  bottom = 'bottom',
  side = 'side',
  main = 'main'
}

/**
 * 视图尺寸、位置
 */
export interface ViewBounds {
  x: number;
  y: number;
  width: number;
  height: number;
}

/**
 * 获取某个显示区域的bounds
 * @param zone
 * @param width
 * @param height
 * @param sidePosition
 */
export const getViewBounds = (zone, width: <fim_suffix>, height, sidePosition?, sideWidth?) => {
  return calculateViewBounds(width, height, sidePosition, sideWidth).get(zone);
};

/**
 * 根据容器的尺寸计算所有显示区域的尺寸与位置
 * TODO：需要加上隐藏边栏的属性参数判断
 * @param width
 * @param height
 * @param sidePosition
 */
export const calculateViewBounds = (width, height, sidePosition?, sideWidth?) => {
  const position: SidePosition = sidePosition || SidePosition.left;
  const _topHeight: number = 50;
  const _bottomHeight: number = 0;
  const _sideWidth: number = sideWidth || 50;
  const _mainHeight: number = height - _topHeight - _bottomHeight;
  let topBounds: ViewBounds = {x: 0, y: 0, width: width, height: _topHeight};
  let bottomBounds: ViewBounds = {x: 0, y: (height - _bottomHeight), width: width, height: _bottomHeight};
  let sideBounds: ViewBounds = {x: 0, y: 0, width: _sideWidth, height: _mainHeight };
  let mainBounds: ViewBounds = {x: 0, y: 0, width: width, height: _mainHeight};
  switch (position) {
    case SidePosition.left:
      sideBounds.y = topBounds.height;
      mainBounds.x = sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width -= mainBounds.x;
      break;
    case SidePosition.right:
      sideBounds.y = topBounds.height;
      sideBounds.x = width - sideBounds.width;
      mainBounds.y = topBounds.height;
      mainBounds.width = sideBounds.x;
      break;
    case SidePosition.top:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      sideBounds.y = topBounds.height;
      mainBounds.height = height - topBounds.height - sideBounds.height - bottomBounds.height;
      mainBounds.y = topBounds.height + sideBounds.height;
      break;
    case SidePosition.bottom:
      sideBounds.height = sideBounds.width;
      sideBounds.width = width;
      mainBounds.y = topBounds.height;
      mainBounds.height -= sideBounds.height;
      sideBounds.y = topBounds.height + mainBounds.height;
      break;
  }
  return new Map([
    [ViewZone.top, topBounds],
    [ViewZone.bottom, bottomBounds],
    [ViewZone.side, sideBounds],
    [ViewZone.main, mainBounds]
  ]);
};
<fim_middle>",correct,247
number,number,3fd36051e56b9451affaa4278b0bd7bb46f75155,"<fim_prefix>type propType = {
	user: string;
	text: string;
	number: string | undefined;
	base: string;
	accent: string;
	icon: boolean;
	flat: boolean;
};

function darken(color, percent: <fim_suffix>) {
	const num = parseInt(color.replace('#', ''), 16),
		amt = Math.round(2.55 * percent),
		R = (num >> 16) + amt,
		B = ((num >> 8) & 0x00ff) + amt,
		G = (num & 0x0000ff) + amt;
	return (
		'#' +
		(
			0x1000000 +
			(R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
			(B < 255 ? (B < 1 ? 0 : B) : 255) * 0x100 +
			(G < 255 ? (G < 1 ? 0 : G) : 255)
		)
			.toString(16)
			.slice(1)
	);
}

export default function standardTemplate(props) {
	function offsetText() {
		if (props.number) {
			if (parseInt(props.number, 10) < 10) {
				return '22';
			}
			if (
				parseInt(props.number, 10) >= 10 &&
				parseInt(props.number) < 100
			) {
				return '18';
			}
			if (
				parseInt(props.number) >= 100 &&
				parseInt(props.number) < 1000
			) {
				return '14';
			}
			if (
				parseInt(props.number) >= 100 &&
				parseInt(props.number) < 1000
			) {
				return '11';
			}
			if (
				parseInt(props.number) >= 1000 &&
				parseInt(props.number) < 10000
			) {
				return '10';
			}
			if (
				parseInt(props.number) >= 10000 &&
				parseInt(props.number) < 100000
			) {
				return '8';
			}
			if (
				parseInt(props.number) >= 100000 &&
				parseInt(props.number) < 999999
			) {
				return '4';
			}
			if (parseInt(props.number) > 999999) {
				return '16';
			}
		}
	}

	function isFlat(section) {
		if (props.flat != true) {
			return `<stop stop-color=""${darken(section, 20)}""
      offset=""0%""/>`;
		}
		return null;
	}

	const itsOverAMillion =
		props.number && parseInt(props.number) < 999999 ? props.number : '1M+';

	const icon =
		props.icon == true
			? `<svg x=""22""><path dominant-baseline=""middle"" fill=""${props.text}"" d=""M10 7.5a2.5 2.5 0 1 0 2.5 2.5A2.5 2.5 0 0 0 10 7.5zm0 7a4.5 4.5 0 1 1 4.5-4.5 4.5 4.5 0 0 1-4.5 4.5zM10 3C3 3 0 10 0 10s3 7 10 7 10-7 10-7-3-7-10-7z""/></svg>`
			: `<text fill=""${darken(props.text, 8)}""
              fill-opacity="".2"">
        <tspan x=""15"" y=""15"" aria-hidden=""true"">Views</tspan>
      </text>
      <text fill=""${props.text}"">
        <tspan x=""15"" y=""14.5"">Views</tspan>
      </text>`;
	return `<svg xmlns=""http://www.w3.org/2000/svg"" width=""115"" height=""20"">
  <title>${props.user} - ${props.number} Views</title>
  <defs>
    <linearGradient id=""text-fill"" x1=""50%"" y1=""0%"" x2=""50%"" y2=""100%"">
      ${isFlat(props.base)}
      <stop stop-color=""${props.base}"" offset=""100%""/>
    </linearGradient>
    <linearGradient id=""count-fill"" x1=""50%"" y1=""0%"" x2=""50%"" y2=""100%"">
      ${isFlat(props.accent)}
      <stop stop-color=""${props.accent}"" offset=""100%""/>
    </linearGradient>
  </defs>
   <g fill=""none"" fill-rule=""evenodd"">
    <g font-family=""'DejaVu Sans',Verdana,Geneva,sans-serif"" font-size=""11"">
      <path d=""M0,3 C0,1.3431 1.3552,0 3.02702703,0 L65,0 L65,20 L3.02702703,20 C1.3552,20 0,18.6569 0,17 L0,3 Z"" fill=""url(#text-fill)"" fill-rule=""nonzero""/>
      ${icon}
    </g>
    </g>
    <g transform=""translate(65)"" font-family=""'DejaVu Sans',Verdana,Geneva,sans-serif"" font-size=""11"">
      <path d=""M0 0h46.939C48.629 0 50 1.343 50 3v14c0 1.657-1.37 3-3.061 3H0V0z"" id=""state-bg"" fill=""url(#count-fill)"" fill-rule=""nonzero""/>
      <text fill=""${darken(props.text, 8)}""
      fill-opacity="".2"" aria-hidden=""true"">
        <tspan x=""${offsetText()}"" y=""15"">${itsOverAMillion}</tspan>
      </text>
      <text fill=""${props.text}"">
        <tspan x=""${offsetText()}"" y=""14.5"">${itsOverAMillion}</tspan>
      </text>
    </g>
</svg>`;
}
<fim_middle>",correct,251
number,number,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine: <fim_suffix>) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,260
number,number,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine: <fim_suffix>) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,262
number,number,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex: <fim_suffix>) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,268
number,number,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement): <fim_suffix> {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,270
number,number,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine: <fim_suffix>) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,274
number,number,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index : <fim_suffix>)  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,290
number,number,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState) : <fim_suffix> {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,294
number,number,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input) : <fim_suffix> {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,301
number,number,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input) : <fim_suffix> {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,306
number,number,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount: <fim_suffix> = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,315
number,number,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init: <fim_suffix> = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,350
number,number,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value: <fim_suffix>) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,370
number,number,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value: <fim_suffix>) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,380
number,number,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value: <fim_suffix>)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,428
number,number,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b: <fim_suffix>)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,431
number,number,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g: <fim_suffix>, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,432
number,number,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r: <fim_suffix>, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,433
number,number,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v: <fim_suffix>)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,435
number,number,38ecb036ee2a515af40d1ec36c6e8f3d62d34f83,"<fim_prefix>interface WrappingWord {
  current: string;
  done: string[];
  progress: {
    count: number;
    words: string[];
  };
}

const createWrappingWord = (current) => ({
  current,
  done: [],
  progress: {
    count: current.length + 1,
    words: [current],
  },
});

const oneSpace = 1;
const mergeWrappingWords =
  (width) =>
  (total, next) => {
    const newCount = next.current.length + total.progress.count + oneSpace;
    return newCount > width
      ? {
          current: next.current,
          done: [...total.done, total.progress.words.join(' ')],
          progress: {
            count: next.current.length + oneSpace,
            words: [next.current],
          },
        }
      : {
          current: next.current,
          done: total.done,
          progress: {
            count: newCount,
            words: [...total.progress.words, next.current],
          },
        };
  };

export const wrapWord = (width: <fim_suffix>, text) => {
  const words = text.split(' ').map(createWrappingWord);
  const result = words.reduce(mergeWrappingWords(width));

  const done =
    result.progress.words.length > 0
      ? [...result.done, result.progress.words.join(' ')]
      : result.done;
  return done.join('\n');
};

type MdLineType =
  | 'blockquote'
  | 'ordered-list'
  | 'unordered-list'
  | 'paragraph'
  | 'header'
  | 'table-row'
  | 'code-block'
  | 'horizontal-line';

const getMdLineType = (line) => {
  const trimmed = line.trim();
  if (trimmed.startsWith('#')) {
    return 'header';
  }
  if (trimmed.startsWith('>')) {
    return 'blockquote';
  }
  if (trimmed.startsWith('1.')) {
    return 'ordered-list';
  }
  if (trimmed.startsWith('---')) {
    return 'horizontal-line';
  }
  if (trimmed.startsWith('-')) {
    return 'unordered-list';
  }
  if (trimmed.includes('|')) {
    return 'table-row';
  }
  if (line.length !== trimmed.length) {
    return 'code-block';
  }
  return 'paragraph';
};

const maxLineP = 78;
const maxLineOther = 72;

/**
 * @see https://cirosantilli.com/markdown-style-guide/
 * @param text
 * @returns
 */
export const normalizeMdLine = (line) => {
  const lineType = getMdLineType(line);
  const keepLineAsIs =
    lineType === 'header' ||
    lineType === 'table-row' ||
    lineType === 'code-block' ||
    lineType === 'horizontal-line';
  if (keepLineAsIs) {
    return line;
  }
  if (lineType === 'paragraph') {
    return wrapWord(maxLineP, line);
  }

  const trimmed = line.trimStart();
  const nbOfLeadingSpaces = line.length - trimmed.length;
  const leadingSpaces = ' '.repeat(nbOfLeadingSpaces);
  if (lineType === 'unordered-list') {
    const ulText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    return `${leadingSpaces}- ${ulText}`;
  }
  if (lineType === 'ordered-list') {
    const olText = wrapWord(maxLineOther, trimmed.slice(2).trim());
    return `${leadingSpaces}1. ${olText}`;
  }
  if (lineType === 'blockquote') {
    const bqText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    const bqSplitted = bqText.split('\n');
    const bqPrefixed = bqSplitted.map((li) => `${leadingSpaces}> ${li}`);
    return bqPrefixed.join('\n');
  }

  throw new Error('should be a supported line type');
};
<fim_middle>",correct,444
number,number,38ecb036ee2a515af40d1ec36c6e8f3d62d34f83,"<fim_prefix>interface WrappingWord {
  current: string;
  done: string[];
  progress: {
    count: number;
    words: string[];
  };
}

const createWrappingWord = (current) => ({
  current,
  done: [],
  progress: {
    count: current.length + 1,
    words: [current],
  },
});

const oneSpace = 1;
const mergeWrappingWords =
  (width: <fim_suffix>) =>
  (total, next) => {
    const newCount = next.current.length + total.progress.count + oneSpace;
    return newCount > width
      ? {
          current: next.current,
          done: [...total.done, total.progress.words.join(' ')],
          progress: {
            count: next.current.length + oneSpace,
            words: [next.current],
          },
        }
      : {
          current: next.current,
          done: total.done,
          progress: {
            count: newCount,
            words: [...total.progress.words, next.current],
          },
        };
  };

export const wrapWord = (width, text) => {
  const words = text.split(' ').map(createWrappingWord);
  const result = words.reduce(mergeWrappingWords(width));

  const done =
    result.progress.words.length > 0
      ? [...result.done, result.progress.words.join(' ')]
      : result.done;
  return done.join('\n');
};

type MdLineType =
  | 'blockquote'
  | 'ordered-list'
  | 'unordered-list'
  | 'paragraph'
  | 'header'
  | 'table-row'
  | 'code-block'
  | 'horizontal-line';

const getMdLineType = (line) => {
  const trimmed = line.trim();
  if (trimmed.startsWith('#')) {
    return 'header';
  }
  if (trimmed.startsWith('>')) {
    return 'blockquote';
  }
  if (trimmed.startsWith('1.')) {
    return 'ordered-list';
  }
  if (trimmed.startsWith('---')) {
    return 'horizontal-line';
  }
  if (trimmed.startsWith('-')) {
    return 'unordered-list';
  }
  if (trimmed.includes('|')) {
    return 'table-row';
  }
  if (line.length !== trimmed.length) {
    return 'code-block';
  }
  return 'paragraph';
};

const maxLineP = 78;
const maxLineOther = 72;

/**
 * @see https://cirosantilli.com/markdown-style-guide/
 * @param text
 * @returns
 */
export const normalizeMdLine = (line) => {
  const lineType = getMdLineType(line);
  const keepLineAsIs =
    lineType === 'header' ||
    lineType === 'table-row' ||
    lineType === 'code-block' ||
    lineType === 'horizontal-line';
  if (keepLineAsIs) {
    return line;
  }
  if (lineType === 'paragraph') {
    return wrapWord(maxLineP, line);
  }

  const trimmed = line.trimStart();
  const nbOfLeadingSpaces = line.length - trimmed.length;
  const leadingSpaces = ' '.repeat(nbOfLeadingSpaces);
  if (lineType === 'unordered-list') {
    const ulText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    return `${leadingSpaces}- ${ulText}`;
  }
  if (lineType === 'ordered-list') {
    const olText = wrapWord(maxLineOther, trimmed.slice(2).trim());
    return `${leadingSpaces}1. ${olText}`;
  }
  if (lineType === 'blockquote') {
    const bqText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    const bqSplitted = bqText.split('\n');
    const bqPrefixed = bqSplitted.map((li) => `${leadingSpaces}> ${li}`);
    return bqPrefixed.join('\n');
  }

  throw new Error('should be a supported line type');
};
<fim_middle>",correct,448
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage: <fim_suffix>
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,454
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx: <fim_suffix>,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,455
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage: <fim_suffix>
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,458
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx: <fim_suffix>,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,459
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn: <fim_suffix>
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,464
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n: <fim_suffix>,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,465
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage): <fim_suffix> => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,466
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n, nPerPage: <fim_suffix>) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,467
number,number,fdc9189ec7b996193ecc113e362ffdc22f88d5cc,"<fim_prefix>/**
 * get the number of pages
 * @param  {[type]} n        total number of rows
 * @param  {[type]} nPerPage number of rows per page
 * @return {[type]}          number of pages
 */
export const getNPage = (n: <fim_suffix>, nPerPage) => {
  return Math.ceil(n / nPerPage);
};

interface GetPaginationReturn {
  idx: number;
  nPerPage: number;
  nPage: number;
}

export const getPagination = (
  n,
  nPerPageIn
) => {
  const nPerPage = nPerPageIn || 10;
  const nPage = getNPage(n, nPerPage);
  const idx = 1;

  return {
    idx,
    nPerPage,
    nPage
  };
};

/**
 * get list of page based on the index (-i means that there's a gap - we do not use null so that it can than be used as an index)
 * @param  {[type]} idx   the page on which the user id
 * @param  {[type]} nPage the total amount of pages
 * @return {[type]}       [1, null, idx - 1, idx, idx + 1, null, nPage]
 */
export const getPageTiles = (idx, nPage) => {
  if (idx < 1) {
    idx = 1;
  }

  if (idx > nPage) {
    idx = nPage;
  }

  const b1 = idx - 1;
  const b2 = idx + 1;

  // init array
  const arr = [idx];

  if (idx > 1) {
    arr.unshift(b1);
  }

  if (idx === nPage && nPage > 3) {
    arr.unshift(b1 - 1);
  }

  if (idx < nPage) {
    arr.push(b2);
  }

  if (idx === 1 && nPage > 3) {
    arr.push(3);
  }

  if (b1 > 2 && nPage > 4) {
    arr.unshift(-1);
  }

  if (b1 > 1) {
    arr.unshift(1);
  }

  if (b2 < nPage - 1 && nPage > 4) {
    arr.push(-2);
  }

  if (b2 < nPage) {
    arr.push(nPage);
  }

  return arr;
};

export const paginationBoundaries = (
  idx,
  nPerPage
) => {
  const start = (idx - 1) * nPerPage;
  const end = idx * nPerPage;

  return { start, end };
};

export const withPagination = <A>(
  data,
  idx,
  nPerPage
) => {
  const { start, end } = paginationBoundaries(idx, nPerPage);

  return data.slice(start, end);
};
<fim_middle>",correct,468
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance: <fim_suffix> = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,471
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance: <fim_suffix>)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,474
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance: <fim_suffix>, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,478
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last: <fim_suffix>, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,479
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first: <fim_suffix>, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,480
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance: <fim_suffix>)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,483
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2): <fim_suffix>
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,485
number,number,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2): <fim_suffix>
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified)
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,489
number,number,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue (): <fim_suffix> {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,510
number,number,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue (): <fim_suffix> {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,512
number,number,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors) {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode: <fim_suffix> = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,628
number,number,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors) {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode: <fim_suffix> = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,633
number,number,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors) {
    this.cors = !!cors;
  }

  json(body, statusCode: <fim_suffix> = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,635
number,number,2f9ed4c5926a0fcede392151f980e017c0c93acb,"<fim_prefix>interface WordCoord {
  start: number[]
  end: number[]
}

interface SearchResult {
  [k: string]: WordCoord | undefined
}

export default class WordSearch {
  // For searching in all 8 directions
  static directions: { row: number; col: number }[] = [
    { row: 0, col: 1 }, // left to right
    { row: 0, col: -1 }, // right to left
    { row: 1, col: 0 }, // top to bottom
    { row: -1, col: 0 }, // bottom to top
    { row: 1, col: 1 }, // top left to bottom right
    { row: 1, col: -1 }, // top right to bottom left
    { row: -1, col: 1 }, // bottom left to top right
    { row: -1, col: -1 }, // bottom right to top left
  ]

  private rowLen: number
  private colLen: number

  constructor(private grid = []) {
    this.rowLen = this.grid.length
    this.colLen = this.grid[0]?.length || 0
  }

  find(words) {
    const result: SearchResult = {}

    for (const word of words) {
      for (let row = 0; row < this.rowLen; row++) {
        for (let col = 0; col < this.colLen; col++) {
          if (!result[word]) {
            result[word] = this.findWord(word, row, col)
          }
        }
      }
    }

    return result
  }

  findWord(word, row, col: <fim_suffix>) {
    // Word is not found if the first letter doesn't match.
    if (this.grid[row][col] !== word[0]) {
      return
    }

    // Search in all directions starting from (row, col).
    for (const direction of WordSearch.directions) {
      let rowDir = row + direction.row
      let colDir = col + direction.col
      let i = 0

      // First letter is already checked, start searching from the second letter.
      for (i = 1; i < word.length; i++) {
        // Stop if out of bound.
        if (rowDir >= this.rowLen || rowDir < 0 || colDir >= this.colLen || colDir < 0) {
          break
        }

        // Stop if letter doesn't match.
        if (this.grid[rowDir][colDir] !== word[i]) {
          break
        }

        // Move in particular direction.
        rowDir += direction.row
        colDir += direction.col
      }

      // If all letters matched then value of i is equal to the length of the word.
      if (i === word.length) {
        // Result should be in math indexes which start from (1, 1).
        // So we need to add 1 to indexes but it depends on direction in which word was found.
        const rowAdd = 1 - direction.row
        const colAdd = 1 - direction.col

        return {
          start: [row + 1, col + 1],
          end: [rowDir + rowAdd, colDir + colAdd],
        }
      }
    }
  }
}
<fim_middle>",correct,640
number,number,e91a96aa1ed7352799ddb4e0d1ecdd24fe548d74,"<fim_prefix>/**
 * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.
 * 
 * ```js
 * // Yields ` orange `;
 * between(`apple orange melon`, `apple`, `melon`);
 * ```
 * @param source Source text 
 * @param start Start match
 * @param end If undefined, `start` will be used instead
 * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.
 * @returns 
 */
export const between = (source, start, end?, lastEndMatch = true) => {
  const startPos = source.indexOf(start);
  if (startPos < 0) return;

  if (end === undefined) end = start;

  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos+1);
  if (endPos < 0) return;

  return source.substring(startPos+1, endPos);
};

/**
 * Returns first position of the given character code, or -1 if not found.
 * @param source Source string
 * @param code Code to seek
 * @param start Start index, 0 by default
 * @param end End index (inclusive), source.length-1 by default
 * @returns Found position, or -1 if not found
 */
export const indexOfCharCode = (source, code, start = 0, end = source.length-1) => {
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i=start;i<=end;i++) {
    if (source.charCodeAt(i) === code) return i;
  }
  return -1;
};

/**
 * Returns `source` with chars removed at `removeStart` position
 * ```js
 * omitChars(`hello there`, 1, 3);
 * // Yields: `ho there`
 * ```
 * @param source 
 * @param removeStart Start point to remove
 * @param removeLength Number of characters to remove 
 * @returns 
 */
export const omitChars = (source, removeStart, removeLength) =>  source.substring(0, removeStart) + source.substring(removeStart+removeLength);

/**
 * Splits a string into `length`-size chunks.
 * 
 * If `length` is greater than the length of `source`, a single element array is returned with source.
 * The final array element may be smaller if we ran out of characters.
 * 
 * ```js
 * splitByLength(`hello there`, 2);
 * // Yields:
 * // [`he`, `ll`, `o `, `th`, `er`, `e`]
 * ```
 * @param source Source string
 * @param length Length of each chunk
 * @returns 
 */
export const splitByLength = (source, length: <fim_suffix>) => {
  const chunks = Math.ceil(source.length/length);
  const ret:string[] = [];
  //eslint-disable-next-line functional/no-let
  let start = 0;

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let  
  for (let c=0;c<chunks;c++) {
    //eslint-disable-next-line functional/immutable-data
    ret.push(source.substring(start, start+length));
    start += length;
  }
  return ret;
};

/**
 * Returns the `source` string up until (and excluding) `match`. If match is not
 * found, all of `source` is returned.
 * 
 * ```js
 * // Yields `apple `
 * untilMarch(`apple orange melon`, `orange`);
 * ```
 * @param source 
 * @param match 
 * @param startPos If provided, gives the starting offset. Default 0
 */
export const untilMatch = (source, match, startPos = 0) => {
  if (startPos > source.length) throw new Error(`startPos should be less than length`);
  const m = source.indexOf(match, startPos);
  
  if (m < 0) return source;
  return source.substring(startPos, m);
};

/**
 * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.
 * ```js
 * unwrap(""'hello'"", ""'"");        // hello
 * unwrap(""apple"", ""a"");          // apple
 * unwrap(""wow"", ""w"");            // o
 * unwrap(`""'blah'""`, '""', ""'"");  // blah
 * ```
 * @param source 
 * @param wrappers 
 * @returns 
 */
export const unwrap = (source, ...wrappers) => {
  //eslint-disable-next-line functional/no-let
  let matched = false;
  //eslint-disable-next-line functional/no-loop-statement
  do {
    matched = false;
    //eslint-disable-next-line functional/no-loop-statement
    for (const w of wrappers) {
      if (source.startsWith(w) && source.endsWith(w)) {
        source = source.substring(w.length, source.length - (w.length * 2) + 1);
        matched = true;
      }
    }
  } while (matched);

  return source;
};

/**
 * A range
 */
export type Range = {
  /**
   * Text of range
   */
  readonly text: string
  /**
   * Start position, with respect to source text
   */
   readonly start: number
  /**
   * End position, with respect to source text
   */
   readonly end: number
  /**
   * Index of range. First range is 0
   */
   readonly index: number
}

export type LineSpan = {
  readonly start: number
  readonly end: number
  readonly length: number
}

/**
 * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.
 * 
 * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.
 * 
 * @param ranges Ranges
 * @param start Start character position, in source text reference
 * @param end End character position, in source text reference
 * @returns Span
 */
export const lineSpan = (ranges, start, end) => {
  //eslint-disable-next-line functional/no-let
  let s = -1;
  //eslint-disable-next-line functional/no-let
  let e = -1;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < ranges.length; i++) {
    const r = ranges[i];
    s = i;
    if (r.text.length === 0) continue;
    if (start < r.end) {
      break;
    }
  }

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = s; i < ranges.length; i++) {
    const r = ranges[i];
    e = i;
    if (end === r.end) {
      e = i + 1;
      break;
    }
    if (end < r.end) {
      break;
    }
  }
  return {length: e - s, start: s, end: e};
};

/**
 * Splits a source string into ranges:
 * ```js
 * const ranges = splitRanges(""hello;there;fella"", "";"");
 * ```
 * 
 * Each range consists of:
 * ```js
 * { 
 *  text: string  - the text of range
 *  start: number - start pos of range, wrt to source
 *  end: number   - end pos of range, wrt to source
 *  index: number - index of range (starting at 0)
 * }
 * ```
 * @param source 
 * @param split 
 * @returns 
 */
export const splitRanges = (source, split) => {
  //eslint-disable-next-line functional/no-let
  let start = 0;
  //eslint-disable-next-line functional/no-let
  let text = ``;
  const ranges: Range[] = [];
  //eslint-disable-next-line functional/no-let
  let index = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (source.indexOf(split, i) === i) {
      //eslint-disable-next-line functional/no-let
      const end = i;
      //eslint-disable-next-line functional/immutable-data
      ranges.push({
        text, start, end, index
      });
      start = end + 1;
      text = ``;
      index++;
    } else {
      text += source.charAt(i);
    }
  }
  if (start < source.length) {
    //eslint-disable-next-line functional/immutable-data
    ranges.push({text, start, index, end: source.length});
  }
  return ranges;
};

/**
 * Counts the number of times one of `chars` appears at the front of
 * a string, contiguously.
 * 
 * ```js
 * countCharsFromStart(`  hi`, ` `); // 2
 * countCharsFromStart(`hi  `, ` `); // 0
 * countCharsFromStart(`  hi  `, ` `); // 2
 * ```
 * @param source 
 * @param chars 
 * @returns 
 */
export const countCharsFromStart = (source, ...chars) => {
  //eslint-disable-next-line functional/no-let
  let counted = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (chars.includes(source.charAt(i))) {
      counted++;
    } else {
      break;
    }
  }
  return counted;
};

/**
 * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.
 * If _end_ is omitted, the the `start` value will be used.
 * 
 * ```js
 * startsEnds(`This is a string`, `This`, `string`); // True
 * startsEnds(`This is a string`, `is`, `a`); // False
 * starsEnds(`test`, `t`); // True, starts and ends with 't'
 * ```
 * @param source String to search within 
 * @param start Start
 * @param end End (if omitted, start will be looked for at end as well)
 * @returns True if source starts and ends with provided values.
 */
export const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);

//eslint-disable-next-line no-useless-escape
export const htmlEntities = (source) => source.replace(/[\u00A0-\u9999<>\&]/g, i => `&#${i.charCodeAt(0)};`);<fim_middle>",correct,755
number,number,e91a96aa1ed7352799ddb4e0d1ecdd24fe548d74,"<fim_prefix>/**
 * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.
 * 
 * ```js
 * // Yields ` orange `;
 * between(`apple orange melon`, `apple`, `melon`);
 * ```
 * @param source Source text 
 * @param start Start match
 * @param end If undefined, `start` will be used instead
 * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.
 * @returns 
 */
export const between = (source, start, end?, lastEndMatch = true) => {
  const startPos = source.indexOf(start);
  if (startPos < 0) return;

  if (end === undefined) end = start;

  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos+1);
  if (endPos < 0) return;

  return source.substring(startPos+1, endPos);
};

/**
 * Returns first position of the given character code, or -1 if not found.
 * @param source Source string
 * @param code Code to seek
 * @param start Start index, 0 by default
 * @param end End index (inclusive), source.length-1 by default
 * @returns Found position, or -1 if not found
 */
export const indexOfCharCode = (source, code, start = 0, end = source.length-1) => {
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i=start;i<=end;i++) {
    if (source.charCodeAt(i) === code) return i;
  }
  return -1;
};

/**
 * Returns `source` with chars removed at `removeStart` position
 * ```js
 * omitChars(`hello there`, 1, 3);
 * // Yields: `ho there`
 * ```
 * @param source 
 * @param removeStart Start point to remove
 * @param removeLength Number of characters to remove 
 * @returns 
 */
export const omitChars = (source, removeStart, removeLength: <fim_suffix>) =>  source.substring(0, removeStart) + source.substring(removeStart+removeLength);

/**
 * Splits a string into `length`-size chunks.
 * 
 * If `length` is greater than the length of `source`, a single element array is returned with source.
 * The final array element may be smaller if we ran out of characters.
 * 
 * ```js
 * splitByLength(`hello there`, 2);
 * // Yields:
 * // [`he`, `ll`, `o `, `th`, `er`, `e`]
 * ```
 * @param source Source string
 * @param length Length of each chunk
 * @returns 
 */
export const splitByLength = (source, length) => {
  const chunks = Math.ceil(source.length/length);
  const ret:string[] = [];
  //eslint-disable-next-line functional/no-let
  let start = 0;

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let  
  for (let c=0;c<chunks;c++) {
    //eslint-disable-next-line functional/immutable-data
    ret.push(source.substring(start, start+length));
    start += length;
  }
  return ret;
};

/**
 * Returns the `source` string up until (and excluding) `match`. If match is not
 * found, all of `source` is returned.
 * 
 * ```js
 * // Yields `apple `
 * untilMarch(`apple orange melon`, `orange`);
 * ```
 * @param source 
 * @param match 
 * @param startPos If provided, gives the starting offset. Default 0
 */
export const untilMatch = (source, match, startPos = 0) => {
  if (startPos > source.length) throw new Error(`startPos should be less than length`);
  const m = source.indexOf(match, startPos);
  
  if (m < 0) return source;
  return source.substring(startPos, m);
};

/**
 * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.
 * ```js
 * unwrap(""'hello'"", ""'"");        // hello
 * unwrap(""apple"", ""a"");          // apple
 * unwrap(""wow"", ""w"");            // o
 * unwrap(`""'blah'""`, '""', ""'"");  // blah
 * ```
 * @param source 
 * @param wrappers 
 * @returns 
 */
export const unwrap = (source, ...wrappers) => {
  //eslint-disable-next-line functional/no-let
  let matched = false;
  //eslint-disable-next-line functional/no-loop-statement
  do {
    matched = false;
    //eslint-disable-next-line functional/no-loop-statement
    for (const w of wrappers) {
      if (source.startsWith(w) && source.endsWith(w)) {
        source = source.substring(w.length, source.length - (w.length * 2) + 1);
        matched = true;
      }
    }
  } while (matched);

  return source;
};

/**
 * A range
 */
export type Range = {
  /**
   * Text of range
   */
  readonly text: string
  /**
   * Start position, with respect to source text
   */
   readonly start: number
  /**
   * End position, with respect to source text
   */
   readonly end: number
  /**
   * Index of range. First range is 0
   */
   readonly index: number
}

export type LineSpan = {
  readonly start: number
  readonly end: number
  readonly length: number
}

/**
 * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.
 * 
 * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.
 * 
 * @param ranges Ranges
 * @param start Start character position, in source text reference
 * @param end End character position, in source text reference
 * @returns Span
 */
export const lineSpan = (ranges, start, end) => {
  //eslint-disable-next-line functional/no-let
  let s = -1;
  //eslint-disable-next-line functional/no-let
  let e = -1;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < ranges.length; i++) {
    const r = ranges[i];
    s = i;
    if (r.text.length === 0) continue;
    if (start < r.end) {
      break;
    }
  }

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = s; i < ranges.length; i++) {
    const r = ranges[i];
    e = i;
    if (end === r.end) {
      e = i + 1;
      break;
    }
    if (end < r.end) {
      break;
    }
  }
  return {length: e - s, start: s, end: e};
};

/**
 * Splits a source string into ranges:
 * ```js
 * const ranges = splitRanges(""hello;there;fella"", "";"");
 * ```
 * 
 * Each range consists of:
 * ```js
 * { 
 *  text: string  - the text of range
 *  start: number - start pos of range, wrt to source
 *  end: number   - end pos of range, wrt to source
 *  index: number - index of range (starting at 0)
 * }
 * ```
 * @param source 
 * @param split 
 * @returns 
 */
export const splitRanges = (source, split) => {
  //eslint-disable-next-line functional/no-let
  let start = 0;
  //eslint-disable-next-line functional/no-let
  let text = ``;
  const ranges: Range[] = [];
  //eslint-disable-next-line functional/no-let
  let index = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (source.indexOf(split, i) === i) {
      //eslint-disable-next-line functional/no-let
      const end = i;
      //eslint-disable-next-line functional/immutable-data
      ranges.push({
        text, start, end, index
      });
      start = end + 1;
      text = ``;
      index++;
    } else {
      text += source.charAt(i);
    }
  }
  if (start < source.length) {
    //eslint-disable-next-line functional/immutable-data
    ranges.push({text, start, index, end: source.length});
  }
  return ranges;
};

/**
 * Counts the number of times one of `chars` appears at the front of
 * a string, contiguously.
 * 
 * ```js
 * countCharsFromStart(`  hi`, ` `); // 2
 * countCharsFromStart(`hi  `, ` `); // 0
 * countCharsFromStart(`  hi  `, ` `); // 2
 * ```
 * @param source 
 * @param chars 
 * @returns 
 */
export const countCharsFromStart = (source, ...chars) => {
  //eslint-disable-next-line functional/no-let
  let counted = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (chars.includes(source.charAt(i))) {
      counted++;
    } else {
      break;
    }
  }
  return counted;
};

/**
 * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.
 * If _end_ is omitted, the the `start` value will be used.
 * 
 * ```js
 * startsEnds(`This is a string`, `This`, `string`); // True
 * startsEnds(`This is a string`, `is`, `a`); // False
 * starsEnds(`test`, `t`); // True, starts and ends with 't'
 * ```
 * @param source String to search within 
 * @param start Start
 * @param end End (if omitted, start will be looked for at end as well)
 * @returns True if source starts and ends with provided values.
 */
export const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);

//eslint-disable-next-line no-useless-escape
export const htmlEntities = (source) => source.replace(/[\u00A0-\u9999<>\&]/g, i => `&#${i.charCodeAt(0)};`);<fim_middle>",correct,757
number,number,e91a96aa1ed7352799ddb4e0d1ecdd24fe548d74,"<fim_prefix>/**
 * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.
 * 
 * ```js
 * // Yields ` orange `;
 * between(`apple orange melon`, `apple`, `melon`);
 * ```
 * @param source Source text 
 * @param start Start match
 * @param end If undefined, `start` will be used instead
 * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.
 * @returns 
 */
export const between = (source, start, end?, lastEndMatch = true) => {
  const startPos = source.indexOf(start);
  if (startPos < 0) return;

  if (end === undefined) end = start;

  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos+1);
  if (endPos < 0) return;

  return source.substring(startPos+1, endPos);
};

/**
 * Returns first position of the given character code, or -1 if not found.
 * @param source Source string
 * @param code Code to seek
 * @param start Start index, 0 by default
 * @param end End index (inclusive), source.length-1 by default
 * @returns Found position, or -1 if not found
 */
export const indexOfCharCode = (source, code, start = 0, end = source.length-1) => {
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i=start;i<=end;i++) {
    if (source.charCodeAt(i) === code) return i;
  }
  return -1;
};

/**
 * Returns `source` with chars removed at `removeStart` position
 * ```js
 * omitChars(`hello there`, 1, 3);
 * // Yields: `ho there`
 * ```
 * @param source 
 * @param removeStart Start point to remove
 * @param removeLength Number of characters to remove 
 * @returns 
 */
export const omitChars = (source, removeStart: <fim_suffix>, removeLength) =>  source.substring(0, removeStart) + source.substring(removeStart+removeLength);

/**
 * Splits a string into `length`-size chunks.
 * 
 * If `length` is greater than the length of `source`, a single element array is returned with source.
 * The final array element may be smaller if we ran out of characters.
 * 
 * ```js
 * splitByLength(`hello there`, 2);
 * // Yields:
 * // [`he`, `ll`, `o `, `th`, `er`, `e`]
 * ```
 * @param source Source string
 * @param length Length of each chunk
 * @returns 
 */
export const splitByLength = (source, length) => {
  const chunks = Math.ceil(source.length/length);
  const ret:string[] = [];
  //eslint-disable-next-line functional/no-let
  let start = 0;

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let  
  for (let c=0;c<chunks;c++) {
    //eslint-disable-next-line functional/immutable-data
    ret.push(source.substring(start, start+length));
    start += length;
  }
  return ret;
};

/**
 * Returns the `source` string up until (and excluding) `match`. If match is not
 * found, all of `source` is returned.
 * 
 * ```js
 * // Yields `apple `
 * untilMarch(`apple orange melon`, `orange`);
 * ```
 * @param source 
 * @param match 
 * @param startPos If provided, gives the starting offset. Default 0
 */
export const untilMatch = (source, match, startPos = 0) => {
  if (startPos > source.length) throw new Error(`startPos should be less than length`);
  const m = source.indexOf(match, startPos);
  
  if (m < 0) return source;
  return source.substring(startPos, m);
};

/**
 * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.
 * ```js
 * unwrap(""'hello'"", ""'"");        // hello
 * unwrap(""apple"", ""a"");          // apple
 * unwrap(""wow"", ""w"");            // o
 * unwrap(`""'blah'""`, '""', ""'"");  // blah
 * ```
 * @param source 
 * @param wrappers 
 * @returns 
 */
export const unwrap = (source, ...wrappers) => {
  //eslint-disable-next-line functional/no-let
  let matched = false;
  //eslint-disable-next-line functional/no-loop-statement
  do {
    matched = false;
    //eslint-disable-next-line functional/no-loop-statement
    for (const w of wrappers) {
      if (source.startsWith(w) && source.endsWith(w)) {
        source = source.substring(w.length, source.length - (w.length * 2) + 1);
        matched = true;
      }
    }
  } while (matched);

  return source;
};

/**
 * A range
 */
export type Range = {
  /**
   * Text of range
   */
  readonly text: string
  /**
   * Start position, with respect to source text
   */
   readonly start: number
  /**
   * End position, with respect to source text
   */
   readonly end: number
  /**
   * Index of range. First range is 0
   */
   readonly index: number
}

export type LineSpan = {
  readonly start: number
  readonly end: number
  readonly length: number
}

/**
 * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.
 * 
 * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.
 * 
 * @param ranges Ranges
 * @param start Start character position, in source text reference
 * @param end End character position, in source text reference
 * @returns Span
 */
export const lineSpan = (ranges, start, end) => {
  //eslint-disable-next-line functional/no-let
  let s = -1;
  //eslint-disable-next-line functional/no-let
  let e = -1;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < ranges.length; i++) {
    const r = ranges[i];
    s = i;
    if (r.text.length === 0) continue;
    if (start < r.end) {
      break;
    }
  }

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = s; i < ranges.length; i++) {
    const r = ranges[i];
    e = i;
    if (end === r.end) {
      e = i + 1;
      break;
    }
    if (end < r.end) {
      break;
    }
  }
  return {length: e - s, start: s, end: e};
};

/**
 * Splits a source string into ranges:
 * ```js
 * const ranges = splitRanges(""hello;there;fella"", "";"");
 * ```
 * 
 * Each range consists of:
 * ```js
 * { 
 *  text: string  - the text of range
 *  start: number - start pos of range, wrt to source
 *  end: number   - end pos of range, wrt to source
 *  index: number - index of range (starting at 0)
 * }
 * ```
 * @param source 
 * @param split 
 * @returns 
 */
export const splitRanges = (source, split) => {
  //eslint-disable-next-line functional/no-let
  let start = 0;
  //eslint-disable-next-line functional/no-let
  let text = ``;
  const ranges: Range[] = [];
  //eslint-disable-next-line functional/no-let
  let index = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (source.indexOf(split, i) === i) {
      //eslint-disable-next-line functional/no-let
      const end = i;
      //eslint-disable-next-line functional/immutable-data
      ranges.push({
        text, start, end, index
      });
      start = end + 1;
      text = ``;
      index++;
    } else {
      text += source.charAt(i);
    }
  }
  if (start < source.length) {
    //eslint-disable-next-line functional/immutable-data
    ranges.push({text, start, index, end: source.length});
  }
  return ranges;
};

/**
 * Counts the number of times one of `chars` appears at the front of
 * a string, contiguously.
 * 
 * ```js
 * countCharsFromStart(`  hi`, ` `); // 2
 * countCharsFromStart(`hi  `, ` `); // 0
 * countCharsFromStart(`  hi  `, ` `); // 2
 * ```
 * @param source 
 * @param chars 
 * @returns 
 */
export const countCharsFromStart = (source, ...chars) => {
  //eslint-disable-next-line functional/no-let
  let counted = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (chars.includes(source.charAt(i))) {
      counted++;
    } else {
      break;
    }
  }
  return counted;
};

/**
 * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.
 * If _end_ is omitted, the the `start` value will be used.
 * 
 * ```js
 * startsEnds(`This is a string`, `This`, `string`); // True
 * startsEnds(`This is a string`, `is`, `a`); // False
 * starsEnds(`test`, `t`); // True, starts and ends with 't'
 * ```
 * @param source String to search within 
 * @param start Start
 * @param end End (if omitted, start will be looked for at end as well)
 * @returns True if source starts and ends with provided values.
 */
export const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);

//eslint-disable-next-line no-useless-escape
export const htmlEntities = (source) => source.replace(/[\u00A0-\u9999<>\&]/g, i => `&#${i.charCodeAt(0)};`);<fim_middle>",correct,758
number,number,e91a96aa1ed7352799ddb4e0d1ecdd24fe548d74,"<fim_prefix>/**
 * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.
 * 
 * ```js
 * // Yields ` orange `;
 * between(`apple orange melon`, `apple`, `melon`);
 * ```
 * @param source Source text 
 * @param start Start match
 * @param end If undefined, `start` will be used instead
 * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.
 * @returns 
 */
export const between = (source, start, end?, lastEndMatch = true) => {
  const startPos = source.indexOf(start);
  if (startPos < 0) return;

  if (end === undefined) end = start;

  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos+1);
  if (endPos < 0) return;

  return source.substring(startPos+1, endPos);
};

/**
 * Returns first position of the given character code, or -1 if not found.
 * @param source Source string
 * @param code Code to seek
 * @param start Start index, 0 by default
 * @param end End index (inclusive), source.length-1 by default
 * @returns Found position, or -1 if not found
 */
export const indexOfCharCode = (source, code, start = 0, end = source.length-1): <fim_suffix> => {
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i=start;i<=end;i++) {
    if (source.charCodeAt(i) === code) return i;
  }
  return -1;
};

/**
 * Returns `source` with chars removed at `removeStart` position
 * ```js
 * omitChars(`hello there`, 1, 3);
 * // Yields: `ho there`
 * ```
 * @param source 
 * @param removeStart Start point to remove
 * @param removeLength Number of characters to remove 
 * @returns 
 */
export const omitChars = (source, removeStart, removeLength) =>  source.substring(0, removeStart) + source.substring(removeStart+removeLength);

/**
 * Splits a string into `length`-size chunks.
 * 
 * If `length` is greater than the length of `source`, a single element array is returned with source.
 * The final array element may be smaller if we ran out of characters.
 * 
 * ```js
 * splitByLength(`hello there`, 2);
 * // Yields:
 * // [`he`, `ll`, `o `, `th`, `er`, `e`]
 * ```
 * @param source Source string
 * @param length Length of each chunk
 * @returns 
 */
export const splitByLength = (source, length) => {
  const chunks = Math.ceil(source.length/length);
  const ret:string[] = [];
  //eslint-disable-next-line functional/no-let
  let start = 0;

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let  
  for (let c=0;c<chunks;c++) {
    //eslint-disable-next-line functional/immutable-data
    ret.push(source.substring(start, start+length));
    start += length;
  }
  return ret;
};

/**
 * Returns the `source` string up until (and excluding) `match`. If match is not
 * found, all of `source` is returned.
 * 
 * ```js
 * // Yields `apple `
 * untilMarch(`apple orange melon`, `orange`);
 * ```
 * @param source 
 * @param match 
 * @param startPos If provided, gives the starting offset. Default 0
 */
export const untilMatch = (source, match, startPos = 0) => {
  if (startPos > source.length) throw new Error(`startPos should be less than length`);
  const m = source.indexOf(match, startPos);
  
  if (m < 0) return source;
  return source.substring(startPos, m);
};

/**
 * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.
 * ```js
 * unwrap(""'hello'"", ""'"");        // hello
 * unwrap(""apple"", ""a"");          // apple
 * unwrap(""wow"", ""w"");            // o
 * unwrap(`""'blah'""`, '""', ""'"");  // blah
 * ```
 * @param source 
 * @param wrappers 
 * @returns 
 */
export const unwrap = (source, ...wrappers) => {
  //eslint-disable-next-line functional/no-let
  let matched = false;
  //eslint-disable-next-line functional/no-loop-statement
  do {
    matched = false;
    //eslint-disable-next-line functional/no-loop-statement
    for (const w of wrappers) {
      if (source.startsWith(w) && source.endsWith(w)) {
        source = source.substring(w.length, source.length - (w.length * 2) + 1);
        matched = true;
      }
    }
  } while (matched);

  return source;
};

/**
 * A range
 */
export type Range = {
  /**
   * Text of range
   */
  readonly text: string
  /**
   * Start position, with respect to source text
   */
   readonly start: number
  /**
   * End position, with respect to source text
   */
   readonly end: number
  /**
   * Index of range. First range is 0
   */
   readonly index: number
}

export type LineSpan = {
  readonly start: number
  readonly end: number
  readonly length: number
}

/**
 * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.
 * 
 * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.
 * 
 * @param ranges Ranges
 * @param start Start character position, in source text reference
 * @param end End character position, in source text reference
 * @returns Span
 */
export const lineSpan = (ranges, start, end) => {
  //eslint-disable-next-line functional/no-let
  let s = -1;
  //eslint-disable-next-line functional/no-let
  let e = -1;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < ranges.length; i++) {
    const r = ranges[i];
    s = i;
    if (r.text.length === 0) continue;
    if (start < r.end) {
      break;
    }
  }

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = s; i < ranges.length; i++) {
    const r = ranges[i];
    e = i;
    if (end === r.end) {
      e = i + 1;
      break;
    }
    if (end < r.end) {
      break;
    }
  }
  return {length: e - s, start: s, end: e};
};

/**
 * Splits a source string into ranges:
 * ```js
 * const ranges = splitRanges(""hello;there;fella"", "";"");
 * ```
 * 
 * Each range consists of:
 * ```js
 * { 
 *  text: string  - the text of range
 *  start: number - start pos of range, wrt to source
 *  end: number   - end pos of range, wrt to source
 *  index: number - index of range (starting at 0)
 * }
 * ```
 * @param source 
 * @param split 
 * @returns 
 */
export const splitRanges = (source, split) => {
  //eslint-disable-next-line functional/no-let
  let start = 0;
  //eslint-disable-next-line functional/no-let
  let text = ``;
  const ranges: Range[] = [];
  //eslint-disable-next-line functional/no-let
  let index = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (source.indexOf(split, i) === i) {
      //eslint-disable-next-line functional/no-let
      const end = i;
      //eslint-disable-next-line functional/immutable-data
      ranges.push({
        text, start, end, index
      });
      start = end + 1;
      text = ``;
      index++;
    } else {
      text += source.charAt(i);
    }
  }
  if (start < source.length) {
    //eslint-disable-next-line functional/immutable-data
    ranges.push({text, start, index, end: source.length});
  }
  return ranges;
};

/**
 * Counts the number of times one of `chars` appears at the front of
 * a string, contiguously.
 * 
 * ```js
 * countCharsFromStart(`  hi`, ` `); // 2
 * countCharsFromStart(`hi  `, ` `); // 0
 * countCharsFromStart(`  hi  `, ` `); // 2
 * ```
 * @param source 
 * @param chars 
 * @returns 
 */
export const countCharsFromStart = (source, ...chars) => {
  //eslint-disable-next-line functional/no-let
  let counted = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (chars.includes(source.charAt(i))) {
      counted++;
    } else {
      break;
    }
  }
  return counted;
};

/**
 * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.
 * If _end_ is omitted, the the `start` value will be used.
 * 
 * ```js
 * startsEnds(`This is a string`, `This`, `string`); // True
 * startsEnds(`This is a string`, `is`, `a`); // False
 * starsEnds(`test`, `t`); // True, starts and ends with 't'
 * ```
 * @param source String to search within 
 * @param start Start
 * @param end End (if omitted, start will be looked for at end as well)
 * @returns True if source starts and ends with provided values.
 */
export const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);

//eslint-disable-next-line no-useless-escape
export const htmlEntities = (source) => source.replace(/[\u00A0-\u9999<>\&]/g, i => `&#${i.charCodeAt(0)};`);<fim_middle>",correct,760
number,number,e91a96aa1ed7352799ddb4e0d1ecdd24fe548d74,"<fim_prefix>/**
 * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.
 * 
 * ```js
 * // Yields ` orange `;
 * between(`apple orange melon`, `apple`, `melon`);
 * ```
 * @param source Source text 
 * @param start Start match
 * @param end If undefined, `start` will be used instead
 * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.
 * @returns 
 */
export const between = (source, start, end?, lastEndMatch = true) => {
  const startPos = source.indexOf(start);
  if (startPos < 0) return;

  if (end === undefined) end = start;

  const endPos = lastEndMatch ? source.lastIndexOf(end) : source.indexOf(end, startPos+1);
  if (endPos < 0) return;

  return source.substring(startPos+1, endPos);
};

/**
 * Returns first position of the given character code, or -1 if not found.
 * @param source Source string
 * @param code Code to seek
 * @param start Start index, 0 by default
 * @param end End index (inclusive), source.length-1 by default
 * @returns Found position, or -1 if not found
 */
export const indexOfCharCode = (source, code: <fim_suffix>, start = 0, end = source.length-1) => {
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i=start;i<=end;i++) {
    if (source.charCodeAt(i) === code) return i;
  }
  return -1;
};

/**
 * Returns `source` with chars removed at `removeStart` position
 * ```js
 * omitChars(`hello there`, 1, 3);
 * // Yields: `ho there`
 * ```
 * @param source 
 * @param removeStart Start point to remove
 * @param removeLength Number of characters to remove 
 * @returns 
 */
export const omitChars = (source, removeStart, removeLength) =>  source.substring(0, removeStart) + source.substring(removeStart+removeLength);

/**
 * Splits a string into `length`-size chunks.
 * 
 * If `length` is greater than the length of `source`, a single element array is returned with source.
 * The final array element may be smaller if we ran out of characters.
 * 
 * ```js
 * splitByLength(`hello there`, 2);
 * // Yields:
 * // [`he`, `ll`, `o `, `th`, `er`, `e`]
 * ```
 * @param source Source string
 * @param length Length of each chunk
 * @returns 
 */
export const splitByLength = (source, length) => {
  const chunks = Math.ceil(source.length/length);
  const ret:string[] = [];
  //eslint-disable-next-line functional/no-let
  let start = 0;

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let  
  for (let c=0;c<chunks;c++) {
    //eslint-disable-next-line functional/immutable-data
    ret.push(source.substring(start, start+length));
    start += length;
  }
  return ret;
};

/**
 * Returns the `source` string up until (and excluding) `match`. If match is not
 * found, all of `source` is returned.
 * 
 * ```js
 * // Yields `apple `
 * untilMarch(`apple orange melon`, `orange`);
 * ```
 * @param source 
 * @param match 
 * @param startPos If provided, gives the starting offset. Default 0
 */
export const untilMatch = (source, match, startPos = 0) => {
  if (startPos > source.length) throw new Error(`startPos should be less than length`);
  const m = source.indexOf(match, startPos);
  
  if (m < 0) return source;
  return source.substring(startPos, m);
};

/**
 * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.
 * ```js
 * unwrap(""'hello'"", ""'"");        // hello
 * unwrap(""apple"", ""a"");          // apple
 * unwrap(""wow"", ""w"");            // o
 * unwrap(`""'blah'""`, '""', ""'"");  // blah
 * ```
 * @param source 
 * @param wrappers 
 * @returns 
 */
export const unwrap = (source, ...wrappers) => {
  //eslint-disable-next-line functional/no-let
  let matched = false;
  //eslint-disable-next-line functional/no-loop-statement
  do {
    matched = false;
    //eslint-disable-next-line functional/no-loop-statement
    for (const w of wrappers) {
      if (source.startsWith(w) && source.endsWith(w)) {
        source = source.substring(w.length, source.length - (w.length * 2) + 1);
        matched = true;
      }
    }
  } while (matched);

  return source;
};

/**
 * A range
 */
export type Range = {
  /**
   * Text of range
   */
  readonly text: string
  /**
   * Start position, with respect to source text
   */
   readonly start: number
  /**
   * End position, with respect to source text
   */
   readonly end: number
  /**
   * Index of range. First range is 0
   */
   readonly index: number
}

export type LineSpan = {
  readonly start: number
  readonly end: number
  readonly length: number
}

/**
 * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.
 * 
 * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.
 * 
 * @param ranges Ranges
 * @param start Start character position, in source text reference
 * @param end End character position, in source text reference
 * @returns Span
 */
export const lineSpan = (ranges, start, end) => {
  //eslint-disable-next-line functional/no-let
  let s = -1;
  //eslint-disable-next-line functional/no-let
  let e = -1;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < ranges.length; i++) {
    const r = ranges[i];
    s = i;
    if (r.text.length === 0) continue;
    if (start < r.end) {
      break;
    }
  }

  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = s; i < ranges.length; i++) {
    const r = ranges[i];
    e = i;
    if (end === r.end) {
      e = i + 1;
      break;
    }
    if (end < r.end) {
      break;
    }
  }
  return {length: e - s, start: s, end: e};
};

/**
 * Splits a source string into ranges:
 * ```js
 * const ranges = splitRanges(""hello;there;fella"", "";"");
 * ```
 * 
 * Each range consists of:
 * ```js
 * { 
 *  text: string  - the text of range
 *  start: number - start pos of range, wrt to source
 *  end: number   - end pos of range, wrt to source
 *  index: number - index of range (starting at 0)
 * }
 * ```
 * @param source 
 * @param split 
 * @returns 
 */
export const splitRanges = (source, split) => {
  //eslint-disable-next-line functional/no-let
  let start = 0;
  //eslint-disable-next-line functional/no-let
  let text = ``;
  const ranges: Range[] = [];
  //eslint-disable-next-line functional/no-let
  let index = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (source.indexOf(split, i) === i) {
      //eslint-disable-next-line functional/no-let
      const end = i;
      //eslint-disable-next-line functional/immutable-data
      ranges.push({
        text, start, end, index
      });
      start = end + 1;
      text = ``;
      index++;
    } else {
      text += source.charAt(i);
    }
  }
  if (start < source.length) {
    //eslint-disable-next-line functional/immutable-data
    ranges.push({text, start, index, end: source.length});
  }
  return ranges;
};

/**
 * Counts the number of times one of `chars` appears at the front of
 * a string, contiguously.
 * 
 * ```js
 * countCharsFromStart(`  hi`, ` `); // 2
 * countCharsFromStart(`hi  `, ` `); // 0
 * countCharsFromStart(`  hi  `, ` `); // 2
 * ```
 * @param source 
 * @param chars 
 * @returns 
 */
export const countCharsFromStart = (source, ...chars) => {
  //eslint-disable-next-line functional/no-let
  let counted = 0;
  //eslint-disable-next-line functional/no-loop-statement,functional/no-let
  for (let i = 0; i < source.length; i++) {
    if (chars.includes(source.charAt(i))) {
      counted++;
    } else {
      break;
    }
  }
  return counted;
};

/**
 * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.
 * If _end_ is omitted, the the `start` value will be used.
 * 
 * ```js
 * startsEnds(`This is a string`, `This`, `string`); // True
 * startsEnds(`This is a string`, `is`, `a`); // False
 * starsEnds(`test`, `t`); // True, starts and ends with 't'
 * ```
 * @param source String to search within 
 * @param start Start
 * @param end End (if omitted, start will be looked for at end as well)
 * @returns True if source starts and ends with provided values.
 */
export const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);

//eslint-disable-next-line no-useless-escape
export const htmlEntities = (source) => source.replace(/[\u00A0-\u9999<>\&]/g, i => `&#${i.charCodeAt(0)};`);<fim_middle>",correct,761
number,number,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b: <fim_suffix>) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l) => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,780
number,number,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g: <fim_suffix>, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l) => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,781
number,number,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r: <fim_suffix>, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l) => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,782
number,number,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b): <fim_suffix> => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l) => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,783
number,number,e92848efdb8efe2325f8d32ba61a54d2b22ab4fe,"<fim_prefix>// https://stackoverflow.com/questions/2353211/hsl-to-rgb-color-conversion

export type Hue = number; // [0, 1]
export type Saturation = number; // [0, 1]
export type Lightness = number; // [0, 1]
export type Hsl = readonly [Hue, Saturation, Lightness]; // [0,1]
export type Rgb = readonly [number, number, number]; // [0,255]

export const hueToRgb = (p, q, t) => {
	if (t < 0) t += 1; // eslint-disable-line no-param-reassign
	if (t > 1) t -= 1; // eslint-disable-line no-param-reassign
	if (t < 1 / 6) return p + (q - p) * 6 * t;
	if (t < 1 / 2) return q;
	if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
	return p;
};

export const rgbToHex = (r, g, b: <fim_suffix>) => (r << 16) + (g << 8) + b;

/**
 * Converts an RGB color value to HSL. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values r/g/b are in the range [0,255] and
 * returns h/s/l in the range [0,1].
 */
export const rgbToHsl = (r, g, b) => {
	r /= 255; // eslint-disable-line no-param-reassign
	g /= 255; // eslint-disable-line no-param-reassign
	b /= 255; // eslint-disable-line no-param-reassign
	const max = Math.max(r, g, b);
	const min = Math.min(r, g, b);
	const l: Lightness = (max + min) / 2;
	let h!: Hue, s: Saturation;
	if (max === min) {
		h = s = 0; // achromatic
	} else {
		const d = max - min;
		s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
		switch (max) {
			case r:
				h = (g - b) / d + (g < b ? 6 : 0);
				break;
			case g:
				h = (b - r) / d + 2;
				break;
			case b:
				h = (r - g) / d + 4;
				break;
		}
		h /= 6;
	}
	return [h, s, l];
};

/**
 * Converts an HSL color value to RGB. Conversion formula
 * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
 * Values h/s/l are in the range [0,1] and
 * returns r/g/b in the range [0,255].
 */
export const hslToRgb = (h, s, l) => {
	let r: number, g: number, b: number;
	if (s === 0) {
		r = g = b = l; // achromatic
	} else {
		const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
		const p = 2 * l - q;
		r = hueToRgb(p, q, h + 1 / 3);
		g = hueToRgb(p, q, h);
		b = hueToRgb(p, q, h - 1 / 3);
	}
	return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
};

export const hslToHex = (h, s, l) =>
	rgbToHex(...hslToRgb(h, s, l));

export const hslToStr = (h, s, l) =>
	`hsl(${h * 360}, ${s * 100}%, ${l * 100}%)`;
<fim_middle>",correct,784
number,number,0a16fcadcae6b37d4e03cfab51755d1accf91b9b,"<fim_prefix>interface UsePaginationProps {
  count: number;
  page: number;
  onPageChange: (page) => void;
  disabled?: boolean;
  siblingCount?: number;
  boundaryCount?: number;
}

const usePagination = ({
  count,
  page,
  onPageChange,
  disabled,
  siblingCount = 1,
  boundaryCount = 1
}) => {
  const range = (start, end: <fim_suffix>) => {
    const length = end - start + 1;

    return Array.from({ length }).map((_, index) => index + start);
  };

  const startPage = 1;
  const endPage = count;

  const startPages = range(startPage, Math.min(boundaryCount, count));
  const endPages = range(Math.max(count - boundaryCount + 1, boundaryCount + 1), count);

  const siblingsStart = Math.max(
    Math.min(
      page + 1 - siblingCount,
      count - boundaryCount - siblingCount * 2 - 1,
    ),
    boundaryCount
  );

  const siblingsEnd = Math.min(
    Math.max(
      page + siblingCount,
      boundaryCount + siblingCount,
    ),
    endPages.length > 0 ? endPages[0] - 2 : endPage - 1,
  );

 
  const itemList = [
    ...startPages,
    'prev',
    ...range(siblingsStart, siblingsEnd),
    ...(siblingsEnd < count - boundaryCount - 1 ? ['end-ellipsis'] : count - boundaryCount > boundaryCount ? [count - boundaryCount] : []),
    ...endPages,
    'next',
    ...endPages
  ];

  const items = itemList.map((item, index) => 
    (typeof item === 'number' ? {
      key: index,
      onClick: () => onPageChange(item - 1),
      disabled,
      selected: item - 1 === page,
      item,
    } :
    {
      key: index,
      onClick: () => onPageChange(item === 'next' ? page + 1 : page - 1),
      disabled: disabled || item.indexOf('ellipsis') > -1 || (item === 'next' ? page >= count - 1 : page - 1 < 0),
      selected: false,
      item,
    }
    
    ));
  return {
    items,
  }
}

export default usePagination;
<fim_middle>",correct,791
number,number,0a16fcadcae6b37d4e03cfab51755d1accf91b9b,"<fim_prefix>interface UsePaginationProps {
  count: number;
  page: number;
  onPageChange: (page) => void;
  disabled?: boolean;
  siblingCount?: number;
  boundaryCount?: number;
}

const usePagination = ({
  count,
  page,
  onPageChange,
  disabled,
  siblingCount = 1,
  boundaryCount = 1
}) => {
  const range = (start: <fim_suffix>, end) => {
    const length = end - start + 1;

    return Array.from({ length }).map((_, index) => index + start);
  };

  const startPage = 1;
  const endPage = count;

  const startPages = range(startPage, Math.min(boundaryCount, count));
  const endPages = range(Math.max(count - boundaryCount + 1, boundaryCount + 1), count);

  const siblingsStart = Math.max(
    Math.min(
      page + 1 - siblingCount,
      count - boundaryCount - siblingCount * 2 - 1,
    ),
    boundaryCount
  );

  const siblingsEnd = Math.min(
    Math.max(
      page + siblingCount,
      boundaryCount + siblingCount,
    ),
    endPages.length > 0 ? endPages[0] - 2 : endPage - 1,
  );

 
  const itemList = [
    ...startPages,
    'prev',
    ...range(siblingsStart, siblingsEnd),
    ...(siblingsEnd < count - boundaryCount - 1 ? ['end-ellipsis'] : count - boundaryCount > boundaryCount ? [count - boundaryCount] : []),
    ...endPages,
    'next',
    ...endPages
  ];

  const items = itemList.map((item, index) => 
    (typeof item === 'number' ? {
      key: index,
      onClick: () => onPageChange(item - 1),
      disabled,
      selected: item - 1 === page,
      item,
    } :
    {
      key: index,
      onClick: () => onPageChange(item === 'next' ? page + 1 : page - 1),
      disabled: disabled || item.indexOf('ellipsis') > -1 || (item === 'next' ? page >= count - 1 : page - 1 < 0),
      selected: false,
      item,
    }
    
    ));
  return {
    items,
  }
}

export default usePagination;
<fim_middle>",correct,792
number,number,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n: <fim_suffix>) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,824
number,number,0ac7f06fab3e6c96afdb4f4fd1f32942b98e0e8c,"<fim_prefix>export const Config = {
  MaxLetters: 20,
  TileCount: 6,
  TileSize: 60,
  TileSpacing: 10,
};

export enum Directions {
  Up,
  Left,
  Down,
  Right,
}

export enum CursorDirections {
  LeftToRight = ""left-to-right"",
  TopToBottom = ""top-to-bottom"",
}

type Cursor = {
  row: number;
  col: number;
  direction: CursorDirections;
};

export type Letter = {
  id: string;
  letter: string; // TODO: refactor to `char`
};

export enum TileState {
  IDLE = ""idle"",
  VALID = ""valid"",
  INVALID = ""invalid"",
  MIXED = ""mixed"",
}

export enum TileChangeReason {
  MOVED = ""moved"",
  LETTER = ""letter"",
}

export type Tile = {
  id: string;
  row: number;
  col: number;
  letter: Letter | null;
  state: TileState;
  changeReason: TileChangeReason | undefined;
};

export type Board = {
  tiles: Tile[][];
  cursor: Cursor;
};

// https://en.wikipedia.org/wiki/Bananagrams#cite_note-7
const Letters = [
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""J"",
  ""K"",
  ""Q"",
  ""X"",
  ""Z"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""B"",
  ""C"",
  ""F"",
  ""H"",
  ""M"",
  ""P"",
  ""V"",
  ""W"",
  ""Y"",
  ""G"",
  ""G"",
  ""G"",
  ""G"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""L"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""D"",
  ""S"",
  ""U"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""N"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""T"",
  ""R"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""O"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""I"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""A"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
  ""E"",
];

// @TODO use a seeded randomizer so we can get one combo per day.
function getRandom<T>(arr, n: <fim_suffix>) {
  var result = new Array(n),
    len = arr.length,
    taken = new Array(len);
  if (n > len) throw new RangeError(""getRandom: more elements taken than available"");
  while (n--) {
    var x = Math.floor(Math.random() * len);
    result[n] = arr[x in taken ? taken[x] : x];
    taken[x] = --len in taken ? taken[len] : len;
  }
  return result;
}

export function shuffle<T>(arr) {
  return getRandom(arr, arr.length);
}

export function getRandomLetters(n) {
  return getRandom(Letters, n);
}

export function wrapCursor(board, cursor) {
  const maxRow = board.tiles.length;
  const maxCol = board.tiles[0].length;

  const rowOverflow = Math.floor(cursor.row / maxRow);
  const colOverflow = Math.floor(cursor.col / maxCol);

  // Simple case, just bring back to reality.
  if (rowOverflow && colOverflow) {
    return {
      row: cursor.row % maxRow,
      col: cursor.col % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is overflowing, increment as needed.
  if (rowOverflow > 0) {
    return {
      row: cursor.row % maxRow,
      col: (cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the col is overflowing, increment as needed.
  if (colOverflow > 0) {
    return {
      row: (cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  // If only the row is underflowing, increment as needed.
  if (rowOverflow < 0) {
    return {
      row: (maxRow + cursor.row) % maxRow,
      col: (maxCol + cursor.col + rowOverflow) % maxCol,
      direction: cursor.direction,
    };
  }
  // If only the col is underflowing, increment as needed.
  if (colOverflow < 0) {
    return {
      row: (maxRow + cursor.row + colOverflow) % maxRow,
      col: (maxCol + cursor.col) % maxCol,
      direction: cursor.direction,
    };
  }

  return cursor;
}

export function incrementCursor(board) {
  return moveBoardCursorToNextEmptyTile(board) || board.cursor;
}

function moveBoardCursorToNextEmptyTile(board) {
  const { row, col, direction } = board.cursor;

  switch (direction) {
    case CursorDirections.LeftToRight: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row,
          col: col + 1,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row,
          col: col + i,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
    case CursorDirections.TopToBottom: {
      // If we're on a letter, always just move forward 1.
      if (getTileAtCursor(board).letter) {
        return wrapCursor(board, {
          row: row + 1,
          col,
          direction,
        });
      }

      // Otherwise, move to next empty square.
      let nextCursor;

      // Max 36 attempts. Kinda jank but guarentees no infinte loop.
      for (let i = 1; i < 36; i++) {
        nextCursor = wrapCursor(board, {
          row: row + i,
          col,
          direction,
        });

        if (!getTileAtCursor(board, nextCursor).letter) {
          return nextCursor;
        }
      }

      return nextCursor;
    }
  }
}

export function getTileAtCursor(board, cursor?) {
  const c = cursor || board.cursor;
  return board.tiles[c.row][c.col];
}

export function updateCursorInDirection(board, direction) {
  switch (direction) {
    case Directions.Down:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row + 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Up:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row - 1,
          col: board.cursor.col,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Left:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col - 1,
          direction: board.cursor.direction,
        }),
      };
    case Directions.Right:
      return {
        ...board,
        cursor: wrapCursor(board, {
          row: board.cursor.row,
          col: board.cursor.col + 1,
          direction: board.cursor.direction,
        }),
      };
  }
}

export function decrementCursor(board) {
  const cursor = board.cursor;

  switch (cursor.direction) {
    case CursorDirections.LeftToRight:
      return wrapCursor(board, {
        row: cursor.row,
        col: cursor.col - 1,
        direction: cursor.direction,
      });
    case CursorDirections.TopToBottom:
      return wrapCursor(board, {
        row: cursor.row - 1,
        col: cursor.col,
        direction: cursor.direction,
      });
  }
}

function shiftBoardUp(board) {
  const topRow = board.tiles[0];

  // Don't move board in this direction if it'd overflow.
  if (topRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [...board.tiles.slice(1), topRow].map((row) =>
    row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardDown(board) {
  const bottomRow = board.tiles[board.tiles.length - 1];

  // Don't move board in this direction if it'd overflow.
  if (bottomRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const newLetterPositions = [bottomRow, ...board.tiles.slice(0, board.tiles.length - 1)].map(
    (row) => row.map((tile) => tile.letter),
  );

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardLeft(board) {
  const maxC = board.tiles[0].length;
  const leftRow = board.tiles.map((row) => row[0]).flat();

  // Don't move board in this direction if it'd overflow.
  if (leftRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c + 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

function shiftBoardRight(board) {
  const maxC = board.tiles[0].length;
  const rightRow = board.tiles.map((row) => row[row.length - 1]).flat();

  // Don't move board in this direction if it'd overflow.
  if (rightRow.some((tile) => tile.letter !== null)) {
    return board;
  }

  const prevLetterPositions = board.tiles.map((row) => row.map((tile) => tile.letter));

  const newLetterPositions = prevLetterPositions.map((_) => []) as (Letter | null)[][];

  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newLetterPositions[r][c] = prevLetterPositions[r][(maxC + c - 1) % maxC];
    }
  }

  const newTiles = board.tiles.slice();
  for (let r = 0; r < board.tiles.length; r++) {
    for (let c = 0; c < board.tiles[0].length; c++) {
      newTiles[r][c] = {
        ...newTiles[r][c],
        letter: newLetterPositions[r][c],
        changeReason: TileChangeReason.MOVED,
      };
    }
  }

  return {
    ...board,
    tiles: newTiles,
  };
}

export function moveBoard(board, direction) {
  switch (direction) {
    case Directions.Up:
      return shiftBoardUp(board);
    case Directions.Down:
      return shiftBoardDown(board);
    case Directions.Left:
      return shiftBoardLeft(board);
    case Directions.Right:
      return shiftBoardRight(board);
  }
}

export function getPuzzleNumber() {
  const now = new Date();
  const start = new Date(now.getFullYear(), 0, 0);
  const diff = now.getTime() - start.getTime();
  const oneDay = 1000 * 60 * 60 * 24;
  const day = Math.floor(diff / oneDay);
  return day;
}
<fim_middle>",correct,827
number,number,bbb3c6df82171fa90d0040776b93e6265574820e,"<fim_prefix>export enum AllianceColor {
    BLUE, RED
}

export enum StoneType {
    SKYSTONE, STONE
}

export enum ScoringResult {
    SCORED, FAILED, DID_NOT_TRY
}

// OK FTC state-of-the-art mobile phone control system
export enum DisconnectStatus {
    NO_DISCONNECT, PARTIAL, TOTAL
}

export class MatchEntry {
    matchCode: string;
    teamNumber: number;
    alliance: AllianceColor;
    auto: AutonomousPerformance;
    teleOp: TeleOpPerformance;
    endgame: EndgamePerformance;
    disconnect: DisconnectStatus;
    remarks?: string;

    constructor(matchCode, teamNumber, alliance,
        auto, teleOp, endgame,
        disconnect, remarks?) {
        this.matchCode = matchCode;
        this.teamNumber = teamNumber;
        this.alliance = alliance;
        this.auto = auto;
        this.teleOp = teleOp;
        this.endgame = endgame;
        this.disconnect = disconnect;
        this.remarks = remarks;

        this.validateAutonomous();
        this.validateMetadata();
    }

    public validateMetadata() {
        if (!isValidMatchCode(this.matchCode)) {
            throw new Error(`Match code ""${this.matchCode}"" is invalid`);
        }
        if (isNaN(this.teamNumber)) {
            throw new Error(`Invalid team number`);
        }
        if (this.teamNumber < 1 || Math.floor(this.teamNumber) !== this.teamNumber) {
            throw new Error(`Team number ${this.teamNumber} is invalid`);
        }
        if (this.disconnect === DisconnectStatus.TOTAL && this.getTotalScore() > 0) {
            throw new Error('A totally disconnected team cannot score points');
        }
    }

    public validateAutonomous() {
        if (this.auto.cyclesAttempted < this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous cyclesAttempted < num of deliveredStones`);
        }
        if (this.auto.stonesOnFoundation > this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous stonesOnFoundation > num of deliveredStones`);
        }
    }

    getAutonomousScore() {
        let score = 0;
        // 4.5.2.1
        if (this.auto.movedFoundation === ScoringResult.SCORED) {
            score += 10;
        }
        // 4.5.2.2
        for (let i = 0; i < this.auto.deliveredStones.length; i++) {
            const stone = this.auto.deliveredStones[i];
            if (stone === StoneType.SKYSTONE && i < 2) {
                score += 10;
            } else if (stone != undefined) {
                score += 2;
            }
        }
        // 4.5.2.3
        if (this.auto.parked === ScoringResult.SCORED) {
            score += 5;
        }
        // 4.5.2.4
        score += this.auto.stonesOnFoundation * 4;
        return score;
    }

    getTeleOpScore() {
        let score = 0;
        // 4.5.3.1
        score += this.teleOp.allianceStonesDelivered;
        // 4.5.3.2
        score += this.teleOp.stonesPerLevel.reduce((a, b) => a + b, 0);
        // 4.5.3.3
        score += this.teleOp.stonesPerLevel.length * 2;
        return score;
    }

    getEndgameScore() {
        let score = 0;
        // 4.5.4.1
        if (this.endgame.capstoneLevel !== undefined) {
            score += 5 + this.endgame.capstoneLevel;
        }
        // 4.5.4.2
        if (this.endgame.movedFoundation === ScoringResult.SCORED) {
            score += 15;
        }
        // 4.5.4.3
        if (this.endgame.parked === ScoringResult.SCORED) {
            score += 5;
        }
        return score;
    }

    getTotalScore(): <fim_suffix> {
        return this.getAutonomousScore() + this.getTeleOpScore() + this.getEndgameScore();
    }
}

export interface AutonomousPerformance {
    deliveredStones: StoneType[];
    cyclesAttempted: number;
    stonesOnFoundation: number;
    parked: ScoringResult;
    movedFoundation: ScoringResult;
}

export interface TeleOpPerformance {
    allianceStonesDelivered: number;
    neutralStonesDelivered: number;
    stonesPerLevel: number[];
}

export interface EndgamePerformance {
    movedFoundation: ScoringResult;
    capstoneLevel?: number;
    parked: ScoringResult;
}

export type MatchEntrySet = MatchEntry[];

export function isValidMatchCode(matchCode) {
    const matchResult = matchCode.match(/^([QF][1-9][0-9]*)|(SF[12]-[1-9][0-9]*)$/);
    return matchResult !== null && matchResult[0] === matchCode;
}
<fim_middle>",correct,854
number,number,bbb3c6df82171fa90d0040776b93e6265574820e,"<fim_prefix>export enum AllianceColor {
    BLUE, RED
}

export enum StoneType {
    SKYSTONE, STONE
}

export enum ScoringResult {
    SCORED, FAILED, DID_NOT_TRY
}

// OK FTC state-of-the-art mobile phone control system
export enum DisconnectStatus {
    NO_DISCONNECT, PARTIAL, TOTAL
}

export class MatchEntry {
    matchCode: string;
    teamNumber: number;
    alliance: AllianceColor;
    auto: AutonomousPerformance;
    teleOp: TeleOpPerformance;
    endgame: EndgamePerformance;
    disconnect: DisconnectStatus;
    remarks?: string;

    constructor(matchCode, teamNumber, alliance,
        auto, teleOp, endgame,
        disconnect, remarks?) {
        this.matchCode = matchCode;
        this.teamNumber = teamNumber;
        this.alliance = alliance;
        this.auto = auto;
        this.teleOp = teleOp;
        this.endgame = endgame;
        this.disconnect = disconnect;
        this.remarks = remarks;

        this.validateAutonomous();
        this.validateMetadata();
    }

    public validateMetadata() {
        if (!isValidMatchCode(this.matchCode)) {
            throw new Error(`Match code ""${this.matchCode}"" is invalid`);
        }
        if (isNaN(this.teamNumber)) {
            throw new Error(`Invalid team number`);
        }
        if (this.teamNumber < 1 || Math.floor(this.teamNumber) !== this.teamNumber) {
            throw new Error(`Team number ${this.teamNumber} is invalid`);
        }
        if (this.disconnect === DisconnectStatus.TOTAL && this.getTotalScore() > 0) {
            throw new Error('A totally disconnected team cannot score points');
        }
    }

    public validateAutonomous() {
        if (this.auto.cyclesAttempted < this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous cyclesAttempted < num of deliveredStones`);
        }
        if (this.auto.stonesOnFoundation > this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous stonesOnFoundation > num of deliveredStones`);
        }
    }

    getAutonomousScore() {
        let score = 0;
        // 4.5.2.1
        if (this.auto.movedFoundation === ScoringResult.SCORED) {
            score += 10;
        }
        // 4.5.2.2
        for (let i = 0; i < this.auto.deliveredStones.length; i++) {
            const stone = this.auto.deliveredStones[i];
            if (stone === StoneType.SKYSTONE && i < 2) {
                score += 10;
            } else if (stone != undefined) {
                score += 2;
            }
        }
        // 4.5.2.3
        if (this.auto.parked === ScoringResult.SCORED) {
            score += 5;
        }
        // 4.5.2.4
        score += this.auto.stonesOnFoundation * 4;
        return score;
    }

    getTeleOpScore() {
        let score = 0;
        // 4.5.3.1
        score += this.teleOp.allianceStonesDelivered;
        // 4.5.3.2
        score += this.teleOp.stonesPerLevel.reduce((a, b) => a + b, 0);
        // 4.5.3.3
        score += this.teleOp.stonesPerLevel.length * 2;
        return score;
    }

    getEndgameScore(): <fim_suffix> {
        let score = 0;
        // 4.5.4.1
        if (this.endgame.capstoneLevel !== undefined) {
            score += 5 + this.endgame.capstoneLevel;
        }
        // 4.5.4.2
        if (this.endgame.movedFoundation === ScoringResult.SCORED) {
            score += 15;
        }
        // 4.5.4.3
        if (this.endgame.parked === ScoringResult.SCORED) {
            score += 5;
        }
        return score;
    }

    getTotalScore() {
        return this.getAutonomousScore() + this.getTeleOpScore() + this.getEndgameScore();
    }
}

export interface AutonomousPerformance {
    deliveredStones: StoneType[];
    cyclesAttempted: number;
    stonesOnFoundation: number;
    parked: ScoringResult;
    movedFoundation: ScoringResult;
}

export interface TeleOpPerformance {
    allianceStonesDelivered: number;
    neutralStonesDelivered: number;
    stonesPerLevel: number[];
}

export interface EndgamePerformance {
    movedFoundation: ScoringResult;
    capstoneLevel?: number;
    parked: ScoringResult;
}

export type MatchEntrySet = MatchEntry[];

export function isValidMatchCode(matchCode) {
    const matchResult = matchCode.match(/^([QF][1-9][0-9]*)|(SF[12]-[1-9][0-9]*)$/);
    return matchResult !== null && matchResult[0] === matchCode;
}
<fim_middle>",correct,855
number,number,bbb3c6df82171fa90d0040776b93e6265574820e,"<fim_prefix>export enum AllianceColor {
    BLUE, RED
}

export enum StoneType {
    SKYSTONE, STONE
}

export enum ScoringResult {
    SCORED, FAILED, DID_NOT_TRY
}

// OK FTC state-of-the-art mobile phone control system
export enum DisconnectStatus {
    NO_DISCONNECT, PARTIAL, TOTAL
}

export class MatchEntry {
    matchCode: string;
    teamNumber: number;
    alliance: AllianceColor;
    auto: AutonomousPerformance;
    teleOp: TeleOpPerformance;
    endgame: EndgamePerformance;
    disconnect: DisconnectStatus;
    remarks?: string;

    constructor(matchCode, teamNumber, alliance,
        auto, teleOp, endgame,
        disconnect, remarks?) {
        this.matchCode = matchCode;
        this.teamNumber = teamNumber;
        this.alliance = alliance;
        this.auto = auto;
        this.teleOp = teleOp;
        this.endgame = endgame;
        this.disconnect = disconnect;
        this.remarks = remarks;

        this.validateAutonomous();
        this.validateMetadata();
    }

    public validateMetadata() {
        if (!isValidMatchCode(this.matchCode)) {
            throw new Error(`Match code ""${this.matchCode}"" is invalid`);
        }
        if (isNaN(this.teamNumber)) {
            throw new Error(`Invalid team number`);
        }
        if (this.teamNumber < 1 || Math.floor(this.teamNumber) !== this.teamNumber) {
            throw new Error(`Team number ${this.teamNumber} is invalid`);
        }
        if (this.disconnect === DisconnectStatus.TOTAL && this.getTotalScore() > 0) {
            throw new Error('A totally disconnected team cannot score points');
        }
    }

    public validateAutonomous() {
        if (this.auto.cyclesAttempted < this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous cyclesAttempted < num of deliveredStones`);
        }
        if (this.auto.stonesOnFoundation > this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous stonesOnFoundation > num of deliveredStones`);
        }
    }

    getAutonomousScore() {
        let score = 0;
        // 4.5.2.1
        if (this.auto.movedFoundation === ScoringResult.SCORED) {
            score += 10;
        }
        // 4.5.2.2
        for (let i = 0; i < this.auto.deliveredStones.length; i++) {
            const stone = this.auto.deliveredStones[i];
            if (stone === StoneType.SKYSTONE && i < 2) {
                score += 10;
            } else if (stone != undefined) {
                score += 2;
            }
        }
        // 4.5.2.3
        if (this.auto.parked === ScoringResult.SCORED) {
            score += 5;
        }
        // 4.5.2.4
        score += this.auto.stonesOnFoundation * 4;
        return score;
    }

    getTeleOpScore(): <fim_suffix> {
        let score = 0;
        // 4.5.3.1
        score += this.teleOp.allianceStonesDelivered;
        // 4.5.3.2
        score += this.teleOp.stonesPerLevel.reduce((a, b) => a + b, 0);
        // 4.5.3.3
        score += this.teleOp.stonesPerLevel.length * 2;
        return score;
    }

    getEndgameScore() {
        let score = 0;
        // 4.5.4.1
        if (this.endgame.capstoneLevel !== undefined) {
            score += 5 + this.endgame.capstoneLevel;
        }
        // 4.5.4.2
        if (this.endgame.movedFoundation === ScoringResult.SCORED) {
            score += 15;
        }
        // 4.5.4.3
        if (this.endgame.parked === ScoringResult.SCORED) {
            score += 5;
        }
        return score;
    }

    getTotalScore() {
        return this.getAutonomousScore() + this.getTeleOpScore() + this.getEndgameScore();
    }
}

export interface AutonomousPerformance {
    deliveredStones: StoneType[];
    cyclesAttempted: number;
    stonesOnFoundation: number;
    parked: ScoringResult;
    movedFoundation: ScoringResult;
}

export interface TeleOpPerformance {
    allianceStonesDelivered: number;
    neutralStonesDelivered: number;
    stonesPerLevel: number[];
}

export interface EndgamePerformance {
    movedFoundation: ScoringResult;
    capstoneLevel?: number;
    parked: ScoringResult;
}

export type MatchEntrySet = MatchEntry[];

export function isValidMatchCode(matchCode) {
    const matchResult = matchCode.match(/^([QF][1-9][0-9]*)|(SF[12]-[1-9][0-9]*)$/);
    return matchResult !== null && matchResult[0] === matchCode;
}
<fim_middle>",correct,856
number,number,bbb3c6df82171fa90d0040776b93e6265574820e,"<fim_prefix>export enum AllianceColor {
    BLUE, RED
}

export enum StoneType {
    SKYSTONE, STONE
}

export enum ScoringResult {
    SCORED, FAILED, DID_NOT_TRY
}

// OK FTC state-of-the-art mobile phone control system
export enum DisconnectStatus {
    NO_DISCONNECT, PARTIAL, TOTAL
}

export class MatchEntry {
    matchCode: string;
    teamNumber: number;
    alliance: AllianceColor;
    auto: AutonomousPerformance;
    teleOp: TeleOpPerformance;
    endgame: EndgamePerformance;
    disconnect: DisconnectStatus;
    remarks?: string;

    constructor(matchCode, teamNumber, alliance,
        auto, teleOp, endgame,
        disconnect, remarks?) {
        this.matchCode = matchCode;
        this.teamNumber = teamNumber;
        this.alliance = alliance;
        this.auto = auto;
        this.teleOp = teleOp;
        this.endgame = endgame;
        this.disconnect = disconnect;
        this.remarks = remarks;

        this.validateAutonomous();
        this.validateMetadata();
    }

    public validateMetadata() {
        if (!isValidMatchCode(this.matchCode)) {
            throw new Error(`Match code ""${this.matchCode}"" is invalid`);
        }
        if (isNaN(this.teamNumber)) {
            throw new Error(`Invalid team number`);
        }
        if (this.teamNumber < 1 || Math.floor(this.teamNumber) !== this.teamNumber) {
            throw new Error(`Team number ${this.teamNumber} is invalid`);
        }
        if (this.disconnect === DisconnectStatus.TOTAL && this.getTotalScore() > 0) {
            throw new Error('A totally disconnected team cannot score points');
        }
    }

    public validateAutonomous() {
        if (this.auto.cyclesAttempted < this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous cyclesAttempted < num of deliveredStones`);
        }
        if (this.auto.stonesOnFoundation > this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous stonesOnFoundation > num of deliveredStones`);
        }
    }

    getAutonomousScore(): <fim_suffix> {
        let score = 0;
        // 4.5.2.1
        if (this.auto.movedFoundation === ScoringResult.SCORED) {
            score += 10;
        }
        // 4.5.2.2
        for (let i = 0; i < this.auto.deliveredStones.length; i++) {
            const stone = this.auto.deliveredStones[i];
            if (stone === StoneType.SKYSTONE && i < 2) {
                score += 10;
            } else if (stone != undefined) {
                score += 2;
            }
        }
        // 4.5.2.3
        if (this.auto.parked === ScoringResult.SCORED) {
            score += 5;
        }
        // 4.5.2.4
        score += this.auto.stonesOnFoundation * 4;
        return score;
    }

    getTeleOpScore() {
        let score = 0;
        // 4.5.3.1
        score += this.teleOp.allianceStonesDelivered;
        // 4.5.3.2
        score += this.teleOp.stonesPerLevel.reduce((a, b) => a + b, 0);
        // 4.5.3.3
        score += this.teleOp.stonesPerLevel.length * 2;
        return score;
    }

    getEndgameScore() {
        let score = 0;
        // 4.5.4.1
        if (this.endgame.capstoneLevel !== undefined) {
            score += 5 + this.endgame.capstoneLevel;
        }
        // 4.5.4.2
        if (this.endgame.movedFoundation === ScoringResult.SCORED) {
            score += 15;
        }
        // 4.5.4.3
        if (this.endgame.parked === ScoringResult.SCORED) {
            score += 5;
        }
        return score;
    }

    getTotalScore() {
        return this.getAutonomousScore() + this.getTeleOpScore() + this.getEndgameScore();
    }
}

export interface AutonomousPerformance {
    deliveredStones: StoneType[];
    cyclesAttempted: number;
    stonesOnFoundation: number;
    parked: ScoringResult;
    movedFoundation: ScoringResult;
}

export interface TeleOpPerformance {
    allianceStonesDelivered: number;
    neutralStonesDelivered: number;
    stonesPerLevel: number[];
}

export interface EndgamePerformance {
    movedFoundation: ScoringResult;
    capstoneLevel?: number;
    parked: ScoringResult;
}

export type MatchEntrySet = MatchEntry[];

export function isValidMatchCode(matchCode) {
    const matchResult = matchCode.match(/^([QF][1-9][0-9]*)|(SF[12]-[1-9][0-9]*)$/);
    return matchResult !== null && matchResult[0] === matchCode;
}
<fim_middle>",correct,857
number,number,bbb3c6df82171fa90d0040776b93e6265574820e,"<fim_prefix>export enum AllianceColor {
    BLUE, RED
}

export enum StoneType {
    SKYSTONE, STONE
}

export enum ScoringResult {
    SCORED, FAILED, DID_NOT_TRY
}

// OK FTC state-of-the-art mobile phone control system
export enum DisconnectStatus {
    NO_DISCONNECT, PARTIAL, TOTAL
}

export class MatchEntry {
    matchCode: string;
    teamNumber: number;
    alliance: AllianceColor;
    auto: AutonomousPerformance;
    teleOp: TeleOpPerformance;
    endgame: EndgamePerformance;
    disconnect: DisconnectStatus;
    remarks?: string;

    constructor(matchCode, teamNumber: <fim_suffix>, alliance,
        auto, teleOp, endgame,
        disconnect, remarks?) {
        this.matchCode = matchCode;
        this.teamNumber = teamNumber;
        this.alliance = alliance;
        this.auto = auto;
        this.teleOp = teleOp;
        this.endgame = endgame;
        this.disconnect = disconnect;
        this.remarks = remarks;

        this.validateAutonomous();
        this.validateMetadata();
    }

    public validateMetadata() {
        if (!isValidMatchCode(this.matchCode)) {
            throw new Error(`Match code ""${this.matchCode}"" is invalid`);
        }
        if (isNaN(this.teamNumber)) {
            throw new Error(`Invalid team number`);
        }
        if (this.teamNumber < 1 || Math.floor(this.teamNumber) !== this.teamNumber) {
            throw new Error(`Team number ${this.teamNumber} is invalid`);
        }
        if (this.disconnect === DisconnectStatus.TOTAL && this.getTotalScore() > 0) {
            throw new Error('A totally disconnected team cannot score points');
        }
    }

    public validateAutonomous() {
        if (this.auto.cyclesAttempted < this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous cyclesAttempted < num of deliveredStones`);
        }
        if (this.auto.stonesOnFoundation > this.auto.deliveredStones.length) {
            throw new RangeError(`${this.teamNumber} ${this.matchCode}: autonomous stonesOnFoundation > num of deliveredStones`);
        }
    }

    getAutonomousScore() {
        let score = 0;
        // 4.5.2.1
        if (this.auto.movedFoundation === ScoringResult.SCORED) {
            score += 10;
        }
        // 4.5.2.2
        for (let i = 0; i < this.auto.deliveredStones.length; i++) {
            const stone = this.auto.deliveredStones[i];
            if (stone === StoneType.SKYSTONE && i < 2) {
                score += 10;
            } else if (stone != undefined) {
                score += 2;
            }
        }
        // 4.5.2.3
        if (this.auto.parked === ScoringResult.SCORED) {
            score += 5;
        }
        // 4.5.2.4
        score += this.auto.stonesOnFoundation * 4;
        return score;
    }

    getTeleOpScore() {
        let score = 0;
        // 4.5.3.1
        score += this.teleOp.allianceStonesDelivered;
        // 4.5.3.2
        score += this.teleOp.stonesPerLevel.reduce((a, b) => a + b, 0);
        // 4.5.3.3
        score += this.teleOp.stonesPerLevel.length * 2;
        return score;
    }

    getEndgameScore() {
        let score = 0;
        // 4.5.4.1
        if (this.endgame.capstoneLevel !== undefined) {
            score += 5 + this.endgame.capstoneLevel;
        }
        // 4.5.4.2
        if (this.endgame.movedFoundation === ScoringResult.SCORED) {
            score += 15;
        }
        // 4.5.4.3
        if (this.endgame.parked === ScoringResult.SCORED) {
            score += 5;
        }
        return score;
    }

    getTotalScore() {
        return this.getAutonomousScore() + this.getTeleOpScore() + this.getEndgameScore();
    }
}

export interface AutonomousPerformance {
    deliveredStones: StoneType[];
    cyclesAttempted: number;
    stonesOnFoundation: number;
    parked: ScoringResult;
    movedFoundation: ScoringResult;
}

export interface TeleOpPerformance {
    allianceStonesDelivered: number;
    neutralStonesDelivered: number;
    stonesPerLevel: number[];
}

export interface EndgamePerformance {
    movedFoundation: ScoringResult;
    capstoneLevel?: number;
    parked: ScoringResult;
}

export type MatchEntrySet = MatchEntry[];

export function isValidMatchCode(matchCode) {
    const matchResult = matchCode.match(/^([QF][1-9][0-9]*)|(SF[12]-[1-9][0-9]*)$/);
    return matchResult !== null && matchResult[0] === matchCode;
}
<fim_middle>",correct,864
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f: <fim_suffix>) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,866
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num): <fim_suffix> {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,868
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num: <fim_suffix>) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,869
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance: <fim_suffix>) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,870
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest: <fim_suffix>, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,871
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal(): <fim_suffix> {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,877
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate: <fim_suffix>) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,879
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate(): <fim_suffix> {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,880
number,number,bbeb8eb498d7a9ef5e16ad93deb0f56fb1ec44fd,"<fim_prefix>export type RepaymentFrequency = 'yearly' | 'quarterly' | 'monthly' | 'fortnightly' | 'weekly';

export interface LoanPayment {
    /**
     * Payment amount.
     */
    amount: number;

    /**
     * Principal part.
     */
    principal: number;

    /**
     * Interest payment part.
     */
    interest: number;

    /**
     * Remaining balance.
     */
    balance: number;
}

export interface LoanInterface {

    // Adjustable properties

    /**
     * Loan amount.
     */
    amount: number;

    /**
     * Interest rate, 0-100.
     */
    interestRate: number;

    /**
     * Sets or gets loan period in months.
     * Overrides one previously defined in years.
     * @see #years
     */
    months: number;

    /**
     * Sets or gets loan period in years.
     * Overrides one previously defined in months.
     * @see #months
     */
    years: number;

    /**
     * 'monthly' by default.
     */
    repaymentFrequency: RepaymentFrequency;

    /**
     * Optional extra payment.
     */
    extraPayment: number;

    /**
     * Sets or gets the number of interest only repayments.
     * Overrides one previously defined in years (below).
     * Default is 0.
     */
    interestOnlyRepaymentCount: number;

    /**
     * Sets or gets the number of interest only repayments in years.
     * Overrides one defined in repayment count (above).
     * Default is 0.
     */
    interestOnlyYears: number;

    /**
     * Whether to calculate weekly and fortnightly repayments based on the
     * yearly repayment amount, instead of deriving it from monthly repayment.
     * Default is false, which means to derive weekly and fortnightly repayment
     * amount from monthly repayments, decreasing the total cost of the loan.
     * See https://www.savings.com.au/home-loans/monthly-fortnightly-weekly-mortgage-repayments
     */
    calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments: boolean;

    /**
     * Sets or gets the length of the fractional part for numbers used in calculation.
     * Default is 8.
     */
    rounding: number;

    // ARM (Adjustable Rate Mortgage) options

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period.
     * Overrides one previously defined in years (below).
     * Default is 0.
     * @see https://www.valuepenguin.com/loans/fixed-vs-variable-interest-rates
     */
    armFixedRateForRepaymentCount: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) period in years.
     * Overrides one previously defined in repayment count (above).
     * Default is 0.
     */
    armFixedRateForYears: number;

    /**
     * Rate that will be used for calculating variable rate
     * part of the loan with adjustments etc as the initial rate
     * that will be adjusted over time.
     */
    armInitialVariableRate: number;

    /**
     * Repayment count between ARM adjustments.
     * Overrides one previously defined in months (below).
     */
    armRepaymentCountBetweenAdjustments: number;

    /**
     * Sets or gets the ARM (Adjustable Rate Mortgage) adjustment period in months.
     * Overrides one previously defined in repayment count (above).
     * Default is 12.
     */
    armMonthsBetweenAdjustments: number;

    /**
     * Interest rate adjustment for ARM.
     */
    armExpectedAdjustmentRate: number;

    /**
     * Max interest rate for ARM.
     */
    armMaximumInterestRate: number;

    /**
     * Gets the average repayments _after_
     * interest-only repayment period.
     */
    readonly repaymentAmount: number;

    /**
     * Total repayments sum.
     */
    readonly totalCost: number;

    /**
     * Total interest charged.
     */
    readonly totalInterest: number;

    readonly paymentsCountPerYear: number;
    readonly paymentsCountTotal: number;

    /**
     * Payment schedule for the loan.
     */
    readonly payments: LoanPayment[];

    // Methods

    /**
     * To easily calculate differences between various loan options.
     * @return Loan with the exact same options as the current one.
     */
    clone();
}

export class Loan implements LoanInterface {
    private _rate: number = 0;
    private _termInMonths: number = 0;
    private _interestOnlyRepayments = 0;
    private _calculated = false;
    private _armVariableRate: number = 0;

    private _amount: number = 0;

    get amount() {
        return this._amount;
    }

    set amount(amount) {
        if (this._amount === amount) {
            return;
        }
        this._amount = amount;
        this._invalidate();
    }

    private _repaymentFrequency: RepaymentFrequency = 'monthly';

    get repaymentFrequency() {
        return this._repaymentFrequency;
    }

    set repaymentFrequency(f) {
        if (this._repaymentFrequency === f) {
            return;
        }
        this._repaymentFrequency = f;
        this._invalidate();
    }

    private _extraPayment = 0;

    get extraPayment() {
        return this._extraPayment;
    }

    set extraPayment(p) {
        if (this._extraPayment === p) {
            return;
        }
        this._extraPayment = p;
        this._invalidate();
    }

    private _interestOnlyYears = 0;

    get interestOnlyYears() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears;
        }
        return this._interestOnlyRepayments / this.paymentsCountPerYear;
    }

    set interestOnlyYears(y) {
        if (this._interestOnlyYears === y) {
            return;
        }
        this._interestOnlyYears = y;
        this._interestOnlyRepayments = 0;
        this._invalidate();
    }

    private _calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = false;

    get calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments() {
        return this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
    }

    set calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments(value) {
        this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = value;
        this._invalidate();
    }

    private _totalCost = 0;

    get totalCost() {
        this._calculate();
        return this._totalCost;
    }

    private _totalInterest = 0;

    get totalInterest() {
        this._calculate();
        return this._totalInterest;
    }

    private _payments: LoanPayment[] = [];

    get payments() {
        this._calculate();
        return this._payments;
    }

    private _armFixedRateForRepaymentCount = 0;

    get armFixedRateForRepaymentCount() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears * this.paymentsCountPerYear;
        }
        return this._armFixedRateForRepaymentCount;
    }

    set armFixedRateForRepaymentCount(n) {
        if (this._armFixedRateForRepaymentCount === n) {
            return;
        }
        this._armFixedRateForRepaymentCount = n;
        this._armFixedRateForYears = 0;
        this._invalidate();
    }

    private _armFixedRateForYears = 0;

    get armFixedRateForYears() {
        if (this._armFixedRateForYears) {
            return this._armFixedRateForYears;
        }
        return this._armFixedRateForRepaymentCount / this.paymentsCountPerYear;
    }

    set armFixedRateForYears(y) {
        if (this._armFixedRateForYears === y) {
            return;
        }
        this._armFixedRateForRepaymentCount = 0;
        this._armFixedRateForYears = y;
        this._invalidate();
    }

    private _armRepaymentCountBetweenAdjustments = 0;

    get armRepaymentCountBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments / 12 * this.paymentsCountPerYear;
        }
        return this._armRepaymentCountBetweenAdjustments;
    }

    set armRepaymentCountBetweenAdjustments(m) {
        if (this._armRepaymentCountBetweenAdjustments === m) {
            return;
        }
        this._armRepaymentCountBetweenAdjustments = m;
        this._armMonthsBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armMonthsBetweenAdjustments = 12;

    get armMonthsBetweenAdjustments() {
        if (this._armMonthsBetweenAdjustments) {
            return this._armMonthsBetweenAdjustments;
        }
        return this._armRepaymentCountBetweenAdjustments / this.paymentsCountPerYear * 12;
    }

    set armMonthsBetweenAdjustments(m) {
        if (this._armMonthsBetweenAdjustments === m) {
            return;
        }
        this._armMonthsBetweenAdjustments = m;
        this._armRepaymentCountBetweenAdjustments = 0;
        this._invalidate();
    }

    private _armExpectedAdjustmentRate: number = 0;

    get armExpectedAdjustmentRate() {
        return this._armExpectedAdjustmentRate;
    }

    set armExpectedAdjustmentRate(rate) {
        if (this._armExpectedAdjustmentRate === rate) {
            return;
        }
        this._armExpectedAdjustmentRate = rate;
        this._invalidate();
    }

    private _armMaximumInterestRate: number = 0;

    get armMaximumInterestRate() {
        return this._armMaximumInterestRate;
    }

    set armMaximumInterestRate(rate) {
        if (this._armMaximumInterestRate === rate) {
            return;
        }
        this._armMaximumInterestRate = rate;
        this._invalidate();
    }

    private _rounding = 8;

    get rounding() {
        return this._rounding;
    }

    set rounding(r) {
        if (this._rounding === r) {
            return;
        }
        this._rounding = r;
        this._invalidate();
    }

    get interestRate() {
        return this._rate;
    }

    set interestRate(rate) {
        if (this._rate === rate) {
            return;
        }
        this._rate = rate;
        this._invalidate();
    }

    get months() {
        return this._termInMonths;
    }

    set months(m) {
        if (this._termInMonths === m) {
            return;
        }
        this._termInMonths = m;
        this._invalidate();
    }

    get years() {
        return Math.floor(this._termInMonths / 12);
    }

    set years(y) {
        if (this._termInMonths === y * 12) {
            return;
        }
        this._termInMonths = y * 12;
        this._invalidate();
    }

    get interestOnlyRepaymentCount() {
        if (this._interestOnlyYears) {
            return this._interestOnlyYears * this.paymentsCountPerYear;
        }
        return this._interestOnlyRepayments;
    }

    set interestOnlyRepaymentCount(n: <fim_suffix>) {
        if (this._interestOnlyRepayments === n) {
            return;
        }
        this._interestOnlyRepayments = n;
        this._interestOnlyYears = 0;
        this._invalidate();
    }

    get armInitialVariableRate() {
        return this._armVariableRate;
    }

    set armInitialVariableRate(rate) {
        if (this._armVariableRate === rate) {
            return;
        }
        this._armVariableRate = rate;
        this._invalidate();
    }

    get paymentsCountPerYear() {
        switch (this._repaymentFrequency) {
            case 'yearly':
                return 1;
            case 'quarterly':
                return 4;
            case 'monthly':
                return 12;
            case 'fortnightly':
                return 26;
            case 'weekly':
                return 52;
        }
    }

    get paymentsCountTotal() {
        return Math.floor(this.paymentsCountPerYear * this._termInMonths / 12);
    }

    get repaymentAmount() {
        if (!this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments) {
            switch (this._repaymentFrequency) {
                case 'weekly':
                case 'fortnightly':
                    const monthly = this.clone();
                    monthly.repaymentFrequency = 'monthly';
                    return 'weekly' === this.repaymentFrequency
                        ? monthly.repaymentAmount / 4
                        : monthly.repaymentAmount / 2;
            }
        }
        const ppy = this.paymentsCountPerYear;
        const paymentsTotal = this.paymentsCountTotal;
        const interestOnlyRepayments = this._interestOnlyRepayments;
        const interest = this._rate / ppy / 100;
        const x = Math.pow(1 + interest, paymentsTotal - interestOnlyRepayments);
        const amount = (this._amount * x * interest) / (x - 1);
        return this._round(amount);
    }

    clone() {
        const copy = new Loan();
        copy._amount = this._amount;
        copy._rate = this._rate;
        copy._termInMonths = this._termInMonths;
        copy._repaymentFrequency = this._repaymentFrequency;
        copy._extraPayment = this._extraPayment;
        copy._interestOnlyRepayments = this._interestOnlyRepayments;
        copy._interestOnlyYears = this._interestOnlyYears;
        copy._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments = this._calculateWeeklyAndFortnightlyRepaymentsBasedOnYearlyRepayments;
        copy._armFixedRateForRepaymentCount = this._armFixedRateForRepaymentCount;
        copy._armFixedRateForYears = this._armFixedRateForYears;
        copy._armVariableRate = this._armVariableRate;
        copy._armRepaymentCountBetweenAdjustments = this._armRepaymentCountBetweenAdjustments;
        copy._armMonthsBetweenAdjustments = this._armMonthsBetweenAdjustments;
        copy._armExpectedAdjustmentRate = this._armExpectedAdjustmentRate;
        copy._armMaximumInterestRate = this._armMaximumInterestRate;
        copy._rounding = this._rounding;
        return copy;
    }

    private _invalidate() {
        this._calculated = false;
    }

    private _calcInterestRateForPeriod() {
        return this.interestRate / this.paymentsCountPerYear / 100;
    }

    private _calculate() {
        if (this._calculated) {
            return;
        }

        if (!this._amount || !this._termInMonths || !this._rate) {
            return;
        }

        this._payments = [];
        this._totalInterest = 0;
        this._totalCost = 0;

        let rate = this._calcInterestRateForPeriod();
        const repayment = this.repaymentAmount;
        const variableRate = this.armInitialVariableRate / 12 / 100;
        const interestOnlyRepayments = this.interestOnlyRepaymentCount;
        const adjustAfterRepayments = this.armFixedRateForRepaymentCount;
        const adjustmentPeriod = this.armRepaymentCountBetweenAdjustments;
        const adjustmentPercentage = this.armExpectedAdjustmentRate / 12 / 100;
        const maxAdjustedRate = this.armMaximumInterestRate / 12 / 100;
        const doAdjustments = variableRate && adjustmentPercentage && maxAdjustedRate;
        let balance = this.amount;
        for (let p = 0, n = this.paymentsCountTotal; balance > 0 && p < n; ++p) {
            if (doAdjustments) {
                if (p === adjustAfterRepayments) {
                    // first time change rate to variable one
                    rate = variableRate;
                }
                if ((p > adjustAfterRepayments) && (p % adjustmentPeriod === 0)) {
                    // then adjust each N repayments
                    rate = Math.min(rate + adjustmentPercentage, maxAdjustedRate);
                }
            }
            const extra = p >= interestOnlyRepayments
                ? this.extraPayment : 0;
            const interest = this._round(rate * balance);
            const amount = p >= interestOnlyRepayments
                ? this._round(Math.min(repayment + extra, balance + interest))
                : interest;
            const principal = p >= interestOnlyRepayments
                ? Math.min(this._round(repayment - interest + extra), balance) : 0;
            balance = this._round(balance - principal);
            this._addPayment(amount, principal, interest, balance);
        }

        if (round(balance, 2) > 0.01) { // ignore less-than-cent balance diffs
            // Interest only loan
            this._addPayment(balance, balance, 0, 0);
        }

        this._calculated = true;
    }

    private _addPayment(amount, principal, interest, balance) {
        let payment = {
            amount: amount,
            principal: principal,
            interest: interest,
            balance: balance
        } as LoanPayment;
        this._payments.push(payment);
        this._totalCost += payment.amount;
        this._totalInterest += payment.interest;
    }

    private _round(num) {
        return round(num, this._rounding);
    }
}

function round(num, f) {
    const div = Math.pow(10, f);
    return Math.round((num + Number.EPSILON) * div) / div;
}
<fim_middle>",correct,881
offsets,offsets,bf991cf13e41beda6a1e948184ea7f39b759886d,"<fim_prefix>interface offsets {
  vertical: number
  horizontal: number
}
export function measureOffsets (
  text,
  fontFamily,
  fontSize,
  createCanvas
): <fim_suffix> {
  const canvas = createCanvas()
  const ctx = canvas.getContext('2d')
  ctx.font = `${fontSize}px ${fontFamily}`

  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize
  ctx.font = `${fontSize}px ${fontFamily}`
  canvas.width = 2 * ctx.measureText(text).width
  canvas.height = 2 * fontSize

  ctx.font = `${fontSize}px ${fontFamily}`
  ctx.textBaseline = 'alphabetic'
  ctx.textAlign = 'center'
  ctx.fillStyle = 'white'
  ctx.fillText(text, canvas.width / 2, canvas.height / 2)

  const data = ctx.getImageData(0, 0, canvas.width, canvas.height).data

  let textTop = 0
  let textBottom = 0
  for (let y = 0; y <= canvas.height; y++) {
    for (let x = 0; x <= canvas.width; x++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]
      if (rValue === 255) {
        if (textTop === 0) {
          textTop = y
        }
        textBottom = y
        break
      }
    }
  }
  const canvasHorizontalCenterLine = canvas.height / 2
  const textHorizontalCenterLine = (textBottom - textTop) / 2 + textTop

  let textLeft = 0
  let textRight = 0
  for (let x = 0; x <= canvas.width; x++) {
    for (let y = 0; y <= canvas.height; y++) {
      const rIndex = 4 * (canvas.width * y + x)
      const rValue = data[rIndex]

      if (rValue === 255) {
        if (textLeft === 0) {
          textLeft = x
        }
        textRight = x
        break
      }
    }
  }

  const canvasVerticalCenterLine = canvas.width / 2
  const textVerticalCenterLine = (textRight - textLeft) / 2 + textLeft

  return {
    vertical: canvasHorizontalCenterLine - textHorizontalCenterLine,
    horizontal: canvasVerticalCenterLine - textVerticalCenterLine
  }
}
<fim_middle>",correct,4433
string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name: <fim_suffix>) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,22
string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name: <fim_suffix>) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,23
string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name: <fim_suffix>,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,28
string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name: <fim_suffix>) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,30
string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key: <fim_suffix>) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,31
string,string,56adb91b1ef4948b08a70815c7446daa4083f9e4,"<fim_prefix>export interface ElementUltraResolverOptions {
  /**
   * use commonjs lib & source css or scss for ssr
   */
  ssr?: boolean

  /**
   * auto import for directives
   *
   * @default true
   */
  directives?: boolean

  /**
   * exclude component name, if match do not resolve the name
   */
  exclude?: RegExp
}

type ElementUltraResolverOptionsResolved = Required<
  Omit<ElementUltraResolverOptions, 'exclude'>
> &
  Pick<ElementUltraResolverOptions, 'exclude'>

function getSideEffects(dirName: <fim_suffix>) {
  const esComponentsFolder = '@element-ultra/components'
  return `${esComponentsFolder}/${dirName}/style/index`
}

function kebabCase(key) {
  const result = key.replace(/([A-Z])/g, ' $1').trim()
  return result.split(' ').join('-').toLowerCase()
}

function resolveComponent(name) {
  if (!name.match(/^El[A-Z]/)) return

  const partialName = kebabCase(name.slice(2)) // ElTableColumn -> table-column

  return {
    importName: name,
    path: `element-ultra`,
    sideEffects: getSideEffects(partialName),
  }
}

function resolveDirective(
  name,
  options
) {
  if (!options.directives) return

  const directives: Record<string, { importName: string; styleName: string }> =
    {
      Loading: { importName: 'ElLoadingDirective', styleName: 'loading' },
      Popover: { importName: 'ElPopoverDirective', styleName: 'popover' },
      InfiniteScroll: {
        importName: 'ElInfiniteScroll',
        styleName: 'infinite-scroll',
      },
    }

  const directive = directives[name]
  if (!directive) return

  return {
    importName: directive.importName,
    path: `element-ultra`,
    sideEffects: getSideEffects(directive.styleName),
  }
}

export function ElementUltraResolver(
  options = {}
) {
  let optionsResolved: ElementUltraResolverOptionsResolved

  async function resolveOptions() {
    if (optionsResolved) return optionsResolved
    optionsResolved = {
      ssr: false,
      directives: true,
      exclude: undefined,
      ...options,
    }
    return optionsResolved
  }

  return [
    {
      type: 'component',
      resolve: async (name) => {
        return resolveComponent(name)
      },
    },
    {
      type: 'directive',
      resolve: async (name) => {
        return resolveDirective(name, await resolveOptions())
      },
    },
  ]
}
<fim_middle>",correct,33
string,string,d1ae764cb9ff20c750831ad4f32847ca64652d84,"<fim_prefix>interface BookmarkBefore {
    name: string
    url: string
    tags: string
    views: string
    discription: string
}

export const mainView = 'Home'

const bookmarksBefore: BookmarkBefore[] = [
    {
        name: 'Google',
        url: 'https://www.google.com',
        tags: 'Search',
        views: 'Home',
        discription: '',
    },
    {
        name: 'Baidu',
        url: 'http://www.baidu.com',
        tags: 'Search',
        views: 'Home',
        discription: '',
    },
    {
        name: 'Bing',
        url: 'https://www.bing.com',
        tags: 'Search',
        views: 'Home',
        discription: '',
    },
    {
        name: 'Zhihu',
        url: 'https://www.zhihu.com',
        tags: 'Social',
        views: 'Home',
        discription: '',
    },
    {
        name: 'BiliBili',
        url: 'https://www.bilibili.com',
        tags: 'Media',
        views: 'Home',
        discription: '',
    },
    {
        name: 'Youtube',
        url: 'https://www.youtube.com',
        tags: 'Media',
        views: 'Home',
        discription: '',
    },
    {
        name: 'Netflix',
        url: 'https://www.netflix.com',
        tags: 'Media',
        views: 'Home',
        discription: '',
    },
    {
        name: 'DeepL',
        url: 'https://www.deepl.com/translator',
        tags: 'Tools',
        views: 'Home',
        discription: '',
    },
    {
        name: 'Github',
        url: 'https://github.com',
        tags: 'Social',
        views: 'Develop, Home',
        discription: '',
    },
    {
        name: 'Gitee',
        url: 'https://gitee.com',
        tags: 'Social',
        views: 'Develop, Home',
        discription: '',
    },
    {
        name: 'LeetCode',
        url: 'https://leetcode-cn.com',
        tags: 'Social',
        views: 'Develop, Home',
        discription: '',
    },
    {
        name: 'CodePen',
        url: 'https://codepen.io',
        tags: 'Social',
        views: 'Develop, Home',
        discription: '',
    },
    {
        name: 'MDN Docs',
        url: 'https://developer.mozilla.org/zh-CN/',
        tags: 'Web',
        views: 'Develop, Home',
        discription: '',
    },
    {
        name: 'freeCodeCamp',
        url: 'https://chinese.freecodecamp.org/learn',
        tags: 'Web',
        views: 'Develop, Home',
        discription: '',
    },
    {
        name: 'Vuejs',
        url: 'https://v3.cn.vuejs.org',
        tags: 'Web',
        views: 'Develop',
        discription: '',
    },
    {
        name: 'React',
        url: 'https://zh-hans.reactjs.org',
        tags: 'Web',
        views: 'Develop',
        discription: '',
    },
    {
        name: 'Element',
        url: 'https://element-plus.org',
        tags: 'Web',
        views: 'Develop',
        discription: '',
    },
    {
        name: 'MUI',
        url: 'https://mui.com/zh/',
        tags: 'Web',
        views: 'Develop',
        discription: '',
    },
    {
        name: 'Webpack',
        url: 'https://webpack.docschina.org',
        tags: 'Web',
        views: 'Develop',
        discription: '',
    },
    {
        name: 'TypeScript',
        url: 'https://www.typescriptlang.org/zh/',
        tags: 'Web',
        views: 'Develop',
        discription: '',
    },
    {
        name: 'Python Docs',
        url: 'https://docs.python.org/3/',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'PyPI',
        url: 'https://pypi.org',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'TestPyPI',
        url: 'https://test.pypi.org',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'Flask',
        url: 'https://dormousehole.readthedocs.io/en/latest/',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'Django',
        url: 'https://www.djangoproject.com',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'PyTorch',
        url: 'https://pytorch.org',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'TensorFlow',
        url: 'https://www.tensorflow.org',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'Pandas',
        url: 'https://pandas.pydata.org',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'Numpy',
        url: 'https://numpy.org',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'Matplotlib',
        url: 'https://matplotlib.org',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'scikt-learn',
        url: 'https://scikit-learn.org/stable/',
        tags: 'Python',
        views: '',
        discription: '',
    },
    {
        name: 'ECharts',
        url: 'https://echarts.apache.org/zh/index.html',
        tags: 'Tools',
        views: '',
        discription: 'ECharts图表',
    },
    {
        name: 'Chart.js',
        url: 'https://chartjs.bootcss.com/',
        tags: 'Tools',
        views: '',
        discription: '轻量级图表',
    },
    {
        name: 'sweetalert2',
        url: 'https://www.sweetalert2.cn',
        tags: 'Tools',
        views: '',
        discription: '弹出框插件',
    },
    {
        name: 'mirai',
        url: 'https://docs.mirai.mamoe.net',
        tags: 'Tools',
        views: '',
        discription: 'QQ服务器mirai开发文档',
    },
    {
        name: 'regex101',
        url: 'https://regex101.com',
        tags: 'Tools',
        views: '',
        discription: '正则表达式测试',
    },
    {
        name: 'VectorLogoZone',
        url: 'https://www.vectorlogo.zone',
        tags: 'Tools',
        views: '',
        discription: '开发文档图标logo',
    },
    {
        name: 'ProcessOn',
        url: 'https://www.processon.com',
        tags: 'Tools',
        views: '',
        discription: '在线流程图思维导图',
    },
    {
        name: 'Excalidraw',
        url: 'https://excalidraw.com',
        tags: 'Tools',
        views: '',
        discription: '流程图画图工具',
    },
    {
        name: 'OKTools',
        url: 'https://oktools.net',
        tags: 'Tools',
        views: '',
        discription: '在线格式转换，编码转换',
    },
    {
        name: 'animista',
        url: 'https://animista.net',
        tags: 'Tools',
        views: '',
        discription: 'CSS UI调试',
    },
    {
        name: 'spinkit',
        url: 'https://tobiasahlin.com/spinkit/',
        tags: 'Tools',
        views: '',
        discription: '各类CSS加载样式',
    },
    {
        name: 'favicon.io',
        url: 'https://favicon.io/favicon-converter/',
        tags: 'Tools',
        views: '',
        discription: '各种尺寸favicon一键生成',
    },
    {
        name: 'Cronitor',
        url: 'https://crontab.guru',
        tags: 'Tools',
        views: '',
        discription: 'Crontab设置可视化',
    },
    {
        name: 'ShieldsIO',
        url: 'https://shields.io',
        tags: 'Tools',
        views: '',
        discription: 'README小图标生成',
    },
    {
        name: '30SecondsOfCode',
        url: 'https://www.30secondsofcode.org',
        tags: 'Tools',
        views: '',
        discription: 'EN各类面试题和知识点',
    },
    {
        name: 'DataStructVisual',
        url: 'https://www.cs.usfca.edu/~galles/visualization/Algorithms.html',
        tags: 'Tools',
        views: '',
        discription: '排序算法可视化',
    },
    {
        name: 'VSCodeThemes',
        url: 'https://vscodethemes.com',
        tags: 'Tools',
        views: '',
        discription: 'VSCode主题',
    },
]

const regexp = new RegExp('https{0,1}://.*?/')

function getFavicon(url: <fim_suffix>) {
    let favicon = url.match(regexp)
    if (favicon) return favicon[0] + 'favicon.ico'
    else return url + '/favicon.ico'
}

export interface Bookmark {
    name: string
    url: string
    img: string
    tags: string | null
    views: string | null
    discription: string
}

export const bookmarks: Bookmark[] = bookmarksBefore.map(item => {
    return {
        name: item.name,
        url: item.url,
        img: getFavicon(item.url),
        tags: item.tags,
        views: item.views,
        discription: item.discription,
    }
})<fim_middle>",correct,39
string,string,5e419a4136fb3538201beb1ba127f65816d4e1af,"<fim_prefix>/**
 * This is the sightseeings dataset for CHINADLE.
 *
 * https://github.com/z0gSh1u/chinadle
 */

// prettier-ignore
type ChinaProvinceOrCity =
  | '北京市'  | '广东省'
  | '山东省'  | '江苏省'
  | '河南省'  | '上海市'
  | '河北省'  | '浙江省'
  | '香港特别行政区'
  | '陕西省'  | '湖南省'
  | '重庆市'  | '福建省'
  | '天津市'  | '云南省'
  | '四川省'  | '广西壮族自治区'
  | '安徽省'  | '海南省'
  | '江西省'  | '湖北省'
  | '山西省'  | '辽宁省'
  | '黑龙江'  | '内蒙古自治区'
  | '澳门特别行政区'
  | '贵州省'  | '甘肃省'
  | '青海省'  | '新疆维吾尔自治区'
  | '西藏自治区'  | '吉林省'
  | '宁夏回族自治区'
  | '台湾'

export interface Sight {
  name: string
  coord: {
    lon: number
    lat: number
  }
  belong: ChinaProvinceOrCity
  brief: string
}

function makeSight(
  name,
  coord,
  belong,
  brief: <fim_suffix>
) {
  const _coord = coord.split(',').map(parseFloat)
  return {
    name,
    coord: {
      lon: _coord[0],
      lat: _coord[1],
    },
    belong,
    brief,
  } as Sight
}

export const ChinaSights: Sight[] = [
  makeSight(
    '泰山',
    '117.094738,36.269893',
    '山东省',
    '“直通帝座”的天堂，百姓崇拜，帝王告祭的神山。'
  ),

  makeSight(
    '黄山',
    '118.168089,30.13039',
    '安徽省',
    '被联合国教科文组织公布为世界地质公园。'
  ),

  makeSight(
    '长白山',
    '128.083986,42.066898',
    '吉林省',
    '中国满族的发祥地和满族文化圣山。'
  ),

  makeSight(
    '日月潭',
    '120.911881,23.854467',
    '台湾',
    '北半湖形状如圆日，南半湖形状如弯月。'
  ),

  makeSight(
    '故宫',
    '116.403414,39.924091',
    '北京市',
    '明清两代的皇家宫殿，旧称紫禁城。'
  ),

  makeSight(
    '黄鹤楼',
    '114.309043,30.550317',
    '湖北省',
    '因唐代诗人崔颢登楼所题《黄鹤楼》一诗而名扬四海。'
  ),

  makeSight(
    '黄果树瀑布',
    '105.679142,25.985778',
    '贵州省',
    '世界上最大的瀑布群'
  ),

  makeSight('秦始皇兵马俑', '109.2851,34.389417', '陕西省', '世界第八大奇迹'),

  makeSight(
    '武夷山',
    '117.963042,27.668108',
    '福建省',
    '典型的丹霞地貌，《世界遗产名录》'
  ),

  makeSight(
    '九寨沟',
    '103.921224,33.163223',
    '四川省',
    '中国第一个以保护自然风景为主要目的的自然保护区'
  ),

  makeSight(
    '布达拉宫',
    '91.125038,29.660346',
    '西藏自治区',
    '吐蕃王朝赞普松赞干布为迎娶文成公主而兴建。'
  ),

  makeSight(
    '东方明珠',
    '121.506379,31.245414',
    '上海市',
    '集都市观光、时尚餐饮、购物娱乐、历史陈列、浦江游览、会展演出、广播电视发射等多功能于一体的上海市标志性建筑之一。'
  ),

  makeSight(
    '井冈山',
    '114.143789,26.636167',
    '江西省',
    '开创了中国第一个农村革命根据地。'
  ),

  makeSight(
    '滕王阁',
    '115.887675,28.687376',
    '江西省',
    '滕王高阁临江渚，佩玉鸣鸾罢歌舞。阁中帝子今何在？槛外长江空自流。'
  ),

  makeSight(
    '天坛',
    '116.417246,39.888243',
    '北京市',
    '天坛公园在明、清两代是帝王祭祀皇天、祈五谷丰登之场所。'
  ),

  makeSight(
    '张家界',
    '110.441345,29.321096',
    '湖南省',
    '中国第一个国家森林公园。'
  ),

  makeSight(
    '鼓浪屿',
    '118.073467,24.450968',
    '福建省',
    '国家5A级旅游景区、全国重点文物保护单位。'
  ),
  
  makeSight(
    '丽江古城',
    '100.242047,26.876464',
    '云南省',
    '街道依山傍水修建，以红色角砾岩铺就。'
  ),

  makeSight(
    '天山天池',
    '88.135728,43.8873826',
    '新疆维吾尔自治区',
    '联合国教科文组织世界遗产名录。'
  ),

  makeSight(
    '中山陵',
    '118.861453,32.059739',
    '江苏省',
    '中国近代伟大的民主革命先行者孙中山先生的陵寝及其附属纪念建筑群。'
  ),
]
<fim_middle>",correct,44
string,string,5e419a4136fb3538201beb1ba127f65816d4e1af,"<fim_prefix>/**
 * This is the sightseeings dataset for CHINADLE.
 *
 * https://github.com/z0gSh1u/chinadle
 */

// prettier-ignore
type ChinaProvinceOrCity =
  | '北京市'  | '广东省'
  | '山东省'  | '江苏省'
  | '河南省'  | '上海市'
  | '河北省'  | '浙江省'
  | '香港特别行政区'
  | '陕西省'  | '湖南省'
  | '重庆市'  | '福建省'
  | '天津市'  | '云南省'
  | '四川省'  | '广西壮族自治区'
  | '安徽省'  | '海南省'
  | '江西省'  | '湖北省'
  | '山西省'  | '辽宁省'
  | '黑龙江'  | '内蒙古自治区'
  | '澳门特别行政区'
  | '贵州省'  | '甘肃省'
  | '青海省'  | '新疆维吾尔自治区'
  | '西藏自治区'  | '吉林省'
  | '宁夏回族自治区'
  | '台湾'

export interface Sight {
  name: string
  coord: {
    lon: number
    lat: number
  }
  belong: ChinaProvinceOrCity
  brief: string
}

function makeSight(
  name,
  coord: <fim_suffix>,
  belong,
  brief
) {
  const _coord = coord.split(',').map(parseFloat)
  return {
    name,
    coord: {
      lon: _coord[0],
      lat: _coord[1],
    },
    belong,
    brief,
  } as Sight
}

export const ChinaSights: Sight[] = [
  makeSight(
    '泰山',
    '117.094738,36.269893',
    '山东省',
    '“直通帝座”的天堂，百姓崇拜，帝王告祭的神山。'
  ),

  makeSight(
    '黄山',
    '118.168089,30.13039',
    '安徽省',
    '被联合国教科文组织公布为世界地质公园。'
  ),

  makeSight(
    '长白山',
    '128.083986,42.066898',
    '吉林省',
    '中国满族的发祥地和满族文化圣山。'
  ),

  makeSight(
    '日月潭',
    '120.911881,23.854467',
    '台湾',
    '北半湖形状如圆日，南半湖形状如弯月。'
  ),

  makeSight(
    '故宫',
    '116.403414,39.924091',
    '北京市',
    '明清两代的皇家宫殿，旧称紫禁城。'
  ),

  makeSight(
    '黄鹤楼',
    '114.309043,30.550317',
    '湖北省',
    '因唐代诗人崔颢登楼所题《黄鹤楼》一诗而名扬四海。'
  ),

  makeSight(
    '黄果树瀑布',
    '105.679142,25.985778',
    '贵州省',
    '世界上最大的瀑布群'
  ),

  makeSight('秦始皇兵马俑', '109.2851,34.389417', '陕西省', '世界第八大奇迹'),

  makeSight(
    '武夷山',
    '117.963042,27.668108',
    '福建省',
    '典型的丹霞地貌，《世界遗产名录》'
  ),

  makeSight(
    '九寨沟',
    '103.921224,33.163223',
    '四川省',
    '中国第一个以保护自然风景为主要目的的自然保护区'
  ),

  makeSight(
    '布达拉宫',
    '91.125038,29.660346',
    '西藏自治区',
    '吐蕃王朝赞普松赞干布为迎娶文成公主而兴建。'
  ),

  makeSight(
    '东方明珠',
    '121.506379,31.245414',
    '上海市',
    '集都市观光、时尚餐饮、购物娱乐、历史陈列、浦江游览、会展演出、广播电视发射等多功能于一体的上海市标志性建筑之一。'
  ),

  makeSight(
    '井冈山',
    '114.143789,26.636167',
    '江西省',
    '开创了中国第一个农村革命根据地。'
  ),

  makeSight(
    '滕王阁',
    '115.887675,28.687376',
    '江西省',
    '滕王高阁临江渚，佩玉鸣鸾罢歌舞。阁中帝子今何在？槛外长江空自流。'
  ),

  makeSight(
    '天坛',
    '116.417246,39.888243',
    '北京市',
    '天坛公园在明、清两代是帝王祭祀皇天、祈五谷丰登之场所。'
  ),

  makeSight(
    '张家界',
    '110.441345,29.321096',
    '湖南省',
    '中国第一个国家森林公园。'
  ),

  makeSight(
    '鼓浪屿',
    '118.073467,24.450968',
    '福建省',
    '国家5A级旅游景区、全国重点文物保护单位。'
  ),
  
  makeSight(
    '丽江古城',
    '100.242047,26.876464',
    '云南省',
    '街道依山傍水修建，以红色角砾岩铺就。'
  ),

  makeSight(
    '天山天池',
    '88.135728,43.8873826',
    '新疆维吾尔自治区',
    '联合国教科文组织世界遗产名录。'
  ),

  makeSight(
    '中山陵',
    '118.861453,32.059739',
    '江苏省',
    '中国近代伟大的民主革命先行者孙中山先生的陵寝及其附属纪念建筑群。'
  ),
]
<fim_middle>",correct,46
string,string,357ad94655b55a5de65645b359f819f4f0054ef6,"<fim_prefix>
export const MAGIC_METHOD_REG = /^@magic\:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
export const MAGIC_METHOD = ""@magic:"";
export const SPLITTER = ""|"";
export const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
export const FUNC_START_CHARACTER = ""("";
export const FUNC_END_CHARACTER = "")"";

export interface PipeParam {
    type: string;
    value?: string;
    args?: string[];
    func?: string;    
}

export interface PipeObject {
    [key: string]: PipeParam[];
}

export interface MagicMethodResult {
    originalMethod: string;
    method: string;
    args: string[];
    pipes: PipeParam[];
    keys: PipeObject;
}

export default class MagicMethod {

    static make (str, ...args) {
        return `${MAGIC_METHOD}${str} ${args.join(SPLITTER)}`;
    }

    static check(str) {
        return str.match(MAGIC_METHOD_REG) !== null;
    }

    static parse (str)  {
        const matches = str.match(MAGIC_METHOD_REG);
    
        if (!matches) {
            return undefined;
        }    


        const result = matches[0].split(""@magic:"")[1].split(SPLITTER).map(item => item.trim());

        let [ initializer, ...pipes ] = result;
        const [ method, ...args ] = initializer.split("" "");

        const pipeList = pipes.map(it => {
            return this.parsePipe(it);
        }).filter(it => it.value);

        const pipeObjects: PipeObject = {
            'function': [],
            'keyword': [],
            'value': []
        };
        
        pipeList.forEach(pipe => {
            if (pipe.type === ""function"") {
                pipeObjects.function.push(pipe);
            } else if (pipe.type === ""keyword"") {
                pipeObjects.keyword.push(pipe);
            } else {
                pipeObjects.value.push(pipe);
            }
        });

        return {
            originalMethod: str,
            method,
            args,
            pipes: pipeList,
            keys: pipeObjects
        };
    }

    static parsePipe(it: <fim_suffix>) {
        const result = it.match(FUNC_REGEXP);

        if (!result) {
            return {
                type: ""value"",
                value: it
            };
        }

        const [value] = result;

        if (value.includes(FUNC_START_CHARACTER)) {

            const [func, rest] = value.split(FUNC_START_CHARACTER)
            const [args] = rest.split(FUNC_END_CHARACTER);        
            return {
                type: ""function"",
                value,
                func,
                args: args.split("","").map(it => it.trim()).filter(Boolean)
            }
        } 

        return {
            type: ""keyword"",
            value: result[0]
        }
    }
}<fim_middle>",correct,51
string,string,357ad94655b55a5de65645b359f819f4f0054ef6,"<fim_prefix>
export const MAGIC_METHOD_REG = /^@magic\:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
export const MAGIC_METHOD = ""@magic:"";
export const SPLITTER = ""|"";
export const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
export const FUNC_START_CHARACTER = ""("";
export const FUNC_END_CHARACTER = "")"";

export interface PipeParam {
    type: string;
    value?: string;
    args?: string[];
    func?: string;    
}

export interface PipeObject {
    [key: string]: PipeParam[];
}

export interface MagicMethodResult {
    originalMethod: string;
    method: string;
    args: string[];
    pipes: PipeParam[];
    keys: PipeObject;
}

export default class MagicMethod {

    static make (str, ...args) {
        return `${MAGIC_METHOD}${str} ${args.join(SPLITTER)}`;
    }

    static check(str) {
        return str.match(MAGIC_METHOD_REG) !== null;
    }

    static parse (str: <fim_suffix>)  {
        const matches = str.match(MAGIC_METHOD_REG);
    
        if (!matches) {
            return undefined;
        }    


        const result = matches[0].split(""@magic:"")[1].split(SPLITTER).map(item => item.trim());

        let [ initializer, ...pipes ] = result;
        const [ method, ...args ] = initializer.split("" "");

        const pipeList = pipes.map(it => {
            return this.parsePipe(it);
        }).filter(it => it.value);

        const pipeObjects: PipeObject = {
            'function': [],
            'keyword': [],
            'value': []
        };
        
        pipeList.forEach(pipe => {
            if (pipe.type === ""function"") {
                pipeObjects.function.push(pipe);
            } else if (pipe.type === ""keyword"") {
                pipeObjects.keyword.push(pipe);
            } else {
                pipeObjects.value.push(pipe);
            }
        });

        return {
            originalMethod: str,
            method,
            args,
            pipes: pipeList,
            keys: pipeObjects
        };
    }

    static parsePipe(it) {
        const result = it.match(FUNC_REGEXP);

        if (!result) {
            return {
                type: ""value"",
                value: it
            };
        }

        const [value] = result;

        if (value.includes(FUNC_START_CHARACTER)) {

            const [func, rest] = value.split(FUNC_START_CHARACTER)
            const [args] = rest.split(FUNC_END_CHARACTER);        
            return {
                type: ""function"",
                value,
                func,
                args: args.split("","").map(it => it.trim()).filter(Boolean)
            }
        } 

        return {
            type: ""keyword"",
            value: result[0]
        }
    }
}<fim_middle>",correct,53
string,string,357ad94655b55a5de65645b359f819f4f0054ef6,"<fim_prefix>
export const MAGIC_METHOD_REG = /^@magic\:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
export const MAGIC_METHOD = ""@magic:"";
export const SPLITTER = ""|"";
export const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
export const FUNC_START_CHARACTER = ""("";
export const FUNC_END_CHARACTER = "")"";

export interface PipeParam {
    type: string;
    value?: string;
    args?: string[];
    func?: string;    
}

export interface PipeObject {
    [key: string]: PipeParam[];
}

export interface MagicMethodResult {
    originalMethod: string;
    method: string;
    args: string[];
    pipes: PipeParam[];
    keys: PipeObject;
}

export default class MagicMethod {

    static make (str, ...args) {
        return `${MAGIC_METHOD}${str} ${args.join(SPLITTER)}`;
    }

    static check(str: <fim_suffix>) {
        return str.match(MAGIC_METHOD_REG) !== null;
    }

    static parse (str)  {
        const matches = str.match(MAGIC_METHOD_REG);
    
        if (!matches) {
            return undefined;
        }    


        const result = matches[0].split(""@magic:"")[1].split(SPLITTER).map(item => item.trim());

        let [ initializer, ...pipes ] = result;
        const [ method, ...args ] = initializer.split("" "");

        const pipeList = pipes.map(it => {
            return this.parsePipe(it);
        }).filter(it => it.value);

        const pipeObjects: PipeObject = {
            'function': [],
            'keyword': [],
            'value': []
        };
        
        pipeList.forEach(pipe => {
            if (pipe.type === ""function"") {
                pipeObjects.function.push(pipe);
            } else if (pipe.type === ""keyword"") {
                pipeObjects.keyword.push(pipe);
            } else {
                pipeObjects.value.push(pipe);
            }
        });

        return {
            originalMethod: str,
            method,
            args,
            pipes: pipeList,
            keys: pipeObjects
        };
    }

    static parsePipe(it) {
        const result = it.match(FUNC_REGEXP);

        if (!result) {
            return {
                type: ""value"",
                value: it
            };
        }

        const [value] = result;

        if (value.includes(FUNC_START_CHARACTER)) {

            const [func, rest] = value.split(FUNC_START_CHARACTER)
            const [args] = rest.split(FUNC_END_CHARACTER);        
            return {
                type: ""function"",
                value,
                func,
                args: args.split("","").map(it => it.trim()).filter(Boolean)
            }
        } 

        return {
            type: ""keyword"",
            value: result[0]
        }
    }
}<fim_middle>",correct,55
string,string,357ad94655b55a5de65645b359f819f4f0054ef6,"<fim_prefix>
export const MAGIC_METHOD_REG = /^@magic\:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
export const MAGIC_METHOD = ""@magic:"";
export const SPLITTER = ""|"";
export const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
export const FUNC_START_CHARACTER = ""("";
export const FUNC_END_CHARACTER = "")"";

export interface PipeParam {
    type: string;
    value?: string;
    args?: string[];
    func?: string;    
}

export interface PipeObject {
    [key: string]: PipeParam[];
}

export interface MagicMethodResult {
    originalMethod: string;
    method: string;
    args: string[];
    pipes: PipeParam[];
    keys: PipeObject;
}

export default class MagicMethod {

    static make (str, ...args): <fim_suffix> {
        return `${MAGIC_METHOD}${str} ${args.join(SPLITTER)}`;
    }

    static check(str) {
        return str.match(MAGIC_METHOD_REG) !== null;
    }

    static parse (str)  {
        const matches = str.match(MAGIC_METHOD_REG);
    
        if (!matches) {
            return undefined;
        }    


        const result = matches[0].split(""@magic:"")[1].split(SPLITTER).map(item => item.trim());

        let [ initializer, ...pipes ] = result;
        const [ method, ...args ] = initializer.split("" "");

        const pipeList = pipes.map(it => {
            return this.parsePipe(it);
        }).filter(it => it.value);

        const pipeObjects: PipeObject = {
            'function': [],
            'keyword': [],
            'value': []
        };
        
        pipeList.forEach(pipe => {
            if (pipe.type === ""function"") {
                pipeObjects.function.push(pipe);
            } else if (pipe.type === ""keyword"") {
                pipeObjects.keyword.push(pipe);
            } else {
                pipeObjects.value.push(pipe);
            }
        });

        return {
            originalMethod: str,
            method,
            args,
            pipes: pipeList,
            keys: pipeObjects
        };
    }

    static parsePipe(it) {
        const result = it.match(FUNC_REGEXP);

        if (!result) {
            return {
                type: ""value"",
                value: it
            };
        }

        const [value] = result;

        if (value.includes(FUNC_START_CHARACTER)) {

            const [func, rest] = value.split(FUNC_START_CHARACTER)
            const [args] = rest.split(FUNC_END_CHARACTER);        
            return {
                type: ""function"",
                value,
                func,
                args: args.split("","").map(it => it.trim()).filter(Boolean)
            }
        } 

        return {
            type: ""keyword"",
            value: result[0]
        }
    }
}<fim_middle>",correct,56
string,string,357ad94655b55a5de65645b359f819f4f0054ef6,"<fim_prefix>
export const MAGIC_METHOD_REG = /^@magic\:([a-zA-Z][a-zA-Z0-9]*)[\W]{1}(.*)*$/g;
export const MAGIC_METHOD = ""@magic:"";
export const SPLITTER = ""|"";
export const FUNC_REGEXP = /(([\$a-z_\-]+)\([^\(\)]*\)|([a-z_\-]+))/gi;
export const FUNC_START_CHARACTER = ""("";
export const FUNC_END_CHARACTER = "")"";

export interface PipeParam {
    type: string;
    value?: string;
    args?: string[];
    func?: string;    
}

export interface PipeObject {
    [key: string]: PipeParam[];
}

export interface MagicMethodResult {
    originalMethod: string;
    method: string;
    args: string[];
    pipes: PipeParam[];
    keys: PipeObject;
}

export default class MagicMethod {

    static make (str: <fim_suffix>, ...args) {
        return `${MAGIC_METHOD}${str} ${args.join(SPLITTER)}`;
    }

    static check(str) {
        return str.match(MAGIC_METHOD_REG) !== null;
    }

    static parse (str)  {
        const matches = str.match(MAGIC_METHOD_REG);
    
        if (!matches) {
            return undefined;
        }    


        const result = matches[0].split(""@magic:"")[1].split(SPLITTER).map(item => item.trim());

        let [ initializer, ...pipes ] = result;
        const [ method, ...args ] = initializer.split("" "");

        const pipeList = pipes.map(it => {
            return this.parsePipe(it);
        }).filter(it => it.value);

        const pipeObjects: PipeObject = {
            'function': [],
            'keyword': [],
            'value': []
        };
        
        pipeList.forEach(pipe => {
            if (pipe.type === ""function"") {
                pipeObjects.function.push(pipe);
            } else if (pipe.type === ""keyword"") {
                pipeObjects.keyword.push(pipe);
            } else {
                pipeObjects.value.push(pipe);
            }
        });

        return {
            originalMethod: str,
            method,
            args,
            pipes: pipeList,
            keys: pipeObjects
        };
    }

    static parsePipe(it) {
        const result = it.match(FUNC_REGEXP);

        if (!result) {
            return {
                type: ""value"",
                value: it
            };
        }

        const [value] = result;

        if (value.includes(FUNC_START_CHARACTER)) {

            const [func, rest] = value.split(FUNC_START_CHARACTER)
            const [args] = rest.split(FUNC_END_CHARACTER);        
            return {
                type: ""function"",
                value,
                func,
                args: args.split("","").map(it => it.trim()).filter(Boolean)
            }
        } 

        return {
            type: ""keyword"",
            value: result[0]
        }
    }
}<fim_middle>",correct,58
string,string,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type: <fim_suffix>, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,72
string,string,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name: <fim_suffix>, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,73
string,string,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name: <fim_suffix>) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,80
string,string,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value): <fim_suffix> {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,125
string,string,1de17023db3dd839d67e3c887e3f8f7ca9330af7,"<fim_prefix>/*
 * Copyright by LunaSec (owned by Refinery Labs, Inc)
 *
 * Licensed under the Business Source License v1.1
 * (the ""License""); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at
 *
 * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt
 *
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
/* eslint-disable */

// To parse this data:
//
//   import { Convert } from ""./file"";
//
//   const grypeCvss = Convert.toGrypeCvss(json);
//
// These functions will throw an error if the JSON doesn't
// match the expected interface, even if the JSON is valid.

export interface GrypeCvss {
  VendorMetadata: any;
  Metrics: Metrics;
  Vector: string;
  Version: string;
}

export interface Metrics {
  BaseScore: number;
  ExploitabilityScore: number;
  ImpactScore: number;
}

// Converts JSON strings to/from your types
// and asserts the results of JSON.parse at runtime
export class Convert {
  public static toGrypeCvss(json: <fim_suffix>) {
    return cast(JSON.parse(json), a(r('GrypeCvss')));
  }

  public static grypeCvssToJson(value) {
    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);
  }
}

function invalidValue(typ, val, key = '') {
  if (key) {
    throw Error(`Invalid value for key ""${key}"". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);
  }
  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);
}

function jsonToJSProps(typ) {
  if (typ.jsonToJS === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.json] = { key: p.js, typ: p.typ }));
    typ.jsonToJS = map;
  }
  return typ.jsonToJS;
}

function jsToJSONProps(typ) {
  if (typ.jsToJSON === undefined) {
    const map: any = {};
    typ.props.forEach((p) => (map[p.js] = { key: p.json, typ: p.typ }));
    typ.jsToJSON = map;
  }
  return typ.jsToJSON;
}

function transform(val, typ, getProps, key = '') {
  function transformPrimitive(typ, val) {
    if (typeof typ === typeof val) return val;
    return invalidValue(typ, val, key);
  }

  function transformUnion(typs, val) {
    // val must validate against one typ in typs
    const l = typs.length;
    for (let i = 0; i < l; i++) {
      const typ = typs[i];
      try {
        return transform(val, typ, getProps);
      } catch (_) {}
    }
    return invalidValue(typs, val);
  }

  function transformEnum(cases, val) {
    if (cases.indexOf(val) !== -1) return val;
    return invalidValue(cases, val);
  }

  function transformArray(typ, val) {
    // val must be an array with no invalid elements
    if (!Array.isArray(val)) return invalidValue('array', val);
    return val.map((el) => transform(el, typ, getProps));
  }

  function transformDate(val) {
    if (val === null) {
      return null;
    }
    const d = new Date(val);
    if (isNaN(d.valueOf())) {
      return invalidValue('Date', val);
    }
    return d;
  }

  function transformObject(props, additional, val) {
    if (val === null || typeof val !== 'object' || Array.isArray(val)) {
      return invalidValue('object', val);
    }
    const result: any = {};
    Object.getOwnPropertyNames(props).forEach((key) => {
      const prop = props[key];
      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;
      result[prop.key] = transform(v, prop.typ, getProps, prop.key);
    });
    Object.getOwnPropertyNames(val).forEach((key) => {
      if (!Object.prototype.hasOwnProperty.call(props, key)) {
        result[key] = transform(val[key], additional, getProps, key);
      }
    });
    return result;
  }

  if (typ === 'any') return val;
  if (typ === null) {
    if (val === null) return val;
    return invalidValue(typ, val);
  }
  if (typ === false) return invalidValue(typ, val);
  while (typeof typ === 'object' && typ.ref !== undefined) {
    typ = typeMap[typ.ref];
  }
  if (Array.isArray(typ)) return transformEnum(typ, val);
  if (typeof typ === 'object') {
    return typ.hasOwnProperty('unionMembers')
      ? transformUnion(typ.unionMembers, val)
      : typ.hasOwnProperty('arrayItems')
      ? transformArray(typ.arrayItems, val)
      : typ.hasOwnProperty('props')
      ? transformObject(getProps(typ), typ.additional, val)
      : invalidValue(typ, val);
  }
  // Numbers can be parsed by Date but shouldn't be.
  if (typ === Date && typeof val !== 'number') return transformDate(val);
  return transformPrimitive(typ, val);
}

function cast<T>(val, typ) {
  return transform(val, typ, jsonToJSProps);
}

function uncast<T>(val, typ) {
  return transform(val, typ, jsToJSONProps);
}

function a(typ) {
  return { arrayItems: typ };
}

function u(...typs) {
  return { unionMembers: typs };
}

function o(props, additional) {
  return { props, additional };
}

function m(additional) {
  return { props: [], additional };
}

function r(name) {
  return { ref: name };
}

const typeMap: any = {
  GrypeCvss: o(
    [
      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },
      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },
      { json: 'Vector', js: 'Vector', typ: '' },
      { json: 'Version', js: 'Version', typ: '' },
    ],
    false
  ),
  Metrics: o(
    [
      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },
      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },
      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },
    ],
    false
  ),
};
<fim_middle>",correct,128
string,string,1942b6b08f1aea40481f0b76c0f95f441675e192,"<fim_prefix>export interface ILiquidityPoolsFilter {
  keyword?: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string
}

export enum StakingStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum MiningStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum NominationStatus {
  Any = 'Any',
  Nominated = 'Nominated',
  Excluded = 'Excluded'
}

export enum LpOrderBy {
  Default = 'Default',
  Liquidity = 'Liquidity',
  Volume = 'Volume',
  StakingWeight = 'StakingWeight'
}

export class LiquidityPoolsFilter implements ILiquidityPoolsFilter {
  keyword: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string

  constructor(filter) {
    if (filter === null || filter === undefined) {
      this.limit = 5;
      this.direction = 'DESC';
      return;
    };

    this.keyword = filter.keyword;
    this.tokens = filter.tokens || [];
    this.markets = filter.markets || [];
    this.liquidityPools = filter.liquidityPools || [];
    this.stakingStatus = filter.stakingStatus;
    this.miningStatus = filter.miningStatus;
    this.nominationStatus = filter.nominationStatus;
    this.orderBy = filter.orderBy;
    this.limit = filter.limit;
    this.direction = filter.direction;
    this.cursor = filter.cursor;
  }

  buildQueryString() {
    if (this.cursor?.length) return `?cursor=${this.cursor}`;

    let query = '';

    if (this.tokens?.length > 0) {
      this.tokens.forEach(contract => query = this.addToQuery(query, 'tokens', contract));
    }

    if (this.liquidityPools?.length > 0) {
      this.liquidityPools.forEach(contract => query = this.addToQuery(query, 'liquidityPools', contract));
    }

    if (this.markets?.length > 0) {
      this.markets.forEach(contract => query = this.addToQuery(query, 'markets', contract));
    }

    query = this.addToQuery(query, 'keyword', this.keyword);
    query = this.addToQuery(query, 'stakingStatus', this.stakingStatus);
    query = this.addToQuery(query, 'miningStatus', this.miningStatus);
    query = this.addToQuery(query, 'nominationStatus', this.nominationStatus);
    query = this.addToQuery(query, 'orderBy', this.orderBy);
    query = this.addToQuery(query, 'limit', this.limit);
    query = this.addToQuery(query, 'direction', this.direction);

    return query
  }

  private addToQuery(query, key, value): <fim_suffix> {
    if (!!value === false) return query;

    const leading = query.length > 0 ? '&' : '?';

    return `${query}${leading}${key}=${value}`;
  }
}
<fim_middle>",correct,129
string,string,1942b6b08f1aea40481f0b76c0f95f441675e192,"<fim_prefix>export interface ILiquidityPoolsFilter {
  keyword?: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string
}

export enum StakingStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum MiningStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum NominationStatus {
  Any = 'Any',
  Nominated = 'Nominated',
  Excluded = 'Excluded'
}

export enum LpOrderBy {
  Default = 'Default',
  Liquidity = 'Liquidity',
  Volume = 'Volume',
  StakingWeight = 'StakingWeight'
}

export class LiquidityPoolsFilter implements ILiquidityPoolsFilter {
  keyword: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string

  constructor(filter) {
    if (filter === null || filter === undefined) {
      this.limit = 5;
      this.direction = 'DESC';
      return;
    };

    this.keyword = filter.keyword;
    this.tokens = filter.tokens || [];
    this.markets = filter.markets || [];
    this.liquidityPools = filter.liquidityPools || [];
    this.stakingStatus = filter.stakingStatus;
    this.miningStatus = filter.miningStatus;
    this.nominationStatus = filter.nominationStatus;
    this.orderBy = filter.orderBy;
    this.limit = filter.limit;
    this.direction = filter.direction;
    this.cursor = filter.cursor;
  }

  buildQueryString() {
    if (this.cursor?.length) return `?cursor=${this.cursor}`;

    let query = '';

    if (this.tokens?.length > 0) {
      this.tokens.forEach(contract => query = this.addToQuery(query, 'tokens', contract));
    }

    if (this.liquidityPools?.length > 0) {
      this.liquidityPools.forEach(contract => query = this.addToQuery(query, 'liquidityPools', contract));
    }

    if (this.markets?.length > 0) {
      this.markets.forEach(contract => query = this.addToQuery(query, 'markets', contract));
    }

    query = this.addToQuery(query, 'keyword', this.keyword);
    query = this.addToQuery(query, 'stakingStatus', this.stakingStatus);
    query = this.addToQuery(query, 'miningStatus', this.miningStatus);
    query = this.addToQuery(query, 'nominationStatus', this.nominationStatus);
    query = this.addToQuery(query, 'orderBy', this.orderBy);
    query = this.addToQuery(query, 'limit', this.limit);
    query = this.addToQuery(query, 'direction', this.direction);

    return query
  }

  private addToQuery(query, key: <fim_suffix>, value) {
    if (!!value === false) return query;

    const leading = query.length > 0 ? '&' : '?';

    return `${query}${leading}${key}=${value}`;
  }
}
<fim_middle>",correct,131
string,string,1942b6b08f1aea40481f0b76c0f95f441675e192,"<fim_prefix>export interface ILiquidityPoolsFilter {
  keyword?: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string
}

export enum StakingStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum MiningStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum NominationStatus {
  Any = 'Any',
  Nominated = 'Nominated',
  Excluded = 'Excluded'
}

export enum LpOrderBy {
  Default = 'Default',
  Liquidity = 'Liquidity',
  Volume = 'Volume',
  StakingWeight = 'StakingWeight'
}

export class LiquidityPoolsFilter implements ILiquidityPoolsFilter {
  keyword: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string

  constructor(filter) {
    if (filter === null || filter === undefined) {
      this.limit = 5;
      this.direction = 'DESC';
      return;
    };

    this.keyword = filter.keyword;
    this.tokens = filter.tokens || [];
    this.markets = filter.markets || [];
    this.liquidityPools = filter.liquidityPools || [];
    this.stakingStatus = filter.stakingStatus;
    this.miningStatus = filter.miningStatus;
    this.nominationStatus = filter.nominationStatus;
    this.orderBy = filter.orderBy;
    this.limit = filter.limit;
    this.direction = filter.direction;
    this.cursor = filter.cursor;
  }

  buildQueryString() {
    if (this.cursor?.length) return `?cursor=${this.cursor}`;

    let query = '';

    if (this.tokens?.length > 0) {
      this.tokens.forEach(contract => query = this.addToQuery(query, 'tokens', contract));
    }

    if (this.liquidityPools?.length > 0) {
      this.liquidityPools.forEach(contract => query = this.addToQuery(query, 'liquidityPools', contract));
    }

    if (this.markets?.length > 0) {
      this.markets.forEach(contract => query = this.addToQuery(query, 'markets', contract));
    }

    query = this.addToQuery(query, 'keyword', this.keyword);
    query = this.addToQuery(query, 'stakingStatus', this.stakingStatus);
    query = this.addToQuery(query, 'miningStatus', this.miningStatus);
    query = this.addToQuery(query, 'nominationStatus', this.nominationStatus);
    query = this.addToQuery(query, 'orderBy', this.orderBy);
    query = this.addToQuery(query, 'limit', this.limit);
    query = this.addToQuery(query, 'direction', this.direction);

    return query
  }

  private addToQuery(query: <fim_suffix>, key, value) {
    if (!!value === false) return query;

    const leading = query.length > 0 ? '&' : '?';

    return `${query}${leading}${key}=${value}`;
  }
}
<fim_middle>",correct,132
string,string,1942b6b08f1aea40481f0b76c0f95f441675e192,"<fim_prefix>export interface ILiquidityPoolsFilter {
  keyword?: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string
}

export enum StakingStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum MiningStatus {
  Any = 'Any',
  Enabled = 'Enabled',
  Disabled = 'Disabled'
}

export enum NominationStatus {
  Any = 'Any',
  Nominated = 'Nominated',
  Excluded = 'Excluded'
}

export enum LpOrderBy {
  Default = 'Default',
  Liquidity = 'Liquidity',
  Volume = 'Volume',
  StakingWeight = 'StakingWeight'
}

export class LiquidityPoolsFilter implements ILiquidityPoolsFilter {
  keyword: string;
  tokens?: string[];
  liquidityPools?: string[];
  markets?: string[];
  stakingStatus?: StakingStatus;
  miningStatus?: MiningStatus;
  nominationStatus?: NominationStatus;
  orderBy?: LpOrderBy;
  limit?: number;
  direction?: string;
  cursor?: string

  constructor(filter) {
    if (filter === null || filter === undefined) {
      this.limit = 5;
      this.direction = 'DESC';
      return;
    };

    this.keyword = filter.keyword;
    this.tokens = filter.tokens || [];
    this.markets = filter.markets || [];
    this.liquidityPools = filter.liquidityPools || [];
    this.stakingStatus = filter.stakingStatus;
    this.miningStatus = filter.miningStatus;
    this.nominationStatus = filter.nominationStatus;
    this.orderBy = filter.orderBy;
    this.limit = filter.limit;
    this.direction = filter.direction;
    this.cursor = filter.cursor;
  }

  buildQueryString(): <fim_suffix> {
    if (this.cursor?.length) return `?cursor=${this.cursor}`;

    let query = '';

    if (this.tokens?.length > 0) {
      this.tokens.forEach(contract => query = this.addToQuery(query, 'tokens', contract));
    }

    if (this.liquidityPools?.length > 0) {
      this.liquidityPools.forEach(contract => query = this.addToQuery(query, 'liquidityPools', contract));
    }

    if (this.markets?.length > 0) {
      this.markets.forEach(contract => query = this.addToQuery(query, 'markets', contract));
    }

    query = this.addToQuery(query, 'keyword', this.keyword);
    query = this.addToQuery(query, 'stakingStatus', this.stakingStatus);
    query = this.addToQuery(query, 'miningStatus', this.miningStatus);
    query = this.addToQuery(query, 'nominationStatus', this.nominationStatus);
    query = this.addToQuery(query, 'orderBy', this.orderBy);
    query = this.addToQuery(query, 'limit', this.limit);
    query = this.addToQuery(query, 'direction', this.direction);

    return query
  }

  private addToQuery(query, key, value) {
    if (!!value === false) return query;

    const leading = query.length > 0 ? '&' : '?';

    return `${query}${leading}${key}=${value}`;
  }
}
<fim_middle>",correct,133
string,string,196eddfafd2d46c55f2c0ee864b90bcea2e010a9,"<fim_prefix>type FormatType = 'money' | 'cn_money'

class Num {
  private v!: number

  private static numberFmt = new Intl.NumberFormat('zh-Hans-CN', {
    maximumFractionDigits: 2
  })

  private money(money, decimal?) {
    if (!money) return '0'
    let [intPart, decPart = ''] = String(money).split('.')
    const len = intPart.length - 1
    let arr: string[] = []
    intPart
      .split('')
      .reverse()
      .forEach((item: <fim_suffix>, index) => {
        arr.push(item)
        if (index && (index + 1) % 3 === 0 && index !== len) {
          arr.push(',')
        }
      })
    let result = arr.reverse().join('')
    if(decimal) {
      decPart = decPart?.substring(0, decimal)
      result = `${result}.${decPart.padEnd(decimal, '0')}`
    }else {
      decPart ? result = `${result}.${decPart}` : void 0
    }
    return result
  }

  private cn_money(money) {
    const CN_NUMS = ['零', '壹', '贰', '叁', '肆', '伍', '陆', '柒', '捌', '玖']
    const CN_INT_RADICE = ['', '拾', '佰', '仟']
    const CN_INT_UNITS = ['', '万', '亿', '兆']
    const CN_DEC_UNITS = ['角', '分', '毫', '厘']
    let result = ''
    if (!money) return '零元整'
    if (money >= 999999999999999.9999) return ''
    const [intPart, decPart] = String(+money.toFixed(4)).split('.')
    if (parseInt(intPart, 10) > 0) {
      let count = 0
      const IntLen = intPart.length
      for (let i = 0; i < IntLen; i++) {
        let n = intPart.substring(i, i + 1)
        let p = IntLen - i - 1
        let q = p / 4
        let m = p % 4
        if (n === '0') {
          count++
        } else {
          if (count > 0) {
            result += CN_NUMS[0]
          }
          count = 0
          result += CN_NUMS[parseInt(n)] + CN_INT_RADICE[m]
        }
        if (m === 0 && count < 4) {
          result += CN_INT_UNITS[q]
        }
      }
      result = `${result}元`
    }
    if (decPart) {
      const decLen = decPart.length
      for (let i = 0; i < decLen; i++) {
        let n = decPart.substring(i, i + 1)
        if (n !== '0') result += CN_NUMS[Number(n)] + CN_DEC_UNITS[i]
      }
    } else {
      result = `${result}整`
    }
    return result
  }

  constructor(n) {
    this.v = n
  }

  /**
   * 将数字格式化
   * @param type 格式化类型
   * @param decimal 小数位数
   */
  format(type, decimal?) {
    return this[type](this.v, decimal)
  }

  /**
   * 指定数字最大保留几位小数点
   * @param n 位数
   */
  fixed(n) {
    const { v } = this
    return +v.toFixed(n)
  }

  /**
   * 遍历数字
  */
   each(fn) {
    const { v } = this
    for(let i = 1; i <= v; i++) {
      fn(i)
    }
  }
}

interface N {
  (n)
}

/**
 * 包裹一个数字以方便
 * @param n 数字
 */
export const n = <N>function n(n) {
  return new Num(n)
}
<fim_middle>",correct,145
string,string,31aa148b40c5f5c58ac8f3921068c68d4402d68f,"<fim_prefix>export interface IGoogleLanguage {
  language_name: string;
  language_code: string;
}

export const google_languages: IGoogleLanguage[] = [
  { language_name: ""Automatic Detection"", language_code: ""auto"" },
  { language_name: ""Afrikaans"", language_code: ""af"" },
  { language_name: ""Albanian"", language_code: ""sq"" },
  { language_name: ""Arabic"", language_code: ""ar"" },
  { language_name: ""Azerbaijani"", language_code: ""az"" },
  { language_name: ""Basque"", language_code: ""eu"" },
  { language_name: ""Bengali"", language_code: ""bn"" },
  { language_name: ""Belarusian"", language_code: ""be"" },
  { language_name: ""Bulgarian"", language_code: ""bg"" },
  { language_name: ""Catalan"", language_code: ""ca"" },
  { language_name: ""Chinese Simplified"", language_code: ""zh-CN"" },
  { language_name: ""Chinese Traditional"", language_code: ""zh-TW"" },
  { language_name: ""Croatian"", language_code: ""hr"" },
  { language_name: ""Czech"", language_code: ""cs"" },
  { language_name: ""Danish"", language_code: ""da"" },
  { language_name: ""Dutch"", language_code: ""nl"" },
  { language_name: ""English"", language_code: ""en"" },
  { language_name: ""Esperanto"", language_code: ""eo"" },
  { language_name: ""Estonian"", language_code: ""et"" },
  { language_name: ""Filipino"", language_code: ""tl"" },
  { language_name: ""Finnish"", language_code: ""fi"" },
  { language_name: ""French"", language_code: ""fr"" },
  { language_name: ""Galician"", language_code: ""gl"" },
  { language_name: ""Georgian"", language_code: ""ka"" },
  { language_name: ""German"", language_code: ""de"" },
  { language_name: ""Greek"", language_code: ""el"" },
  { language_name: ""Gujarati"", language_code: ""gu"" },
  { language_name: ""Haitian Creole"", language_code: ""ht"" },
  { language_name: ""Hebrew"", language_code: ""iw"" },
  { language_name: ""Hindi"", language_code: ""hi"" },
  { language_name: ""Hungarian"", language_code: ""hu"" },
  { language_name: ""Icelandic"", language_code: ""is"" },
  { language_name: ""Indonesian"", language_code: ""id"" },
  { language_name: ""Irish"", language_code: ""ga"" },
  { language_name: ""Italian"", language_code: ""it"" },
  { language_name: ""Japanese"", language_code: ""ja"" },
  { language_name: ""Kannada"", language_code: ""kn"" },
  { language_name: ""Korean"", language_code: ""ko"" },
  { language_name: ""Latin"", language_code: ""la"" },
  { language_name: ""Latvian"", language_code: ""lv"" },
  { language_name: ""Lithuanian"", language_code: ""lt"" },
  { language_name: ""Macedonian"", language_code: ""mk"" },
  { language_name: ""Malay"", language_code: ""ms"" },
  { language_name: ""Maltese"", language_code: ""mt"" },
  { language_name: ""Norwegian"", language_code: ""no"" },
  { language_name: ""Persian"", language_code: ""fa"" },
  { language_name: ""Polish"", language_code: ""pl"" },
  { language_name: ""Portuguese"", language_code: ""pt"" },
  { language_name: ""Romanian"", language_code: ""ro"" },
  { language_name: ""Russian"", language_code: ""ru"" },
  { language_name: ""Serbian"", language_code: ""sr"" },
  { language_name: ""Slovak"", language_code: ""sk"" },
  { language_name: ""Slovenian"", language_code: ""sl"" },
  { language_name: ""Spanish"", language_code: ""es"" },
  { language_name: ""Swahili"", language_code: ""sw"" },
  { language_name: ""Swedish"", language_code: ""sv"" },
  { language_name: ""Tamil"", language_code: ""ta"" },
  { language_name: ""Telugu"", language_code: ""te"" },
  { language_name: ""Thai"", language_code: ""th"" },
  { language_name: ""Turkish"", language_code: ""tr"" },
  { language_name: ""Ukrainian"", language_code: ""uk"" },
  { language_name: ""Urdu"", language_code: ""ur"" },
  { language_name: ""Vietnamese"", language_code: ""vi"" },
  { language_name: ""Welsh"", language_code: ""cy"" },
  { language_name: ""Yiddish"", language_code: ""yi"" },
];

export function getLanguagesFromGoogleUrl(url: <fim_suffix>) {
  const parsedUrl = url.match(/#(\w+)\/(\w+)\//);
  if (!parsedUrl) {
    throw new Error(`Could not parse google url: ${url}`);
  }
  const [, fromCode, toCode] = parsedUrl;
  const fromLang = google_languages.find((l) => l.language_code === fromCode);
  const toLang = google_languages.find((l) => l.language_code === toCode);
  if (!fromLang || !toLang) {
    throw new Error(
      `Could not find language with code ${fromCode} or ${toCode}. Check if ${url} is valid google url`
    );
  }
  const from = fromLang.language_code;
  const to = toLang.language_code;
  return { from, to };
}
<fim_middle>",correct,200
string,string,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name: <fim_suffix>
) => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,207
string,string,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook: <fim_suffix>,
  name
) => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,208
string,string,181ec44034d7ff44d9293788b657b1a2036d874b,"<fim_prefix>type InstanceType = ""object"" | ""array"" | ""boolean"" | ""number"" | ""string"";

export interface ValidationError {
  /**
   * Schema keyword.
   */
  keyword: string;

  /**
   * Schema location.
   */
  location: string;

  /**
   * Error message.
   */
  message: string;
}

export interface ValidationResult {
  /**
   * Validation test result.
   */
  valid: boolean;

  /**
   * Any validation test errors.
   */
  errors: ValidationError[];
}

/**
 * @summary Subset of JSON Type Definition.
 *
 * @see https://ajv.js.org/json-type-definition.html
 */
export interface Schema {
  type?: InstanceType;
  properties?: Record<string, Schema>;
}

/**
 * @summary Schema-based data validator.
 */
export class Validator {
  constructor(private readonly schema) {}

  /**
   * Performs the instance validation test based on the provided schema.
   * @param instance the instance to validate.
   * @returns result of validation test.
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  public test(instance) {
    return this.validate(instance, this.schema, ""#"");
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private validate(instance, schema, location: <fim_suffix>) {
    const instanceType = this.processInstance(instance);
    const { type: $type, properties: $properties } = schema;
    const errors: ValidationError[] = [];

    // type
    if ($type && $type !== instanceType) {
      errors.push({
        keyword: ""type"",
        location: `${location}/type`,
        message: `Instance type ""${instanceType}"" is invalid. Expected ""${$type}"".`,
      });
    }

    // properties
    if ($properties) {
      for (const key in $properties) {
        if (key in instance) {
          const result = this.validate(
            instance[key],
            $properties[key] ?? {},
            `${location}/properties`
          );
          if (!result.valid) {
            errors.push(
              {
                keyword: ""properties"",
                location: `${location}/properties`,
                message: `Property ""${key}"" does not match schema.`,
              },
              ...result.errors
            );
          }
        } else {
          errors.push({
            keyword: ""properties"",
            location: `${location}/properties`,
            message: `Instance does not have required property ""${key}"".`,
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors: errors,
    };
  }

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  private processInstance(instance) {
    const rawType = typeof instance;

    switch (rawType) {
      case ""boolean"":
      case ""number"":
      case ""string"":
        return rawType;
      case ""object"":
        if (Array.isArray(instance)) return ""array"";
        else return ""object"";
      default:
        // undefined, bigint, function, symbol
        throw new Error(`Instances of ""${rawType}"" type are not supported.`);
    }
  }
}
<fim_middle>",correct,230
string,string,3fd36051e56b9451affaa4278b0bd7bb46f75155,"<fim_prefix>type propType = {
	user: string;
	text: string;
	number: string | undefined;
	base: string;
	accent: string;
	icon: boolean;
	flat: boolean;
};

function darken(color: <fim_suffix>, percent) {
	const num = parseInt(color.replace('#', ''), 16),
		amt = Math.round(2.55 * percent),
		R = (num >> 16) + amt,
		B = ((num >> 8) & 0x00ff) + amt,
		G = (num & 0x0000ff) + amt;
	return (
		'#' +
		(
			0x1000000 +
			(R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
			(B < 255 ? (B < 1 ? 0 : B) : 255) * 0x100 +
			(G < 255 ? (G < 1 ? 0 : G) : 255)
		)
			.toString(16)
			.slice(1)
	);
}

export default function standardTemplate(props) {
	function offsetText() {
		if (props.number) {
			if (parseInt(props.number, 10) < 10) {
				return '22';
			}
			if (
				parseInt(props.number, 10) >= 10 &&
				parseInt(props.number) < 100
			) {
				return '18';
			}
			if (
				parseInt(props.number) >= 100 &&
				parseInt(props.number) < 1000
			) {
				return '14';
			}
			if (
				parseInt(props.number) >= 100 &&
				parseInt(props.number) < 1000
			) {
				return '11';
			}
			if (
				parseInt(props.number) >= 1000 &&
				parseInt(props.number) < 10000
			) {
				return '10';
			}
			if (
				parseInt(props.number) >= 10000 &&
				parseInt(props.number) < 100000
			) {
				return '8';
			}
			if (
				parseInt(props.number) >= 100000 &&
				parseInt(props.number) < 999999
			) {
				return '4';
			}
			if (parseInt(props.number) > 999999) {
				return '16';
			}
		}
	}

	function isFlat(section) {
		if (props.flat != true) {
			return `<stop stop-color=""${darken(section, 20)}""
      offset=""0%""/>`;
		}
		return null;
	}

	const itsOverAMillion =
		props.number && parseInt(props.number) < 999999 ? props.number : '1M+';

	const icon =
		props.icon == true
			? `<svg x=""22""><path dominant-baseline=""middle"" fill=""${props.text}"" d=""M10 7.5a2.5 2.5 0 1 0 2.5 2.5A2.5 2.5 0 0 0 10 7.5zm0 7a4.5 4.5 0 1 1 4.5-4.5 4.5 4.5 0 0 1-4.5 4.5zM10 3C3 3 0 10 0 10s3 7 10 7 10-7 10-7-3-7-10-7z""/></svg>`
			: `<text fill=""${darken(props.text, 8)}""
              fill-opacity="".2"">
        <tspan x=""15"" y=""15"" aria-hidden=""true"">Views</tspan>
      </text>
      <text fill=""${props.text}"">
        <tspan x=""15"" y=""14.5"">Views</tspan>
      </text>`;
	return `<svg xmlns=""http://www.w3.org/2000/svg"" width=""115"" height=""20"">
  <title>${props.user} - ${props.number} Views</title>
  <defs>
    <linearGradient id=""text-fill"" x1=""50%"" y1=""0%"" x2=""50%"" y2=""100%"">
      ${isFlat(props.base)}
      <stop stop-color=""${props.base}"" offset=""100%""/>
    </linearGradient>
    <linearGradient id=""count-fill"" x1=""50%"" y1=""0%"" x2=""50%"" y2=""100%"">
      ${isFlat(props.accent)}
      <stop stop-color=""${props.accent}"" offset=""100%""/>
    </linearGradient>
  </defs>
   <g fill=""none"" fill-rule=""evenodd"">
    <g font-family=""'DejaVu Sans',Verdana,Geneva,sans-serif"" font-size=""11"">
      <path d=""M0,3 C0,1.3431 1.3552,0 3.02702703,0 L65,0 L65,20 L3.02702703,20 C1.3552,20 0,18.6569 0,17 L0,3 Z"" fill=""url(#text-fill)"" fill-rule=""nonzero""/>
      ${icon}
    </g>
    </g>
    <g transform=""translate(65)"" font-family=""'DejaVu Sans',Verdana,Geneva,sans-serif"" font-size=""11"">
      <path d=""M0 0h46.939C48.629 0 50 1.343 50 3v14c0 1.657-1.37 3-3.061 3H0V0z"" id=""state-bg"" fill=""url(#count-fill)"" fill-rule=""nonzero""/>
      <text fill=""${darken(props.text, 8)}""
      fill-opacity="".2"" aria-hidden=""true"">
        <tspan x=""${offsetText()}"" y=""15"">${itsOverAMillion}</tspan>
      </text>
      <text fill=""${props.text}"">
        <tspan x=""${offsetText()}"" y=""14.5"">${itsOverAMillion}</tspan>
      </text>
    </g>
</svg>`;
}
<fim_middle>",correct,252
string,string,3fe8267a4b8aed719bfa5cfc4d16f245a2d85629,"<fim_prefix>export declare type SvmType =
  | BoolType
  | U8intType
  | U16intType
  | U32intType
  | U64intType
  | ByteType
  | B256Type
  | AddressType
  | StringType
  | ArrayType
  | TupleType
  | UnknownType;
/**
 * Like SvmType but with void
 */
export declare type SvmOutputType = SvmType | VoidType;

export declare type BoolType = {
  type: 'bool';
  originalType: string;
};
export declare type U8intType = {
  type: 'u8';
  bits: 8;
  originalType: string;
};
export declare type U16intType = {
  type: 'u16';
  bits: 16;
  originalType: string;
};
export declare type U32intType = {
  type: 'u32';
  bits: 32;
  originalType: string;
};
export declare type U64intType = {
  type: 'u64';
  bits: 64;
  originalType: string;
};
export declare type ByteType = {
  type: 'byte';
  size: 1;
  originalType: string;
};
export declare type B256Type = {
  type: 'b256';
  originalType: string;
};
export declare type AddressType = {
  type: 'address';
  originalType: string;
};
export declare type StringType = {
  type: 'string';
  size: number;
  originalType: string;
};
export declare type ArrayType = {
  type: 'array';
  itemType: SvmType;
  size?: number;
  originalType: string;
};
export declare type TupleType = {
  type: 'tuple';
  structName: string;
  components: SvmSymbol[];
  originalType: string;
};
export declare type UnknownType = {
  type: 'unknown';
  originalType: string;
};

export declare type VoidType = {
  type: 'void';
};

export declare type SvmSymbol = {
  type: SvmType;
  name: string;
};

const stringRegEx = /str\[([0-9]+)\]/;
const arrayRegEx = /\[(\w+);\s*([0-9]+)\]/;
/**
 * Used to check if type is a custom struct
 */
const structRegEx = /^(struct|enum)/;

/**
 * Converts valid file names to valid javascript symbols and does best effort to make them readable.
 * Example: ds-token.test becomes DsTokenTest
 */
export function normalizeName(rawName) {
  const transformations: ((s) => string)[] = [
    (s) => s.replace(/\s+/g, '-'), // spaces to - so later we can automatically convert them
    (s) => s.replace(/\./g, '-'), // replace "".""
    (s) => s.replace(/_/g, '-'), // replace ""_""
    (s) => s.replace(/-[a-z]/g, (match) => match.substr(-1).toUpperCase()), // delete '-' and capitalize the letter after them
    (s) => s.replace(/-/g, ''), // delete any '-' left
    (s) => s.replace(/^\d+/, ''), // removes leading digits
    (s) => s.charAt(0).toUpperCase() + s.slice(1),
  ];

  const finalName = transformations.reduce((s, t) => t(s), rawName);

  if (finalName === '') {
    throw new Error(`Can't guess class name, please rename file: ${rawName}`);
  }

  return finalName;
}

/**
 * Parses the SvmType from the JSON ABI; recusively on non-primatives
 */
export function parseSvmType(rawType, components?, name?: <fim_suffix>) {
  const stringMatch = rawType.match(stringRegEx);
  if (stringMatch !== null) {
    const length = stringMatch[1];

    return {
      type: 'string',
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  const arrayMatch = rawType.match(arrayRegEx);
  if (arrayMatch !== null) {
    const type = arrayMatch[1];
    const length = arrayMatch[2];
    return {
      type: 'array',
      itemType: parseSvmType(type, components),
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  // If type starts with struct/enum we can treat it as tuple.
  // In this way, the parser can process all components from the struct.
  if (structRegEx.test(rawType)) {
    if (!components) throw new Error(`${rawType} specified without components!`);
    return {
      type: 'tuple',
      components,
      originalType: rawType,
      // Remove struct prefix enabling the code parser
      // To create a Class with the structName
      structName: rawType.replace(structRegEx, '').trim(),
    };
  }

  switch (rawType) {
    case 'u8':
      return { type: 'u8', bits: 8, originalType: rawType };
    case 'u16':
      return { type: 'u16', bits: 16, originalType: rawType };
    case 'u32':
      return { type: 'u32', bits: 32, originalType: rawType };
    case 'u64':
      return { type: 'u64', bits: 64, originalType: rawType };
    case 'bool':
      return { type: 'bool', originalType: rawType };
    case 'address':
      return { type: 'address', originalType: rawType };
    case 'b256':
      return { type: 'b256', originalType: rawType };
    case 'byte':
      return { type: 'byte', size: 1, originalType: rawType };
    case 'tuple':
      if (!components) throw new Error('Tuple specified without components!');
      return {
        type: 'tuple',
        components,
        originalType: rawType,
        structName: normalizeName(name || ''),
      };
    default:
  }

  return { type: 'unknown', originalType: rawType };
}
<fim_middle>",correct,254
string,string,3fe8267a4b8aed719bfa5cfc4d16f245a2d85629,"<fim_prefix>export declare type SvmType =
  | BoolType
  | U8intType
  | U16intType
  | U32intType
  | U64intType
  | ByteType
  | B256Type
  | AddressType
  | StringType
  | ArrayType
  | TupleType
  | UnknownType;
/**
 * Like SvmType but with void
 */
export declare type SvmOutputType = SvmType | VoidType;

export declare type BoolType = {
  type: 'bool';
  originalType: string;
};
export declare type U8intType = {
  type: 'u8';
  bits: 8;
  originalType: string;
};
export declare type U16intType = {
  type: 'u16';
  bits: 16;
  originalType: string;
};
export declare type U32intType = {
  type: 'u32';
  bits: 32;
  originalType: string;
};
export declare type U64intType = {
  type: 'u64';
  bits: 64;
  originalType: string;
};
export declare type ByteType = {
  type: 'byte';
  size: 1;
  originalType: string;
};
export declare type B256Type = {
  type: 'b256';
  originalType: string;
};
export declare type AddressType = {
  type: 'address';
  originalType: string;
};
export declare type StringType = {
  type: 'string';
  size: number;
  originalType: string;
};
export declare type ArrayType = {
  type: 'array';
  itemType: SvmType;
  size?: number;
  originalType: string;
};
export declare type TupleType = {
  type: 'tuple';
  structName: string;
  components: SvmSymbol[];
  originalType: string;
};
export declare type UnknownType = {
  type: 'unknown';
  originalType: string;
};

export declare type VoidType = {
  type: 'void';
};

export declare type SvmSymbol = {
  type: SvmType;
  name: string;
};

const stringRegEx = /str\[([0-9]+)\]/;
const arrayRegEx = /\[(\w+);\s*([0-9]+)\]/;
/**
 * Used to check if type is a custom struct
 */
const structRegEx = /^(struct|enum)/;

/**
 * Converts valid file names to valid javascript symbols and does best effort to make them readable.
 * Example: ds-token.test becomes DsTokenTest
 */
export function normalizeName(rawName) {
  const transformations: ((s) => string)[] = [
    (s) => s.replace(/\s+/g, '-'), // spaces to - so later we can automatically convert them
    (s) => s.replace(/\./g, '-'), // replace "".""
    (s) => s.replace(/_/g, '-'), // replace ""_""
    (s) => s.replace(/-[a-z]/g, (match) => match.substr(-1).toUpperCase()), // delete '-' and capitalize the letter after them
    (s) => s.replace(/-/g, ''), // delete any '-' left
    (s) => s.replace(/^\d+/, ''), // removes leading digits
    (s) => s.charAt(0).toUpperCase() + s.slice(1),
  ];

  const finalName = transformations.reduce((s, t) => t(s), rawName);

  if (finalName === '') {
    throw new Error(`Can't guess class name, please rename file: ${rawName}`);
  }

  return finalName;
}

/**
 * Parses the SvmType from the JSON ABI; recusively on non-primatives
 */
export function parseSvmType(rawType: <fim_suffix>, components?, name?) {
  const stringMatch = rawType.match(stringRegEx);
  if (stringMatch !== null) {
    const length = stringMatch[1];

    return {
      type: 'string',
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  const arrayMatch = rawType.match(arrayRegEx);
  if (arrayMatch !== null) {
    const type = arrayMatch[1];
    const length = arrayMatch[2];
    return {
      type: 'array',
      itemType: parseSvmType(type, components),
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  // If type starts with struct/enum we can treat it as tuple.
  // In this way, the parser can process all components from the struct.
  if (structRegEx.test(rawType)) {
    if (!components) throw new Error(`${rawType} specified without components!`);
    return {
      type: 'tuple',
      components,
      originalType: rawType,
      // Remove struct prefix enabling the code parser
      // To create a Class with the structName
      structName: rawType.replace(structRegEx, '').trim(),
    };
  }

  switch (rawType) {
    case 'u8':
      return { type: 'u8', bits: 8, originalType: rawType };
    case 'u16':
      return { type: 'u16', bits: 16, originalType: rawType };
    case 'u32':
      return { type: 'u32', bits: 32, originalType: rawType };
    case 'u64':
      return { type: 'u64', bits: 64, originalType: rawType };
    case 'bool':
      return { type: 'bool', originalType: rawType };
    case 'address':
      return { type: 'address', originalType: rawType };
    case 'b256':
      return { type: 'b256', originalType: rawType };
    case 'byte':
      return { type: 'byte', size: 1, originalType: rawType };
    case 'tuple':
      if (!components) throw new Error('Tuple specified without components!');
      return {
        type: 'tuple',
        components,
        originalType: rawType,
        structName: normalizeName(name || ''),
      };
    default:
  }

  return { type: 'unknown', originalType: rawType };
}
<fim_middle>",correct,256
string,string,3fe8267a4b8aed719bfa5cfc4d16f245a2d85629,"<fim_prefix>export declare type SvmType =
  | BoolType
  | U8intType
  | U16intType
  | U32intType
  | U64intType
  | ByteType
  | B256Type
  | AddressType
  | StringType
  | ArrayType
  | TupleType
  | UnknownType;
/**
 * Like SvmType but with void
 */
export declare type SvmOutputType = SvmType | VoidType;

export declare type BoolType = {
  type: 'bool';
  originalType: string;
};
export declare type U8intType = {
  type: 'u8';
  bits: 8;
  originalType: string;
};
export declare type U16intType = {
  type: 'u16';
  bits: 16;
  originalType: string;
};
export declare type U32intType = {
  type: 'u32';
  bits: 32;
  originalType: string;
};
export declare type U64intType = {
  type: 'u64';
  bits: 64;
  originalType: string;
};
export declare type ByteType = {
  type: 'byte';
  size: 1;
  originalType: string;
};
export declare type B256Type = {
  type: 'b256';
  originalType: string;
};
export declare type AddressType = {
  type: 'address';
  originalType: string;
};
export declare type StringType = {
  type: 'string';
  size: number;
  originalType: string;
};
export declare type ArrayType = {
  type: 'array';
  itemType: SvmType;
  size?: number;
  originalType: string;
};
export declare type TupleType = {
  type: 'tuple';
  structName: string;
  components: SvmSymbol[];
  originalType: string;
};
export declare type UnknownType = {
  type: 'unknown';
  originalType: string;
};

export declare type VoidType = {
  type: 'void';
};

export declare type SvmSymbol = {
  type: SvmType;
  name: string;
};

const stringRegEx = /str\[([0-9]+)\]/;
const arrayRegEx = /\[(\w+);\s*([0-9]+)\]/;
/**
 * Used to check if type is a custom struct
 */
const structRegEx = /^(struct|enum)/;

/**
 * Converts valid file names to valid javascript symbols and does best effort to make them readable.
 * Example: ds-token.test becomes DsTokenTest
 */
export function normalizeName(rawName) {
  const transformations: ((s: <fim_suffix>) => string)[] = [
    (s) => s.replace(/\s+/g, '-'), // spaces to - so later we can automatically convert them
    (s) => s.replace(/\./g, '-'), // replace "".""
    (s) => s.replace(/_/g, '-'), // replace ""_""
    (s) => s.replace(/-[a-z]/g, (match) => match.substr(-1).toUpperCase()), // delete '-' and capitalize the letter after them
    (s) => s.replace(/-/g, ''), // delete any '-' left
    (s) => s.replace(/^\d+/, ''), // removes leading digits
    (s) => s.charAt(0).toUpperCase() + s.slice(1),
  ];

  const finalName = transformations.reduce((s, t) => t(s), rawName);

  if (finalName === '') {
    throw new Error(`Can't guess class name, please rename file: ${rawName}`);
  }

  return finalName;
}

/**
 * Parses the SvmType from the JSON ABI; recusively on non-primatives
 */
export function parseSvmType(rawType, components?, name?) {
  const stringMatch = rawType.match(stringRegEx);
  if (stringMatch !== null) {
    const length = stringMatch[1];

    return {
      type: 'string',
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  const arrayMatch = rawType.match(arrayRegEx);
  if (arrayMatch !== null) {
    const type = arrayMatch[1];
    const length = arrayMatch[2];
    return {
      type: 'array',
      itemType: parseSvmType(type, components),
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  // If type starts with struct/enum we can treat it as tuple.
  // In this way, the parser can process all components from the struct.
  if (structRegEx.test(rawType)) {
    if (!components) throw new Error(`${rawType} specified without components!`);
    return {
      type: 'tuple',
      components,
      originalType: rawType,
      // Remove struct prefix enabling the code parser
      // To create a Class with the structName
      structName: rawType.replace(structRegEx, '').trim(),
    };
  }

  switch (rawType) {
    case 'u8':
      return { type: 'u8', bits: 8, originalType: rawType };
    case 'u16':
      return { type: 'u16', bits: 16, originalType: rawType };
    case 'u32':
      return { type: 'u32', bits: 32, originalType: rawType };
    case 'u64':
      return { type: 'u64', bits: 64, originalType: rawType };
    case 'bool':
      return { type: 'bool', originalType: rawType };
    case 'address':
      return { type: 'address', originalType: rawType };
    case 'b256':
      return { type: 'b256', originalType: rawType };
    case 'byte':
      return { type: 'byte', size: 1, originalType: rawType };
    case 'tuple':
      if (!components) throw new Error('Tuple specified without components!');
      return {
        type: 'tuple',
        components,
        originalType: rawType,
        structName: normalizeName(name || ''),
      };
    default:
  }

  return { type: 'unknown', originalType: rawType };
}
<fim_middle>",correct,257
string,string,3fe8267a4b8aed719bfa5cfc4d16f245a2d85629,"<fim_prefix>export declare type SvmType =
  | BoolType
  | U8intType
  | U16intType
  | U32intType
  | U64intType
  | ByteType
  | B256Type
  | AddressType
  | StringType
  | ArrayType
  | TupleType
  | UnknownType;
/**
 * Like SvmType but with void
 */
export declare type SvmOutputType = SvmType | VoidType;

export declare type BoolType = {
  type: 'bool';
  originalType: string;
};
export declare type U8intType = {
  type: 'u8';
  bits: 8;
  originalType: string;
};
export declare type U16intType = {
  type: 'u16';
  bits: 16;
  originalType: string;
};
export declare type U32intType = {
  type: 'u32';
  bits: 32;
  originalType: string;
};
export declare type U64intType = {
  type: 'u64';
  bits: 64;
  originalType: string;
};
export declare type ByteType = {
  type: 'byte';
  size: 1;
  originalType: string;
};
export declare type B256Type = {
  type: 'b256';
  originalType: string;
};
export declare type AddressType = {
  type: 'address';
  originalType: string;
};
export declare type StringType = {
  type: 'string';
  size: number;
  originalType: string;
};
export declare type ArrayType = {
  type: 'array';
  itemType: SvmType;
  size?: number;
  originalType: string;
};
export declare type TupleType = {
  type: 'tuple';
  structName: string;
  components: SvmSymbol[];
  originalType: string;
};
export declare type UnknownType = {
  type: 'unknown';
  originalType: string;
};

export declare type VoidType = {
  type: 'void';
};

export declare type SvmSymbol = {
  type: SvmType;
  name: string;
};

const stringRegEx = /str\[([0-9]+)\]/;
const arrayRegEx = /\[(\w+);\s*([0-9]+)\]/;
/**
 * Used to check if type is a custom struct
 */
const structRegEx = /^(struct|enum)/;

/**
 * Converts valid file names to valid javascript symbols and does best effort to make them readable.
 * Example: ds-token.test becomes DsTokenTest
 */
export function normalizeName(rawName): <fim_suffix> {
  const transformations: ((s) => string)[] = [
    (s) => s.replace(/\s+/g, '-'), // spaces to - so later we can automatically convert them
    (s) => s.replace(/\./g, '-'), // replace "".""
    (s) => s.replace(/_/g, '-'), // replace ""_""
    (s) => s.replace(/-[a-z]/g, (match) => match.substr(-1).toUpperCase()), // delete '-' and capitalize the letter after them
    (s) => s.replace(/-/g, ''), // delete any '-' left
    (s) => s.replace(/^\d+/, ''), // removes leading digits
    (s) => s.charAt(0).toUpperCase() + s.slice(1),
  ];

  const finalName = transformations.reduce((s, t) => t(s), rawName);

  if (finalName === '') {
    throw new Error(`Can't guess class name, please rename file: ${rawName}`);
  }

  return finalName;
}

/**
 * Parses the SvmType from the JSON ABI; recusively on non-primatives
 */
export function parseSvmType(rawType, components?, name?) {
  const stringMatch = rawType.match(stringRegEx);
  if (stringMatch !== null) {
    const length = stringMatch[1];

    return {
      type: 'string',
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  const arrayMatch = rawType.match(arrayRegEx);
  if (arrayMatch !== null) {
    const type = arrayMatch[1];
    const length = arrayMatch[2];
    return {
      type: 'array',
      itemType: parseSvmType(type, components),
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  // If type starts with struct/enum we can treat it as tuple.
  // In this way, the parser can process all components from the struct.
  if (structRegEx.test(rawType)) {
    if (!components) throw new Error(`${rawType} specified without components!`);
    return {
      type: 'tuple',
      components,
      originalType: rawType,
      // Remove struct prefix enabling the code parser
      // To create a Class with the structName
      structName: rawType.replace(structRegEx, '').trim(),
    };
  }

  switch (rawType) {
    case 'u8':
      return { type: 'u8', bits: 8, originalType: rawType };
    case 'u16':
      return { type: 'u16', bits: 16, originalType: rawType };
    case 'u32':
      return { type: 'u32', bits: 32, originalType: rawType };
    case 'u64':
      return { type: 'u64', bits: 64, originalType: rawType };
    case 'bool':
      return { type: 'bool', originalType: rawType };
    case 'address':
      return { type: 'address', originalType: rawType };
    case 'b256':
      return { type: 'b256', originalType: rawType };
    case 'byte':
      return { type: 'byte', size: 1, originalType: rawType };
    case 'tuple':
      if (!components) throw new Error('Tuple specified without components!');
      return {
        type: 'tuple',
        components,
        originalType: rawType,
        structName: normalizeName(name || ''),
      };
    default:
  }

  return { type: 'unknown', originalType: rawType };
}
<fim_middle>",correct,258
string,string,3fe8267a4b8aed719bfa5cfc4d16f245a2d85629,"<fim_prefix>export declare type SvmType =
  | BoolType
  | U8intType
  | U16intType
  | U32intType
  | U64intType
  | ByteType
  | B256Type
  | AddressType
  | StringType
  | ArrayType
  | TupleType
  | UnknownType;
/**
 * Like SvmType but with void
 */
export declare type SvmOutputType = SvmType | VoidType;

export declare type BoolType = {
  type: 'bool';
  originalType: string;
};
export declare type U8intType = {
  type: 'u8';
  bits: 8;
  originalType: string;
};
export declare type U16intType = {
  type: 'u16';
  bits: 16;
  originalType: string;
};
export declare type U32intType = {
  type: 'u32';
  bits: 32;
  originalType: string;
};
export declare type U64intType = {
  type: 'u64';
  bits: 64;
  originalType: string;
};
export declare type ByteType = {
  type: 'byte';
  size: 1;
  originalType: string;
};
export declare type B256Type = {
  type: 'b256';
  originalType: string;
};
export declare type AddressType = {
  type: 'address';
  originalType: string;
};
export declare type StringType = {
  type: 'string';
  size: number;
  originalType: string;
};
export declare type ArrayType = {
  type: 'array';
  itemType: SvmType;
  size?: number;
  originalType: string;
};
export declare type TupleType = {
  type: 'tuple';
  structName: string;
  components: SvmSymbol[];
  originalType: string;
};
export declare type UnknownType = {
  type: 'unknown';
  originalType: string;
};

export declare type VoidType = {
  type: 'void';
};

export declare type SvmSymbol = {
  type: SvmType;
  name: string;
};

const stringRegEx = /str\[([0-9]+)\]/;
const arrayRegEx = /\[(\w+);\s*([0-9]+)\]/;
/**
 * Used to check if type is a custom struct
 */
const structRegEx = /^(struct|enum)/;

/**
 * Converts valid file names to valid javascript symbols and does best effort to make them readable.
 * Example: ds-token.test becomes DsTokenTest
 */
export function normalizeName(rawName: <fim_suffix>) {
  const transformations: ((s) => string)[] = [
    (s) => s.replace(/\s+/g, '-'), // spaces to - so later we can automatically convert them
    (s) => s.replace(/\./g, '-'), // replace "".""
    (s) => s.replace(/_/g, '-'), // replace ""_""
    (s) => s.replace(/-[a-z]/g, (match) => match.substr(-1).toUpperCase()), // delete '-' and capitalize the letter after them
    (s) => s.replace(/-/g, ''), // delete any '-' left
    (s) => s.replace(/^\d+/, ''), // removes leading digits
    (s) => s.charAt(0).toUpperCase() + s.slice(1),
  ];

  const finalName = transformations.reduce((s, t) => t(s), rawName);

  if (finalName === '') {
    throw new Error(`Can't guess class name, please rename file: ${rawName}`);
  }

  return finalName;
}

/**
 * Parses the SvmType from the JSON ABI; recusively on non-primatives
 */
export function parseSvmType(rawType, components?, name?) {
  const stringMatch = rawType.match(stringRegEx);
  if (stringMatch !== null) {
    const length = stringMatch[1];

    return {
      type: 'string',
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  const arrayMatch = rawType.match(arrayRegEx);
  if (arrayMatch !== null) {
    const type = arrayMatch[1];
    const length = arrayMatch[2];
    return {
      type: 'array',
      itemType: parseSvmType(type, components),
      size: parseInt(length, 10),
      originalType: rawType,
    };
  }

  // If type starts with struct/enum we can treat it as tuple.
  // In this way, the parser can process all components from the struct.
  if (structRegEx.test(rawType)) {
    if (!components) throw new Error(`${rawType} specified without components!`);
    return {
      type: 'tuple',
      components,
      originalType: rawType,
      // Remove struct prefix enabling the code parser
      // To create a Class with the structName
      structName: rawType.replace(structRegEx, '').trim(),
    };
  }

  switch (rawType) {
    case 'u8':
      return { type: 'u8', bits: 8, originalType: rawType };
    case 'u16':
      return { type: 'u16', bits: 16, originalType: rawType };
    case 'u32':
      return { type: 'u32', bits: 32, originalType: rawType };
    case 'u64':
      return { type: 'u64', bits: 64, originalType: rawType };
    case 'bool':
      return { type: 'bool', originalType: rawType };
    case 'address':
      return { type: 'address', originalType: rawType };
    case 'b256':
      return { type: 'b256', originalType: rawType };
    case 'byte':
      return { type: 'byte', size: 1, originalType: rawType };
    case 'tuple':
      if (!components) throw new Error('Tuple specified without components!');
      return {
        type: 'tuple',
        components,
        originalType: rawType,
        structName: normalizeName(name || ''),
      };
    default:
  }

  return { type: 'unknown', originalType: rawType };
}
<fim_middle>",correct,259
string,string,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm: <fim_suffix>) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,264
string,string,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step: <fim_suffix>) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,285
string,string,a0e68d8c7d5c53c1a4acd46a1337e2ef0e513855,"<fim_prefix>export interface IYamlHighlight {
    startIndex: number;
    endIndex: number;
}

type startIndexAccType = { startIndex: number; prevIndent: number; tempMatch: RegExpMatchArray | null; };

function checkAndUpdateIndent(startIndexAcc , index )  {
  if (index >= startIndexAcc.prevIndent) {
    startIndexAcc.prevIndent = index
    return true
  } else {
    return false
  }
}

export class ResourceHighlightsHelperService {

  static splitPathToSteps(path: <fim_suffix>) {
    const splitRegExp = new RegExp(/[a-zA-Z]+|\[[^[]+]/, 'g');

    return path.match(splitRegExp)?.reduce((acc, step) => {
      const trimRegExp = new RegExp(/[^[\]\d]+/);

      if (trimRegExp.test(step)) {
        acc.push(trimRegExp.exec(step)?.[0] || '');
      } else {
        acc[acc.length - 1] = acc[acc.length - 1] + step;
      }

      return acc;
    }, []) || [];
  }

  static getStartAndEndIndexes(steps, lines) {
    const startIndexAcc = ResourceHighlightsHelperService.getStartIndexAcc(steps, lines);
    const startIndex = startIndexAcc.startIndex;
    const endIndex = ResourceHighlightsHelperService.getEndIndex(startIndex, lines, !!startIndexAcc.tempMatch);

    return { startIndex, endIndex };
  }


  static getStartIndexAcc(steps, lines) {
    const indentArray = '- ';
    // const indentArray = '  - ';
    const regExpForArray = new RegExp(/\[\d+]/);
    const regExpForArrayIndex = new RegExp(/\d+/);

    return steps.reduce((startIndexAcc, step, stepIndex) => {
      const stepWithOutArr = step.replace(regExpForArray, '') + ':';

      if (startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, stepWithOutArr);
      } else {
        startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
          if (indexLine > startIndexAcc.startIndex) {
            return checkAndUpdateIndent(startIndexAcc, line.indexOf(stepWithOutArr))
          }

          return false;
        });
      }

      startIndexAcc.tempMatch = step.match(regExpForArrayIndex);

      const isLastItem = stepIndex === (steps.length - 1);

      if (isLastItem && startIndexAcc.tempMatch) {
        handleArrayMatch(startIndexAcc, lines, indentArray, indentArray)
      }

      return startIndexAcc;
    }, { startIndex: -1, prevIndent: 0, tempMatch: null });
  }

  static getEndIndex(startIndex, lines, isArrElement) {
    const indent = ' ';
    const regExp = isArrElement ? new RegExp(/-/) : new RegExp(/\w/);
    const regExpResult: RegExpExecArray | null = regExp.exec(lines[startIndex]);
    const controlIndex = regExpResult?.index || 0;
    const firstParallelLineIndex = lines.findIndex((line, lineIndex) => {
      if (lineIndex > startIndex) {
        return line[controlIndex] !== indent;
      }

      return false;
    });

    return firstParallelLineIndex - 1;
  }
}

function handleArrayMatch(startIndexAcc, lines, indentArray, searchTerm) {
  if (startIndexAcc.tempMatch) {

    const arrayIndex = +startIndexAcc.tempMatch[0];
    let controlIndex: number | null = null;

    // find first indentation of array
    let arrayIndent: number;
    lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        arrayIndent = line.indexOf(indentArray);
        if (arrayIndent >= startIndexAcc.prevIndent) {
          return true;
        }

        return false;
      }

      return false;
    });

    startIndexAcc.startIndex = lines.findIndex((line, indexLine) => {
      if (indexLine > startIndexAcc.startIndex) {
        if (controlIndex !== arrayIndex && line.indexOf(indentArray) === arrayIndent) {
          controlIndex = controlIndex === null ? 0 : controlIndex + 1;
        }

        if (controlIndex === arrayIndex) {
          return checkAndUpdateIndent(startIndexAcc, line.indexOf(searchTerm));
        }

        return false;
      }

      return false;
    });
  }
}

<fim_middle>",correct,288
string,string,bd5fedd15b33868f0983320e9179fbd4b6751d7e,"<fim_prefix>export default class Day2 {
    public static calculatePart1(input)  {
        const reducer = (state, i)  =>
        {
            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, depth: state.depth };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0 });
    }

    public static calculatePart2(input)  {
        const reducer = (state, i)  =>
        {
            const aim = state.aim ?? 0;

            switch (i.direction) {
                case Direction.Forward:
                    return { horizontal: state.horizontal + i.distance, 
                             depth: state.depth + (aim * i.distance), 
                             aim: aim };
                case Direction.Down:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim + i.distance };
                case Direction.Up:
                    return { horizontal: state.horizontal, depth: state.depth, aim: aim - i.distance };
            }
        };
        
        return Day2.calculate(input, reducer, { horizontal: 0, depth: 0, aim: 0 });
    }

    private static calculate(
        input, 
        reducertialState)  {
        const position = input
            .map(Day2.parse)
            .reduce(reducer, initialState);

        return position.horizontal * position.depth;
    }

    private static parse(input: <fim_suffix>)  {
        const parts = input.split(' ');
        return {
            direction: parts[0] as Direction,
            distance: parseInt(parts[1], 10)
        };
    }
}

enum Direction {
    Forward = ""forward"",
    Down = ""down"",
    Up = ""up""
}

interface Instruction {
    direction: Direction;
    distance: number;
}

interface Position {
    horizontal: number;
    depth: number;
    aim?: number;
}<fim_middle>",correct,293
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts): <fim_suffix> => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,308
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]): <fim_suffix> =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,319
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s: <fim_suffix>, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,324
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k: <fim_suffix>, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,325
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
): <fim_suffix> =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,331
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s): <fim_suffix> =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,335
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s: <fim_suffix>) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,336
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s): <fim_suffix> => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,337
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
): <fim_suffix> => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,345
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm): <fim_suffix> => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,352
string,string,bdac4a3099eb083ed1e13572210323b445063c8f,"<fim_prefix>/**
 * @category db-common
 * @module internal
 */

//https://stackoverflow.com/questions/15300704/regex-with-my-jquery-function-for-sql-variable-name-validation
/**
 * Transform value to correct sql name.
 * Note! Dont use other symbols than ^A-Za-z_0-9
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitize = (nm): <fim_suffix> => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitize(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};
/**
 * Transform value to correct sql name.
 * Instead of sqlsanitize also allows .
 * For e.g. table name
 * Note! Dont use other symbols than ^A-Za-z_0-9.
 * @function
 * @param {string} nm
 * @returns {string}
 */
export const sqlsanitizeAllowDots = (nm) => {
  if (typeof nm === ""symbol"") {
    return nm.description ? sqlsanitizeAllowDots(nm.description) : """";
  }
  const s = nm.replace(/[^A-Za-z_0-9.""]*/g, """");
  if (s[0] >= ""0"" && s[0] <= ""9"") return `_${s}`;
  else return s;
};

type PlaceHolderStack = {
  push: (x) => string; //push value, return placeholder
  is_sqlite: boolean;
  getValues: () => Value[];
};

const postgresPlaceHolderStack = (init = 0) => {
  let values: Value[] = [];
  let i = init;
  return {
    push(x) {
      values.push(x);
      i += 1;
      return `$${i}`;
    },
    is_sqlite: false,
    getValues() {
      return values;
    },
  };
};

const sqlitePlaceHolderStack = () => {
  let values: Value[] = [];
  return {
    push(x) {
      values.push(x);
      return `?`;
    },
    is_sqlite: true,
    getValues() {
      return values;
    },
  };
};

/**
 *
 * @param {object} v
 * @param {string} i
 * @param {boolean} is_sqlite
 * @returns {string}
 */
const whereFTS = (
  v,
  phs
) => {
  const { fields, table } = v;
  let flds = fields
    .filter((f) => f.type && f.type.sql_name === ""text"")
    .map(
      (f) =>
        ""coalesce("" +
        (table
          ? `""${sqlsanitize(table)}"".""${sqlsanitize(f.name)}""`
          : `""${sqlsanitize(f.name)}""`) +
        "",'')""
    )
    .join("" || ' ' || "");
  if (flds === """") flds = ""''"";
  if (phs.is_sqlite)
    return `${flds} LIKE '%' || ${phs.push(v.searchTerm)} || '%'`;
  else
    return `to_tsvector('english', ${flds}) @@ plainto_tsquery('english', ${phs.push(
      v.searchTerm
    )})`;
};

export type Value = string | number | boolean | Date | Value[];

export type Where = {
  _fts?: { fields: any[]; table?: string; searchTerm: string };
  or?: Where[];
  not?: Where | symbol;
  eq?: Value[];
  [key: string]:
    | { in: Value[] }
    | { or: Value[] }
    | { gt: Value; equal?: boolean }
    | { lt: Value; equal?: boolean }
    | Value[]
    | { inSelect: { where: Where; field: string; table: string } }
    | null
    | symbol
    | any; // TODO Value
};

/**
 *
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const subSelectWhere = (phs) => (
  k,
  v
) => {
  const whereObj = v.inSelect.where;
  const wheres = whereObj ? Object.entries(whereObj) : [];
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(phs)).join("" and "")
      : """";
  return `${quote(sqlsanitizeAllowDots(k))} in (select ${
    v.inSelect.field
  } from ${v.inSelect.table} ${where})`;
};

/**
 * @param {string} s
 * @returns {string}
 */
const wrapParens = (s) => (s ? `(${s})` : s);
/**
 * @param {string} s
 * @returns {string}
 */
const quote = (s) =>
  s.includes(""."")
    ? s.split(""."").map(quote).join(""."")
    : s.includes('""')
    ? s
    : `""${s}""`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereOr = (phs) => (
  ors
) =>
  wrapParens(
    ors
      .map((vi) =>
        Object.entries(vi)
          .map((kv) => whereClause(phs)(kv))
          .join("" and "")
      )
      .join("" or "")
  );

const equals = ([v1, v2], phs) => {
  const pVal = (v) =>
    typeof v === ""symbol""
      ? quote(sqlsanitizeAllowDots(v))
      : phs.push(v) + (typeof v === ""string"" ? ""::text"" : """");
  const isNull = (v) => `${pVal(v)} is null`;
  if (v1 === null && v2 === null) return ""null is null"";
  if (v1 === null) return isNull(v2);
  if (v2 === null) return isNull(v1);
  return `${pVal(v1)}=${pVal(v2)}`;
};
const slugifyQuery = (k, s, phs) =>
  phs.is_sqlite
    ? `REPLACE(LOWER(${quote(sqlsanitizeAllowDots(k))}),' ','-')=${phs.push(s)}`
    : `REGEXP_REPLACE(REPLACE(LOWER(${quote(
        sqlsanitizeAllowDots(k)
      )}),' ','-'),'[^\\w-]','','g')=${phs.push(s)}`;
/**
 * @param {boolean} is_sqlite
 * @param {string} i
 * @returns {function}
 */
const whereClause = (
  phs
) => ([k, v]) =>
  k === ""_fts""
    ? whereFTS(v, phs)
    : typeof (v || {}).in !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} = ${
        phs.is_sqlite ? """" : ""ANY""
      } (${phs.push(v.in)})`
    : k === ""or"" && Array.isArray(v)
    ? whereOr(phs)(v)
    : typeof (v || {}).slugify !== ""undefined""
    ? slugifyQuery(k, v.slugify, phs)
    : k === ""not"" && typeof v === ""object""
    ? `not (${Object.entries(v)
        .map((kv) => whereClause(phs)(kv))
        .join("" and "")})`
    : k === ""eq"" && Array.isArray(v)
    ? // @ts-ignore
      equals(v, phs)
    : v && v.or && Array.isArray(v.or)
    ? wrapParens(v.or.map((vi) => whereClause(phs)([k, vi])).join("" or ""))
    : Array.isArray(v)
    ? v.map((vi) => whereClause(phs)([k, vi])).join("" and "")
    : typeof (v || {}).ilike !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))} ${
        phs.is_sqlite ? ""LIKE"" : ""ILIKE""
      } '%' || ${phs.push(v.ilike)} || '%'`
    : typeof (v || {}).gt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}>${v.equal ? ""="" : """"}${phs.push(v.gt)}`
    : typeof (v || {}).lt !== ""undefined""
    ? `${quote(sqlsanitizeAllowDots(k))}<${v.equal ? ""="" : """"}${phs.push(v.lt)}`
    : typeof (v || {}).inSelect !== ""undefined""
    ? subSelectWhere(phs)(k, v)
    : typeof (v || {}).json !== ""undefined""
    ? phs.is_sqlite
      ? `json_extract(${quote(
          sqlsanitizeAllowDots(k)
        )}, '$.${sqlsanitizeAllowDots(v.json[0])}')=${phs.push(v.json[1])}`
      : `${quote(sqlsanitizeAllowDots(k))}->>'${sqlsanitizeAllowDots(
          v.json[0]
        )}'=${phs.push(v.json[1])}`
    : v === null
    ? `${quote(sqlsanitizeAllowDots(k))} is null`
    : k === ""not""
    ? `not (${typeof v === ""symbol"" ? v.description : phs.push(v)})`
    : `${quote(sqlsanitizeAllowDots(k))}=${
        typeof v === ""symbol"" ? v.description : phs.push(v)
      }`;

type WhereAndVals = {
  where: string;
  values: Value[];
};
/**
 * @param {object} whereObj
 * @param {boolean} is_sqlite
 * @param {number} initCount
 * @returns {object}
 */
export const mkWhere = (
  whereObj,
  is_sqlite = false,
  initCount = 0
) => {
  const wheres = whereObj ? Object.entries(whereObj) : [];
  //console.log({ wheres });
  const placeHolderStack = is_sqlite
    ? sqlitePlaceHolderStack()
    : postgresPlaceHolderStack(initCount);
  const where =
    whereObj && wheres.length > 0
      ? ""where "" + wheres.map(whereClause(placeHolderStack)).join("" and "")
      : """";
  const values = placeHolderStack.getValues();
  return { where, values };
};

/**
 * @param {number|string} x
 * @returns {number|null}
 */
const toInt = (x) =>
  typeof x === ""number""
    ? Math.round(x)
    : typeof x === ""string""
    ? parseInt(x)
    : null;

export type CoordOpts = {
  latField: number | string;
  longField: number | string;
  lat: number | string;
  long: number | string;
};
/**
 * @param {object} opts
 * @param {string} opts.latField
 * @param {string} opts.longField
 * @param {number} opts.lat
 * @param {number} opts.long
 * @returns {string}
 */
const getDistanceOrder = ({ latField, longField, lat, long }) => {
  const cos_lat_2 = Math.pow(Math.cos((+lat * Math.PI) / 180), 2);
  return `((${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})*(${sqlsanitizeAllowDots(
    `${latField}`
  )} - ${+lat})) + ((${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*(${sqlsanitizeAllowDots(
    `${longField}`
  )} - ${+long})*${cos_lat_2})`;
};

export type SelectOptions = {
  orderBy?: { distance: CoordOpts } | string;
  limit?: string | number;
  offset?: string | number;
  nocase?: boolean;
  orderDesc?: boolean;
  cached?: boolean;
  versioned?: boolean;
  min_role_read?: number;
  min_role_write?: number;
  ownership_field_id?: string;
  ownership_formula?: string;
  description?: string;
};
export const orderByIsObject = (
  object
): object is { distance: CoordOpts } => {
  return object && object.distance;
};

export type JoinField = {
  ref: any;
  target: any;
  through: any;
  [key: string]: any;
};

export type JoinOptions = {
  joinFields?: JoinField;
  aggregations?: AggregationOptions[];
  where: any;
} & SelectOptions;

export type AggregationOptions = {
  table: string;
  ref: string;
  field: string;
  where?: Where;
  aggregate: string;
  subselect?: SubselectOptions;
};

export type SubselectOptions = {
  tableName: string;
  whereField: string;
  field: string;
  table: any; // TODO without circular deps
};

/**
 * @param {object} selopts
 * @returns {string}
 */
export const mkSelectOptions = (selopts) => {
  const orderby =
    selopts.orderBy === ""RANDOM()""
      ? ""order by RANDOM()""
      : selopts.orderBy &&
        typeof selopts.orderBy === ""object"" &&
        selopts.orderBy.distance
      ? `order by ${getDistanceOrder(selopts.orderBy.distance)}`
      : selopts.orderBy && typeof selopts.orderBy === ""string"" && selopts.nocase
      ? `order by lower(${quote(sqlsanitizeAllowDots(selopts.orderBy))})${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : selopts.orderBy && typeof selopts.orderBy === ""string""
      ? `order by ${quote(sqlsanitizeAllowDots(selopts.orderBy))}${
          selopts.orderDesc ? "" DESC"" : """"
        }`
      : """";
  const limit = selopts.limit ? `limit ${toInt(selopts.limit)}` : """";
  const offset = selopts.offset ? `offset ${toInt(selopts.offset)}` : """";
  return [orderby, limit, offset].filter((s) => s).join("" "");
};

export type Row = { [key: string]: any };
<fim_middle>",correct,354
string,string,d226f7a775ab4b9a5b374fcabee402f9b81938cc,"<fim_prefix>export type FeeType = {
  winston: string;
  ar: string;
};

export type Tag = { name: string; value: string };

export const getDefaultFee = () => {
  return {
    winston: """",
    ar: """",
  };
};

export const generateFakeInteraction = (
  input,
  id: <fim_suffix>,
  blockId,
  blockHeight,
  ownerAddress,
  recipient,
  extraTag,
  quantity,
  fee,
  blockTimestamp,
) => {
  const tags: Array<Tag> = [{
    name: ""Input"",
    value: JSON.stringify(input),
  }];

  if (extraTag) {
    tags.push(extraTag);
  }

  return {
    cursor: """",
    node: {
      id,
      anchor: undefined,
      signature: undefined,
      recipient,
      owner: {
        address: ownerAddress,
      },
      fee,
      quantity,
      data: undefined,
      tags,
      block: {
        id: blockId || """",
        timestamp: blockTimestamp || 0,
        height: blockHeight || 0,
        previous: undefined,
      },
      parent: undefined,
      bundledIn: undefined,
    },
  };
};
<fim_middle>",correct,364
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color): <fim_suffix> {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,367
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value): <fim_suffix> {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,369
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color): <fim_suffix> {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,371
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color): <fim_suffix> {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,373
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value): <fim_suffix> {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,375
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color): <fim_suffix> {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,377
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value): <fim_suffix> {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,379
string,string,d22867b9d0de4356470dda9ffe4c488bb5dec6d5,"<fim_prefix>export interface Color {
	r: number;
	g: number;
	b: number;
	alpha: number;
}

export enum ColorType {
	hex,
	rgb,
	hsl,
	// hsv,
	// vec,
	uicolor,
}

export const htmlColorNames = [
	""indianred"",
	""lightcoral"",
	""salmon"",
	""darksalmon"",
	""lightsalmon"",
	""lavender"",
	""slategray"",
];

export function random() {
	return {
		r: Math.floor(Math.random() * 255),
		g: Math.floor(Math.random() * 255),
		b: Math.floor(Math.random() * 255),
		alpha: 1,
	};
}

export function parse(color: <fim_suffix>) {
	if (color.startsWith(""#"")) {
		// #rgb / #rgba
		if (color.length === 4 || color.length === 5) {
			return [
				ColorType.hex,
				{
					r: Math.max(
						Number.parseInt(color.slice(1, 2), 16) * 16,
						255,
					),
					g: Math.max(
						Number.parseInt(color.slice(2, 3), 16) * 16,
						255,
					),
					b: Math.max(
						Number.parseInt(color.slice(3, 4), 16) * 16,
						255,
					),
					alpha:
						color.length === 5
							? Number.parseInt(color.slice(4, 5), 16) / 15
							: 1,
				},
			];
		}

		// #rrggbb / #rrggbbaa
		else if (color.length === 7 || color.length === 9) {
			return [
				ColorType.hex,
				{
					r: Number.parseInt(color.slice(1, 3), 16),
					g: Number.parseInt(color.slice(3, 5), 16),
					b: Number.parseInt(color.slice(5, 7), 16),
					alpha:
						color.length === 9
							? Number.parseInt(color.slice(7, 9), 16) / 255
							: 1,
				},
			];
		}
	}

	// rgb(r, g, b) / rgba(r, g, b, a)
	else if (color.startsWith(""rgb"")) {
		let hasAlpha = color[3] === ""a"";
		let [r, g, b, alpha] = color.slice(hasAlpha ? 5 : 4, -1).split("","");

		return [
			ColorType.rgb,
			{
				r: Number.parseInt(r),
				g: Number.parseInt(g),
				b: Number.parseInt(b),
				alpha: hasAlpha ? Number.parseFloat(alpha) : 1,
			},
		];
	}

	// hsl(h, s%, l%)
	else if (color.startsWith(""hsl"")) {
		return [
			ColorType.hsl,
			{
				r: 0,
				g: 0,
				b: 0,
				alpha: 1,
			},
		];
	}

	return [ColorType.hex, random()];
}

// Helper function for formatting hex colors
function hp(value) {
	return Math.floor(value).toString(16).padStart(2, ""0"");
}

export function hex(color) {
	return color.alpha < 1
		? `#${hp(color.r)}${hp(color.g)}${hp(color.b)}${hp(color.alpha * 255)}`
		: `#${hp(color.r)}${hp(color.g)}${hp(color.b)}`;
}

// Helper function for formatting rgba/rgba/hsl colors
function rp(value) {
	return Math.floor(value).toString();
}

export function rgb(color) {
	return color.alpha < 1
		? `rgba(${rp(color.r)}, ${rp(color.g)}, ${rp(
				color.b,
		  )}, ${color.alpha.toString().slice(0, 4)})`
		: `rgb(${rp(color.r)}, ${rp(color.g)}, ${rp(color.b)})`;
}

export function hsl(color) {
	return color.alpha < 1
		? `hsla(${color.r}, 42%, 63%, ${up(color.alpha)})`
		: `hsl(${color.r}, 42%, 63%)`;
}

function up(value) {
	return value.toString().slice(0, 4);
}

export function uicolor(color) {
	return `UIColor(red: ${up(color.r)}, green: ${up(color.g)}, blue: ${up(
		color.b,
	)}, alpha: ${up(color.r)})`;
}

export default {
	ColorType,
	random,
	parse,
	hex,
	rgb,
	hsl,
};
<fim_middle>",correct,382
string,string,9561f88ffc8f31e9c7d0151d058ab8d7dc194fb3,"<fim_prefix>
const literalTypes = () => {
  let places: 'sea' | 'mountain';
  let numbers: 5 | 4 | 3 | 2 | 1;
  
  type Mixed = string | number
  const age1: Mixed = 25
  const age2: Mixed = '25'

  places = 'sea';
  places = 'mountain';

  // numbers = 10;
  numbers = 3
  numbers = 1
}

const restType = () => {
  const myCollections: string[] = ['1', '2', '3']

  const myNewCollections = [
    ...myCollections,
    '4',
    '5'
  ]
}

// variadic tuple
const typeTuple = () => {
  const myTup: [string, boolean] = ['John', true]
  
  const anotherTup: [string, number, (a, b) => boolean] = [
    'john',
    18,
    function (first, second) {
      return (first + second) % 10 === 0
    }
  ]

  type RestAndBool = [...any[], boolean]
  const restAndBool: RestAndBool = [
    true,
    1,
    2,
    'as',
    true,
  ]

  type StringAndRest = [string, ...any[]]
  const stringAndRest: StringAndRest = [
    '1',
    '2',
    true,
  ]
}

const typeArrayFunction = () => {
  // @ts-ignore
  const arrFns: [() => string] = [
    () => {
      return 'valid'
    },
    (a, b): <fim_suffix> => {
      const h = a + b
      return a + b as unknown as string
    }
  ]

  const arrFns2: Array<() => string> = [
    () => {
      return 'valid'
    },
  ]

  const objFn: { () }[] = [
    () => 'still ok',
    () => {
      return 'also ok'
    },
  ]
}

const fnJSONType = () => {
  const myJson: { [key: string]: any } = {
    abc: 'foo',
    def: 'bar',
    num: 123
  }
}<fim_middle>",correct,398
string,string,9561f88ffc8f31e9c7d0151d058ab8d7dc194fb3,"<fim_prefix>
const literalTypes = () => {
  let places: 'sea' | 'mountain';
  let numbers: 5 | 4 | 3 | 2 | 1;
  
  type Mixed = string | number
  const age1: Mixed = 25
  const age2: Mixed = '25'

  places = 'sea';
  places = 'mountain';

  // numbers = 10;
  numbers = 3
  numbers = 1
}

const restType = () => {
  const myCollections: string[] = ['1', '2', '3']

  const myNewCollections = [
    ...myCollections,
    '4',
    '5'
  ]
}

// variadic tuple
const typeTuple = () => {
  const myTup: [string, boolean] = ['John', true]
  
  const anotherTup: [string, number, (a, b) => boolean] = [
    'john',
    18,
    function (first, second) {
      return (first + second) % 10 === 0
    }
  ]

  type RestAndBool = [...any[], boolean]
  const restAndBool: RestAndBool = [
    true,
    1,
    2,
    'as',
    true,
  ]

  type StringAndRest = [string, ...any[]]
  const stringAndRest: StringAndRest = [
    '1',
    '2',
    true,
  ]
}

const typeArrayFunction = () => {
  // @ts-ignore
  const arrFns: [() => string] = [
    (): <fim_suffix> => {
      return 'valid'
    },
    (a, b) => {
      const h = a + b
      return a + b as unknown as string
    }
  ]

  const arrFns2: Array<() => string> = [
    () => {
      return 'valid'
    },
  ]

  const objFn: { () }[] = [
    () => 'still ok',
    () => {
      return 'also ok'
    },
  ]
}

const fnJSONType = () => {
  const myJson: { [key: string]: any } = {
    abc: 'foo',
    def: 'bar',
    num: 123
  }
}<fim_middle>",correct,401
string,string,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops): <fim_suffix>
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,423
string,string,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops: <fim_suffix>)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,426
string,string,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value): <fim_suffix>
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,427
string,string,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b): <fim_suffix>
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,430
string,string,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops)
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v): <fim_suffix>
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,434
string,string,38ecb036ee2a515af40d1ec36c6e8f3d62d34f83,"<fim_prefix>interface WrappingWord {
  current: string;
  done: string[];
  progress: {
    count: number;
    words: string[];
  };
}

const createWrappingWord = (current) => ({
  current,
  done: [],
  progress: {
    count: current.length + 1,
    words: [current],
  },
});

const oneSpace = 1;
const mergeWrappingWords =
  (width) =>
  (total, next) => {
    const newCount = next.current.length + total.progress.count + oneSpace;
    return newCount > width
      ? {
          current: next.current,
          done: [...total.done, total.progress.words.join(' ')],
          progress: {
            count: next.current.length + oneSpace,
            words: [next.current],
          },
        }
      : {
          current: next.current,
          done: total.done,
          progress: {
            count: newCount,
            words: [...total.progress.words, next.current],
          },
        };
  };

export const wrapWord = (width, text) => {
  const words = text.split(' ').map(createWrappingWord);
  const result = words.reduce(mergeWrappingWords(width));

  const done =
    result.progress.words.length > 0
      ? [...result.done, result.progress.words.join(' ')]
      : result.done;
  return done.join('\n');
};

type MdLineType =
  | 'blockquote'
  | 'ordered-list'
  | 'unordered-list'
  | 'paragraph'
  | 'header'
  | 'table-row'
  | 'code-block'
  | 'horizontal-line';

const getMdLineType = (line) => {
  const trimmed = line.trim();
  if (trimmed.startsWith('#')) {
    return 'header';
  }
  if (trimmed.startsWith('>')) {
    return 'blockquote';
  }
  if (trimmed.startsWith('1.')) {
    return 'ordered-list';
  }
  if (trimmed.startsWith('---')) {
    return 'horizontal-line';
  }
  if (trimmed.startsWith('-')) {
    return 'unordered-list';
  }
  if (trimmed.includes('|')) {
    return 'table-row';
  }
  if (line.length !== trimmed.length) {
    return 'code-block';
  }
  return 'paragraph';
};

const maxLineP = 78;
const maxLineOther = 72;

/**
 * @see https://cirosantilli.com/markdown-style-guide/
 * @param text
 * @returns
 */
export const normalizeMdLine = (line): <fim_suffix> => {
  const lineType = getMdLineType(line);
  const keepLineAsIs =
    lineType === 'header' ||
    lineType === 'table-row' ||
    lineType === 'code-block' ||
    lineType === 'horizontal-line';
  if (keepLineAsIs) {
    return line;
  }
  if (lineType === 'paragraph') {
    return wrapWord(maxLineP, line);
  }

  const trimmed = line.trimStart();
  const nbOfLeadingSpaces = line.length - trimmed.length;
  const leadingSpaces = ' '.repeat(nbOfLeadingSpaces);
  if (lineType === 'unordered-list') {
    const ulText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    return `${leadingSpaces}- ${ulText}`;
  }
  if (lineType === 'ordered-list') {
    const olText = wrapWord(maxLineOther, trimmed.slice(2).trim());
    return `${leadingSpaces}1. ${olText}`;
  }
  if (lineType === 'blockquote') {
    const bqText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    const bqSplitted = bqText.split('\n');
    const bqPrefixed = bqSplitted.map((li) => `${leadingSpaces}> ${li}`);
    return bqPrefixed.join('\n');
  }

  throw new Error('should be a supported line type');
};
<fim_middle>",correct,438
string,string,38ecb036ee2a515af40d1ec36c6e8f3d62d34f83,"<fim_prefix>interface WrappingWord {
  current: string;
  done: string[];
  progress: {
    count: number;
    words: string[];
  };
}

const createWrappingWord = (current) => ({
  current,
  done: [],
  progress: {
    count: current.length + 1,
    words: [current],
  },
});

const oneSpace = 1;
const mergeWrappingWords =
  (width) =>
  (total, next) => {
    const newCount = next.current.length + total.progress.count + oneSpace;
    return newCount > width
      ? {
          current: next.current,
          done: [...total.done, total.progress.words.join(' ')],
          progress: {
            count: next.current.length + oneSpace,
            words: [next.current],
          },
        }
      : {
          current: next.current,
          done: total.done,
          progress: {
            count: newCount,
            words: [...total.progress.words, next.current],
          },
        };
  };

export const wrapWord = (width, text) => {
  const words = text.split(' ').map(createWrappingWord);
  const result = words.reduce(mergeWrappingWords(width));

  const done =
    result.progress.words.length > 0
      ? [...result.done, result.progress.words.join(' ')]
      : result.done;
  return done.join('\n');
};

type MdLineType =
  | 'blockquote'
  | 'ordered-list'
  | 'unordered-list'
  | 'paragraph'
  | 'header'
  | 'table-row'
  | 'code-block'
  | 'horizontal-line';

const getMdLineType = (line) => {
  const trimmed = line.trim();
  if (trimmed.startsWith('#')) {
    return 'header';
  }
  if (trimmed.startsWith('>')) {
    return 'blockquote';
  }
  if (trimmed.startsWith('1.')) {
    return 'ordered-list';
  }
  if (trimmed.startsWith('---')) {
    return 'horizontal-line';
  }
  if (trimmed.startsWith('-')) {
    return 'unordered-list';
  }
  if (trimmed.includes('|')) {
    return 'table-row';
  }
  if (line.length !== trimmed.length) {
    return 'code-block';
  }
  return 'paragraph';
};

const maxLineP = 78;
const maxLineOther = 72;

/**
 * @see https://cirosantilli.com/markdown-style-guide/
 * @param text
 * @returns
 */
export const normalizeMdLine = (line: <fim_suffix>) => {
  const lineType = getMdLineType(line);
  const keepLineAsIs =
    lineType === 'header' ||
    lineType === 'table-row' ||
    lineType === 'code-block' ||
    lineType === 'horizontal-line';
  if (keepLineAsIs) {
    return line;
  }
  if (lineType === 'paragraph') {
    return wrapWord(maxLineP, line);
  }

  const trimmed = line.trimStart();
  const nbOfLeadingSpaces = line.length - trimmed.length;
  const leadingSpaces = ' '.repeat(nbOfLeadingSpaces);
  if (lineType === 'unordered-list') {
    const ulText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    return `${leadingSpaces}- ${ulText}`;
  }
  if (lineType === 'ordered-list') {
    const olText = wrapWord(maxLineOther, trimmed.slice(2).trim());
    return `${leadingSpaces}1. ${olText}`;
  }
  if (lineType === 'blockquote') {
    const bqText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    const bqSplitted = bqText.split('\n');
    const bqPrefixed = bqSplitted.map((li) => `${leadingSpaces}> ${li}`);
    return bqPrefixed.join('\n');
  }

  throw new Error('should be a supported line type');
};
<fim_middle>",correct,439
string,string,38ecb036ee2a515af40d1ec36c6e8f3d62d34f83,"<fim_prefix>interface WrappingWord {
  current: string;
  done: string[];
  progress: {
    count: number;
    words: string[];
  };
}

const createWrappingWord = (current) => ({
  current,
  done: [],
  progress: {
    count: current.length + 1,
    words: [current],
  },
});

const oneSpace = 1;
const mergeWrappingWords =
  (width) =>
  (total, next) => {
    const newCount = next.current.length + total.progress.count + oneSpace;
    return newCount > width
      ? {
          current: next.current,
          done: [...total.done, total.progress.words.join(' ')],
          progress: {
            count: next.current.length + oneSpace,
            words: [next.current],
          },
        }
      : {
          current: next.current,
          done: total.done,
          progress: {
            count: newCount,
            words: [...total.progress.words, next.current],
          },
        };
  };

export const wrapWord = (width, text): <fim_suffix> => {
  const words = text.split(' ').map(createWrappingWord);
  const result = words.reduce(mergeWrappingWords(width));

  const done =
    result.progress.words.length > 0
      ? [...result.done, result.progress.words.join(' ')]
      : result.done;
  return done.join('\n');
};

type MdLineType =
  | 'blockquote'
  | 'ordered-list'
  | 'unordered-list'
  | 'paragraph'
  | 'header'
  | 'table-row'
  | 'code-block'
  | 'horizontal-line';

const getMdLineType = (line) => {
  const trimmed = line.trim();
  if (trimmed.startsWith('#')) {
    return 'header';
  }
  if (trimmed.startsWith('>')) {
    return 'blockquote';
  }
  if (trimmed.startsWith('1.')) {
    return 'ordered-list';
  }
  if (trimmed.startsWith('---')) {
    return 'horizontal-line';
  }
  if (trimmed.startsWith('-')) {
    return 'unordered-list';
  }
  if (trimmed.includes('|')) {
    return 'table-row';
  }
  if (line.length !== trimmed.length) {
    return 'code-block';
  }
  return 'paragraph';
};

const maxLineP = 78;
const maxLineOther = 72;

/**
 * @see https://cirosantilli.com/markdown-style-guide/
 * @param text
 * @returns
 */
export const normalizeMdLine = (line) => {
  const lineType = getMdLineType(line);
  const keepLineAsIs =
    lineType === 'header' ||
    lineType === 'table-row' ||
    lineType === 'code-block' ||
    lineType === 'horizontal-line';
  if (keepLineAsIs) {
    return line;
  }
  if (lineType === 'paragraph') {
    return wrapWord(maxLineP, line);
  }

  const trimmed = line.trimStart();
  const nbOfLeadingSpaces = line.length - trimmed.length;
  const leadingSpaces = ' '.repeat(nbOfLeadingSpaces);
  if (lineType === 'unordered-list') {
    const ulText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    return `${leadingSpaces}- ${ulText}`;
  }
  if (lineType === 'ordered-list') {
    const olText = wrapWord(maxLineOther, trimmed.slice(2).trim());
    return `${leadingSpaces}1. ${olText}`;
  }
  if (lineType === 'blockquote') {
    const bqText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    const bqSplitted = bqText.split('\n');
    const bqPrefixed = bqSplitted.map((li) => `${leadingSpaces}> ${li}`);
    return bqPrefixed.join('\n');
  }

  throw new Error('should be a supported line type');
};
<fim_middle>",correct,442
string,string,38ecb036ee2a515af40d1ec36c6e8f3d62d34f83,"<fim_prefix>interface WrappingWord {
  current: string;
  done: string[];
  progress: {
    count: number;
    words: string[];
  };
}

const createWrappingWord = (current) => ({
  current,
  done: [],
  progress: {
    count: current.length + 1,
    words: [current],
  },
});

const oneSpace = 1;
const mergeWrappingWords =
  (width) =>
  (total, next) => {
    const newCount = next.current.length + total.progress.count + oneSpace;
    return newCount > width
      ? {
          current: next.current,
          done: [...total.done, total.progress.words.join(' ')],
          progress: {
            count: next.current.length + oneSpace,
            words: [next.current],
          },
        }
      : {
          current: next.current,
          done: total.done,
          progress: {
            count: newCount,
            words: [...total.progress.words, next.current],
          },
        };
  };

export const wrapWord = (width, text: <fim_suffix>) => {
  const words = text.split(' ').map(createWrappingWord);
  const result = words.reduce(mergeWrappingWords(width));

  const done =
    result.progress.words.length > 0
      ? [...result.done, result.progress.words.join(' ')]
      : result.done;
  return done.join('\n');
};

type MdLineType =
  | 'blockquote'
  | 'ordered-list'
  | 'unordered-list'
  | 'paragraph'
  | 'header'
  | 'table-row'
  | 'code-block'
  | 'horizontal-line';

const getMdLineType = (line) => {
  const trimmed = line.trim();
  if (trimmed.startsWith('#')) {
    return 'header';
  }
  if (trimmed.startsWith('>')) {
    return 'blockquote';
  }
  if (trimmed.startsWith('1.')) {
    return 'ordered-list';
  }
  if (trimmed.startsWith('---')) {
    return 'horizontal-line';
  }
  if (trimmed.startsWith('-')) {
    return 'unordered-list';
  }
  if (trimmed.includes('|')) {
    return 'table-row';
  }
  if (line.length !== trimmed.length) {
    return 'code-block';
  }
  return 'paragraph';
};

const maxLineP = 78;
const maxLineOther = 72;

/**
 * @see https://cirosantilli.com/markdown-style-guide/
 * @param text
 * @returns
 */
export const normalizeMdLine = (line) => {
  const lineType = getMdLineType(line);
  const keepLineAsIs =
    lineType === 'header' ||
    lineType === 'table-row' ||
    lineType === 'code-block' ||
    lineType === 'horizontal-line';
  if (keepLineAsIs) {
    return line;
  }
  if (lineType === 'paragraph') {
    return wrapWord(maxLineP, line);
  }

  const trimmed = line.trimStart();
  const nbOfLeadingSpaces = line.length - trimmed.length;
  const leadingSpaces = ' '.repeat(nbOfLeadingSpaces);
  if (lineType === 'unordered-list') {
    const ulText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    return `${leadingSpaces}- ${ulText}`;
  }
  if (lineType === 'ordered-list') {
    const olText = wrapWord(maxLineOther, trimmed.slice(2).trim());
    return `${leadingSpaces}1. ${olText}`;
  }
  if (lineType === 'blockquote') {
    const bqText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    const bqSplitted = bqText.split('\n');
    const bqPrefixed = bqSplitted.map((li) => `${leadingSpaces}> ${li}`);
    return bqPrefixed.join('\n');
  }

  throw new Error('should be a supported line type');
};
<fim_middle>",correct,443
string,string,38ecb036ee2a515af40d1ec36c6e8f3d62d34f83,"<fim_prefix>interface WrappingWord {
  current: string;
  done: string[];
  progress: {
    count: number;
    words: string[];
  };
}

const createWrappingWord = (current: <fim_suffix>) => ({
  current,
  done: [],
  progress: {
    count: current.length + 1,
    words: [current],
  },
});

const oneSpace = 1;
const mergeWrappingWords =
  (width) =>
  (total, next) => {
    const newCount = next.current.length + total.progress.count + oneSpace;
    return newCount > width
      ? {
          current: next.current,
          done: [...total.done, total.progress.words.join(' ')],
          progress: {
            count: next.current.length + oneSpace,
            words: [next.current],
          },
        }
      : {
          current: next.current,
          done: total.done,
          progress: {
            count: newCount,
            words: [...total.progress.words, next.current],
          },
        };
  };

export const wrapWord = (width, text) => {
  const words = text.split(' ').map(createWrappingWord);
  const result = words.reduce(mergeWrappingWords(width));

  const done =
    result.progress.words.length > 0
      ? [...result.done, result.progress.words.join(' ')]
      : result.done;
  return done.join('\n');
};

type MdLineType =
  | 'blockquote'
  | 'ordered-list'
  | 'unordered-list'
  | 'paragraph'
  | 'header'
  | 'table-row'
  | 'code-block'
  | 'horizontal-line';

const getMdLineType = (line) => {
  const trimmed = line.trim();
  if (trimmed.startsWith('#')) {
    return 'header';
  }
  if (trimmed.startsWith('>')) {
    return 'blockquote';
  }
  if (trimmed.startsWith('1.')) {
    return 'ordered-list';
  }
  if (trimmed.startsWith('---')) {
    return 'horizontal-line';
  }
  if (trimmed.startsWith('-')) {
    return 'unordered-list';
  }
  if (trimmed.includes('|')) {
    return 'table-row';
  }
  if (line.length !== trimmed.length) {
    return 'code-block';
  }
  return 'paragraph';
};

const maxLineP = 78;
const maxLineOther = 72;

/**
 * @see https://cirosantilli.com/markdown-style-guide/
 * @param text
 * @returns
 */
export const normalizeMdLine = (line) => {
  const lineType = getMdLineType(line);
  const keepLineAsIs =
    lineType === 'header' ||
    lineType === 'table-row' ||
    lineType === 'code-block' ||
    lineType === 'horizontal-line';
  if (keepLineAsIs) {
    return line;
  }
  if (lineType === 'paragraph') {
    return wrapWord(maxLineP, line);
  }

  const trimmed = line.trimStart();
  const nbOfLeadingSpaces = line.length - trimmed.length;
  const leadingSpaces = ' '.repeat(nbOfLeadingSpaces);
  if (lineType === 'unordered-list') {
    const ulText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    return `${leadingSpaces}- ${ulText}`;
  }
  if (lineType === 'ordered-list') {
    const olText = wrapWord(maxLineOther, trimmed.slice(2).trim());
    return `${leadingSpaces}1. ${olText}`;
  }
  if (lineType === 'blockquote') {
    const bqText = wrapWord(maxLineOther, trimmed.slice(1).trim());
    const bqSplitted = bqText.split('\n');
    const bqPrefixed = bqSplitted.map((li) => `${leadingSpaces}> ${li}`);
    return bqPrefixed.join('\n');
  }

  throw new Error('should be a supported line type');
};
<fim_middle>",correct,450
string,string,fd2a1a5d9252e675d70d3a0ff699537ab95c1e8d,"<fim_prefix>/* eslint-disable @typescript-eslint/no-explicit-any */
export interface HttpRequestOptions {
    method?: string;
    url: string;
    referer?: string;
    resolveWithFullResponse?: boolean;
    form?: any;
    body?: any;
    encoding?: any;
}

export interface GraphQLRequestOptions {
    origin?: string;
    referer?: string;
    query: string;
    variables?: object;
}

export interface Credit {
    session?: string;
    csrfToken: string;
}

export interface TopicTag {
    name: string;
    slug: string;
    translatedName?: string;
}

export interface CodeSnippet {
    lang: string;
    langSlug: string;
    code: string;
}

export interface ContestInfo {
    id: number;
    title: string;
    title_slug: string;
    description: string;
    duration: number;
    start_time: number;
    is_virtual: boolean;
    origin_start_time: number;
    is_private: boolean;
    related_contest_title: string | null;
}

export interface SimpleProblemInfoInContest {
    id: number;
    question_id: number;
    credit: number;
    title: string;
    english_title: string;
    title_slug: string;
    category_slug: string;
}

export interface Company {
    name: string;
    description: string;
    logo: string;
    slug: string;
}

export enum LangSlug {
    ""cpp"" = ""cpp"",
    ""java"" = ""java"",
    ""python"" = ""python"",
    ""python3"" = ""python3"",
    ""c"" = ""c"",
    ""csharp"" = ""csharp"",
    ""javascript"" = ""javascript"",
    ""ruby"" = ""ruby"",
    ""swift"" = ""swift"",
    ""golang"" = ""golang"",
    ""scala"" = ""scala"",
    ""kotlin"" = ""kotlin"",
    ""rust"" = ""rust"",
    ""php"" = ""php"",
    ""typescript"" = ""typescript"",
    ""racket"" = ""racket"",
    ""erlang"" = ""erlang"",
    ""elixir"" = ""elixir"",
}

export const LangText: Record<LangSlug, string> = {
    [LangSlug.cpp]: ""C++"",
    [LangSlug.java]: ""Java"",
    [LangSlug.python]: ""Python 2"",
    [LangSlug.python3]: ""Python 3"",
    [LangSlug.c]: ""C"",
    [LangSlug.csharp]: ""C#"",
    [LangSlug.javascript]: ""JavaScript"",
    [LangSlug.ruby]: ""Ruby"",
    [LangSlug.swift]: ""Swift"",
    [LangSlug.golang]: ""Go"",
    [LangSlug.scala]: ""Scala"",
    [LangSlug.kotlin]: ""Kotlin"",
    [LangSlug.rust]: ""Rust"",
    [LangSlug.php]: ""PHP"",
    [LangSlug.typescript]: ""TypeScript"",
    [LangSlug.racket]: ""Racket"",
    [LangSlug.erlang]: ""Erlang"",
    [LangSlug.elixir]: ""Elixir"",
};

export function LangExt(langSlug): <fim_suffix> {
    switch (langSlug) {
        case LangSlug.cpp:
            return ""cpp"";
        case LangSlug.java:
            return ""java"";
        case LangSlug.python:
            return ""py2"";
        case LangSlug.python3:
            return ""py"";
        case LangSlug.c:
            return ""c"";
        case LangSlug.csharp:
            return ""cs"";
        case LangSlug.javascript:
            return ""js"";
        case LangSlug.ruby:
            return ""rb"";
        case LangSlug.swift:
            return ""swift"";
        case LangSlug.golang:
            return ""go"";
        case LangSlug.scala:
            return ""scala"";
        case LangSlug.kotlin:
            return ""kotlin"";
        case LangSlug.rust:
            return ""rs"";
        case LangSlug.php:
            return ""php"";
        case LangSlug.typescript:
            return ""ts"";
        case LangSlug.racket:
            return ""racket"";
        case LangSlug.erlang:
            return ""erlang"";
        case LangSlug.elixir:
            return ""elixir"";
        default:
            return ""unknown"";
    }
}

export enum ProblemStatus {
    ""Accept"",
    ""NotAccept"",
    ""NotStart"",
}

export enum ProblemDifficulty {
    ""Easy"",
    ""Medium"",
    ""Hard"",
}

export enum SubmissionStatus {
    ""Accepted"",
    ""Compile Error"",
    ""Wrong Answer"",
    ""Time Limit Exceeded"",
}

export enum EndPoint {
    ""US"",
    ""CN"",
}

export interface Uris {
    base: string;
    login: string;
    graphql: string;
    problemsAll: string;
    problem: string;
    contestInfo: string;
    submit: string;
    submission: string;
}

export interface OutputDetail {
    codeOutput: string;
    expectedOutput: string;
    input: string;
    compileError: string;
    runtimeError: string;
    lastTestcase: string;
    __typename: string;
}
<fim_middle>",correct,451
string,string,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue (): <fim_suffix> {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,516
string,string,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json: <fim_suffix>) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,523
string,string,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?, stack?: <fim_suffix>) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,526
string,string,14b6f3ea549b72c43492b5117122ae84aeb1824e,"<fim_prefix>export type JsonValue =
  | string
  | number
  | null
  | boolean
  | JsonValue[]
  | { [property: string]: JsonValue }

export type JsonKey = string | number

export enum JsonError {
  /// Type is not json encodable
  unsupportedType,

  /// Out of bound access to list
  indexOutOfBounds,

  /// Unexpected type
  wrongType,

  /// Entry does not exists
  notExist
}

export class JsonException extends Error {
  readonly error: JsonError

  constructor (error, reason?: <fim_suffix>, stack?) {
    super()

    this.error = error
    this.name = JsonError[error]
    this.stack = stack

    switch (error) {
      case JsonError.unsupportedType:
        reason = reason ?? 'JSON Error: not a valid JSON value'
        break
      case JsonError.indexOutOfBounds:
        reason = reason ?? 'JSON Error: index out of bounds'
        break
      case JsonError.wrongType:
        reason =
          reason ??
          'JSON Error: either key is not a index type or value is not indexable'
        break
      case JsonError.notExist:
        reason = reason ?? ""JSON Error: key does't not exists""
        break
    }
  }
}

export default class TypedJson {
  readonly rawValue: JsonValue

  readonly exception?: JsonException

  constructor (rawValue, exception?) {
    this.rawValue = rawValue
    this.exception = exception
  }

  static fromString (json) {
    return new TypedJson(JSON.parse(json))
  }

  get (keyOrPath) {
    if (Array.isArray(keyOrPath)) {
      if (keyOrPath.length == 0) {
        throw new Error(""Path can't be empty"")
      }

      return keyOrPath.length > 1
        ? this.get(keyOrPath[0]).get(keyOrPath.slice(1))
        : this.get(keyOrPath[0])
    }

    if (Array.isArray(this.rawValue)) {
      const array = this.rawValue as JsonValue[]
      let index: number

      if (typeof keyOrPath === 'string') {
        index = parseInt(keyOrPath)

        if (isNaN(index)) {
          return new TypedJson(
            null,
            new JsonException(
              JsonError.wrongType,
              `JSON Error: index must be a number, string given`
            )
          )
        }
      } else {
        index = (keyOrPath as number) | 0 // Ensure integer
      }

      if (index < 0 || index >= array.length) {
        return new TypedJson(
          null,
          new JsonException(JsonError.indexOutOfBounds)
        )
      }

      return new TypedJson(array[index])
    } else if (typeof this.rawValue === 'object' && this.rawValue !== null) {
      const map = this.rawValue as { [property: string]: JsonValue }
      let index: string =
        typeof keyOrPath === 'string' ? keyOrPath : `${keyOrPath}`

      let result = new TypedJson(map[index])
      if (!map.hasOwnProperty(index)) {
        return new TypedJson(
          null,
          new JsonException(
            JsonError.notExist,
            `JSON Error: key ${index} does not exists`
          )
        )
      }

      return result
    }

    return new TypedJson(null, new JsonException(JsonError.wrongType))
  }

  exists (key, notNull = true) {
    return (
      this.get(key).exception === undefined &&
      (!notNull || this.get(key).rawValue !== null)
    )
  }

  string () {
    return typeof this.rawValue === 'string' ? this.rawValue : undefined
  }

  stringValue () {
    if (typeof this.rawValue === 'string') {
      return this.rawValue
    } else if (['boolean', 'number'].indexOf(typeof this.rawValue) >= 0) {
      return `${this.rawValue}`
    }

    return ''
  }

  boolean () {
    return typeof this.rawValue === 'boolean' ? this.rawValue : undefined
  }

  booleanValue () {
    if (typeof this.rawValue === 'boolean') {
      return this.rawValue
    } else if (typeof this.rawValue === 'number') {
      return this.rawValue === 1
    } else if (typeof this.rawValue === 'string') {
      return (
        ['true', 'y', 't', 'yes', '1'].indexOf(this.rawValue.toLowerCase()) >= 0
      )
    }

    return false
  }

  integer () {
    return typeof this.rawValue === 'number' && Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  integerValue () {
    if (typeof this.rawValue === 'number') {
      return Number.isInteger(this.rawValue)
        ? this.rawValue
        : Math.round(this.rawValue)
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseInt(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  float () {
    return typeof this.rawValue === 'number' && !Number.isInteger(this.rawValue)
      ? this.rawValue
      : undefined
  }

  floatValue () {
    if (typeof this.rawValue === 'number') {
      return this.rawValue
    } else if (typeof this.rawValue === 'boolean') {
      return this.rawValue ? 1 : 0
    } else if (typeof this.rawValue === 'string') {
      let parsed = parseFloat(this.rawValue)
      return isNaN(parsed) ? 0 : parsed
    }

    return 0
  }

  array () {
    return Array.isArray(this.rawValue)
      ? this.rawValue.map(value => new TypedJson(value))
      : undefined
  }

  arrayValue () {
    return this.array() ?? []
  }

  arrayRaw () {
    return Array.isArray(this.rawValue) ? this.rawValue : undefined
  }

  arrayRawValue () {
    return this.arrayRaw() ?? []
  }

  object () {
    if (typeof this.rawValue !== 'object' || Array.isArray(this.rawValue)) {
      return undefined
    }

    let obj: any = {}
    Object.entries(this.rawValue ?? []).forEach(item => {
      obj[item[0]] = new TypedJson(item[1])
    })

    return obj
  }

  objectValue () {
    return this.object() ?? {}
  }

  objectRaw () {
    return this.rawValue !== null &&
      typeof this.rawValue === 'object' &&
      !Array.isArray(this.rawValue)
      ? this.rawValue
      : undefined
  }

  objectRawValue () {
    return this.objectRaw() ?? {}
  }
}
<fim_middle>",correct,527
string,string,a502da435a6278844d221141f6cce947032e53cc,"<fim_prefix>export interface LanguageInterface {
  name: string;
  code: string;
  nativeName: string;
  layout: ""ltr"" | ""rtl"";
}

export interface LanguagesInterface {
  [key: string]: LanguageInterface;
}

export interface TranslatorOptions {
  cache?: boolean;
  defaultLanguage: string;
  currentLangauge: string;
  engine: TranslateEngine;
}

export type TranslationResponseShape = Record<string, string>;

export type TranslateEngine = (
  language,
  targets
) => Promise<TranslationResponseShape> | TranslationResponseShape;

export type CacheSetter = (key, value) => Promise<void> | void;
export type CacheGetter = (
  key
) => Promise<string | null> | string | null;

export class Translator {
  protected TranslationTargets: string[] = [];
  protected TranslationResults: Record<string, string> = {};
  protected CacheEngines?: {
    setter: CacheSetter;
    getter: CacheGetter;
  };

  // Global Metadata
  public metadata: Record<string, any> = {};

  constructor(protected Options) {
    // Validate Options
    this.setOptions(this.Options);
  }

  public setTranslations(
    translations
  ) {
    if (typeof translations === ""object"")
      this.TranslationTargets = translations;
    else if (typeof translations === ""function"") {
      this.TranslationTargets = translations(this.TranslationTargets);
    }

    return this;
  }

  public getTranslated() {
    return this.TranslationResults;
  }

  public setCacheEngines(setter, getter) {
    if (typeof setter !== ""function"")
      throw new Error(`Please provide a valid Cache Setter Function!`);
    else if (typeof getter !== ""function"")
      throw new Error(`Please provide a valid Cache Getter Function!`);

    this.CacheEngines = { setter, getter };
    return this;
  }

  public setOptions(options) {
    // Validate Options
    if (options.engine && typeof options.engine !== ""function"")
      throw new Error(`Please provide a valid Translation Engine Function!`);

    // Set Options
    this.Options = {
      ...this.Options,
      ...options,
    };

    return this;
  }

  public async setCache(key, value) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.setter === ""function""
    )
      this.CacheEngines.setter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key,
        value
      );
  }

  public async getCache(key: <fim_suffix>) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.getter === ""function""
    )
      return this.CacheEngines.getter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key
      );
    else return null;
  }

  public async translate<T extends string | string[]>(
    targets?
  ) {
    // Resolve Targets
    if (targets === undefined) targets = this.TranslationTargets as T;

    // Collect Translations from Cache
    let Translated: Record<string, string> = {
      ...(
        await Promise.all(
          (targets instanceof Array ? targets : [targets]).map(
            async (target) => {
              const value = await this.getCache(target);
              if (value || target === """")
                return {
                  key: target,
                  value: target === """" ? target : value,
                };
              else return undefined;
            }
          )
        )
      )
        .filter((v) => v !== undefined)
        .reduce(
          (object, item) => ({
            ...object,
            [item!.key]: item!.value,
          }),
          {}
        ),
    };

    // Get Translated Targets
    const TranslatedTargets = Object.keys(Translated);

    // Filter Remaining Targets
    const RemainingTranslations = (targets instanceof Array
      ? targets
      : [targets]
    ).filter((target) => !TranslatedTargets.includes(target));

    // Check Remaining Length
    if (RemainingTranslations.length) {
      try {
        // Fetch New Translations
        const Results =
          this.Options.defaultLanguage !== this.Options.currentLangauge
            ? await this.Options.engine(
                {
                  default: this.Options.defaultLanguage,
                  current: this.Options.currentLangauge,
                },
                RemainingTranslations
              )
            : RemainingTranslations.reduce<TranslationResponseShape>(
                (object, target) => ({ ...object, [target]: target }),
                {}
              );

        if (typeof Results === ""object"") {
          // Store Translation to Cache
          if (this.Options.defaultLanguage !== this.Options.currentLangauge)
            await Promise.all(
              Object.keys(Results).map((target) =>
                this.setCache(target, Results[target])
              )
            );

          // Combine Results
          Translated = {
            ...Translated,
            ...Results,
          };
        }
      } catch (e) {
        // Combine Results
        Translated = {
          ...Translated,
          ...RemainingTranslations.reduce<TranslationResponseShape>(
            (object, target) => ({ ...object, [target]: target }),
            {}
          ),
        };
      }
    }

    // Store Results
    this.TranslationResults = ((targets instanceof Array
      ? targets
      : [targets]) as string[]).reduce(
      (object, target) => ({
        ...object,
        [target]: Translated[target],
      }),
      {}
    );

    // Return Results
    return (typeof targets === ""string""
      ? Object.values(this.TranslationResults)[0]
      : this.TranslationResults) as any;
  }
}
<fim_middle>",correct,565
string,string,a502da435a6278844d221141f6cce947032e53cc,"<fim_prefix>export interface LanguageInterface {
  name: string;
  code: string;
  nativeName: string;
  layout: ""ltr"" | ""rtl"";
}

export interface LanguagesInterface {
  [key: string]: LanguageInterface;
}

export interface TranslatorOptions {
  cache?: boolean;
  defaultLanguage: string;
  currentLangauge: string;
  engine: TranslateEngine;
}

export type TranslationResponseShape = Record<string, string>;

export type TranslateEngine = (
  language,
  targets
) => Promise<TranslationResponseShape> | TranslationResponseShape;

export type CacheSetter = (key, value) => Promise<void> | void;
export type CacheGetter = (
  key
) => Promise<string | null> | string | null;

export class Translator {
  protected TranslationTargets: string[] = [];
  protected TranslationResults: Record<string, string> = {};
  protected CacheEngines?: {
    setter: CacheSetter;
    getter: CacheGetter;
  };

  // Global Metadata
  public metadata: Record<string, any> = {};

  constructor(protected Options) {
    // Validate Options
    this.setOptions(this.Options);
  }

  public setTranslations(
    translations
  ) {
    if (typeof translations === ""object"")
      this.TranslationTargets = translations;
    else if (typeof translations === ""function"") {
      this.TranslationTargets = translations(this.TranslationTargets);
    }

    return this;
  }

  public getTranslated() {
    return this.TranslationResults;
  }

  public setCacheEngines(setter, getter) {
    if (typeof setter !== ""function"")
      throw new Error(`Please provide a valid Cache Setter Function!`);
    else if (typeof getter !== ""function"")
      throw new Error(`Please provide a valid Cache Getter Function!`);

    this.CacheEngines = { setter, getter };
    return this;
  }

  public setOptions(options) {
    // Validate Options
    if (options.engine && typeof options.engine !== ""function"")
      throw new Error(`Please provide a valid Translation Engine Function!`);

    // Set Options
    this.Options = {
      ...this.Options,
      ...options,
    };

    return this;
  }

  public async setCache(key, value: <fim_suffix>) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.setter === ""function""
    )
      this.CacheEngines.setter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key,
        value
      );
  }

  public async getCache(key) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.getter === ""function""
    )
      return this.CacheEngines.getter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key
      );
    else return null;
  }

  public async translate<T extends string | string[]>(
    targets?
  ) {
    // Resolve Targets
    if (targets === undefined) targets = this.TranslationTargets as T;

    // Collect Translations from Cache
    let Translated: Record<string, string> = {
      ...(
        await Promise.all(
          (targets instanceof Array ? targets : [targets]).map(
            async (target) => {
              const value = await this.getCache(target);
              if (value || target === """")
                return {
                  key: target,
                  value: target === """" ? target : value,
                };
              else return undefined;
            }
          )
        )
      )
        .filter((v) => v !== undefined)
        .reduce(
          (object, item) => ({
            ...object,
            [item!.key]: item!.value,
          }),
          {}
        ),
    };

    // Get Translated Targets
    const TranslatedTargets = Object.keys(Translated);

    // Filter Remaining Targets
    const RemainingTranslations = (targets instanceof Array
      ? targets
      : [targets]
    ).filter((target) => !TranslatedTargets.includes(target));

    // Check Remaining Length
    if (RemainingTranslations.length) {
      try {
        // Fetch New Translations
        const Results =
          this.Options.defaultLanguage !== this.Options.currentLangauge
            ? await this.Options.engine(
                {
                  default: this.Options.defaultLanguage,
                  current: this.Options.currentLangauge,
                },
                RemainingTranslations
              )
            : RemainingTranslations.reduce<TranslationResponseShape>(
                (object, target) => ({ ...object, [target]: target }),
                {}
              );

        if (typeof Results === ""object"") {
          // Store Translation to Cache
          if (this.Options.defaultLanguage !== this.Options.currentLangauge)
            await Promise.all(
              Object.keys(Results).map((target) =>
                this.setCache(target, Results[target])
              )
            );

          // Combine Results
          Translated = {
            ...Translated,
            ...Results,
          };
        }
      } catch (e) {
        // Combine Results
        Translated = {
          ...Translated,
          ...RemainingTranslations.reduce<TranslationResponseShape>(
            (object, target) => ({ ...object, [target]: target }),
            {}
          ),
        };
      }
    }

    // Store Results
    this.TranslationResults = ((targets instanceof Array
      ? targets
      : [targets]) as string[]).reduce(
      (object, target) => ({
        ...object,
        [target]: Translated[target],
      }),
      {}
    );

    // Return Results
    return (typeof targets === ""string""
      ? Object.values(this.TranslationResults)[0]
      : this.TranslationResults) as any;
  }
}
<fim_middle>",correct,566
string,string,a502da435a6278844d221141f6cce947032e53cc,"<fim_prefix>export interface LanguageInterface {
  name: string;
  code: string;
  nativeName: string;
  layout: ""ltr"" | ""rtl"";
}

export interface LanguagesInterface {
  [key: string]: LanguageInterface;
}

export interface TranslatorOptions {
  cache?: boolean;
  defaultLanguage: string;
  currentLangauge: string;
  engine: TranslateEngine;
}

export type TranslationResponseShape = Record<string, string>;

export type TranslateEngine = (
  language,
  targets
) => Promise<TranslationResponseShape> | TranslationResponseShape;

export type CacheSetter = (key, value) => Promise<void> | void;
export type CacheGetter = (
  key
) => Promise<string | null> | string | null;

export class Translator {
  protected TranslationTargets: string[] = [];
  protected TranslationResults: Record<string, string> = {};
  protected CacheEngines?: {
    setter: CacheSetter;
    getter: CacheGetter;
  };

  // Global Metadata
  public metadata: Record<string, any> = {};

  constructor(protected Options) {
    // Validate Options
    this.setOptions(this.Options);
  }

  public setTranslations(
    translations
  ) {
    if (typeof translations === ""object"")
      this.TranslationTargets = translations;
    else if (typeof translations === ""function"") {
      this.TranslationTargets = translations(this.TranslationTargets);
    }

    return this;
  }

  public getTranslated() {
    return this.TranslationResults;
  }

  public setCacheEngines(setter, getter) {
    if (typeof setter !== ""function"")
      throw new Error(`Please provide a valid Cache Setter Function!`);
    else if (typeof getter !== ""function"")
      throw new Error(`Please provide a valid Cache Getter Function!`);

    this.CacheEngines = { setter, getter };
    return this;
  }

  public setOptions(options) {
    // Validate Options
    if (options.engine && typeof options.engine !== ""function"")
      throw new Error(`Please provide a valid Translation Engine Function!`);

    // Set Options
    this.Options = {
      ...this.Options,
      ...options,
    };

    return this;
  }

  public async setCache(key: <fim_suffix>, value) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.setter === ""function""
    )
      this.CacheEngines.setter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key,
        value
      );
  }

  public async getCache(key) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.getter === ""function""
    )
      return this.CacheEngines.getter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key
      );
    else return null;
  }

  public async translate<T extends string | string[]>(
    targets?
  ) {
    // Resolve Targets
    if (targets === undefined) targets = this.TranslationTargets as T;

    // Collect Translations from Cache
    let Translated: Record<string, string> = {
      ...(
        await Promise.all(
          (targets instanceof Array ? targets : [targets]).map(
            async (target) => {
              const value = await this.getCache(target);
              if (value || target === """")
                return {
                  key: target,
                  value: target === """" ? target : value,
                };
              else return undefined;
            }
          )
        )
      )
        .filter((v) => v !== undefined)
        .reduce(
          (object, item) => ({
            ...object,
            [item!.key]: item!.value,
          }),
          {}
        ),
    };

    // Get Translated Targets
    const TranslatedTargets = Object.keys(Translated);

    // Filter Remaining Targets
    const RemainingTranslations = (targets instanceof Array
      ? targets
      : [targets]
    ).filter((target) => !TranslatedTargets.includes(target));

    // Check Remaining Length
    if (RemainingTranslations.length) {
      try {
        // Fetch New Translations
        const Results =
          this.Options.defaultLanguage !== this.Options.currentLangauge
            ? await this.Options.engine(
                {
                  default: this.Options.defaultLanguage,
                  current: this.Options.currentLangauge,
                },
                RemainingTranslations
              )
            : RemainingTranslations.reduce<TranslationResponseShape>(
                (object, target) => ({ ...object, [target]: target }),
                {}
              );

        if (typeof Results === ""object"") {
          // Store Translation to Cache
          if (this.Options.defaultLanguage !== this.Options.currentLangauge)
            await Promise.all(
              Object.keys(Results).map((target) =>
                this.setCache(target, Results[target])
              )
            );

          // Combine Results
          Translated = {
            ...Translated,
            ...Results,
          };
        }
      } catch (e) {
        // Combine Results
        Translated = {
          ...Translated,
          ...RemainingTranslations.reduce<TranslationResponseShape>(
            (object, target) => ({ ...object, [target]: target }),
            {}
          ),
        };
      }
    }

    // Store Results
    this.TranslationResults = ((targets instanceof Array
      ? targets
      : [targets]) as string[]).reduce(
      (object, target) => ({
        ...object,
        [target]: Translated[target],
      }),
      {}
    );

    // Return Results
    return (typeof targets === ""string""
      ? Object.values(this.TranslationResults)[0]
      : this.TranslationResults) as any;
  }
}
<fim_middle>",correct,567
string,string,a502da435a6278844d221141f6cce947032e53cc,"<fim_prefix>export interface LanguageInterface {
  name: string;
  code: string;
  nativeName: string;
  layout: ""ltr"" | ""rtl"";
}

export interface LanguagesInterface {
  [key: string]: LanguageInterface;
}

export interface TranslatorOptions {
  cache?: boolean;
  defaultLanguage: string;
  currentLangauge: string;
  engine: TranslateEngine;
}

export type TranslationResponseShape = Record<string, string>;

export type TranslateEngine = (
  language,
  targets
) => Promise<TranslationResponseShape> | TranslationResponseShape;

export type CacheSetter = (key, value: <fim_suffix>) => Promise<void> | void;
export type CacheGetter = (
  key
) => Promise<string | null> | string | null;

export class Translator {
  protected TranslationTargets: string[] = [];
  protected TranslationResults: Record<string, string> = {};
  protected CacheEngines?: {
    setter: CacheSetter;
    getter: CacheGetter;
  };

  // Global Metadata
  public metadata: Record<string, any> = {};

  constructor(protected Options) {
    // Validate Options
    this.setOptions(this.Options);
  }

  public setTranslations(
    translations
  ) {
    if (typeof translations === ""object"")
      this.TranslationTargets = translations;
    else if (typeof translations === ""function"") {
      this.TranslationTargets = translations(this.TranslationTargets);
    }

    return this;
  }

  public getTranslated() {
    return this.TranslationResults;
  }

  public setCacheEngines(setter, getter) {
    if (typeof setter !== ""function"")
      throw new Error(`Please provide a valid Cache Setter Function!`);
    else if (typeof getter !== ""function"")
      throw new Error(`Please provide a valid Cache Getter Function!`);

    this.CacheEngines = { setter, getter };
    return this;
  }

  public setOptions(options) {
    // Validate Options
    if (options.engine && typeof options.engine !== ""function"")
      throw new Error(`Please provide a valid Translation Engine Function!`);

    // Set Options
    this.Options = {
      ...this.Options,
      ...options,
    };

    return this;
  }

  public async setCache(key, value) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.setter === ""function""
    )
      this.CacheEngines.setter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key,
        value
      );
  }

  public async getCache(key) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.getter === ""function""
    )
      return this.CacheEngines.getter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key
      );
    else return null;
  }

  public async translate<T extends string | string[]>(
    targets?
  ) {
    // Resolve Targets
    if (targets === undefined) targets = this.TranslationTargets as T;

    // Collect Translations from Cache
    let Translated: Record<string, string> = {
      ...(
        await Promise.all(
          (targets instanceof Array ? targets : [targets]).map(
            async (target) => {
              const value = await this.getCache(target);
              if (value || target === """")
                return {
                  key: target,
                  value: target === """" ? target : value,
                };
              else return undefined;
            }
          )
        )
      )
        .filter((v) => v !== undefined)
        .reduce(
          (object, item) => ({
            ...object,
            [item!.key]: item!.value,
          }),
          {}
        ),
    };

    // Get Translated Targets
    const TranslatedTargets = Object.keys(Translated);

    // Filter Remaining Targets
    const RemainingTranslations = (targets instanceof Array
      ? targets
      : [targets]
    ).filter((target) => !TranslatedTargets.includes(target));

    // Check Remaining Length
    if (RemainingTranslations.length) {
      try {
        // Fetch New Translations
        const Results =
          this.Options.defaultLanguage !== this.Options.currentLangauge
            ? await this.Options.engine(
                {
                  default: this.Options.defaultLanguage,
                  current: this.Options.currentLangauge,
                },
                RemainingTranslations
              )
            : RemainingTranslations.reduce<TranslationResponseShape>(
                (object, target) => ({ ...object, [target]: target }),
                {}
              );

        if (typeof Results === ""object"") {
          // Store Translation to Cache
          if (this.Options.defaultLanguage !== this.Options.currentLangauge)
            await Promise.all(
              Object.keys(Results).map((target) =>
                this.setCache(target, Results[target])
              )
            );

          // Combine Results
          Translated = {
            ...Translated,
            ...Results,
          };
        }
      } catch (e) {
        // Combine Results
        Translated = {
          ...Translated,
          ...RemainingTranslations.reduce<TranslationResponseShape>(
            (object, target) => ({ ...object, [target]: target }),
            {}
          ),
        };
      }
    }

    // Store Results
    this.TranslationResults = ((targets instanceof Array
      ? targets
      : [targets]) as string[]).reduce(
      (object, target) => ({
        ...object,
        [target]: Translated[target],
      }),
      {}
    );

    // Return Results
    return (typeof targets === ""string""
      ? Object.values(this.TranslationResults)[0]
      : this.TranslationResults) as any;
  }
}
<fim_middle>",correct,574
string,string,a502da435a6278844d221141f6cce947032e53cc,"<fim_prefix>export interface LanguageInterface {
  name: string;
  code: string;
  nativeName: string;
  layout: ""ltr"" | ""rtl"";
}

export interface LanguagesInterface {
  [key: string]: LanguageInterface;
}

export interface TranslatorOptions {
  cache?: boolean;
  defaultLanguage: string;
  currentLangauge: string;
  engine: TranslateEngine;
}

export type TranslationResponseShape = Record<string, string>;

export type TranslateEngine = (
  language,
  targets
) => Promise<TranslationResponseShape> | TranslationResponseShape;

export type CacheSetter = (key: <fim_suffix>, value) => Promise<void> | void;
export type CacheGetter = (
  key
) => Promise<string | null> | string | null;

export class Translator {
  protected TranslationTargets: string[] = [];
  protected TranslationResults: Record<string, string> = {};
  protected CacheEngines?: {
    setter: CacheSetter;
    getter: CacheGetter;
  };

  // Global Metadata
  public metadata: Record<string, any> = {};

  constructor(protected Options) {
    // Validate Options
    this.setOptions(this.Options);
  }

  public setTranslations(
    translations
  ) {
    if (typeof translations === ""object"")
      this.TranslationTargets = translations;
    else if (typeof translations === ""function"") {
      this.TranslationTargets = translations(this.TranslationTargets);
    }

    return this;
  }

  public getTranslated() {
    return this.TranslationResults;
  }

  public setCacheEngines(setter, getter) {
    if (typeof setter !== ""function"")
      throw new Error(`Please provide a valid Cache Setter Function!`);
    else if (typeof getter !== ""function"")
      throw new Error(`Please provide a valid Cache Getter Function!`);

    this.CacheEngines = { setter, getter };
    return this;
  }

  public setOptions(options) {
    // Validate Options
    if (options.engine && typeof options.engine !== ""function"")
      throw new Error(`Please provide a valid Translation Engine Function!`);

    // Set Options
    this.Options = {
      ...this.Options,
      ...options,
    };

    return this;
  }

  public async setCache(key, value) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.setter === ""function""
    )
      this.CacheEngines.setter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key,
        value
      );
  }

  public async getCache(key) {
    if (
      [undefined, true].includes(this.Options.cache) &&
      typeof this.CacheEngines?.getter === ""function""
    )
      return this.CacheEngines.getter(
        `TRN_${this.Options.defaultLanguage}_${this.Options.currentLangauge}_` +
          key
      );
    else return null;
  }

  public async translate<T extends string | string[]>(
    targets?
  ) {
    // Resolve Targets
    if (targets === undefined) targets = this.TranslationTargets as T;

    // Collect Translations from Cache
    let Translated: Record<string, string> = {
      ...(
        await Promise.all(
          (targets instanceof Array ? targets : [targets]).map(
            async (target) => {
              const value = await this.getCache(target);
              if (value || target === """")
                return {
                  key: target,
                  value: target === """" ? target : value,
                };
              else return undefined;
            }
          )
        )
      )
        .filter((v) => v !== undefined)
        .reduce(
          (object, item) => ({
            ...object,
            [item!.key]: item!.value,
          }),
          {}
        ),
    };

    // Get Translated Targets
    const TranslatedTargets = Object.keys(Translated);

    // Filter Remaining Targets
    const RemainingTranslations = (targets instanceof Array
      ? targets
      : [targets]
    ).filter((target) => !TranslatedTargets.includes(target));

    // Check Remaining Length
    if (RemainingTranslations.length) {
      try {
        // Fetch New Translations
        const Results =
          this.Options.defaultLanguage !== this.Options.currentLangauge
            ? await this.Options.engine(
                {
                  default: this.Options.defaultLanguage,
                  current: this.Options.currentLangauge,
                },
                RemainingTranslations
              )
            : RemainingTranslations.reduce<TranslationResponseShape>(
                (object, target) => ({ ...object, [target]: target }),
                {}
              );

        if (typeof Results === ""object"") {
          // Store Translation to Cache
          if (this.Options.defaultLanguage !== this.Options.currentLangauge)
            await Promise.all(
              Object.keys(Results).map((target) =>
                this.setCache(target, Results[target])
              )
            );

          // Combine Results
          Translated = {
            ...Translated,
            ...Results,
          };
        }
      } catch (e) {
        // Combine Results
        Translated = {
          ...Translated,
          ...RemainingTranslations.reduce<TranslationResponseShape>(
            (object, target) => ({ ...object, [target]: target }),
            {}
          ),
        };
      }
    }

    // Store Results
    this.TranslationResults = ((targets instanceof Array
      ? targets
      : [targets]) as string[]).reduce(
      (object, target) => ({
        ...object,
        [target]: Translated[target],
      }),
      {}
    );

    // Return Results
    return (typeof targets === ""string""
      ? Object.values(this.TranslationResults)[0]
      : this.TranslationResults) as any;
  }
}
<fim_middle>",correct,575
string,string,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors) {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType: <fim_suffix> = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,627
string,string,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors) {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename: <fim_suffix>) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,630
string,string,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors) {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType: <fim_suffix>, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,631
string,string,2f9ed4c5926a0fcede392151f980e017c0c93acb,"<fim_prefix>interface WordCoord {
  start: number[]
  end: number[]
}

interface SearchResult {
  [k: string]: WordCoord | undefined
}

export default class WordSearch {
  // For searching in all 8 directions
  static directions: { row: number; col: number }[] = [
    { row: 0, col: 1 }, // left to right
    { row: 0, col: -1 }, // right to left
    { row: 1, col: 0 }, // top to bottom
    { row: -1, col: 0 }, // bottom to top
    { row: 1, col: 1 }, // top left to bottom right
    { row: 1, col: -1 }, // top right to bottom left
    { row: -1, col: 1 }, // bottom left to top right
    { row: -1, col: -1 }, // bottom right to top left
  ]

  private rowLen: number
  private colLen: number

  constructor(private grid = []) {
    this.rowLen = this.grid.length
    this.colLen = this.grid[0]?.length || 0
  }

  find(words) {
    const result: SearchResult = {}

    for (const word of words) {
      for (let row = 0; row < this.rowLen; row++) {
        for (let col = 0; col < this.colLen; col++) {
          if (!result[word]) {
            result[word] = this.findWord(word, row, col)
          }
        }
      }
    }

    return result
  }

  findWord(word: <fim_suffix>, row, col) {
    // Word is not found if the first letter doesn't match.
    if (this.grid[row][col] !== word[0]) {
      return
    }

    // Search in all directions starting from (row, col).
    for (const direction of WordSearch.directions) {
      let rowDir = row + direction.row
      let colDir = col + direction.col
      let i = 0

      // First letter is already checked, start searching from the second letter.
      for (i = 1; i < word.length; i++) {
        // Stop if out of bound.
        if (rowDir >= this.rowLen || rowDir < 0 || colDir >= this.colLen || colDir < 0) {
          break
        }

        // Stop if letter doesn't match.
        if (this.grid[rowDir][colDir] !== word[i]) {
          break
        }

        // Move in particular direction.
        rowDir += direction.row
        colDir += direction.col
      }

      // If all letters matched then value of i is equal to the length of the word.
      if (i === word.length) {
        // Result should be in math indexes which start from (1, 1).
        // So we need to add 1 to indexes but it depends on direction in which word was found.
        const rowAdd = 1 - direction.row
        const colAdd = 1 - direction.col

        return {
          start: [row + 1, col + 1],
          end: [rowDir + rowAdd, colDir + colAdd],
        }
      }
    }
  }
}
<fim_middle>",correct,642
string,string,2fdae3b2fd744628f3655d3b63661a27b1e3bdbd,"<fim_prefix>export interface ModuleOptionsConfig {
  enabledDefault?: boolean;
  headerIP?: string;
}

export interface ModuleOptions {
  url: string;
  environment: string;
  instanceId: string;
  config: ModuleOptionsConfig;
}

export interface UnleashFlagStrategy {
  name: string;
  parameters: { [p: string]: string };
}

export interface UnleashFlagsData {
  name: string;
  description: string;
  enabled: boolean;
  strategies: UnleashFlagStrategy[];
}

export interface NuxtFeatureOptionsContext {
  ip?: string;
}

export class UnleashFlags {
  // eslint-disable-next-line no-useless-constructor
  private constructor (private features, private config, private context) {}

  public static create ({
    features,
    config,
    context
  }) {
    return new UnleashFlags(features, config, context)
  }

  isEnabled (name) {
    if (!this.exists(name)) {
      return this.config.enabledDefault
    }
    return this.features.some(f => f.name === name && f.enabled)
  }

  exists (name) {
    return this.features.some(f => f.name === name)
  }

  isAllowIP (name) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const ips = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (
        this.context.ip !== undefined &&
        this.context.ip.length > 0 &&
        ips.includes(this.context.ip)
      ) {
        return true
      }
    }
    return false
  }

  isAllowUser (name, user) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const users = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (user.length > 0 && users.includes(user)) {
        return true
      }
    }
    return false
  }

  private getFeature (
    name,
    strategyName: <fim_suffix> = 'userWithId'
  ) {
    const feature = this.features.find(
      f => f.name === name
    )
    if (!feature) {
      return {
        feature: undefined,
        strategies: undefined
      }
    }
    const strategies = feature.strategies.filter(
      f => f.name === strategyName
    )
    if (!strategies) {
      return {
        feature,
        strategies: undefined
      }
    }
    return {
      feature,
      strategies
    }
  }
}
<fim_middle>",correct,647
string,string,2fdae3b2fd744628f3655d3b63661a27b1e3bdbd,"<fim_prefix>export interface ModuleOptionsConfig {
  enabledDefault?: boolean;
  headerIP?: string;
}

export interface ModuleOptions {
  url: string;
  environment: string;
  instanceId: string;
  config: ModuleOptionsConfig;
}

export interface UnleashFlagStrategy {
  name: string;
  parameters: { [p: string]: string };
}

export interface UnleashFlagsData {
  name: string;
  description: string;
  enabled: boolean;
  strategies: UnleashFlagStrategy[];
}

export interface NuxtFeatureOptionsContext {
  ip?: string;
}

export class UnleashFlags {
  // eslint-disable-next-line no-useless-constructor
  private constructor (private features, private config, private context) {}

  public static create ({
    features,
    config,
    context
  }) {
    return new UnleashFlags(features, config, context)
  }

  isEnabled (name) {
    if (!this.exists(name)) {
      return this.config.enabledDefault
    }
    return this.features.some(f => f.name === name && f.enabled)
  }

  exists (name) {
    return this.features.some(f => f.name === name)
  }

  isAllowIP (name) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const ips = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (
        this.context.ip !== undefined &&
        this.context.ip.length > 0 &&
        ips.includes(this.context.ip)
      ) {
        return true
      }
    }
    return false
  }

  isAllowUser (name, user) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const users = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (user.length > 0 && users.includes(user)) {
        return true
      }
    }
    return false
  }

  private getFeature (
    name: <fim_suffix>,
    strategyName = 'userWithId'
  ) {
    const feature = this.features.find(
      f => f.name === name
    )
    if (!feature) {
      return {
        feature: undefined,
        strategies: undefined
      }
    }
    const strategies = feature.strategies.filter(
      f => f.name === strategyName
    )
    if (!strategies) {
      return {
        feature,
        strategies: undefined
      }
    }
    return {
      feature,
      strategies
    }
  }
}
<fim_middle>",correct,648
string,string,2fdae3b2fd744628f3655d3b63661a27b1e3bdbd,"<fim_prefix>export interface ModuleOptionsConfig {
  enabledDefault?: boolean;
  headerIP?: string;
}

export interface ModuleOptions {
  url: string;
  environment: string;
  instanceId: string;
  config: ModuleOptionsConfig;
}

export interface UnleashFlagStrategy {
  name: string;
  parameters: { [p: string]: string };
}

export interface UnleashFlagsData {
  name: string;
  description: string;
  enabled: boolean;
  strategies: UnleashFlagStrategy[];
}

export interface NuxtFeatureOptionsContext {
  ip?: string;
}

export class UnleashFlags {
  // eslint-disable-next-line no-useless-constructor
  private constructor (private features, private config, private context) {}

  public static create ({
    features,
    config,
    context
  }) {
    return new UnleashFlags(features, config, context)
  }

  isEnabled (name) {
    if (!this.exists(name)) {
      return this.config.enabledDefault
    }
    return this.features.some(f => f.name === name && f.enabled)
  }

  exists (name) {
    return this.features.some(f => f.name === name)
  }

  isAllowIP (name) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const ips = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (
        this.context.ip !== undefined &&
        this.context.ip.length > 0 &&
        ips.includes(this.context.ip)
      ) {
        return true
      }
    }
    return false
  }

  isAllowUser (name, user: <fim_suffix>) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const users = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (user.length > 0 && users.includes(user)) {
        return true
      }
    }
    return false
  }

  private getFeature (
    name,
    strategyName = 'userWithId'
  ) {
    const feature = this.features.find(
      f => f.name === name
    )
    if (!feature) {
      return {
        feature: undefined,
        strategies: undefined
      }
    }
    const strategies = feature.strategies.filter(
      f => f.name === strategyName
    )
    if (!strategies) {
      return {
        feature,
        strategies: undefined
      }
    }
    return {
      feature,
      strategies
    }
  }
}
<fim_middle>",correct,649
string,string,2fdae3b2fd744628f3655d3b63661a27b1e3bdbd,"<fim_prefix>export interface ModuleOptionsConfig {
  enabledDefault?: boolean;
  headerIP?: string;
}

export interface ModuleOptions {
  url: string;
  environment: string;
  instanceId: string;
  config: ModuleOptionsConfig;
}

export interface UnleashFlagStrategy {
  name: string;
  parameters: { [p: string]: string };
}

export interface UnleashFlagsData {
  name: string;
  description: string;
  enabled: boolean;
  strategies: UnleashFlagStrategy[];
}

export interface NuxtFeatureOptionsContext {
  ip?: string;
}

export class UnleashFlags {
  // eslint-disable-next-line no-useless-constructor
  private constructor (private features, private config, private context) {}

  public static create ({
    features,
    config,
    context
  }) {
    return new UnleashFlags(features, config, context)
  }

  isEnabled (name) {
    if (!this.exists(name)) {
      return this.config.enabledDefault
    }
    return this.features.some(f => f.name === name && f.enabled)
  }

  exists (name) {
    return this.features.some(f => f.name === name)
  }

  isAllowIP (name) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const ips = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (
        this.context.ip !== undefined &&
        this.context.ip.length > 0 &&
        ips.includes(this.context.ip)
      ) {
        return true
      }
    }
    return false
  }

  isAllowUser (name: <fim_suffix>, user) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const users = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (user.length > 0 && users.includes(user)) {
        return true
      }
    }
    return false
  }

  private getFeature (
    name,
    strategyName = 'userWithId'
  ) {
    const feature = this.features.find(
      f => f.name === name
    )
    if (!feature) {
      return {
        feature: undefined,
        strategies: undefined
      }
    }
    const strategies = feature.strategies.filter(
      f => f.name === strategyName
    )
    if (!strategies) {
      return {
        feature,
        strategies: undefined
      }
    }
    return {
      feature,
      strategies
    }
  }
}
<fim_middle>",correct,650
string,string,2fdae3b2fd744628f3655d3b63661a27b1e3bdbd,"<fim_prefix>export interface ModuleOptionsConfig {
  enabledDefault?: boolean;
  headerIP?: string;
}

export interface ModuleOptions {
  url: string;
  environment: string;
  instanceId: string;
  config: ModuleOptionsConfig;
}

export interface UnleashFlagStrategy {
  name: string;
  parameters: { [p: string]: string };
}

export interface UnleashFlagsData {
  name: string;
  description: string;
  enabled: boolean;
  strategies: UnleashFlagStrategy[];
}

export interface NuxtFeatureOptionsContext {
  ip?: string;
}

export class UnleashFlags {
  // eslint-disable-next-line no-useless-constructor
  private constructor (private features, private config, private context) {}

  public static create ({
    features,
    config,
    context
  }) {
    return new UnleashFlags(features, config, context)
  }

  isEnabled (name) {
    if (!this.exists(name)) {
      return this.config.enabledDefault
    }
    return this.features.some(f => f.name === name && f.enabled)
  }

  exists (name: <fim_suffix>) {
    return this.features.some(f => f.name === name)
  }

  isAllowIP (name) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const ips = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (
        this.context.ip !== undefined &&
        this.context.ip.length > 0 &&
        ips.includes(this.context.ip)
      ) {
        return true
      }
    }
    return false
  }

  isAllowUser (name, user) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const users = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (user.length > 0 && users.includes(user)) {
        return true
      }
    }
    return false
  }

  private getFeature (
    name,
    strategyName = 'userWithId'
  ) {
    const feature = this.features.find(
      f => f.name === name
    )
    if (!feature) {
      return {
        feature: undefined,
        strategies: undefined
      }
    }
    const strategies = feature.strategies.filter(
      f => f.name === strategyName
    )
    if (!strategies) {
      return {
        feature,
        strategies: undefined
      }
    }
    return {
      feature,
      strategies
    }
  }
}
<fim_middle>",correct,653
string,string,2fdae3b2fd744628f3655d3b63661a27b1e3bdbd,"<fim_prefix>export interface ModuleOptionsConfig {
  enabledDefault?: boolean;
  headerIP?: string;
}

export interface ModuleOptions {
  url: string;
  environment: string;
  instanceId: string;
  config: ModuleOptionsConfig;
}

export interface UnleashFlagStrategy {
  name: string;
  parameters: { [p: string]: string };
}

export interface UnleashFlagsData {
  name: string;
  description: string;
  enabled: boolean;
  strategies: UnleashFlagStrategy[];
}

export interface NuxtFeatureOptionsContext {
  ip?: string;
}

export class UnleashFlags {
  // eslint-disable-next-line no-useless-constructor
  private constructor (private features, private config, private context) {}

  public static create ({
    features,
    config,
    context
  }) {
    return new UnleashFlags(features, config, context)
  }

  isEnabled (name: <fim_suffix>) {
    if (!this.exists(name)) {
      return this.config.enabledDefault
    }
    return this.features.some(f => f.name === name && f.enabled)
  }

  exists (name) {
    return this.features.some(f => f.name === name)
  }

  isAllowIP (name) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const ips = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (
        this.context.ip !== undefined &&
        this.context.ip.length > 0 &&
        ips.includes(this.context.ip)
      ) {
        return true
      }
    }
    return false
  }

  isAllowUser (name, user) {
    const {
      feature,
      strategies
    } = this.getFeature(name)
    if (!feature || !feature?.enabled || !strategies) {
      return false
    }

    for (const strategy of strategies) {
      const users = strategy.parameters.userIds
        .split(',')
        .map(s => s.trim())
      if (user.length > 0 && users.includes(user)) {
        return true
      }
    }
    return false
  }

  private getFeature (
    name,
    strategyName = 'userWithId'
  ) {
    const feature = this.features.find(
      f => f.name === name
    )
    if (!feature) {
      return {
        feature: undefined,
        strategies: undefined
      }
    }
    const strategies = feature.strategies.filter(
      f => f.name === strategyName
    )
    if (!strategies) {
      return {
        feature,
        strategies: undefined
      }
    }
    return {
      feature,
      strategies
    }
  }
}
<fim_middle>",correct,655
string,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress: <fim_suffix>) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",correct,673
string,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom: <fim_suffix>,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",correct,676
string,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount,
  denom: <fim_suffix>,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",correct,680
string,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress: <fim_suffix>,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",correct,682
string,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress: <fim_suffix>,
  validatorDstAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",correct,683
string,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom: <fim_suffix>,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",correct,685
string,string,b52d90f0836e6909b76a6c1f1093c6a2b1f2117e,"<fim_prefix>export const MSG_DELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgDelegate(
  delegatorAddress,
  validatorAddress: <fim_suffix>,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgDelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_BEGIN_REDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_src_address', type: 'string' },
    { name: 'validator_dst_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgBeginRedelegate(
  delegatorAddress,
  validatorSrcAddress,
  validatorDstAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgBeginRedelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_src_address: validatorSrcAddress,
      validator_dst_address: validatorDstAddress,
    },
  }
}

export const MSG_UNDELEGATE_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
    { name: 'amount', type: 'TypeAmount' },
  ],
  TypeAmount: [
    { name: 'denom', type: 'string' },
    { name: 'amount', type: 'string' },
  ],
}
export function createMsgUndelegate(
  delegatorAddress,
  validatorAddress,
  amount,
  denom,
) {
  return {
    type: 'cosmos-sdk/MsgUndelegate',
    value: {
      amount: {
        amount,
        denom,
      },
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_DELEGATOR_REWARD_TYPES = {
  MsgValue: [
    { name: 'delegator_address', type: 'string' },
    { name: 'validator_address', type: 'string' },
  ],
}

/* eslint-disable camelcase */
export interface MsgWithdrawDelegatorRewardInterface {
  type: string
  value: {
    delegator_address: string
    validator_address: string
  }
}
export function createMsgWithdrawDelegatorReward(
  delegatorAddress,
  validatorAddress,
) {
  return {
    type: 'cosmos-sdk/MsgWithdrawDelegationReward',
    value: {
      delegator_address: delegatorAddress,
      validator_address: validatorAddress,
    },
  }
}

export const MSG_WITHDRAW_VALIDATOR_COMMISSION_TYPES = {
  MsgValue: [{ name: 'validator_address', type: 'string' }],
}

export interface MsgWithdrawValidatorCommissionInterface {
  type: string
  value: {
    validator_address: string
  }
}

export function createMsgWithdrawValidatorCommission(validatorAddress) {
  return {
    type: 'cosmos-sdk/MsgWithdrawValidatorCommission',
    value: {
      validator_address: validatorAddress,
    },
  }
}
<fim_middle>",correct,687
string,string,cb14c7a279f215293358730312da69fac60347a7,"<fim_prefix>const isNull =
	(val): val is null =>
		val === null

const isString =
	(val): val is string =>
		typeof val === ""string""

const isBoolean =
	(val): val is boolean =>
		typeof val === ""boolean""

const isUndefined =
	(val): val is undefined =>
		val === undefined

const isUpperCase =
	(x) =>
		x === x.toUpperCase()

const isEmpty =
	(val) =>
		val.length === 0

const normalizeInput =
	(classNames) =>
		classNames
			.map(
				className => {
					if (isBoolean(className) || isNull(className) || isUndefined(className)) {
						return { className: """", remove: true }
					} else if (isString(className)) {
						if (isEmpty(className)) {
							return { className }
						} else if (isUpperCase(className.charAt(0))) {
							return { className, ignore: true }
						} else {
							return { className }
						}
					} else {
						return className
					}
				},
			)

const filterRemove =
	(classNames) =>
		classNames.filter(({ remove }) => !remove)

const mapBEMValues =
	(classNames, componentName) =>
		classNames.map(
			({ ignore, className }) => {
				if (ignore) {
					return className
				} else if (isEmpty(componentName)) {
					return className
				} else if (isEmpty(className)) {
					return componentName
				} else {
					return `${componentName}__${className}`
				}
			},
		)

const joinToString =
	(classNames) => (
		isEmpty(classNames) ?
			undefined :
			classNames.join("" "")
	)

export const createBEM =
	(componentName: <fim_suffix>) =>
		(...classNames) =>
			joinToString(
				mapBEMValues(
					filterRemove(
						normalizeInput(classNames),
					),
					componentName,
				),
			)

export interface BEMClassType {
	remove?: boolean,
	ignore?: boolean,
	className: string,
}

export type BEMInput =
	BEMClassType | string | boolean | undefined | null<fim_middle>",correct,718
string,string,cb14c7a279f215293358730312da69fac60347a7,"<fim_prefix>const isNull =
	(val): val is null =>
		val === null

const isString =
	(val): val is string =>
		typeof val === ""string""

const isBoolean =
	(val): val is boolean =>
		typeof val === ""boolean""

const isUndefined =
	(val): val is undefined =>
		val === undefined

const isUpperCase =
	(x) =>
		x === x.toUpperCase()

const isEmpty =
	(val) =>
		val.length === 0

const normalizeInput =
	(classNames) =>
		classNames
			.map(
				className => {
					if (isBoolean(className) || isNull(className) || isUndefined(className)) {
						return { className: """", remove: true }
					} else if (isString(className)) {
						if (isEmpty(className)) {
							return { className }
						} else if (isUpperCase(className.charAt(0))) {
							return { className, ignore: true }
						} else {
							return { className }
						}
					} else {
						return className
					}
				},
			)

const filterRemove =
	(classNames) =>
		classNames.filter(({ remove }) => !remove)

const mapBEMValues =
	(classNames, componentName: <fim_suffix>) =>
		classNames.map(
			({ ignore, className }) => {
				if (ignore) {
					return className
				} else if (isEmpty(componentName)) {
					return className
				} else if (isEmpty(className)) {
					return componentName
				} else {
					return `${componentName}__${className}`
				}
			},
		)

const joinToString =
	(classNames) => (
		isEmpty(classNames) ?
			undefined :
			classNames.join("" "")
	)

export const createBEM =
	(componentName) =>
		(...classNames) =>
			joinToString(
				mapBEMValues(
					filterRemove(
						normalizeInput(classNames),
					),
					componentName,
				),
			)

export interface BEMClassType {
	remove?: boolean,
	ignore?: boolean,
	className: string,
}

export type BEMInput =
	BEMClassType | string | boolean | undefined | null<fim_middle>",correct,720
string,string,cb14c7a279f215293358730312da69fac60347a7,"<fim_prefix>const isNull =
	(val): val is null =>
		val === null

const isString =
	(val): val is string =>
		typeof val === ""string""

const isBoolean =
	(val): val is boolean =>
		typeof val === ""boolean""

const isUndefined =
	(val): val is undefined =>
		val === undefined

const isUpperCase =
	(x: <fim_suffix>) =>
		x === x.toUpperCase()

const isEmpty =
	(val) =>
		val.length === 0

const normalizeInput =
	(classNames) =>
		classNames
			.map(
				className => {
					if (isBoolean(className) || isNull(className) || isUndefined(className)) {
						return { className: """", remove: true }
					} else if (isString(className)) {
						if (isEmpty(className)) {
							return { className }
						} else if (isUpperCase(className.charAt(0))) {
							return { className, ignore: true }
						} else {
							return { className }
						}
					} else {
						return className
					}
				},
			)

const filterRemove =
	(classNames) =>
		classNames.filter(({ remove }) => !remove)

const mapBEMValues =
	(classNames, componentName) =>
		classNames.map(
			({ ignore, className }) => {
				if (ignore) {
					return className
				} else if (isEmpty(componentName)) {
					return className
				} else if (isEmpty(className)) {
					return componentName
				} else {
					return `${componentName}__${className}`
				}
			},
		)

const joinToString =
	(classNames) => (
		isEmpty(classNames) ?
			undefined :
			classNames.join("" "")
	)

export const createBEM =
	(componentName) =>
		(...classNames) =>
			joinToString(
				mapBEMValues(
					filterRemove(
						normalizeInput(classNames),
					),
					componentName,
				),
			)

export interface BEMClassType {
	remove?: boolean,
	ignore?: boolean,
	className: string,
}

export type BEMInput =
	BEMClassType | string | boolean | undefined | null<fim_middle>",correct,727
this,this,b7b202e7b28242eca2cfc8f35a2dcfcc2d347d4f,"<fim_prefix>export interface JsonData {
  name: string;
  chars: Chars;
  rows: string[][];
}
export interface Chars {
  edge: string;
  top: string;
  bottom: string;
  corner: string;
}
class Table {
  public name: string;
  public rows: string[][];
  public chars: Chars;
  constructor(name) {
    this.name = name;
    this.rows = [];
    /**
     * @type {{edge:String, fill:String, top:String, bottom: String, corner:String}}
     * @default
     * edge: ""|"",
     * fill: ""─"",
     * top: ""."",
     * bottom: ""'"",
     * corner: ""+""
     *
     */
    this.chars = {
      edge: ""|"",
      top: ""."",
      bottom: ""'"",
      corner: ""+"",
    };
  }
  setSeparator({ edge, top, bottom, corner }) {
    this.chars.edge = edge || this.chars.edge;
    this.chars.top = top || this.chars.top;
    this.chars.bottom = bottom || this.chars.bottom;
    this.chars.corner = corner || this.chars.corner;
    return this;
  }
  setHeading(...headings) {
    this.rows.unshift(headings);
    return this;
  }
  addRow(...row): <fim_suffix> {
    this.rows.push(row);
    return this;
  }
  fromJSON(json) {
    this.name = json.name;
    this.chars = json.chars;
    this.rows = json.rows;
    return this;
  }
  /**
   *
   * @returns {JSON}
   */
  toJSON() {
    return {
      name: this.name,
      chars: this.chars,
      rows: this.rows,
    };
  }

  toString() {
    let table = ""\n"";
    const repeat = Math.max(
      ...this.rows.map((row) => {
        let longest = 0;
        row.forEach((element) => {
          longest += element.length;
        });
        return longest + 6;
      }),
      this.name.length + 6
    );
    table += this.chars.corner;
    table += this.chars.top.repeat(repeat);
    table += this.chars.corner;
    table += ""\n"";
    table += `${this.chars.edge} ${"" "".repeat(this.name.length / 4)} ${
      this.name
    } ${"" "".repeat(this.name.length / 4)} ${this.chars.edge}\n`;
    table += this.chars.corner;
    table += this.chars.bottom.repeat(repeat);
    table += this.chars.corner;
    table += ""\n"";
    this.rows.forEach((row) => {
      table += `${this.chars.edge}`;
      row.forEach((column) => {
        const spaceRepeat = Math.max(0, (this.name.length - column.length) / 4);

        table += "" "".repeat(spaceRepeat);
        table += `${column}`;
        table += "" "".repeat(spaceRepeat);
        table += this.chars.edge;
      });
      table += ""\n"";
      table += this.chars.corner;
      table += this.chars.bottom.repeat(repeat);
      table += this.chars.corner;
      table += ""\n"";
    });
    return table;
  }
}

export default Table;
<fim_middle>",correct,4074
this,this,b7b202e7b28242eca2cfc8f35a2dcfcc2d347d4f,"<fim_prefix>export interface JsonData {
  name: string;
  chars: Chars;
  rows: string[][];
}
export interface Chars {
  edge: string;
  top: string;
  bottom: string;
  corner: string;
}
class Table {
  public name: string;
  public rows: string[][];
  public chars: Chars;
  constructor(name) {
    this.name = name;
    this.rows = [];
    /**
     * @type {{edge:String, fill:String, top:String, bottom: String, corner:String}}
     * @default
     * edge: ""|"",
     * fill: ""─"",
     * top: ""."",
     * bottom: ""'"",
     * corner: ""+""
     *
     */
    this.chars = {
      edge: ""|"",
      top: ""."",
      bottom: ""'"",
      corner: ""+"",
    };
  }
  setSeparator({ edge, top, bottom, corner }) {
    this.chars.edge = edge || this.chars.edge;
    this.chars.top = top || this.chars.top;
    this.chars.bottom = bottom || this.chars.bottom;
    this.chars.corner = corner || this.chars.corner;
    return this;
  }
  setHeading(...headings): <fim_suffix> {
    this.rows.unshift(headings);
    return this;
  }
  addRow(...row) {
    this.rows.push(row);
    return this;
  }
  fromJSON(json) {
    this.name = json.name;
    this.chars = json.chars;
    this.rows = json.rows;
    return this;
  }
  /**
   *
   * @returns {JSON}
   */
  toJSON() {
    return {
      name: this.name,
      chars: this.chars,
      rows: this.rows,
    };
  }

  toString() {
    let table = ""\n"";
    const repeat = Math.max(
      ...this.rows.map((row) => {
        let longest = 0;
        row.forEach((element) => {
          longest += element.length;
        });
        return longest + 6;
      }),
      this.name.length + 6
    );
    table += this.chars.corner;
    table += this.chars.top.repeat(repeat);
    table += this.chars.corner;
    table += ""\n"";
    table += `${this.chars.edge} ${"" "".repeat(this.name.length / 4)} ${
      this.name
    } ${"" "".repeat(this.name.length / 4)} ${this.chars.edge}\n`;
    table += this.chars.corner;
    table += this.chars.bottom.repeat(repeat);
    table += this.chars.corner;
    table += ""\n"";
    this.rows.forEach((row) => {
      table += `${this.chars.edge}`;
      row.forEach((column) => {
        const spaceRepeat = Math.max(0, (this.name.length - column.length) / 4);

        table += "" "".repeat(spaceRepeat);
        table += `${column}`;
        table += "" "".repeat(spaceRepeat);
        table += this.chars.edge;
      });
      table += ""\n"";
      table += this.chars.corner;
      table += this.chars.bottom.repeat(repeat);
      table += this.chars.corner;
      table += ""\n"";
    });
    return table;
  }
}

export default Table;
<fim_middle>",correct,4076
this,this,b7b202e7b28242eca2cfc8f35a2dcfcc2d347d4f,"<fim_prefix>export interface JsonData {
  name: string;
  chars: Chars;
  rows: string[][];
}
export interface Chars {
  edge: string;
  top: string;
  bottom: string;
  corner: string;
}
class Table {
  public name: string;
  public rows: string[][];
  public chars: Chars;
  constructor(name) {
    this.name = name;
    this.rows = [];
    /**
     * @type {{edge:String, fill:String, top:String, bottom: String, corner:String}}
     * @default
     * edge: ""|"",
     * fill: ""─"",
     * top: ""."",
     * bottom: ""'"",
     * corner: ""+""
     *
     */
    this.chars = {
      edge: ""|"",
      top: ""."",
      bottom: ""'"",
      corner: ""+"",
    };
  }
  setSeparator({ edge, top, bottom, corner }): <fim_suffix> {
    this.chars.edge = edge || this.chars.edge;
    this.chars.top = top || this.chars.top;
    this.chars.bottom = bottom || this.chars.bottom;
    this.chars.corner = corner || this.chars.corner;
    return this;
  }
  setHeading(...headings) {
    this.rows.unshift(headings);
    return this;
  }
  addRow(...row) {
    this.rows.push(row);
    return this;
  }
  fromJSON(json) {
    this.name = json.name;
    this.chars = json.chars;
    this.rows = json.rows;
    return this;
  }
  /**
   *
   * @returns {JSON}
   */
  toJSON() {
    return {
      name: this.name,
      chars: this.chars,
      rows: this.rows,
    };
  }

  toString() {
    let table = ""\n"";
    const repeat = Math.max(
      ...this.rows.map((row) => {
        let longest = 0;
        row.forEach((element) => {
          longest += element.length;
        });
        return longest + 6;
      }),
      this.name.length + 6
    );
    table += this.chars.corner;
    table += this.chars.top.repeat(repeat);
    table += this.chars.corner;
    table += ""\n"";
    table += `${this.chars.edge} ${"" "".repeat(this.name.length / 4)} ${
      this.name
    } ${"" "".repeat(this.name.length / 4)} ${this.chars.edge}\n`;
    table += this.chars.corner;
    table += this.chars.bottom.repeat(repeat);
    table += this.chars.corner;
    table += ""\n"";
    this.rows.forEach((row) => {
      table += `${this.chars.edge}`;
      row.forEach((column) => {
        const spaceRepeat = Math.max(0, (this.name.length - column.length) / 4);

        table += "" "".repeat(spaceRepeat);
        table += `${column}`;
        table += "" "".repeat(spaceRepeat);
        table += this.chars.edge;
      });
      table += ""\n"";
      table += this.chars.corner;
      table += this.chars.bottom.repeat(repeat);
      table += this.chars.corner;
      table += ""\n"";
    });
    return table;
  }
}

export default Table;
<fim_middle>",correct,4078
unknown,unknown,334799763d7d1337e3c485d09fc1b22e9544bfe9,"<fim_prefix>const MAGIC_DATA_TOKEN = ""__context_container__"";
const VERSION = ""1.0.0"";

/**
 * All the data of our context is stored inside a property with a
 * long name that starts and ends with two underscores.
 * This is to indicate that the context data should never be accessed directly.
 */
export type Context = { [MAGIC_DATA_TOKEN]: unknown };

/**
 * We deliberately did not make the key of type 'string', to encourage the
 * use of the createKey. The createKey function ensures a better naming
 * convention by splitting the key into 3 parts: namespace, hook name, and
 * a name for the state.
 */
export type Key = unknown;

/**
 * Holds the created keys to warn about duplications
 */
const usedKeys = new Set<Key>();

/**
 * Use this function to create a distinguishable
 * key for a contextual state.
 */
export const createKey = (
  namespace,
  hook,
  name
) => {
  const key = `${namespace}/${hook}/${name}`;
  if (usedKeys.has(key)) {
    throw new Error(
      `The context key '${key}' is already created somewhere else`
    );
  }
  usedKeys.add(key);
  return key;
};

/**
 * Checks if the provided value is a valid context object.
 */
export const isContext = (value: <fim_suffix>) => {
  return !!(value as Context)[MAGIC_DATA_TOKEN];
};

/**
 * Major hook that can be used to:
 * - create a new context
 * - create a fork of a context
 * - get or initialize a contextual state
 */
export const useContext = (context?) => {
  let map: Map<Key, unknown>;

  if (context) {
    map = context[MAGIC_DATA_TOKEN] as Map<Key, unknown>;
    if (!map) {
      throw ""An invalid context object has been provided"";
    }
  } else {
    map = new Map();
    context = {
      [MAGIC_DATA_TOKEN]: map,
      __context_version__: VERSION,
    } as Context;
  }

  return {
    /**
     * The current context object.
     */
    context,

    /**
     * Returns TRUE if the specified key is not used in the context yet.
     */
    isAvailable(key) {
      return map.has(key);
    },

    /**
     * Accesses the contextual state related to the specified key.
     * If the state does not exist yet, the result of the initializer
     * will be set and returned.
     */
    use<T>(key, initializer?) {
      if (map.has(key)) {
        return map.get(key) as T;
      }

      if (!initializer) {
        throw `No context data available for '${key}'`;
      }

      const value = initializer();
      map.set(key, value);
      return value;
    },

    /**
     * Makes a fork of the current context.
     * The forked context allows you to keep access to the states
     * of the current context, but newly initialized states, created
     * in the forked context, are not seen by hooks using the current context.
     */
    fork() {
      return {
        ...context,
        [MAGIC_DATA_TOKEN]: new Map(map),
      } as Context;
    },
  };
};
<fim_middle>",correct,205
unknown,unknown,8dd4eba467cc4f8c283713bdfc23d3b71e87f31d,"<fim_prefix>export type BasePostMessageCallbackProps<T> = {
  onMessage?: (message) => void
  onInvalidMessageError?: (message, error) => void
}

// This is an internal error. Thrown when we are decoding a post message's
// metadata and we encourntered a missing field or an invalid value. This
// likely means there has been a change to the definition of a post message
// that we do not know about.
export class PostMessageFieldDecodeError extends Error {
  public messageType: string
  public field: string
  public expectedType: TypeDef
  public gotValue: unknown

  constructor(messageType, field, expectedType, gotValue: <fim_suffix>) {
    super(`Unable to decode '${field}' from '${messageType}'`)

    this.messageType = messageType
    this.field = field
    this.expectedType = expectedType
    this.gotValue = gotValue

    Object.setPrototypeOf(this, PostMessageFieldDecodeError.prototype)
  }
}

// This is an internal error. Thrown when we get a post message we don't konw
// about. This likely means there is a new post message that this package needs
// to define.
export class PostMessageUnknownTypeError extends Error {
  public postMessageType: string

  constructor(postMessageType) {
    super(`Unknown post message: ${postMessageType}`)

    this.postMessageType = postMessageType

    Object.setPrototypeOf(this, PostMessageUnknownTypeError.prototype)
  }
}

export type MessageEventData = {
  mx?: boolean
  metadata?: Metadata
  type?: string
}

export type Value = string | number
export type NestedValue = Record<string, Value>
export type TypeDef = string | Array<string> | Record<string, string>
export type Metadata = Record<string, Value | NestedValue>

export function assertMessageProp(
  container,
  postMessageType,
  field,
  expectedType,
) {
  const value = container[field]

  const valueIsDefined = typeof value !== ""undefined""
  const valueIsString = typeof value === ""string""
  const valueIsNumber = typeof value === ""number""
  const valueIsObject = typeof value === ""object"" && !Array.isArray(value)

  const typeIsString = expectedType === ""string""
  const typeIsNumber = expectedType === ""number""
  const typeIsArray = expectedType instanceof Array
  const typeIsObject = typeof expectedType === ""object"" && !Array.isArray(expectedType)

  if (!valueIsDefined) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsString && !valueIsString) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsNumber && !valueIsNumber) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsArray && !(valueIsString && expectedType.includes(value))) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && !valueIsObject) {
    throw new PostMessageFieldDecodeError(postMessageType, field, expectedType, value)
  } else if (typeIsObject && valueIsObject) {
    Object.keys(expectedType).forEach((field) => {
      assertMessageProp(value, postMessageType, field, expectedType[field])
    })
  }
}
<fim_middle>",correct,2990
unknown,unknown,b898174dc9208306ba4726075f110ac026c56fe6,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// This file contains generic TypeScript types, and predicate methods
type VoidReturn = void | undefined;

export type VoidCallback<Args extends unknown[] = []> = Args extends []
	? ((arg?) => VoidReturn)
	: ((...args) => VoidReturn);

export type DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};

export type AsyncVoidCallback<Args extends unknown[] = []> = AsyncCallback<
	VoidReturn,
	Args
>;

export type AsyncCallback<Return, Args extends unknown[] = []> = Args extends []
	? (() => Return | Promise<Return>)
	: ((...args) => Return | Promise<Return>);

export type ErrorCallback<Err extends Error = Error> = (err) => void;

export type MapKey<T> = T extends Map<infer K, unknown> ? K : never;

export type MapValue<T> = T extends Map<unknown, infer V> ? V : never;

export type SetValue<T> = T extends Set<infer V> ? V : never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export type UnionToIntersection<U> = (U extends any ? (k) => void : never) extends ((
	k,
) => void)
	? I
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
type ClassConstructorParams<T> = T extends {
	new (
		...args
	): any;
}
	? R
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export interface Class<T, Args extends any[] = ClassConstructorParams<T>> {
	new (
		...args
	): T;
	prototype: T;
}

export type Dict<T> = Record<string, T>;

export type RequiredProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]-?: NonNullable<Obj[Key]>
};

export type OptionalProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]?: Obj[Key]
};

export type TaggedTemplateFunction<Ret, Sub> = (
	strs,
	...substitutions
) => Ret;

// Turn a type that contains interfaces into regular objects
export type InterfaceToObject<T> = T extends {}
	? {[K in keyof T]: InterfaceToObject<T[K]>}
	: T;

export type UnknownObject = Dict<unknown>;

export type UnknownFunction = (...args) => unknown;

export function isObject(obj): obj is UnknownObject {
	return typeof obj === ""object"" && obj !== null && !Array.isArray(obj);
}

export function isPlainObject(obj): obj is UnknownObject {
	// Weird duck typing for cross-realm objects
	return (
		isObject(obj) &&
		obj.constructor !== undefined &&
		obj.constructor.name === ""Object""
	);
}

export function isIterable(obj: <fim_suffix>): obj is Iterable<unknown> {
	if (typeof obj === ""object"" && obj != null) {
		// @ts-ignore
		return typeof obj[Symbol.iterator] === ""function"";
	} else {
		return false;
	}
}

// TypeScript has awful behaviour where it treats optional properties and undefined values as the same
// eg. https://www.typescriptlang.org/play/index.html?ssl=3&ssc=1&pln=1&pc=1#code/C4TwDgpgBAChBOBnA9gOygXigbwFBQKgDMBLJYAOQEMBbCALikWHhNQHMBufQgGyubU6jZqw7cAvt1wBjNMyhgq8YCSq84SNIzyEo-QbQgB+ESzbsANLgmYcPAgcpHGAV1QATCKVQQP1qVxZeWBFBBRURk0Iu11CUnIhBigAIgBlCAAjAVUqVBTrPSckxhSKdxAqAocoADp6pRU1DXC0AOkAeg79HKSoEkQody8fPyhM11CAFTSoD2QIRFQAclCEeGR4XEgtVFrio0wMLGHvNj9OIA
// https://github.com/microsoft/TypeScript/issues/13195
// This means that places where we expect to receive a value when object spreading in a partial object
// can actually have undefined values!
export function mergeObjects<A extends object>(
	a,
	b,
) {
	if (b === undefined) {
		return a;
	}

	const newObj: A = {
		...a,
		...b,
	};

	// If b contains undefined properties then use the value from A
	for (const key in b) {
		if (b[key] === undefined) {
			// @ts-ignore
			newObj[key] = a[key];
		}
	}

	return newObj;
}

export function equalArray<A extends unknown[], B extends unknown[]>(
	a,
	b,
): a is B {
	if (a.length !== b.length) {
		return false;
	}

	if (a === b) {
		return true;
	}

	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

// Check if a value is instance of a class, disallowing inheritance
// rome-ignore lint/ts/noExplicitAny: Necessary
export function isSafeInstanceof<ClassType extends new (
	...args
) => any>(inst, Class): inst is InstanceType<ClassType> {
	return inst instanceof Class && inst.constructor === Class;
}
<fim_middle>",correct,3221
unknown,unknown,b898174dc9208306ba4726075f110ac026c56fe6,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
// This file contains generic TypeScript types, and predicate methods
type VoidReturn = void | undefined;

export type VoidCallback<Args extends unknown[] = []> = Args extends []
	? ((arg?) => VoidReturn)
	: ((...args) => VoidReturn);

export type DeepPartial<T> = {[P in keyof T]?: DeepPartial<T[P]>};

export type AsyncVoidCallback<Args extends unknown[] = []> = AsyncCallback<
	VoidReturn,
	Args
>;

export type AsyncCallback<Return, Args extends unknown[] = []> = Args extends []
	? (() => Return | Promise<Return>)
	: ((...args) => Return | Promise<Return>);

export type ErrorCallback<Err extends Error = Error> = (err) => void;

export type MapKey<T> = T extends Map<infer K, unknown> ? K : never;

export type MapValue<T> = T extends Map<unknown, infer V> ? V : never;

export type SetValue<T> = T extends Set<infer V> ? V : never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export type UnionToIntersection<U> = (U extends any ? (k) => void : never) extends ((
	k,
) => void)
	? I
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
type ClassConstructorParams<T> = T extends {
	new (
		...args
	): any;
}
	? R
	: never;

// rome-ignore lint/ts/noExplicitAny: future cleanup
export interface Class<T, Args extends any[] = ClassConstructorParams<T>> {
	new (
		...args
	): T;
	prototype: T;
}

export type Dict<T> = Record<string, T>;

export type RequiredProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]-?: NonNullable<Obj[Key]>
};

export type OptionalProps<Obj, Keys extends keyof Obj> = Omit<Obj, Keys> & {
	[Key in Keys]?: Obj[Key]
};

export type TaggedTemplateFunction<Ret, Sub> = (
	strs,
	...substitutions
) => Ret;

// Turn a type that contains interfaces into regular objects
export type InterfaceToObject<T> = T extends {}
	? {[K in keyof T]: InterfaceToObject<T[K]>}
	: T;

export type UnknownObject = Dict<unknown>;

export type UnknownFunction = (...args) => unknown;

export function isObject(obj): obj is UnknownObject {
	return typeof obj === ""object"" && obj !== null && !Array.isArray(obj);
}

export function isPlainObject(obj: <fim_suffix>): obj is UnknownObject {
	// Weird duck typing for cross-realm objects
	return (
		isObject(obj) &&
		obj.constructor !== undefined &&
		obj.constructor.name === ""Object""
	);
}

export function isIterable(obj): obj is Iterable<unknown> {
	if (typeof obj === ""object"" && obj != null) {
		// @ts-ignore
		return typeof obj[Symbol.iterator] === ""function"";
	} else {
		return false;
	}
}

// TypeScript has awful behaviour where it treats optional properties and undefined values as the same
// eg. https://www.typescriptlang.org/play/index.html?ssl=3&ssc=1&pln=1&pc=1#code/C4TwDgpgBAChBOBnA9gOygXigbwFBQKgDMBLJYAOQEMBbCALikWHhNQHMBufQgGyubU6jZqw7cAvt1wBjNMyhgq8YCSq84SNIzyEo-QbQgB+ESzbsANLgmYcPAgcpHGAV1QATCKVQQP1qVxZeWBFBBRURk0Iu11CUnIhBigAIgBlCAAjAVUqVBTrPSckxhSKdxAqAocoADp6pRU1DXC0AOkAeg79HKSoEkQody8fPyhM11CAFTSoD2QIRFQAclCEeGR4XEgtVFrio0wMLGHvNj9OIA
// https://github.com/microsoft/TypeScript/issues/13195
// This means that places where we expect to receive a value when object spreading in a partial object
// can actually have undefined values!
export function mergeObjects<A extends object>(
	a,
	b,
) {
	if (b === undefined) {
		return a;
	}

	const newObj: A = {
		...a,
		...b,
	};

	// If b contains undefined properties then use the value from A
	for (const key in b) {
		if (b[key] === undefined) {
			// @ts-ignore
			newObj[key] = a[key];
		}
	}

	return newObj;
}

export function equalArray<A extends unknown[], B extends unknown[]>(
	a,
	b,
): a is B {
	if (a.length !== b.length) {
		return false;
	}

	if (a === b) {
		return true;
	}

	for (let i = 0; i < a.length; i++) {
		if (a[i] !== b[i]) {
			return false;
		}
	}

	return true;
}

// Check if a value is instance of a class, disallowing inheritance
// rome-ignore lint/ts/noExplicitAny: Necessary
export function isSafeInstanceof<ClassType extends new (
	...args
) => any>(inst, Class): inst is InstanceType<ClassType> {
	return inst instanceof Class && inst.constructor === Class;
}
<fim_middle>",correct,3222
unknown,unknown,9df566c660a96ca1ea9c774ead4166eff4ea2801,"<fim_prefix>export interface AsyncPushCallbacks<T> {
  next: (value) => void;
  done: () => void;
  error: (err: <fim_suffix>) => void;
}

export function createAsyncIterable<T = unknown>(
  listener
) {
  let done = false;
  let error: unknown | null = null;

  const pushQueue: T[] = [];
  const pullQueue: Array<
    [
      (x) => void,
      (err) => void
    ]
  > = [];

  return {
    [Symbol.asyncIterator]() {
      listener({
        next: (value) => {
          if (done || error) return;
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[0]({ value, done: false });
          } else {
            pushQueue.push(value);
          }
        },
        error: (err) => {
          if (done || error) return;
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[1](err);
          }
          error = err;
        },
        done: () => {
          if (pullQueue.length > 0) {
            pullQueue.shift()?.[0]({ value: undefined, done: true });
          }
          done = true;
        },
      });

      return {
        next() {
          return new Promise<{ value: T | undefined; done: boolean }>(
            (resolve, reject) => {
              if (pushQueue.length > 0) {
                resolve({ value: pushQueue.shift(), done: false });
              } else if (done) {
                resolve({ value: undefined, done: true });
              } else if (error) {
                reject(error);
              } else {
                pullQueue.push([resolve, reject]);
              }
            }
          );
        },
      };
    },
  } as AsyncIterable<T>;
}
<fim_middle>",correct,4185
unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error: <fim_suffix>) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4414
unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?: <fim_suffix>) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4416
unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?: <fim_suffix>) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4417
unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?: <fim_suffix>) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4418
unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?: <fim_suffix>) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4419
unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?: <fim_suffix>) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4420
unknown,unknown,296932523e3b4463c9162828391a37d94cb76f5d,"<fim_prefix>export type ErrorResponse = {
  message: string;
  dev?: unknown;
};

export class HTTPException extends Error {
  readonly statusCode: number;
  readonly error?: unknown;

  constructor(message, statusCode, error?: <fim_suffix>) {
    super(message);

    this.error = typeof error !== 'undefined' ? error : '';
    this.statusCode = statusCode;
  }

  public toResponse() {
    const obj: ErrorResponse = { message: this.message };
    if (this.error) {
      obj.dev = this.error;
    }
    return obj;
  }

  public static notFoundErr(error?) {
    return new HTTPException(
      'The requested resource could not be found.',
      404,
      error
    );
  }

  public static methodErr(error?) {
    return new HTTPException(
      'The requested action is made using an illegal method.',
      405,
      error
    );
  }

  public static malformedErr(error?) {
    return new HTTPException(
      'The requested action could not be exercised due to malformed syntax.',
      400,
      error
    );
  }

  public static internalErr(error?) {
    return new HTTPException(
      'Something went wrong. Please try again later.',
      500,
      error
    );
  }

  public static unprocessableErr(error?) {
    return new HTTPException(
      'The request was well-formed but not honored.' +
        ' Perhaps the action trying to be performed has already been done?',
      422,
      error
    );
  }

  public static authErr(error?) {
    return new HTTPException(
      'The provided credentials are either invalid or has' +
        ' insufficient privilege to perform the requested action.',
      401,
      error
    );
  }

  public static getError(error) {
    const isHttpException = error instanceof HTTPException;
    const isError = error instanceof Error;
    const result: ErrorResponse & { statusCode: number } = {
      statusCode: isHttpException ? error.statusCode : 500,
      message: 'Something went wrong. Please try again.',
    };
    if (isHttpException) {
      const res = error.toResponse();
      result.message = res.message;
      if (res.dev) {
        result.dev = res.dev;
      }
    } else if (isError) {
      result.message = error.message;
    }
    return result;
  }
}
<fim_middle>",correct,4421
unknown,unknown,827363613ce8b25b320df2a9f97559bc4db11fc5,"<fim_prefix>/* eslint-disable */
// @ts-nocheck
/*
* This file is a generated Typescript file for GRPC Gateway, DO NOT MODIFY
*/

/**
 * base64 encoder and decoder
 * Copied and adapted from https://github.com/protobufjs/protobuf.js/blob/master/lib/base64/index.js
 */
// Base64 encoding table
const b64 = new Array(64);

// Base64 decoding table
const s64 = new Array(123);

// 65..90, 97..122, 48..57, 43, 47
for (let i = 0; i < 64;)
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;

export function b64Encode(buffer, start, end) {
	let parts: string[] = null;
  const chunk = [];
  let i = 0, // output index
    j = 0, // goto index
    t;     // temporary
  while (start < end) {
    const b = buffer[start++];
    switch (j) {
      case 0:
        chunk[i++] = b64[b >> 2];
        t = (b & 3) << 4;
        j = 1;
        break;
      case 1:
        chunk[i++] = b64[t | b >> 4];
        t = (b & 15) << 2;
        j = 2;
        break;
      case 2:
        chunk[i++] = b64[t | b >> 6];
        chunk[i++] = b64[b & 63];
        j = 0;
        break;
    }
    if (i > 8191) {
      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
      i = 0;
    }
  }
  if (j) {
    chunk[i++] = b64[t];
    chunk[i++] = 61;
    if (j === 1)
      chunk[i++] = 61;
  }
  if (parts) {
    if (i)
      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
    return parts.join("""");
  }
  return String.fromCharCode.apply(String, chunk.slice(0, i));
}

const invalidEncoding = ""invalid encoding"";

export function b64Decode(s) {
	const buffer = [];
	let offset = 0;
  let j = 0, // goto index
      t;     // temporary
  for (let i = 0; i < s.length;) {
    let c = s.charCodeAt(i++);
    if (c === 61 && j > 1)
        break;
    if ((c = s64[c]) === undefined)
        throw Error(invalidEncoding);
    switch (j) {
      case 0:
        t = c;
        j = 1;
        break;
      case 1:
        buffer[offset++] = t << 2 | (c & 48) >> 4;
        t = c;
        j = 2;
        break;
      case 2:
        buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
        t = c;
        j = 3;
        break;
      case 3:
        buffer[offset++] = (t & 3) << 6 | c;
        j = 0;
        break;
    }
  }
  if (j === 1)
      throw Error(invalidEncoding);
  return new Uint8Array(buffer);
}

function b64Test(s) {
	return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s);
}

export interface InitReq extends RequestInit {
  pathPrefix?: string
}

export function replacer(key, value) {
  if(value && value.constructor === Uint8Array) {
    return b64Encode(value, 0, value.length);
  }

  return value;
}

export function fetchReq<I, O>(path, init?) {
  const {pathPrefix, ...req} = init || {}

  const url = pathPrefix ? `${pathPrefix}${path}` : path

  return fetch(url, req).then(r => r.json().then((body) => {
    if (!r.ok) { throw body; }
    return body;
  })) as Promise<O>
}

// NotifyStreamEntityArrival is a callback that will be called on streaming entity arrival
export type NotifyStreamEntityArrival<T> = (resp) => void

/**
 * fetchStreamingRequest is able to handle grpc-gateway server side streaming call
 * it takes NotifyStreamEntityArrival that lets users respond to entity arrival during the call
 * all entities will be returned as an array after the call finishes.
 **/
export async function fetchStreamingRequest<S, R>(path, callback?, init?) {
  const {pathPrefix, ...req} = init || {}
  const url = pathPrefix ?`${pathPrefix}${path}` : path
  const result = await fetch(url, req)
  // needs to use the .ok to check the status of HTTP status code
  // http other than 200 will not throw an error, instead the .ok will become false.
  // see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#
  if (!result.ok) {
    const resp = await result.json()
    const errMsg = resp.error && resp.error.message ? resp.error.message : """"
    throw new Error(errMsg)
  }

  if (!result.body) {
    throw new Error(""response doesnt have a body"")
  }

  await result.body
    .pipeThrough(new TextDecoderStream())
    .pipeThrough<R>(getNewLineDelimitedJSONDecodingStream<R>())
    .pipeTo(getNotifyEntityArrivalSink((e) => {
      if (callback) {
        callback(e)
      }
    }))

  // wait for the streaming to finish and return the success respond
  return
}

/**
 * JSONStringStreamController represents the transform controller that's able to transform the incoming
 * new line delimited json content stream into entities and able to push the entity to the down stream
 */
interface JSONStringStreamController<T> extends TransformStreamDefaultController {
  buf?: string
  pos?: number
  enqueue: (s) => void
}

/**
 * getNewLineDelimitedJSONDecodingStream returns a TransformStream that's able to handle new line delimited json stream content into parsed entities
 */
function getNewLineDelimitedJSONDecodingStream<T>() {
  return new TransformStream({
    start(controller) {
      controller.buf = ''
      controller.pos = 0
    },

    transform(chunk, controller) {
      if (controller.buf === undefined) {
        controller.buf = ''
      }
      if (controller.pos === undefined) {
        controller.pos = 0
      }
      controller.buf += chunk
      while (controller.pos < controller.buf.length) {
        if (controller.buf[controller.pos] === '\n') {
          const line = controller.buf.substring(0, controller.pos)
          const response = JSON.parse(line)
          controller.enqueue(response.result)
          controller.buf = controller.buf.substring(controller.pos + 1)
          controller.pos = 0
        } else {
          ++controller.pos
        }
      }
    }
  })

}

/**
 * getNotifyEntityArrivalSink takes the NotifyStreamEntityArrival callback and return
 * a sink that will call the callback on entity arrival
 * @param notifyCallback
 */
function getNotifyEntityArrivalSink<T>(notifyCallback) {
  return new WritableStream<T>({
    write(entity) {
      notifyCallback(entity)
    }
  })
}

type Primitive = string | boolean | number;
type RequestPayload = Record<string, unknown>;
type FlattenedRequestPayload = Record<string, Primitive | Array<Primitive>>;

/**
 * Checks if given value is a plain object
 * Logic copied and adapted from below source: 
 * https://github.com/char0n/ramda-adjunct/blob/master/src/isPlainObj.js
 * @param  {unknown} value
 * @return {boolean}
 */
function isPlainObject(value: <fim_suffix>) {
  const isObject =
    Object.prototype.toString.call(value).slice(8, -1) === ""Object"";
  const isObjLike = value !== null && isObject;

  if (!isObjLike || !isObject) {
    return false;
  }

  const proto = Object.getPrototypeOf(value);

  const hasObjectConstructor =
    typeof proto === ""object"" &&
    proto.constructor === Object.prototype.constructor;

  return hasObjectConstructor;
}

/**
 * Checks if given value is of a primitive type
 * @param  {unknown} value
 * @return {boolean}
 */
function isPrimitive(value) {
  return [""string"", ""number"", ""boolean""].some(t => typeof value === t);
}

/**
 * Checks if given primitive is zero-value
 * @param  {Primitive} value
 * @return {boolean}
 */
function isZeroValuePrimitive(value) {
  return value === false || value === 0 || value === """";
}

/**
 * Flattens a deeply nested request payload and returns an object
 * with only primitive values and non-empty array of primitive values
 * as per https://github.com/googleapis/googleapis/blob/master/google/api/http.proto
 * @param  {RequestPayload} requestPayload
 * @param  {String} path
 * @return {FlattenedRequestPayload>}
 */
function flattenRequestPayload<T extends RequestPayload>(
  requestPayload,
  path = """"
) {
  return Object.keys(requestPayload).reduce(
    (acc, key) => {
      const value = requestPayload[key];
      const newPath = path ? [path, key].join(""."") : key;

      const isNonEmptyPrimitiveArray =
        Array.isArray(value) &&
        value.every(v => isPrimitive(v)) &&
        value.length > 0;

      const isNonZeroValuePrimitive =
        isPrimitive(value) && !isZeroValuePrimitive(value as Primitive);

      let objectToMerge = {};

      if (isPlainObject(value)) {
        objectToMerge = flattenRequestPayload(value as RequestPayload, newPath);
      } else if (isNonZeroValuePrimitive || isNonEmptyPrimitiveArray) {
        objectToMerge = { [newPath]: value };
      }

      return { ...acc, ...objectToMerge };
    },
    {} as T
  ) as FlattenedRequestPayload;
}

/**
 * Renders a deeply nested request payload into a string of URL search
 * parameters by first flattening the request payload and then removing keys
 * which are already present in the URL path.
 * @param  {RequestPayload} requestPayload
 * @param  {string[]} urlPathParams
 * @return {string}
 */
export function renderURLSearchParams<T extends RequestPayload>(
  requestPayload,
  urlPathParams = []
) {
  const flattenedRequestPayload = flattenRequestPayload(requestPayload);

  const urlSearchParams = Object.keys(flattenedRequestPayload).reduce(
    (acc, key) => {
      // key should not be present in the url path as a parameter
      const value = flattenedRequestPayload[key];
      if (urlPathParams.find(f => f === key)) {
        return acc;
      }
      return Array.isArray(value)
        ? [...acc, ...value.map(m => [key, m.toString()])]
        : (acc = [...acc, [key, value.toString()]]);
    },
    [] as string[][]
  );

  return new URLSearchParams(urlSearchParams).toString();
}<fim_middle>",correct,4884
unknown,unknown,47dc91afa9f261374fcc8a999842718632fdfb4f,"<fim_prefix>export class ParseError extends Error {
  value: unknown;
  config: ParserConfig<any>;
  reason?: unknown;

  constructor(message, value, config, reason?) {
    let errorMessage = message;
    if (reason != null) {
      errorMessage += `\nReason:\n${String(reason)}`;
    }
    errorMessage += `\nValue:\n${JSON.stringify(value, null, 2)}`;
    super(errorMessage);
    this.value = value;
    this.config = config;
    this.reason = reason;
  }
}

export interface ParserConfig<T, TPreTransform = T> {
  /**
   * Parses the type using either a primitive value compatible with typeof
   * or a type guard function.
   */
  type: string | ((value) => value is TPreTransform);
  /** If set to true, null or undefined values will be parsed without error. */
  optional?: true;
  /**
   * Parser or a record of parsers for the enumerable fields of an object.
   *
   * If passed a record of parsers, a strict set of fields will be parsed using
   * a specific parse config for each field.
   *
   * If passed a single parser, an arbitrary set of fields will be parsed using
   * the same parse config for each field.
   *
   * If the value is not an object, this config field is ignored.
   */
  fields?:
    | {
        [K in keyof TPreTransform]: Parser<TPreTransform[K], any>;
      }
    | Parser<TPreTransform[keyof TPreTransform], any>;
  /**
   * Parser for the elements of a list.
   *
   * If the value is not an array, this config field is ignored.
   */
  elements?: TPreTransform extends unknown[] ? Parser<TPreTransform[number], any> : never;
  /**
   * Transforms the value when parsing using the provided function.
   *
   * If field or element parse configs include transforms, those transforms
   * will be applied prior to the overall transform function.
   */
  transform?: (value) => T;
}

export class Parser<T, TPreTransform = T> {
  config: ParserConfig<T, TPreTransform>;

  constructor(
    configypeof config === ""function"" ? config(this) : config;
  }

  /**
   * Parses a value using the provided config, and throws a ParseError if the
   * value could not be parsed.
   */
  parse(value) {
    const { optional, type, fields, elements, transform } = this.config;

    if (value == null) {
      if (optional != true) {
        throw new ParseError(""Required value was null, undefined, or unset"", value, this.config);
      } else {
        return value as any as T;
      }
    }

    if (typeof type === ""string"" && typeof value !== type) {
      throw new ParseError(""Value was not the expected type"", value, this.config);
    }

    if (typeof type === ""function"" && !type(value)) {
      throw new ParseError(
        ""Value was not the expected type; value did not pass type guard"",
        value,
        this.config
      );
    }

    let parsedPreTransform: any;

    if (elements && Array.isArray(value)) {
      parsedPreTransform = value.map((element) => elements.parse(element));
    } else if (fields && typeof value === ""object"" && !Array.isArray(value)) {
      parsedPreTransform = {};
      if (fields instanceof Parser) {
        for (const key in value) {
          parsedPreTransform[key] = fields.parse((value as any)[key]);
        }
      } else {
        for (const key in fields) {
          parsedPreTransform[key] = fields[key].parse((value as any)[key]);
        }
        for (const key in value) {
          if (!(key in fields)) {
            throw new ParseError(""Unexpected field in value"", value, this.config);
          }
        }
      }
    } else {
      parsedPreTransform = value;
    }

    if (transform) {
      try {
        return transform(parsedPreTransform as TPreTransform);
      } catch (transformErr) {
        throw new ParseError(
          ""Could not transform value while parsing"",
          parsedPreTransform,
          this.config,
          transformErr
        );
      }
    }

    return parsedPreTransform as T;
  }
}

export const stringParser = new Parser<string>({ type: ""string"" });
export const numberParser = new Parser<number>({ type: ""number"" });
export const booleanParser = new Parser<boolean>({ type: ""boolean"" });
export const unknownRecordParser = new Parser<Record<string, unknown>>({
  type: (value: <fim_suffix>): value is Record<string, unknown> =>
    typeof value === ""object"" &&
    value != null &&
    Object.keys(value).every((key) => typeof key === ""string""),
});
export const dateStringParser = new Parser<Date, string>({
  type: ""string"",
  transform(dateString) {
    const parsedDate = new Date(dateString);
    if (parsedDate.toString() === ""Invalid Date"") {
      throw new Error(""Invalid date string"");
    }
    return parsedDate;
  },
});
export function makeEnumParser<TEnumType, TEnumObj extends Record<string, any>>(enumObj) {
  return new Parser<TEnumType>({
    type: (value): value is TEnumType => Object.values(enumObj).includes(value),
  });
}
<fim_middle>",correct,5291
unknown,unknown,47dc91afa9f261374fcc8a999842718632fdfb4f,"<fim_prefix>export class ParseError extends Error {
  value: unknown;
  config: ParserConfig<any>;
  reason?: unknown;

  constructor(message, value, config, reason?: <fim_suffix>) {
    let errorMessage = message;
    if (reason != null) {
      errorMessage += `\nReason:\n${String(reason)}`;
    }
    errorMessage += `\nValue:\n${JSON.stringify(value, null, 2)}`;
    super(errorMessage);
    this.value = value;
    this.config = config;
    this.reason = reason;
  }
}

export interface ParserConfig<T, TPreTransform = T> {
  /**
   * Parses the type using either a primitive value compatible with typeof
   * or a type guard function.
   */
  type: string | ((value) => value is TPreTransform);
  /** If set to true, null or undefined values will be parsed without error. */
  optional?: true;
  /**
   * Parser or a record of parsers for the enumerable fields of an object.
   *
   * If passed a record of parsers, a strict set of fields will be parsed using
   * a specific parse config for each field.
   *
   * If passed a single parser, an arbitrary set of fields will be parsed using
   * the same parse config for each field.
   *
   * If the value is not an object, this config field is ignored.
   */
  fields?:
    | {
        [K in keyof TPreTransform]: Parser<TPreTransform[K], any>;
      }
    | Parser<TPreTransform[keyof TPreTransform], any>;
  /**
   * Parser for the elements of a list.
   *
   * If the value is not an array, this config field is ignored.
   */
  elements?: TPreTransform extends unknown[] ? Parser<TPreTransform[number], any> : never;
  /**
   * Transforms the value when parsing using the provided function.
   *
   * If field or element parse configs include transforms, those transforms
   * will be applied prior to the overall transform function.
   */
  transform?: (value) => T;
}

export class Parser<T, TPreTransform = T> {
  config: ParserConfig<T, TPreTransform>;

  constructor(
    configypeof config === ""function"" ? config(this) : config;
  }

  /**
   * Parses a value using the provided config, and throws a ParseError if the
   * value could not be parsed.
   */
  parse(value) {
    const { optional, type, fields, elements, transform } = this.config;

    if (value == null) {
      if (optional != true) {
        throw new ParseError(""Required value was null, undefined, or unset"", value, this.config);
      } else {
        return value as any as T;
      }
    }

    if (typeof type === ""string"" && typeof value !== type) {
      throw new ParseError(""Value was not the expected type"", value, this.config);
    }

    if (typeof type === ""function"" && !type(value)) {
      throw new ParseError(
        ""Value was not the expected type; value did not pass type guard"",
        value,
        this.config
      );
    }

    let parsedPreTransform: any;

    if (elements && Array.isArray(value)) {
      parsedPreTransform = value.map((element) => elements.parse(element));
    } else if (fields && typeof value === ""object"" && !Array.isArray(value)) {
      parsedPreTransform = {};
      if (fields instanceof Parser) {
        for (const key in value) {
          parsedPreTransform[key] = fields.parse((value as any)[key]);
        }
      } else {
        for (const key in fields) {
          parsedPreTransform[key] = fields[key].parse((value as any)[key]);
        }
        for (const key in value) {
          if (!(key in fields)) {
            throw new ParseError(""Unexpected field in value"", value, this.config);
          }
        }
      }
    } else {
      parsedPreTransform = value;
    }

    if (transform) {
      try {
        return transform(parsedPreTransform as TPreTransform);
      } catch (transformErr) {
        throw new ParseError(
          ""Could not transform value while parsing"",
          parsedPreTransform,
          this.config,
          transformErr
        );
      }
    }

    return parsedPreTransform as T;
  }
}

export const stringParser = new Parser<string>({ type: ""string"" });
export const numberParser = new Parser<number>({ type: ""number"" });
export const booleanParser = new Parser<boolean>({ type: ""boolean"" });
export const unknownRecordParser = new Parser<Record<string, unknown>>({
  type: (value): value is Record<string, unknown> =>
    typeof value === ""object"" &&
    value != null &&
    Object.keys(value).every((key) => typeof key === ""string""),
});
export const dateStringParser = new Parser<Date, string>({
  type: ""string"",
  transform(dateString) {
    const parsedDate = new Date(dateString);
    if (parsedDate.toString() === ""Invalid Date"") {
      throw new Error(""Invalid date string"");
    }
    return parsedDate;
  },
});
export function makeEnumParser<TEnumType, TEnumObj extends Record<string, any>>(enumObj) {
  return new Parser<TEnumType>({
    type: (value): value is TEnumType => Object.values(enumObj).includes(value),
  });
}
<fim_middle>",correct,5297
unknown,unknown,47dc91afa9f261374fcc8a999842718632fdfb4f,"<fim_prefix>export class ParseError extends Error {
  value: unknown;
  config: ParserConfig<any>;
  reason?: unknown;

  constructor(message, value: <fim_suffix>, config, reason?) {
    let errorMessage = message;
    if (reason != null) {
      errorMessage += `\nReason:\n${String(reason)}`;
    }
    errorMessage += `\nValue:\n${JSON.stringify(value, null, 2)}`;
    super(errorMessage);
    this.value = value;
    this.config = config;
    this.reason = reason;
  }
}

export interface ParserConfig<T, TPreTransform = T> {
  /**
   * Parses the type using either a primitive value compatible with typeof
   * or a type guard function.
   */
  type: string | ((value) => value is TPreTransform);
  /** If set to true, null or undefined values will be parsed without error. */
  optional?: true;
  /**
   * Parser or a record of parsers for the enumerable fields of an object.
   *
   * If passed a record of parsers, a strict set of fields will be parsed using
   * a specific parse config for each field.
   *
   * If passed a single parser, an arbitrary set of fields will be parsed using
   * the same parse config for each field.
   *
   * If the value is not an object, this config field is ignored.
   */
  fields?:
    | {
        [K in keyof TPreTransform]: Parser<TPreTransform[K], any>;
      }
    | Parser<TPreTransform[keyof TPreTransform], any>;
  /**
   * Parser for the elements of a list.
   *
   * If the value is not an array, this config field is ignored.
   */
  elements?: TPreTransform extends unknown[] ? Parser<TPreTransform[number], any> : never;
  /**
   * Transforms the value when parsing using the provided function.
   *
   * If field or element parse configs include transforms, those transforms
   * will be applied prior to the overall transform function.
   */
  transform?: (value) => T;
}

export class Parser<T, TPreTransform = T> {
  config: ParserConfig<T, TPreTransform>;

  constructor(
    configypeof config === ""function"" ? config(this) : config;
  }

  /**
   * Parses a value using the provided config, and throws a ParseError if the
   * value could not be parsed.
   */
  parse(value) {
    const { optional, type, fields, elements, transform } = this.config;

    if (value == null) {
      if (optional != true) {
        throw new ParseError(""Required value was null, undefined, or unset"", value, this.config);
      } else {
        return value as any as T;
      }
    }

    if (typeof type === ""string"" && typeof value !== type) {
      throw new ParseError(""Value was not the expected type"", value, this.config);
    }

    if (typeof type === ""function"" && !type(value)) {
      throw new ParseError(
        ""Value was not the expected type; value did not pass type guard"",
        value,
        this.config
      );
    }

    let parsedPreTransform: any;

    if (elements && Array.isArray(value)) {
      parsedPreTransform = value.map((element) => elements.parse(element));
    } else if (fields && typeof value === ""object"" && !Array.isArray(value)) {
      parsedPreTransform = {};
      if (fields instanceof Parser) {
        for (const key in value) {
          parsedPreTransform[key] = fields.parse((value as any)[key]);
        }
      } else {
        for (const key in fields) {
          parsedPreTransform[key] = fields[key].parse((value as any)[key]);
        }
        for (const key in value) {
          if (!(key in fields)) {
            throw new ParseError(""Unexpected field in value"", value, this.config);
          }
        }
      }
    } else {
      parsedPreTransform = value;
    }

    if (transform) {
      try {
        return transform(parsedPreTransform as TPreTransform);
      } catch (transformErr) {
        throw new ParseError(
          ""Could not transform value while parsing"",
          parsedPreTransform,
          this.config,
          transformErr
        );
      }
    }

    return parsedPreTransform as T;
  }
}

export const stringParser = new Parser<string>({ type: ""string"" });
export const numberParser = new Parser<number>({ type: ""number"" });
export const booleanParser = new Parser<boolean>({ type: ""boolean"" });
export const unknownRecordParser = new Parser<Record<string, unknown>>({
  type: (value): value is Record<string, unknown> =>
    typeof value === ""object"" &&
    value != null &&
    Object.keys(value).every((key) => typeof key === ""string""),
});
export const dateStringParser = new Parser<Date, string>({
  type: ""string"",
  transform(dateString) {
    const parsedDate = new Date(dateString);
    if (parsedDate.toString() === ""Invalid Date"") {
      throw new Error(""Invalid date string"");
    }
    return parsedDate;
  },
});
export function makeEnumParser<TEnumType, TEnumObj extends Record<string, any>>(enumObj) {
  return new Parser<TEnumType>({
    type: (value): value is TEnumType => Object.values(enumObj).includes(value),
  });
}
<fim_middle>",correct,5299
void,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,61
void,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,64
void,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,65
void,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize() {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,66
void,void,35b6c6d6cf43374159e7f7c86517b7faf952db91,"<fim_prefix>/* eslint-disable max-len */
// Send, Receive, Deposit, Withdrawal, Income
export interface Transaction {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

// Buy, Sell, Swap
export interface Order {
    id: string;
    timestamp: Date;
    type: string;
    baseCurrency: string;
    baseQuantity: number;
    baseUsdPrice: number;
    quoteCurrency: string;
    quoteQuantity: number;
    quotePrice: number;
    quoteUsdPrice: number;
    feeCurrency: string;
    feeQuantity: number;
    feeUsdPrice: number;
    feeTotal: number;
    subTotal: number;
    total: number;
}

/**
 * A base class to support general connection operations
 */
export default class BaseConnection {
    name: string;
    type: string;
    connection: any;
    credentials?: any;
    balances: any;
    symbols: Array<any>;
    initialized: boolean;
    requireSymbols: boolean;
    requireUsdValuation: boolean;
    stableCoins: Array<string> = [""USDC"", ""USDT""];
    fiatCurrencies: Array<string> = [""USD""];
    stableCurrencies: Array<string> = [""USD"", ""USDC"", ""USDT""];

    /**
     * Create BaseConnection instance
     * @param {string} name - Name of connection (Ex: coinbase)
     * @param {string} type - Type of connection (Ex: api)
     * @param {any} params - (Optional) Additional paramaters
     */
    constructor(name, type, params = {}) {
        this.name = name;
        this.type = type;
        this.connection = null;
        this.initialized = false;
        this.symbols = [];
        this.requireSymbols = params.requireSymbols
            ? params.requireSymbols
            : false;
        this.requireUsdValuation = params.requireUsdValuation
            ? params.requireUsdValuation
            : true;
    }

    /**
     * JSON object representing connection
     * @return {any}
     */
    toJSON() {
        const baseJSON = {
            name: this.name,
            type: this.type,
            params: {},
        };
        if (this.credentials) {
            const updatedParams: any = baseJSON.params;
            updatedParams.credentials = this.credentials;
            baseJSON.params = updatedParams;
        }
        return baseJSON;
    }

    /**
     * HELPER: Convert buy/sell to swap if no fiat is involved in order
     *
     * @param {any} order - Order instance
     * @return {Order} Reformatted Order
     */
    _attemptedSwapConversion(order) {
        if (!this.fiatCurrencies.includes(order.quoteCurrency)) {
            if (order.type === ""sell"") {
                const tempBC = order.baseCurrency;
                const tempBQ = order.baseQuantity;
                const tempBP = order.baseUsdPrice;
                order.baseCurrency = order.quoteCurrency;
                order.baseQuantity = order.quoteQuantity;
                order.baseUsdPrice = order.quoteUsdPrice;
                order.quoteCurrency = tempBC;
                order.quoteQuantity = tempBQ;
                order.quoteUsdPrice = tempBP;
                order.quotePrice = order.baseUsdPrice / order.quoteUsdPrice;
            }
            order.type = ""swap"";
        }
        return order;
    }

    /**
     * Initialize exchange by fetching balances and loading markets
     * @return {void}
     */
    initialize(): <fim_suffix> {
        throw Error(
            `NotImplementedError: ${this.name}.initialize() has not been implemented.`
        );
    }

    /**
     * Fetch Account Balances
     * @return {void}
     */
    getBalances() {
        throw Error(
            `NotImplementedError: ${this.name}.getBalances() has not been implemented.`
        );
    }

    /**
     * Fetch Account Withdrawals
     * @return {void}
     */
    getWithdrawals() {
        throw Error(
            `NotImplementedError: ${this.name}.getWithdrawals() has not been implemented.`
        );
    }

    /**
     * Fetch Account Deposits
     * @return {void}
     */
    getDeposits() {
        throw Error(
            `NotImplementedError: ${this.name}.getDeposits() has not been implemented.`
        );
    }

    /**
     * Fetch Account Orders
     * @return {void}
     */
    getOrders() {
        throw Error(
            `NotImplementedError: ${this.name}.getOrders() has not been implemented.`
        );
    }

    /**
     * Fetch all account ledger (withdrawals, deposits, and orders)
     * @return {void}
     */
    getLedger() {
        throw Error(
            `NotImplementedError: ${this.name}.getLedger() has not been implemented.`
        );
    }

    /**
     * Fetch account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getAllTransactions() {
        throw Error(
            `NotImplementedError: ${this.name}.getAllTransactions() has not been implemented.`
        );
    }

    /**
     * Fetch all account transactions (withdrawals, deposits, and orders)
     * @return {void}
     */
    getTxUsdVal() {
        throw Error(
            `NotImplementedError: ${this.name}.getTxUsdVal() has not been implemented.`
        );
    }
}
<fim_middle>",correct,67
void,void,1d39ec473347edb072e37f629ad2a9736fad5a7a,"<fim_prefix>export const Kind = 'Core#ResponseAuthorization';

export interface IResponseAuthorization {
  kind: typeof Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method: string;
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;
}

export class ResponseAuthorization {
  kind = Kind;
  /**
   * The requested by the authorization server authentication method
   */
  method = 'unknown';
  /**
   * The current state if the authorization process. This is used by NTLM authorization helper.
   */
  state?: number;
  /**
   * The headers association with the response.
   */
  headers?: string;
  /**
   * When returned by the server, the value of the challenge.
   */
  challengeHeader?: string;

  /**
   * @param input The response authorization definition used to restore the state.
   */
  constructor(input?) {
    let init: IResponseAuthorization;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        method: 'unknown',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new response authorization clearing anything that is so far defined.
   * 
   * Note, this throws an error when the object is not a response authorization.
   */
  new(init): <fim_suffix> {
    if (!ResponseAuthorization.isResponseAuthorization(init)) {
      throw new Error(`Not a response authorization.`);
    }
    const { method, state, headers, challengeHeader } = init;
    this.kind = Kind;
    this.method = method;
    this.state = state;
    this.headers = headers;
    this.challengeHeader = challengeHeader;
  }

  /**
   * Checks whether the input is a definition of a response authorization.
   */
  static isResponseAuthorization(input) {
    const typed = input as IResponseAuthorization;
    if (!input || !typed.method) {
      return false;
    }
    return true;
  }

  toJSON() {
    const result: IResponseAuthorization = {
      kind: Kind,
      method: this.method,
    };
    if (typeof this.state === 'number') {
      result.state = this.state;
    }
    if (this.headers) {
      result.headers = this.headers;
    }
    if (this.challengeHeader) {
      result.challengeHeader = this.challengeHeader;
    }
    return result;
  }
}
<fim_middle>",correct,77
void,void,346ecbfdd79cec2fad1ef9b4f5ed650b93705bf7,"<fim_prefix>interface RGB
{
  r: number,
  g: number,
  b: number,
}

export interface Stop
{
  color: string,
  stop: number,
  rgb?: RGB;
}

export type GradientStops = Stop[];

function parseStops(stops): <fim_suffix>
{
  if (stops[0].rgb) return;

  stops.forEach((s) => {
      if (s.rgb === undefined)
      {
        let r = parseInt(s.color.substr(1, 2), 16);
        let g = parseInt(s.color.substr(3, 2), 16);
        let b = parseInt(s.color.substr(5, 2), 16);
        s.rgb = { r: r, g: g, b: b };
      }
    });
  stops.sort();
}

function asHex(v)
{
  return v.toString(16).padStart(2, '0');
}

function toHexColor(r, g, b)
{
  return `#${asHex(r)}${asHex(g)}${asHex(b)}`;
}

export function execGradient(stops, value)
{
  parseStops(stops);
  let r = stops[stops.length-1].rgb.r;
  let g = stops[stops.length-1].rgb.g;
  let b = stops[stops.length-1].rgb.b;
  for (let i = 1; i < stops.length; i++)
  {
    let e = stops[i];
    if (value < e.stop)
    {
      let s = stops[i-1];
      r = s.rgb.r + Math.floor(((e.rgb.r - s.rgb.r) * (value - s.stop) / (e.stop - s.stop)));
      g = s.rgb.g + Math.floor(((e.rgb.g - s.rgb.g) * (value - s.stop) / (e.stop - s.stop)));
      b = s.rgb.b + Math.floor(((e.rgb.b - s.rgb.b) * (value - s.stop) / (e.stop - s.stop)));
      break;
    }
  }
  return toHexColor(r, g, b);
}

export function parseGradient(sStops)
{
  let stops: GradientStops = [];
  let re = / ?([^ ]+) ([^ ,]+%?),?(.*)/;

  if (sStops == null || sStops == '' ) return stops;

  // Strip off leading CSS form if present
  if (sStops.indexOf('linear-gradient') == 0)
  {
    let rePre = /^[^,]*, (.*)\)$/;
    let a = rePre.exec(sStops);
    if (a)
      sStops = a[1];
  }

  while (sStops && sStops != '')
  {
    let a = re.exec(sStops);
    if (a == null)
      break;
    let stop = a[2];
    sStops = a[3];
    if (a[2].indexOf('%') >= 0)
    {
      stop = stop.substr(0, stop.length-1);
      stop = String(Number(stop) * 0.01);
    }
      
    stops.push({ color: a[1], stop: Number(stop) });
  }
  return stops;
}

export function asCSSGradient(stops)
{
  parseStops(stops);

  let a: string[] = [];
  stops.forEach((s) => {
      let stop = s.stop >= 0.0 && s.stop <= 1.0 ? `${Math.round(s.stop*100)}%` : String(s.stop);
      a.push(`${toHexColor(s.rgb.r, s.rgb.g, s.rgb.b)} ${stop}`);
    });
  return `linear-gradient(to right, ${a.join(', ')})`;
}
<fim_middle>",correct,436
void,void,fdf12f247ed75d2db7a6597482d6ebb301ddd41c,"<fim_prefix>/*
 Adapted from:
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

export type Point = [ number, number];

// square distance between 2 points
function getSqDist(p1, p2)
{
    var dx = p1[0] - p2[0],
        dy = p1[1] - p2[1];

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2)
{
    var x = p1[0],
        y = p1[1],
        dx = p2[0] - x,
        dy = p2[1] - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2[0];
            y = p2[1];

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p[0] - x;
    dy = p[1] - y;

    return dx * dx + dy * dy;
}


// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance)
{
    let prevPoint: Point = points[0],
        newPoints: Point[] = [prevPoint],
        point: Point;

    for (let i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified): <fim_suffix>
{
  let maxSqDist: number = sqTolerance,
      index: number;

  for (let i = first + 1; i < last; i++)
  {
    let sqDist = getSqSegDist(points[i], points[first], points[last]);

    if (sqDist > maxSqDist)
    {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance)
  {
    if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
    simplified.push(points[index]);
    if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
  }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance)
{
    let last: number = points.length - 1;

    let simplified: Point[] = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
export function simplify(points, tolerance = 1, highestQuality = false)
{
    if (tolerance == 0 || points.length <= 2)
      return points;

    let sqTolerance: number = tolerance * tolerance;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}
<fim_middle>",correct,476
void,void,2f3562fa94911b8c68dcef3c3bf8db8979c4db4a,"<fim_prefix>export interface RestApiResponseOutput {
  readonly headers: {
    [key: string]: any;
  };
  readonly body: any;
  readonly statusCode: number;
}

/**
 * API Gateway Response
 */
export class RestApiResponse {

  public cors: boolean;

  constructor() {
    this.cors = true;
  }

  setCors(cors): <fim_suffix> {
    this.cors = !!cors;
  }

  json(body, statusCode = 200) {
    return this.build(JSON.stringify(body), statusCode, 'application/json');
  }

  error(error, statusCode = 500) {
    let messages;
    if (error instanceof Error) {
      messages = error.toString();
    } else {
      messages = error;
    }
    return this.build(JSON.stringify({
      error: messages,
    }), statusCode ?? error.statusCode ?? 500, 'application/json');
  }

  file(content, contentType, filename) {
    if (typeof content === 'object') {
      content = JSON.stringify(content, null, 4);
    }
    return this.build(content, 200, contentType, {
      'content-disposition': `attachment; filename=${filename}`,
    });
  }

  notFound() {
    return this.build({}, 404);
  }

  build(
    body = {},
    statusCode = 200,
    contentType = 'application/json',
    headers = {},
  ) {
    headers['Content-Type'] = `${contentType};charset=utf-8`;
    if (this.cors) {
      headers['Access-Control-Allow-Origin'] = '*';
      headers['Access-Control-Allow-Headers'] = JSON.stringify([
        'Content-Type',
        'Fetch-Mode',
        'accept',
        'X-Amz-Date',
        'Accept-Encoding',
        'Authorization',
        'X-Api-Key',
        'X-Amz-Security-Token',
        'X-Amz-User-Agent',
      ]);
      headers['Access-Control-Allow-Methods'] = JSON.stringify([
        'HEAD',
        'GET',
        'POST',
        'PUT',
        'DELETE',
      ]);
    }
    return {
      headers,
      body,
      statusCode,
    };
  }
}<fim_middle>",correct,637
void,void,4b26b14a08d5cdfff6183540cb79049b3ed5038a,"<fim_prefix>/* eslint-disable no-constant-condition */

const EOF = '~EOF~'

class Parser {
  private pos = 0

  constructor(private input) {}

  next() {
    if (this.pos >= this.input.length) {
      return EOF
    }
    return this.input[this.pos++]
  }

  backup(): <fim_suffix> {
    this.pos--
  }

  parseTemplate() {
    if (this.next() != '/') {
      throw new Error('binding URL should start with a slash')
    }
    
    return {
      segments: this.parseSegments(),
      verb: this.parseVerb(),
    }
  }

  private parseSegments() {
    let segments: Segment[] = []
    segments.push(this.parseSegment())

    while (true) {
      let r = this.next()
      switch (r) {
        case '/':
          segments.push(this.parseSegment())
          continue

        case ':':
        case '}':
          this.backup()
          return segments

        case EOF:
          return segments

        default:
          throw new Error(`unexpected ${r} in segments`)
      }
    }
  }

  private parseSegment() {
    let content = ''
    while (true) {
      let r = this.next()
      switch (r) {
        case EOF:
          if (!content.length) {
            throw new Error(`unexpected EOF in segment`)
          }
          return { content }

        case '{':
          return { content, variable: this.parseVariable() }

        case ':':
        case '/':
        case '}':
          this.backup()
          if (!content.length) {
            throw new Error(`unexpected ${r} in segment`)
          }
          return { content }

        default:
          content += r
      }
    }
  }

  private parseVariable() {
    let v: Variable = {
      name: '',
    }
    while (true) {
      let r = this.next()
      switch (r) {
        case '}':
          if (!v.name.length) {
            throw new Error(`empty variable name`)
          }
          return v

        case '=':
          v.parts = this.parseSegments().map(segment => {
            if (!segment.content.length) {
              throw new Error(`unexpected empty segment`)
            }
            return segment.content
          })
          break

        case EOF:
          throw new Error(`unexpected EOF in variable ${v.name}`)

        default:
          v.name += r
      }
    }
  }

  private parseVerb() {
    let r = this.next()
    switch (r) {
      case ':':
        break

      case EOF:
        return ''

      default:
        throw new Error(`unexpected ${r} in verb`)
    }

    let verb = ''
    while (true) {
      let r = this.next()
      if (r === EOF) {
        if (!verb.length) {
          throw new Error(`empty verb`)
        }
        return verb
      }
      verb += r
    }
  }
}

interface Binding {
  segments: Segment[]
  verb: string
}

interface Segment {
  content: string
  variable?: Variable
}

interface Variable {
  name: string
  parts?: string[]
}

export function buildURL(template, params) {
  let parser = new Parser(template)
  let binding = parser.parseTemplate()

  let parts = binding.segments.map(segment => {
    if (segment.variable) {
      if (!params[segment.variable.name]) {
        throw new Error(`input parameter ${segment.variable.name} is required`)
      }

      return params[segment.variable.name]
    }
    return segment.content
  })
  let verb = binding.verb ? `:${binding.verb}` : ''
  return '/' + parts.join('/') + verb
}
<fim_middle>",correct,929
void,void,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className): <fim_suffix> {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,985
void,void,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className): <fim_suffix> {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,987
void,void,53b6ef015e8c8793036ec97b599fa436cd131b3f,"<fim_prefix>export type Constructor<T = any> = { new (...args): T };
export type ServiceRegistry = WeakMap<Constructor, any[]>;

export class Container {
  private registry: ServiceRegistry;
  private instances: WeakMap<Constructor, any>;

  constructor() {
    this.registry = new WeakMap();
    this.instances = new WeakMap();
  }

  /**
   * Adds a class and its constructor arguments to the container. Each time `get()` is called,
   * a new instance of the class will be returned.
   * @param newClass The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  add<T extends Constructor>(newClass, ...args) {
    this.registry.set(newClass, args);
    return this;
  }

  /**
   * Adds a static instance of a class to the container. Instead of creating a new instance
   * each time `get()` is called, that single instance will be returned instead.
   * @param className The class to add to the container.
   * @param args The arguments to pass to the class's constructor. Can be a primitive or
   * another class. If a class is used, the container will create an instance of it and
   * pass it to the constructor.
   * @returns The container object returns itself, allowing chaining multiple calls to `add()`.
   */
  addStatic<T extends Constructor>(className, ...args) {
    const instance = new className(...args);
    this.instances.set(className, instance);
    return this;
  }

  /**
   * Appends arguments to a class's existing arguments array.
   * @param className The class to modify.
   * @param newArgs The new arguments to append to the existing arguments array.
   */
  appendArgs(className, ...newArgs): <fim_suffix> {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const args = this.registry.get(className) as any[]; // can never be undefined in `add()`
    args.push(...newArgs);
    this.registry.set(className, args);
  }

  /**
   * Reurns an instance of a class from the container. If the class was registered using
   * `addStatic()`, a singleton instance will be returned with each call to `get()`.
   *
   * If a class depends on another class added to the container, it will build an instance
   * of it using the stored arguments and inject it as a dependency. If a class was registered
   * using `addStatic()`, the container will inject a singleton instance of that class.
   * @param className The class to retrieve.
   * @returns An instance of the provided `className`.
   */
  get<T>(className) {
    // Check for an existing static instance and return it.
    const existing = this.instances.get(className) as T;
    if (existing) {
      return existing;
    }

    // Otherwise, build a brand new instance.
    const args = this.registry.get(className);
    if (!args) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }

    const preparedArgs = args.map((arg) => {
      if (typeof arg != ""function"") {
        return arg;
      }

      // Try: is the function a constructor? If not, a TypeError will be thrown.
      try {
        new arg();
      } catch (error) {
        // In that case, return it as a callback argument.
        return arg;
      }

      // Otherwise, try to retrieve it from the container.
      const maybeConstructor = arg as Constructor;
      const registered = this.get(maybeConstructor);
      return registered;
    });

    return new className(...preparedArgs);
  }

  /**
   * Removes a class from the container.
   * @param className The class to remove.
   */
  delete(className) {
    if (!this.has(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.registry.delete(className);
  }

  /**
   * Removes a static instance from the container.
   * @param className The class to remove.
   */
  deleteStatic(className) {
    if (!this.hasStatic(className)) {
      throw new ContainerError(
        `${className.name} is not registered in container.`
      );
    }
    this.instances.delete(className);
  }

  /**
   * Checks for the presence of a class in the registry.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  has(className) {
    return this.registry.has(className);
  }

  /**
   * Checks for the presence of a static instance in the container.
   * @param className The class to look for.
   * @returns `true` if found, `false` if not.
   */
  hasStatic(className) {
    return this.instances.has(className);
  }
}

export class ContainerError extends Error {
  name = ""ContainerError"";

  constructor(public message) {
    super();
  }
}
<fim_middle>",correct,991
void,void,d7fb9092fdb59a5468c3a31287ec18c440855fd2,"<fim_prefix>//
// SOME BASIC MATRIX OPERATIONS FOR MBR
//

/* 

These custom functions are used by minimumBoundingRectangle(), instead of the
same-named mathjs versions. They are tailored specifically for that routine and
are NOT intended for general use.

export declare function matrix(x: Matrix): Matrix;

export declare function multiply(a: Matrix, b: Matrix): Matrix;

export declare function transpose(a: Matrix, b: Matrix): Matrix;

export declare function apply((a: Matrix, over: Dim, cb: applyCB): Vector;

export declare function min(a: Vector): number;

export declare function max(a: Vector): number;

export declare function concat(a: Matrix, b: Matrix, by: Dim): Matrix;

export declare function row(a: Matrix, i: number): Vector;

export declare function subtract(a: Vector, b: Vector): Vector;

export declare function dotMultiply(a: Vector, b: Vector): Vector;

export declare function index(a: Range, b: Range): Index;

export declare function range(start: number, end: number, includeEnd: boolean = false): Vector;

export declare function subset(a: Matrix, select: Index): Matrix;

*/


export type Matrix = number[][];
export type Vector = number[];                // A general vector or a row or a column
export type Range = number[];
export type Index = number[][];
export type applyCB = (v) => number;

export const enum Dim
{
  Rows,
  Columns
}

export function matrix(a)
{
  return a;
}

export function multiply(a, b)
{
  protect((nRows(a) > 0), ""In multiply, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In multiply, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In multiply, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In multiply, input matrix 'b' has no columns. "");

  const m = nRows(a);
  const n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  protect((p == n), ""In multiply, the # rows in matrix 'b' doesn't match the number of columns in matrix 'a'."");

  let c: Matrix = initialize(m, n);

  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < q; j++)
    {
      const aRow = row(a, i);
      const bCol = column(b, j);

      c[i][j] = dotProduct(aRow, bCol);
    }
  }

  return c;
}

export function transpose(a)
{
  protect((nRows(a) > 0), ""In transpose, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In transpose, input matrix has no columns. "");

  const j = nRows(a);
  const i = nCols(a);

  let b: Matrix = initialize(i, j);

  for (let m = 0; m < j; m++)
  {
    for (let n = 0; n < i; n++)
    {
      b[n][m] = a[m][n];
    }
  }

  return b;
}

export function apply(a, over, cb)
{
  protect((nRows(a) > 0), ""In apply, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In apply, input matrix has no columns. "");

  let m = nRows(a);
  let n = nCols(a);

  let result: Vector = [];

  const iEnd = (over == Dim.Rows) ? m : n;
  const extractFn = (over == Dim.Rows) ? row : column;

  for (let i = 0; i < iEnd; i++)
  {
    const v: Vector = extractFn(a, i);
    result.push(cb(v));
  }

  return result;
}

export function min(v)
{
  return Math.min(...v);
}

export function max(v)
{
  return Math.max(...v);
}

export function concat(a, b, by)
{
  protect((nRows(a) > 0), ""In concat, input matrix 'a' has no rows. "");
  protect((nCols(a) > 0), ""In concat, input matrix 'a' has no columns. "");
  protect((nRows(b) > 0), ""In concat, input matrix 'b' has no rows. "");
  protect((nCols(b) > 0), ""In concat, input matrix 'b' has no columns. "");

  let m = nRows(a);
  let n = nCols(a);
  const p = nRows(b);
  const q = nCols(b);

  const {i, j} = (by == Dim.Columns) ? {i: m, j: n + q} : {i: m + p, j: n};
  let c: Matrix = initialize(i, j);

  if (by == Dim.Rows)
    protect((n == q), ""In concat, concatenating rows but the # of columns don't match. "");
  else // (by == Dim.Columns)
    protect((m == p), ""In concat, concatenating columns but the # of rows don't match. "");

  // Copy the first array
  for (let i = 0; i < m; i++)
  {
    for (let j = 0; j < n; j++)
    {
      c[i][j] = a[i][j];
    }
  }

  m = (by == Dim.Rows) ? m : 0;
  n = (by == Dim.Columns) ? n : 0;

  // Copy the second array to the right (by columns) or below (by rows)
  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      c[i+m][j+n] = b[i][j];
    }
  }

  return c;
}

export function row(a, i)
{
  protect((nRows(a) > 0), ""In row, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In row, input matrix has no columns. "");
  protect((i >= 0), ""In row, invalid row index."");

  return a[i];
}

export function column(a, j)
{
  protect((nRows(a) > 0), ""In column, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In column, input matrix has no columns. "");
  protect((j >= 0), ""In row, invalid column index."");

  let v: any = [];

  for (let i = 0; i < nRows(a); i++)
  {
    v.push(a[i][j]);
  }

  return v;
}

export function subtract(a, b)
{
  protect((a.length == b.length), ""In subtract, the input vectors have different lengths."");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] - b[i]);
  }

  return c;
}

export function dotMultiply(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotMultiply, the vectors aren't the same length. "");

  let c: Vector = [];

  for (let i = 0; i < a.length; i++)
  {
    c.push(a[i] * b[i]);
  }

  return c;
}

export function index(a, b)
{
  return [a, b];
}

export function range(start, end, includeEnd = false)
{
  let r: Vector = [];

  end += includeEnd ? 1 : 0;
  for (let i = start; i < end; i++)
  {
    r.push(i);
  }
  
  return r;
}

export function subset(a, select)
{
  protect((nRows(a) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(a) > 0), ""In subset, input matrix has no columns. "");

  protect((nRows(select) > 0), ""In subset, input matrix has no rows. "");
  protect((nCols(select) > 0), ""In subset, input matrix has no columns. "");

  const m = nRows(a);
  const n = nCols(a);

  const rowRange = row(select, 0) as Range;
  const colRange = row(select, 1) as Range;
  const p = rowRange.length;
  const q = colRange.length;

  let b: Matrix = initialize(p, q);

  for (let i = 0; i < p; i++)
  {
    for (let j = 0; j < q; j++)
    {
      b[i][j] = a[rowRange[i]][colRange[j]];
    }
  }

  return b;
}


// HELPERS

function initialize(rows, cols)
{
  protect(((rows > 0) || (cols > 0)), ""In initialize, the # of rows or columns is not positive. "");

  return [...Array(rows)].fill(0).map(() => [...Array(cols)].fill(0));
};

const nRows = (a) => a.length;
const nCols = (a) => (a.length > 0) ? a[0].length : 0;

export function dotProduct(a, b)
{
  protect((a.length > 0) && (a.length == b.length), ""In dotProduct, the vectors aren't the same length. "");

  return a.map((value, i) => value * b[i]).reduce((acc, val) => acc + val, 0);
};


function protect(condition, message): <fim_suffix>
{
  if (!condition)
    throw new Error(message);
}
<fim_middle>",correct,1181
void,void,1bdf15e64741ff92173aa49927c0b9358b078f8c,"<fim_prefix>// Copyright (c) 2022 Onur Cinar. All Rights Reserved.
// https://github.com/cinar/indicatorts

/**
 * Tree node.
 */
interface TreeNode {
  value: number;
  left: TreeNode | null;
  right: TreeNode | null;
}

/**
 * Tree result info object.
 */
interface TreeNodeInfo {
  node: TreeNode | null;
  parent: TreeNode | null;
}

/**
 * Binary search tree object.
 */
export class BinarySearchTree {
  private root: TreeNode | null = null;

  /**
   * Inserts the given value.
   * @param value numeric value.
   */
  insert(value): <fim_suffix> {
    const node: TreeNode = {
      value: value,
      left: null,
      right: null,
    };

    if (this.root === null) {
      this.root = node;
      return;
    }

    let current = this.root;
    let found = false;

    while (!found) {
      if (node.value <= current.value) {
        if (current.left === null) {
          current.left = node;
          found = true;
        } else {
          current = current.left;
        }
      } else {
        if (current.right === null) {
          current.right = node;
          found = true;
        } else {
          current = current.right;
        }
      }
    }
  }

  /**
   * Removes the given value.
   * @param value numeric value.
   * @return value removed.
   */
  remove(value) {
    const info: TreeNodeInfo = {
      node: this.root,
      parent: null,
    };

    while (info.node !== null) {
      if (value === info.node.value) {
        this.removeNode(info);
        return true;
      } else {
        info.parent = info.node;

        if (value < info.node.value) {
          info.node = info.node.left;
        } else {
          info.node = info.node.right;
        }
      }
    }

    return false;
  }

  /**
   * Min value.
   * @return min value.
   */
  min() {
    const minInfo = BinarySearchTree.minNode(this.root);
    if (minInfo.node === null) {
      throw new Error('Tree empty');
    }

    return minInfo.node.value;
  }

  /**
   * Max value.
   * @return max value.
   */
  max() {
    const maxInfo = BinarySearchTree.maxNode(this.root);
    if (maxInfo.node === null) {
      throw new Error('Tree empty');
    }

    return maxInfo.node?.value;
  }

  /**
   * Removes the node info.
   * @param info node info.
   */
  private removeNode(info) {
    if (info.node === null) {
      return;
    }

    if (info.node.left !== null && info.node.right !== null) {
      const minInfo = BinarySearchTree.minNode(info.node.right);
      if (minInfo.parent === null) {
        minInfo.parent = info.node;
      }

      this.removeNode(minInfo);
      if (minInfo.node !== null) {
        info.node.value = minInfo.node.value;
      }
    } else {
      let child: TreeNode | null = null;

      if (info.node.left !== null) {
        child = info.node.left;
      } else {
        child = info.node.right;
      }

      if (info.parent === null) {
        this.root = child;
      } else if (info.parent.left === info.node) {
        info.parent.left = child;
      } else {
        info.parent.right = child;
      }
    }
  }

  /**
   * Min node function returns the min node and its parent.
   * @param root root node.
   * @return node info.
   */
  private static minNode(root) {
    const info: TreeNodeInfo = {
      node: null,
      parent: null,
    };

    if (root !== null) {
      info.node = root;

      while (info.node.left !== null) {
        info.parent = info.node;
        info.node = info.node.left;
      }
    }

    return info;
  }

  /**
   * Max node funection returns the mac node and its parent.
   * @param root root node.
   * @return node info.
   */
  private static maxNode(root) {
    const info: TreeNodeInfo = {
      node: null,
      parent: null,
    };

    if (root !== null) {
      info.node = root;

      while (info.node.right !== null) {
        info.parent = info.node;
        info.node = info.node.right;
      }
    }

    return info;
  }
}
<fim_middle>",correct,1340
void,void,39850647fe41aa810255752b914cdd87b3e420dc,"<fim_prefix>export const Kind = 'Core#License';

export interface ILicense {
  kind: typeof Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;
}

export class License {
  kind = Kind;
  /**
   * The URL to the license text.
   * Only `url` or `content` can be used at a time.
   */
  url?: string;
  /**
   * The name of the license.
   */
  name?: string;
  /**
   * The content of the license.
   * Only `url` or `content` can be used at a time.
   */
  content?: string;

  static fromUrl(url, name?) {
    return new License({
      kind: Kind,
      url,
      name,
    });
  }

  static fromContent(content, name?) {
    return new License({
      kind: Kind,
      content,
      name,
    });
  }

  /**
   * @param input The license definition used to restore the state.
   */
  constructor(input?) {
    let init: ILicense;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new license clearing anything that is so far defined.
   * 
   * Note, this throws an error when the license is not a license object.
   */
  new(init): <fim_suffix> {
    if (!License.isLicense(init)) {
      throw new Error(`Not a license.`);
    }
    const { url, content, name } = init;
    this.kind = Kind;
    this.name = name;
    this.content = content;
    this.url = url;
  }

  /**
   * Checks whether the input is a definition of a license.
   */
  static isLicense(input) {
    const typed = input as ILicense;
    if (typed && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: ILicense = {
      kind: Kind,
    };
    if (this.name) {
      result.name = this.name;
    }
    if (this.url) {
      result.url = this.url;
    }
    if (this.content) {
      result.content = this.content;
    }
    return result;
  }
}
<fim_middle>",correct,1624
void,void,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j): <fim_suffix> {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1727
void,void,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index): <fim_suffix> {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1730
void,void,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority) {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i): <fim_suffix> {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1732
void,void,8421a8d472765fd2992d131fb5bbc260d133ef72,"<fim_prefix>interface PQEntry<K> {
  key: K;
  priority: number;
}

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., ""Introduction to Algorithms"". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
export class PriorityQueue<K> {
  private readonly _arr: PQEntry<K>[];
  private readonly _keyIndices: Map<K, number>;

  constructor() {
    this._arr = [];
    this._keyIndices = new Map();
  }

  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }

  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(x => x.key);
  }

  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(key) {
    return this._keyIndices.has(key);
  }

  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   */
  priority(key) {
    const index = this._keyIndices.get(key);
    if(index !== undefined) {
      return this._arr[index].priority;
    }
  }

  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if(this.size() === 0) {
      throw new Error('Queue underflow');
    }
    return this._arr[0].key;
  }

  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function does nothing and returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param key the key to add
   * @param priority the initial priority for the key
   */
  add(key, priority) {
    const keyIndices = this._keyIndices;
    if(!keyIndices.has(key)) {
      const arr = this._arr;
      const index = arr.length;
      keyIndices.set(key, index);
      arr.push({key: key, priority: priority});
      this._decrease(index);
      return true;
    }
    return false;
  }

  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    const min = this._arr.pop()!;
    this._keyIndices.delete(min.key);
    this._heapify(0);
    return min.key;
  }

  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param key the key for which to raise priority
   * @param priority the new priority for the key
   */
  decrease(key, priority): <fim_suffix> {
    const index = this._keyIndices.get(key);

    if(index === undefined)
      throw new RangeError('Key out of range');

    if(priority > this._arr[index].priority) {
      throw new Error('New priority is greater than current priority. ' +
          `Key: ${String(key)} Old: ${this._arr[index].priority} New: ${priority}`);
    }
    this._arr[index].priority = priority;
    this._decrease(index);
  }

  private _heapify(i) {
    const arr = this._arr;
    const l = 2 * i;
    const r = l + 1;
    let largest = i;
    if(l < arr.length) {
      largest = arr[l].priority < arr[largest].priority ? l : largest;
      if(r < arr.length) {
        largest = arr[r].priority < arr[largest].priority ? r : largest;
      }
      if(largest !== i) {
        this._swap(i, largest);
        this._heapify(largest);
      }
    }
  }

  private _decrease(index) {
    const arr = this._arr;
    const priority = arr[index].priority;
    let parent: number;
    while(index !== 0) {
      // eslint-disable-next-line no-bitwise
      parent = index >> 1;
      if(arr[parent].priority < priority) {
        break;
      }
      this._swap(index, parent);
      index = parent;
    }
  }

  private _swap(i, j) {
    const arr = this._arr;
    const keyIndices = this._keyIndices;
    const origArrI = arr[i];
    const origArrJ = arr[j];
    arr[i] = origArrJ;
    arr[j] = origArrI;
    keyIndices.set(origArrJ.key, i);
    keyIndices.set(origArrI.key, j);
  }
}
<fim_middle>",correct,1734
void,void,8432c37532d90458c6cbb23b64c49fcf8e55c8b7,"<fim_prefix>//
// Tokenizer for the Aqua language.
//

export enum TokenType {
    EOF,
    PLUS,
    MINUS,
    NUMBER,
    SEMICOLON,
    CONST,
    LET,
    ASSIGNMENT,
    IDENTIFIER,
    OPEN_PAREN,
    CLOSE_PAREN,
    OPEN_BRACKET,
    CLOSE_BRACKET,
    OPEN_BRACE,
    CLOSE_BRACE,
    FUNCTION,
    COMMA,
    RETURN,
    IF,
    ELSE,
    WHILE,
    FOR,    
    AND,
    OR,
    EQ,
    NE,
    LTE,
    LT,
    GTE,
    GT,
    MULTIPLY,
    DIVIDE,
    NOT,
    DOT,
    TXN,
    GTXN,
    ARG,
    ADDR,
    GLOBAL,
    ONCOMPLETE,
    TYPEENUM,
    STRING,
};

//
// Maps TokenType to the name of each type of token.
//
export const TOKEN_NAME = [
    ""end-of-file"",
    ""+"",
    ""-"",
    ""number"",
    ""semicolon"",
    ""const"",
    ""let"",
    ""="",
    ""identifier"",
    ""("",
    "")"",
    ""{"",
    ""}"",
    ""["",
    ""]"",
    ""function"",
    "","",
    ""return"",
    ""if"",
    ""else"",
    ""while"",
    ""for"",
    ""&&"",
    ""||"",
    ""=="",
    ""!="",
    ""<="",
    ""<"",
    "">="",
    "">"",
    ""*"",
    ""/"",
    ""!"",
    ""."",
    ""txn"",
    ""gtxn"",
    ""arg"",
    ""addr"",
    ""global"",
    ""OnComplete"",
    ""TypeEnum"",
    ""string literal"",
];

//
// A lookup table for single character operators.
//
const SINGLE_CHARACTER_OPERATORS = {
    ""+"": TokenType.PLUS,
    ""-"": TokenType.MINUS,
    "";"": TokenType.SEMICOLON,
    ""="": TokenType.ASSIGNMENT,
    ""("": TokenType.OPEN_PAREN,
    "")"": TokenType.CLOSE_PAREN,
    ""{"": TokenType.OPEN_BRACKET,
    ""}"": TokenType.CLOSE_BRACKET,
    ""["": TokenType.OPEN_BRACE,
    ""]"": TokenType.CLOSE_BRACE,
    "","": TokenType.COMMA,
    ""<"": TokenType.LT,
    "">"": TokenType.GT,
    ""*"": TokenType.MULTIPLY,
    ""/"": TokenType.DIVIDE,
    ""!"": TokenType.NOT,
    ""."": TokenType.DOT,
}

//
// A lookup table for two character operators.
//
const TWO_CHARACTER_OPERATORS = {
    ""&"": {
        ""&"": TokenType.AND,
    },
    ""|"": {
        ""|"": TokenType.OR,
    },
    ""="": {
        ""="": TokenType.EQ,
    },
    ""!"": {
        ""="": TokenType.NE,
    },
    ""<"": {
        ""="": TokenType.LTE,
    },
    "">"": {
        ""="": TokenType.GTE,
    },
}

//
// Maps a string of characters to a TokenType.
//
export const KEYWORDS = {
    const: TokenType.CONST,
    let: TokenType.LET,
    function: TokenType.FUNCTION,
    return: TokenType.RETURN,
    if: TokenType.IF,
    else: TokenType.ELSE,
    for: TokenType.FOR,
    while: TokenType.WHILE,
    txn: TokenType.TXN,
    gtxn: TokenType.GTXN,
    arg: TokenType.ARG,
    addr: TokenType.ADDR,
    global: TokenType.GLOBAL,
    OnComplete: TokenType.ONCOMPLETE,
    TypeEnum: TokenType.TYPEENUM,
};

//
// Represents a token.
//
export interface IToken {
    //
    // Specifies the type of token.
    //
    readonly type: TokenType;

    //
    // The value of the token, for tokens that have a value.
    //
    readonly value?: any;

    //
    // Line number where the token starts.
    //
    readonly line: number;

    //
    // Column number where the token starts.
    //
    readonly column: number;

    //
    // The string value of the token.
    //
    // TODO: This should only be read from the source code buffer when necessary.
    //
    readonly string: string;
}

//
// Interface for reporting errors.
//
export interface IError {
    //
    // The error message.
    //
    msg: string;

    //
    // 1-based line number where the error occurred.
    //
    line: number;

    //
    // 0-based column number where the error occurred.
    //
    column: number;
}

//
// Interface to a source code tokenizer for the Aqua language.
//
export interface ITokenizer {
    //
    // Scans the next token and makes it the current token.
    //
    readNext();

    //
    // Returns the current token.
    //
    getCurrent();

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd();

    //
    // Gets the current line number in the input.
    //
    getLine();

    //
    // Gets the current column number in the input.
    //
    getColumn();    
}

//
// Defines a handler for errors.
//
export type OnErrorFn = (err) => void;

//
// A source code tokenizer for the Aqua language.
//
export class Tokenizer implements ITokenizer {

    //
    // The source code being tokenized.
    //
    private code: string;

    //
    // The current position in the code to read the next token.
    //
    private curPosition: number;

    //
    // Tracks the current line number within the input.
    //
    private curLine: number;

    //
    // Tracks the current column number within the input.
    //
    private curColumn: number;

    //
    // The position in the code where the current token starts.
    //
    private curTokenStart?: number;

    //
    // The line in the code where the current token starts.
    //
    private curTokenLine?: number;

    //
    // The column in the code where the current token starts.
    //
    private curTokenColumn?: number;

    //
    // The most recently scannned token.
    //
    private curToken?: IToken;

    //
    // A simple interface that allows the tokenizer to report an error and continue scanning.
    //
    private onError?: OnErrorFn;

    constructor(code, onError?) {
        this.code = code;
        this.curPosition = 0;
        this.curLine = 1;
        this.curColumn = 0;
        this.onError = onError;
    }

    //
    // Scans the next token and makes it the current token.
    // This must be called at least once to ""prime"" the tokenizer before trying to look at the
    // ""current token"".
    //
    readNext() {

        while (true) {
            this.skipWhitespace();

            if (this.isAtEnd()) {
                this.setCurrent({ 
                    type: TokenType.EOF,
                    line: this.curLine,
                    column: this.curColumn,
                    string: ""end of file"",
                });
                return;
            }

            this.curTokenStart = this.curPosition;
            this.curTokenLine = this.curLine;
            this.curTokenColumn = this.curColumn;

            const ch = this.advance();

            if (ch === ""/"" && this.peek() === ""/"") {
                // Single line comment.
                this.skipToNewLine();
                continue;
            }

            const twoCharacterTokenLookup = (TWO_CHARACTER_OPERATORS as any)[ch];
            if (twoCharacterTokenLookup !== undefined) {
                const nextCh = this.peek();
                const twoCharacterTokenType = nextCh !== undefined && twoCharacterTokenLookup[nextCh] || undefined;
                if (twoCharacterTokenType !== undefined) {
                    this.advance();
                    this.setCurrent({
                        type: twoCharacterTokenType,
                        line: this.curTokenLine,
                        column: this.curTokenColumn,
                        string: ch + nextCh,   
                    });
                    return;
                }      
            }          

            const singleCharacterTokenType: TokenType = (SINGLE_CHARACTER_OPERATORS as any)[ch];
            if (singleCharacterTokenType !== undefined) {
                this.setCurrent({ 
                    type: singleCharacterTokenType,
                    line: this.curTokenLine,
                    column: this.curTokenColumn,
                    string: ch,
                }); 
                return;
            }

            if (ch === ""\"""") {
                this.stringLiteral();
                return;
            }

            if (this.isDigit(ch)) {
                this.readNumber();
                return;
            }

            if (this.isAlpha(ch)) {
                this.readIdentifer();
                return;
            }

            // Report error, then continue scanning at the next character.

            this.raiseError({
                msg: `Encountered unexpected character ""${ch}""`,
                line: this.curTokenLine,
                column: this.curTokenColumn,
            });
        }    
    }

    //
    // Raises an error.
    //
    private raiseError(err) {
        if (this.onError) {
            this.onError(err);
        }
    }

    //
    // Returns the current token.
    //
    getCurrent() {
        return this.curToken;
    }

    //
    // Returns true once all input has been consumed.
    //
    isAtEnd() {
        return this.curPosition >= this.code.length;
    }

    //
    // Gets the current line number in the input.
    //
    getLine() {
        return this.curLine;
    }

    //
    // Gets the current column number in the input.
    //
    getColumn() {
        return this.curColumn;
    }

    //
    // Sets the current token.
    //
    private setCurrent(token) {
        this.curToken = token;
    }

    //
    // Return the current character and then advance the current position by one place.
    //
    private advance() {
        const ch = this.code[this.curPosition];
        if (ch === ""\n"") {
            this.curLine += 1;
            this.curColumn = 0;
        }
        else {
            this.curColumn += 1;
        }
        this.curPosition += 1;
        return ch;
    }

    //
    // Look at the next character in the input without advancing the position.
    // Returns undefined when there is no more input to look at.
    //
    private peek() {
        if (this.isAtEnd()) {
            return undefined;
        }
        return this.code[this.curPosition];
    }

    //
    // Skips whitespace characters in the code.
    //
    private skipWhitespace() {
        while (true) {
            const ch = this.peek();
            if (ch === "" "" || ch === ""\t"" || ch === ""\r"" || ch === ""\n"") {
                this.advance();
            }
            else {                
                break;
            }
        } 
    }

    //
    // Skips to the next new line.
    //
    private skipToNewLine(): <fim_suffix> {
        while (true) {
            const ch = this.peek();
            if (ch === ""\n"") {
                break;
            }
            if (ch === undefined) {
                break;
            }
            this.advance();
        } 
    }

    //
    // https://stackoverflow.com/a/38370808/25868
    //
    private readonly charCodeZero = ""0"".charCodeAt(0);
    private readonly charCodeNine = ""9"".charCodeAt(0);    
    private readonly charCodea = ""a"".charCodeAt(0);
    private readonly charCodez = ""z"".charCodeAt(0);
    private readonly charCodeA = ""A"".charCodeAt(0);
    private readonly charCodeZ = ""Z"".charCodeAt(0);
    private readonly charCode_ = ""_"".charCodeAt(0);

    //
    // Returns true if the specified charater is a digit.
    //
    private isDigit(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodeZero  && charCode <= this.charCodeNine;
    }

    //
    // Reads the subsequent digits of a number token.
    //
    private readNumber() {
        while (this.isDigit(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);

        this.setCurrent({ 
            type: TokenType.NUMBER, 
            value: parseFloat(stringValue),
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: stringValue,
        }); 
    }

    //
    // Returns true if the specified charater is a alphabetical character..
    //
    private isAlpha(ch) {
        if (ch === undefined) {
            // No more input, so by definition it's not a digit.
            return false;
        }
        const charCode = ch.charCodeAt(0); //TODO: Optimization: Just pass the character offset in the original buffer through and then pull the char code directly from the buffer.
        return charCode >= this.charCodea && charCode <= this.charCodez
            || charCode >= this.charCodeA && charCode <= this.charCodeZ
            || charCode === this.charCode_;
    }

    //
    // Returns true if the specified charater is a alphabetical or numerical character.
    //
    private isAlphaNumeric(ch) {
        return this.isAlpha(ch) || this.isDigit(ch);
    }

    //
    // Reads the subsequent digits of an identifier or keyword token.
    //
    private readIdentifer() {
        while (this.isAlphaNumeric(this.peek())) {
            this.advance();
        }

        const stringValue = this.code.substring(this.curTokenStart!, this.curPosition);
        const tokenType = (KEYWORDS as any)[stringValue];
        if (tokenType === undefined) {
            this.setCurrent({ 
                type: TokenType.IDENTIFIER, 
                value: stringValue,
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
        else {
            this.setCurrent({ 
                type: tokenType, 
                line: this.curTokenLine!,
                column: this.curTokenColumn!,
                string: stringValue,
            }); 
        }
    }

    //
    // Reads the characters of a string literal.
    //
    private stringLiteral() {
        while (true) {
            const ch = this.peek();
            if (ch === undefined) {
                // End of file!
                this.raiseError({
                    msg: ""Unterminated string literal."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            if (ch === ""\n"") {
                // End of file!
                this.raiseError({
                    msg: ""String literal was terminated by a new line."",
                    line: this.curTokenLine!,
                    column: this.curTokenColumn!,
                });
                break;
            }
            this.advance();
            if (ch === ""\"""") {
                break; // End of string literal.
            }
        }

        const value = this.code.substring(this.curTokenStart! + 1, this.curPosition - 1);

        this.setCurrent({ 
            type: TokenType.STRING, 
            value: value,
            line: this.curTokenLine!,
            column: this.curTokenColumn!,
            string: value,
        }); 
    }
}<fim_middle>",correct,1757
void,void,c638aa7811a23127f92dc64cfed37e179ef1cc7f,"<fim_prefix>export const Kind = 'Core#Thing';

/**
 * An interface describing a base metadata of a thing.
 */
export declare interface IThing {
  /**
   * The data kind. The application ignores the input with an unknown `kind`, unless it can be determined from the context.
   */
  kind?: typeof Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;
}

export class Thing {
  kind = Kind;
  /**
   * The name of the thing.
   */
  name?: string;
  /**
   * Optional value to overwrite the `name` in the UI.
   * The primary descriptive field is the `name`. The display name is only used in the presentation of the data.
   */
  displayName?: string;
  /**
   * The description of the thing.
   */
  description?: string;
  /**
   * The version number of the thing.
   */
  version?: string;

  /**
   * Returns one in this order:
   * - displayName
   * - name
   * - 'Unnamed object'
   */
  get renderLabel() {
    return this.displayName || this.name || 'Unnamed object';
  }

  /**
   * Creates a basic description from a name.
   */
  static fromName(name) {
    const thing = new Thing({
      name,
      kind: Kind,
    });
    return thing;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IThing;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not a thing.
   */
  new(init): <fim_suffix> {
    if (!Thing.isThing(init)) {
      throw new Error(`Not a thing.`);
    }
    const { description, name, version, displayName } = init;
    this.kind = Kind;
    this.name = name;
    this.displayName = displayName;
    this.description = description;
    this.version = version;
  }

  /**
   * Checks whether the input is a definition of a server.
   */
  static isThing(input) {
    const typed = input as IThing;
    if (input && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IThing = {
      kind: Kind,
    };
    if (typeof this.name === 'string') {
      result.name = this.name;
    }
    if (typeof this.displayName === 'string') {
      result.displayName = this.displayName;
    }
    if (this.description) {
      result.description = this.description;
    }
    if (this.version) {
      result.version = this.version;
    }
    return result;
  }
}
<fim_middle>",correct,1809
void,void,c6df44611ee0c019489696962b3397f9bec5493b,"<fim_prefix>const profilePattern =
  /(?:^\[(\d+)\][ |]*(#\w+) (\d+)\/(\d+)$)|(?:^\[(\d+)\][ |]*([^(]+)\((\d+)\/(\d+)\) - ([\d.]+)%\/([\d.]+)%$)/;
const startPattern = /--- BEGIN PROFILE DUMP ---/;
const endPattern = /--- END PROFILE DUMP ---/;

export class ProfileReport {
  root: ProfileLine = new Root();
  constructor(text) {
    this.parseProfileReport(text);
  }

  private parseProfileReport(text): <fim_suffix> {
    const lines = text.split(/\r?\n/);
    let parent: ProfileLine = this.root;
    let previous: ProfileLine = this.root;
    let lastLevel = 0;
    let foundStart = false;
    for (const line of lines) {
      if (!foundStart) {
        if (!startPattern.exec(line)) continue;
        foundStart = true;
        continue;
      }
      if (endPattern.exec(line)) break;
      let m;
      if ((m = profilePattern.exec(line)) != null) {
        const level = parseInt(m[1] ?? m[5], 10);
        if (level < lastLevel) {
          while (level <= parent.level && parent != this.root)
            parent = parent.parent;
        } else if (level > lastLevel) {
          parent = previous;
        }
        lastLevel = level;

        let current;
        if (m[1]) {
          // counter
          current = {
            parent,
            text: m[2],
            children: [],
            level,
            num1: parseInt(m[3]),
            num2: parseInt(m[4]),
          } as CounterLine;
        } else if (m[5]) {
          // pct
          current = {
            parent,
            text: m[6],
            children: [],
            level,
            num1: parseInt(m[7]),
            num2: parseInt(m[8]),
            pctParent: parseFloat(m[9]),
            pctTotal: parseFloat(m[10]),
          } as PctLine;
        } else continue;

        parent.children.push(current);
        previous = current;
      }
    }
  }
}

// [00] tick (86/1)      - 95.17%/95.17%
// ---- text (num1/num2) - pctParent / ptcTotal

export interface ProfileLine {
  parent: ProfileLine;
  level: number;
  children: ProfileLine[];
  text: string;
}

class Root implements ProfileLine {
  parent = this;
  level = -1;
  children: ProfileLine[] = [];
  text = 'Profile Report';
}

export interface PctLine extends ProfileLine {
  parent: ProfileLine;
  num1: number;
  num2: number;
  pctParent: number;
  pctTotal: number;
}

export interface CounterLine extends ProfileLine {
  parent: ProfileLine;
  num1: number;
  num2: number;
}
<fim_middle>",correct,1933
void,void,cad75d6e0e19940214d2e23030bb2088464397b3,"<fim_prefix>export const Kind = 'Core#RequestTime';

/**
 * Schema definition for API Client request timings. This is mostly consistent with HAR timings.
 */
export interface IRequestTime {
  kind?: typeof Kind;
  connect: number;
  receive: number;
  send: number;
  wait: number;
  blocked: number;
  dns: number;
  ssl?: number;
}


export class RequestTime {
  kind = Kind;
  connect = -1;
  receive = -1;
  send = -1;
  wait = -1;
  blocked = -1;
  dns = -1;
  ssl?: number;

  /**
   * @param input The timings definition used to restore the state.
   */
  constructor(input?) {
    let init: IRequestTime;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        connect: -1,
        receive: -1,
        send: -1,
        wait: -1,
        blocked: -1,
        dns: -1,
      };
    }
    this.new(init);
  }

  /**
   * Creates a new timing clearing anything that is so far defined.
   */
  new(init): <fim_suffix> {
    const { connect=-1, receive=-1, send=-1, wait=-1, blocked=-1, dns=-1, ssl=-1 } = init;
    this.kind = Kind;
    this.connect = connect;
    this.receive = receive;
    this.send = send;
    this.wait = wait;
    this.blocked = blocked;
    this.dns = dns;
    this.ssl = ssl;
  }

  toJSON() {
    const result: IRequestTime = {
      kind: Kind,
      connect: this.connect,
      receive: this.receive,
      send: this.send,
      wait: this.wait,
      blocked: this.blocked,
      dns: this.dns,
    };
    if (typeof this.ssl === 'number') {
      result.ssl = this.ssl;
    }
    return result;
  }

  total() {
    let result = 0;
    if (typeof this.connect === 'number' && this.connect > 0) {
      result += this.connect;
    }
    if (typeof this.receive === 'number' && this.receive > 0) {
      result += this.receive;
    }
    if (typeof this.send === 'number' && this.send > 0) {
      result += this.send;
    }
    if (typeof this.wait === 'number' && this.wait > 0) {
      result += this.wait;
    }
    if (typeof this.blocked === 'number' && this.blocked > 0) {
      result += this.blocked;
    }
    if (typeof this.dns === 'number' && this.dns > 0) {
      result += this.dns;
    }
    if (typeof this.ssl === 'number' && this.ssl > 0) {
      result += this.ssl;
    }
    return result;
  }
}
<fim_middle>",correct,2031
void,void,c5f60702c43becf44a23804b3ee1c09511c1e323,"<fim_prefix>export interface TreeNode<TData, TId = string> {
  id: TId;
  data: TData;
  children?: TreeNode<TData, TId>[];
}

export interface TreeSearchEntry<TData, TId = string> {
  node: TreeNode<TData, TId>;
  parents: TreeNode<TData, TId>[];
}

/**
 * Performs a preorder traversal over a tree, and runs a callback for each node.
 *
 * @param root - Root node to traverse, representing a tree
 * @param callback - The callback to run for each node
 */
export function treeTraverse<TData, TId = string>(
  root,
  callback
): <fim_suffix> {
  const nodesToTraverse: TreeNode<TData, TId>[] = [root];
  let currentNode: TreeNode<TData, TId> | undefined;
  while ((currentNode = nodesToTraverse.shift())) {
    callback(currentNode);
    if (currentNode.children) {
      nodesToTraverse.push(...currentNode.children);
    }
  }
}

/**
 * Performs a breadth-first-search over a tree, and returns the found node and the list of parent
 * nodes, or null if the node could not be found.
 *
 * @param id - The ID of the node being searched for
 * @param root - Root node to search, representing a tree
 * @returns A search entry containing the found node and the list of parent nodes, or null if the
 * node could not be found
 */
export function treeSearch<TData, TId = string>(
  id,
  root
) {
  const searchEntries: TreeSearchEntry<TData, TId>[] = [
    {
      node: root,
      parents: [],
    },
  ];
  let found = false;
  let currentSearchEntry: TreeSearchEntry<TData, TId> | undefined;
  while (!found && (currentSearchEntry = searchEntries.shift())) {
    const { node, parents } = currentSearchEntry;
    if (node.id === id) {
      found = true;
    } else if (node.children) {
      searchEntries.push(
        ...node.children.map((childNode) => ({ node: childNode, parents: [...parents, node] }))
      );
    }
  }

  if (found && currentSearchEntry) {
    return currentSearchEntry;
  } else {
    return null;
  }
}

/**
 * Updates a node in a tree with the following invariants:
 * - No node is mutated
 * - No node's list of children is mutated
 * - If a child of a node was updated, the parent is updated with a new reference
 *
 * The result of this function is a copy of the root nodes where only the branch that received the
 * update contains new references.
 *
 * @param id - The ID of the target node
 * @param root - A root node representing a tree containing the target node
 * @param update - An updater function for the target node
 * @returns A copy of the root node where the target node and its parents have been updated
 */
export function updateTreeNode<TData, TId = string>(
  id,
  root,
  update
) {
  const searchResult = treeSearch(id, root);
  if (!searchResult) {
    throw new Error(`Could not find tree node with id ""${String(id)} while trying to update""`);
  }

  const { node, parents } = searchResult;
  const updatedNode = update(node);

  let currentNode = updatedNode;
  let currentParent;
  while ((currentParent = parents.pop())) {
    currentParent = {
      ...currentParent,
      // Replace modified node in children list
      children: currentParent.children?.map((childNode) =>
        childNode.id === currentNode.id ? currentNode : childNode
      ),
    };
    currentNode = currentParent;
  }

  // Current node should now be the modified root parent, so replace it in the root node list and
  // return the list.
  return currentNode;
}
<fim_middle>",correct,2144
void,void,76a884ba965e8d7964d8852a0c0f228c1ae1d7ad,"<fim_prefix>type Language = 'en' | 'zh';

type Terms = {
  selfPick: string;
  noFlowers: string;
  flowers: string;
  commonHand: string;
  fullyConcealedHand: string;
  seatWind: string;
  roundWind: string;
  dragons: string;
  mixedOrphans: string;
  winByLastCatch: string;
  robbingKong: string;
  oneCompleteSetOfFlowers: string;
  twoCompleteSetOfFlowers: string;
  winByKong: string;
  mixedOneSuit: string;
  allInTriplets: string;
  flowerHand: string;
  smallDragon: string;
  allOneSuit: string;
  smallWind: string;
  greatDragon: string;
  greatWind: string;
  allHonors: string;
  orphans: string;
  thirteenOrphans: string;
  kaanKaanHand: string;
  winByDoubleKong: string;
  eightImmortalsCrossingTheSea: string;
  allKongs: string;
  nineGates: string;
  earthlyHand: string;
  heavenlyHand: string;
};

export default class Glossary {
  private static readonly CHINESE_MAP: Terms = {
    selfPick: '自摸',
    noFlowers: '無花',
    flowers: '正花',
    commonHand: '平糊',
    fullyConcealedHand: '門前清',
    seatWind: '門風',
    roundWind: '圈風',
    dragons: '中/發/白',
    mixedOrphans: '花幺',
    winByLastCatch: '海底撈月',
    robbingKong: '搶槓',
    oneCompleteSetOfFlowers: '一台花',
    twoCompleteSetOfFlowers: '兩台花',
    winByKong: '槓上自摸',
    mixedOneSuit: '混一色',
    allInTriplets: '對對糊',
    flowerHand: '花糊',
    smallDragon: '小三元',
    allOneSuit: '清一色',
    smallWind: '小四喜',
    greatDragon: '大三元',
    greatWind: '大四喜',
    allHonors: '字一色',
    orphans: '全幺九',
    thirteenOrphans: '十三幺',
    kaanKaanHand: '坎坎糊',
    winByDoubleKong: '槓上槓自摸',
    eightImmortalsCrossingTheSea: '八仙過海',
    allKongs: '十八羅漢',
    nineGates: '九子連環',
    earthlyHand: '地糊',
    heavenlyHand: '天糊',
  };

  private static readonly ENGLISH_MAP: Terms = {
    selfPick: 'self-pick',
    noFlowers: 'no flowers',
    flowers: 'flowers matching seat position',
    commonHand: 'common hand',
    fullyConcealedHand: 'fully concealed hand',
    seatWind: 'seat wind',
    roundWind: 'round wind',
    dragons: 'dragons',
    mixedOrphans: 'mixed orphans',
    winByLastCatch: 'win by last catch',
    robbingKong: 'robbing kong',
    oneCompleteSetOfFlowers: 'one complete set of flowers',
    twoCompleteSetOfFlowers: 'two complete set of flowers',
    winByKong: 'win by Kong',
    mixedOneSuit: 'mixed one suit',
    allInTriplets: 'all in triplets',
    flowerHand: 'flower hand',
    smallDragon: 'small dragon',
    allOneSuit: 'all one suit',
    smallWind: 'small wind',
    greatDragon: 'great dragon',
    greatWind: 'great wind',
    allHonors: 'all honors',
    orphans: 'orphans',
    thirteenOrphans: 'thirteen orphans',
    kaanKaanHand: 'kaan kaan hand',
    winByDoubleKong: 'win by double Kong',
    eightImmortalsCrossingTheSea: 'eight immortals crossing the sea',
    allKongs: 'all Kongs',
    nineGates: 'nine gates',
    earthlyHand: 'earthly hand',
    heavenlyHand: 'heavenly hand',
  };

  private static language: Language = 'en';

  public static get() {
    if (this.language === 'en') {
      return this.ENGLISH_MAP;
    } else if (this.language === 'zh') {
      return this.CHINESE_MAP;
    } else {
      throw new Error('Language setting has not been configured appropriately.');
    }
  }

  public static setLanguage(languageInput): <fim_suffix> {
    if (languageInput === 'zh' || languageInput === 'en') {
      this.language = languageInput;
    } else {
      throw new Error('Invalid input of language setting.');
    }
  }
}
<fim_middle>",correct,2147
void,void,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data): <fim_suffix>=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2312
void,void,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false): <fim_suffix>=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2315
void,void,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn): <fim_suffix>=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2326
void,void,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?): <fim_suffix>=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2328
void,void,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function () {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?): <fim_suffix>=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2331
void,void,692b6650dfaec64762a5a63c3ed9a70a95671b5f,"<fim_prefix>interface busEv{
    name:string,
    isOnce:boolean,
    callback:Function;
}
/**
 * 自定义的事件总线
 * 方法: 
 * on: 绑定一个事件
 * once: 绑定一个一次性事件
 * off: 移除一个事件
 * emit: 触发一个事件
 * use: 添加一个中间件
 */
export class EventBus{
    //事件列表
    public eventArr:Array<any> = [];
    //添加的中间件列表
    public useFunArr:any[] = [];
    constructor(){

    }

    public eventTpl:busEv = {
        name: """", //事件名
        isOnce: false, //是否只执行一次
        //回调
        callback: function (): <fim_suffix> {
        
        }
    }
    
    /**
     * 创建一个事件
     * @param {String} name 
     * @param {Function} callback 
     * @return {eventTpl}
     */
    private createEvent = (name, callback)=>{
        let e:busEv = {
            name: name, //事件名
            isOnce: false, //是否只执行一次
            callback: callback //回调
        }
        return e;
    }

    /**
     * 获取事件
     * @param {String} name 
     * @param {Function} fn 
     * @return {eventTpl}
     */
    private getEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        return this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
                b = b && e.fn === fn;
            }
            return b;
        })
    }

    /**
     * 移除一个事件
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    private removeEvent = (name, fn?)=>{
        let matchFn:any = fn && typeof fn == 'function';
        this.eventArr = this.eventArr.filter((e) => {
            let b = e.name === name;
            if (matchFn) {
            b = b && e.fn === fn;
            }
            return !b;
        })
    }

    /**
     * 移除一个事件, 同removeEvent
     * @param {String} name 
     * @param {Function} fn fn为空则全部移除
     * @return {void}
     */
    public off = (name, fn?)=>{
        this.removeEvent(name, fn);
    }

    /**
     * 添加中间件
     * @param {function(string, object, ()=>{})} fn 中间件函数 fn(name, packet, next)
     * @return {void}
     */
    private use = (fn)=>{
        this.useFunArr.push(fn)
    }

    /**
     * 中间件过滤, 只有添加的中间件执行next(),
     * 才会触发下一个中间件, 
     * 否则终止触发事件
     * @param {String} name 触发事件名
     * @param {Object} packet 触发事件传入的数据
     * @return {boolean} b
     */
    private useFilter = (name, packet)=>{
        let useFunArr:Array<any> = this.useFunArr;
        let len:number = useFunArr.length;
        let index:number = 0;
        if (len) {
            //从第一个中间件开始执行
            useFunArr[0](name, packet, next);
            //执行过的中间件与中间件总数相比较
            if (index === len - 1) {
                return true;
            } else {
                return false;
            }
        }
        return true;
        
        function next() {
            //每执行一个中间件,指数+1
            index++;
            if (index < len) {
                useFunArr[index](name, packet, next);
            }
        }
    }

    /**
     * 添加事件
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {eventTpl}
     */
    public on = (name, fn, cover = false)=>{
        let ev:busEv = this.createEvent(name, fn);
        if (cover) {
            let eventArr = this.getEvent(name);
            if (eventArr.length > 0) {
                this.removeEvent(name);
            }
        }
        this.eventArr.push(ev);
        return ev;
    }

    /**
     * 添加事件, 执行完立即立即销毁
     * @param {String} name 事件名
     * @param {Function} fn 执行的事件函数
     * @param {boolean} cover 是否覆盖之前的事件
     * @return {void}
     */
    public once = (name, fn, cover = false)=>{
        let ev:busEv = this.on(name, fn, cover);
        ev.isOnce = true;
    }

    /**
     * 触发一个事件
     * @param {String} name 事件名
     * @param {Object} data 传入事件监听方法的数据
     * @return {void}
     */
    public emit = (name, data)=> {
        let eventArr:Array<any> = this.getEvent(name);
        let b:boolean = this.useFilter(name, data);
        if (!b) {
            return;
        }
        let len:number = eventArr.length,
            ev:busEv;
        for (let i = 0; i < len; i++) {
            ev = eventArr[i];
            //执行监听的事件
            if (typeof ev.callback === 'function') {
                let b = ev.callback(data);
                if (ev.isOnce) {
                    this.removeEvent(ev.name);
                }
                if (typeof b != 'undefined' && b === false) {
                    return;
                }
            }
        }
    }
}<fim_middle>",correct,2340
void,void,63546d468176bc6f54323adf83e96b4e7d5a7cf9,"<fim_prefix>/**
 * @packageDocumentation
 * @module main
 */

/** A dataset containing all the data to be displayed. */
export interface Dataset {
    /** metadata for this dataset */
    meta: Metadata;
    /**
     * List of structures in the dataset.
     *
     * The structures can either follow the `Structure` interface, in which
     * case they will be loaded as-defined; or contain any kind of data as a
     * [[UserStructure]], in which case the [[ViewersGrid.loadStructure]]
     * callback should be set to translate from whatever is stored to a
     * [[Structure]].
     */
    structures: Structure[] | UserStructure[];
    /**
     * List of properties for the structures (`target == ""structure""`), or
     * atom-centered environments in the structures (`target == ""atom""`).
     *
     * For structure properties, the `values` array of the property should have
     * the same size as the [[Dataset.structures|structure list]].
     *
     * For atomic properties, the `values` array of the property should have
     * the same size as the [[Dataset.environments|environments list]].
     */
    properties: { [name: string]: Property };
    /**
     * List of atom-centered environments in the dataset.
     *
     * Currently, the code assumes that every atom is associated with an
     * environment. This may change in the future.
     */
    environments?: Environment[];
    /** Settings for visualization of this dataset */
    settings?: Partial<Settings>;
}

/**
 * Type definition for settings that can be saved with a dataset. THey should be
 * a simple object with string keys, scalar values, array values or nested
 * Settings objects.
 */
// eslint-disable-next-line @typescript-eslint/no-empty-interface
export interface Settings
    extends Record<
        string,
        string | string[] | number | number[] | boolean | boolean[] | Settings | Settings[]
    > {}

/** Various metadata associated with a dataset */
export interface Metadata {
    /** dataset name */
    name: string;
    /** authors of the dataset */
    authors?: string[];
    /** academic references related to this dataset */
    references?: string[];
    /** description of the dataset */
    description?: string;
}

/** A single atomic structure */
export interface Structure {
    /** Number of atoms in the structure */
    size: number;
    /** Names of all atoms in the structure */
    names: string[];
    /**
     * x position (cartesian coordinate) of all atoms in the structure
     *
     * This array should have the same size as [[Structure.names]], and contain
     * values expressed in Angströms.
     */
    x: number[];
    /**
     * y position (cartesian coordinate) of all atoms in the structure
     *
     * This array should have the same size as [[Structure.names]], and contain
     * values expressed in Angströms.
     */
    y: number[];
    /**
     * z position (cartesian coordinate) of all atoms in the structure
     *
     * This array should have the same size as [[Structure.names]], and contain
     * values expressed in Angströms.
     */
    z: number[];
    /**
     * Unit cell of the system, given as `[ax ay az bx by bz cx cy cz]`, where
     * **a**, **b**, and **c** are the unit cell vectors. All values should be
     * expressed in Angströms.
     */
    cell?: number[];
}

/**
 * User-defined data to allow dynamic loading of the structures.
 *
 * The main use-case of this is making the initial loading time of chemiscope
 * faster by loading structure on-demand, from files, a database or even a
 * javascript program.
 */
export interface UserStructure {
    /** Number of atoms in the structure */
    size: number;
    /**
     * User-defined data which can be turned into a [[Structure]].
     *
     * [[ViewersGrid.loadStructure]] must be set to be able to load this
     * data.
     */
    data: unknown;
}

/** Possible types of properties: full structure property, or atomic property */
export type Target = 'structure' | 'atom';

/**
 * A single property in a dataset.
 *
 * Properties can be physical properties (energy, number of atoms, density,
 * *etc.*); values associated with the structure (such as SOAP vectors),
 * projected onto a lower dimensionality sub-space (through PCA or any other
 * algorithm); or any other value associated with every structure/environment in
 * the dataset.
 */
export interface Property {
    /** is this property associated with a full structure or a single atom? */
    target: Target;
    /**
     * values of the property
     *
     * string values should represent classification results (category ""A"", ""B""
     * or ""C""); and numeric values should be use for everything else.
     */
    values: string[] | number[];
    /** user-facing description of the property */
    description?: string;
    /** unit of the property values */
    units?: string;
}

/**
 * An atom-centered environment.
 *
 * Currently, only spherical (i.e. cutoff-based) environments are supported
 */
export interface Environment {
    /** Index of the related structure in [[Dataset.structures]] */
    structure: number;
    /** Index of the central atom in the structure, 0-based */
    center: number;
    /** Spherical cutoff radius, expressed in Angströms */
    cutoff: number;
}

/** Arbitrary javascript object, to be validated */
export type JsObject = Record<string, unknown>;

/** @hidden
 * Check that the given object, potentially comming from javascript, has all
 * required properties to be a dataset.
 */
export function validateDataset(o): <fim_suffix> {
    if (typeof o !== 'object') {
        throw Error('the dataset must be a JavaScript object');
    }

    if (!('meta' in o)) {
        throw Error('missing ""meta"" key in the dataset');
    } else if (!(typeof o.meta === 'object' && o.meta !== null)) {
        throw Error('""meta"" must be an object in the dataset');
    }
    checkMetadata(o.meta as JsObject);

    if (!('structures' in o)) {
        throw Error('missing ""structures"" key in the dataset');
    } else if (!Array.isArray(o.structures)) {
        throw Error('""structures"" must be an array in the dataset');
    }
    const [structureCount, atomsCount] = checkStructures(o.structures as JsObject[]);

    let envCount = atomsCount;
    if ('environments' in o) {
        if (!Array.isArray(o.environments)) {
            throw Error('""environments"" must be an array in the dataset');
        }

        envCount = o.environments.length;
        checkEnvironments(
            o.environments as JsObject[],
            o.structures as (Structure | UserStructure)[]
        );
    }

    if (!('properties' in o)) {
        throw Error('missing ""properties"" key in then dataset');
    } else if (!(typeof o.properties === 'object' && o.properties !== null)) {
        throw Error('""properties"" must be an object in the dataset');
    }

    checkProperties(o.properties as Record<string, JsObject>, structureCount, envCount);
}

function checkMetadata(o) {
    if (!('name' in o)) {
        throw Error('missing ""meta.name"" key in the dataset');
    } else if (typeof o.name !== 'string') {
        throw Error('""meta.name"" must be a string in the dataset');
    }

    if ('description' in o && typeof o.description !== 'string') {
        throw Error('""meta.description"" should be a string in the dataset');
    }

    if ('authors' in o) {
        if (!Array.isArray(o.authors)) {
            throw Error('""meta.authors"" must be an array in the dataset');
        }

        for (const a of o.authors) {
            if (typeof a !== 'string') {
                throw Error('""meta.authors"" must be an array of strings in the dataset');
            }
        }
    }

    if ('references' in o) {
        if (!Array.isArray(o.references)) {
            throw Error('""meta.references"" must be an array in the dataset');
        }

        for (const a of o.references) {
            if (typeof a !== 'string') {
                throw Error('""meta.references"" must be an array of strings in the dataset');
            }
        }
    }
}

function checkStructures(o) {
    let atomsCount = 0;
    for (let i = 0; i < o.length; i++) {
        const structure = o[i];
        if (
            !(
                'size' in structure &&
                typeof structure.size === 'number' &&
                isPositiveInteger(structure.size)
            )
        ) {
            throw Error(`missing 'size' for structure ${i}`);
        }
        atomsCount += structure.size;

        if ('data' in structure) {
            // user-specified structure, nothing to do
        } else {
            const message = checkStructure(structure);
            if (message !== '') {
                throw Error(`error in structure ${i}: ${message}`);
            }
        }
    }

    return [o.length, atomsCount];
}

/**
 * Check that the given object is a structure. Return a string describing the
 * issue with `s` if any, or the empty string if `s` looks like a valid
 * structure.
 */
export function checkStructure(s) {
    if (typeof s !== 'object') {
        throw Error('the structure must be a JavaScript object');
    }

    if (!('size' in s && typeof s.size === 'number' && isPositiveInteger(s.size))) {
        return 'missing ""size""';
    }

    for (const key of ['names', 'x', 'y', 'z']) {
        if (!(key in s)) {
            return `missing ""${key}""`;
        }
        const array = s[key];
        if (!Array.isArray(array)) {
            return `""${key}"" must be an array`;
        }

        if (s.size > 0 && array.length !== s.size) {
            return `wrong size for ""${key}"", expected ${s.size}, got ${array.length}`;
        }
    }

    if ('cell' in s) {
        if (!(Array.isArray(s.cell) && s.cell.length === 9)) {
            return '""cell"" must be an array of size 9';
        }
    }

    return '';
}

function checkProperties(
    properties,
    structureCount,
    envCount
) {
    for (const key in properties) {
        const property = properties[key];

        if (!('target' in property && typeof property.target === 'string')) {
            Error(`'properties['${key}'].target' should be a string`);
        }

        if (property.target !== 'atom' && property.target !== 'structure') {
            throw Error(`'properties['${key}'].target', should be 'atom' | 'structure'`);
        }

        if (!('values' in property && Array.isArray(property.values))) {
            throw Error(`'properties[""${key}""].values' should be an array`);
        }

        // check size if possible
        let expected = 0;
        if (property.target === 'atom') {
            expected = envCount;
        } else if (property.target === 'structure') {
            expected = structureCount;
        }

        if (expected > 0 && property.values.length !== expected) {
            throw Error(
                `wrong size for 'properties['${key}'].values': expected ${expected}, got ${property.values.length}`
            );
        }

        const initial = typeof property.values[0];
        if (initial !== 'string' && initial !== 'number') {
            throw Error(`'properties['${key}'].values' should contain string or number`);
        }

        for (const value of property.values) {
            if (typeof value !== initial) {
                throw Error(`'properties['${key}'].values' should be of a single type`);
            }
        }

        // check that units & description are valid
        if ('description' in property && typeof property.description !== 'string') {
            throw Error(`'properties['${key}'].description' should contain a string`);
        }

        if ('units' in property && typeof property.units !== 'string') {
            throw Error(`'properties['${key}'].units' should contain a string`);
        }
    }
}

function checkEnvironments(o, structures) {
    for (let i = 0; i < o.length; i++) {
        const env = o[i];

        if (!('structure' in env && typeof env.structure === 'number')) {
            throw Error(`missing 'structure' for environment ${i}`);
        }

        if (!isPositiveInteger(env.structure) || env.structure >= structures.length) {
            throw Error(
                `out of bounds 'structure' for environment ${i}: index is \
                ${env.structure}, we have ${structures.length} structures`
            );
        }

        if (!('center' in env && typeof env.center === 'number')) {
            throw Error(`missing 'center' for environment ${i}`);
        }

        const size = structures[env.structure].size;
        if (!isPositiveInteger(env.center) || env.center >= size) {
            throw Error(
                `out of bounds 'center' for environment ${i}: index is \
                ${env.center}, we have ${size} atoms in structure ${env.structure}`
            );
        }

        if (!('cutoff' in env && typeof env.cutoff === 'number')) {
            throw Error(`missing 'cutoff' for environment ${i}`);
        }
    }
}

function isPositiveInteger(number) {
    return Number.isInteger(number) && number >= 0;
}
<fim_middle>",correct,2369
void,void,f7f098de6ce0870153a7af6a953c190cf705eb1b,"<fim_prefix>export interface OrderedListEntry<T>
{
  prev: OrderedListEntry<T>;
  next: OrderedListEntry<T>;
  value: T;
}

export type OrderedListIndex<T> = { [key: string]: OrderedListEntry<T> };

export class OrderedList<T>
{
  head: OrderedListEntry<T>;
  tail: OrderedListEntry<T>;
  index: OrderedListIndex<T>;

  constructor()
    {
      this.clear();
    }

  isempty()
    {
      return this.head == null;
    }

  clear()
    {
      this.head = null;
      this.tail = null;
      this.index = {};
    }

  insert(key, value)
    {
      if (this.index[key] !== undefined)
        return `memsqs: send: message uid ${key} already exists`;

      let e: OrderedListEntry<T> = { prev: this.tail, next: null, value: value };
      if (this.tail)
        this.tail.next = e;
      this.tail = e;
      if (this.head === null)
        this.head = e;
      this.index[key] = e;
      return null;
    }

  remove(key)
    {
      let e = this.index[key];
      if (e === undefined)
        return `memsqs: remove: message uid ${key} does not exist`;

      if (e === this.tail)
        this.tail = e.prev;
      else
        e.next.prev = e.prev;

      if (e === this.head)
        this.head = e.next;
      else
        e.prev.next = e.next;

      delete this.index[key];

      return null;
    }

  forEach(cb): <fim_suffix>
    {
      for (let p = this.head; p && cb(p.value); p = p.next)
        continue;
    }
}
<fim_middle>",correct,2491
void,void,f7f098de6ce0870153a7af6a953c190cf705eb1b,"<fim_prefix>export interface OrderedListEntry<T>
{
  prev: OrderedListEntry<T>;
  next: OrderedListEntry<T>;
  value: T;
}

export type OrderedListIndex<T> = { [key: string]: OrderedListEntry<T> };

export class OrderedList<T>
{
  head: OrderedListEntry<T>;
  tail: OrderedListEntry<T>;
  index: OrderedListIndex<T>;

  constructor()
    {
      this.clear();
    }

  isempty()
    {
      return this.head == null;
    }

  clear(): <fim_suffix>
    {
      this.head = null;
      this.tail = null;
      this.index = {};
    }

  insert(key, value)
    {
      if (this.index[key] !== undefined)
        return `memsqs: send: message uid ${key} already exists`;

      let e: OrderedListEntry<T> = { prev: this.tail, next: null, value: value };
      if (this.tail)
        this.tail.next = e;
      this.tail = e;
      if (this.head === null)
        this.head = e;
      this.index[key] = e;
      return null;
    }

  remove(key)
    {
      let e = this.index[key];
      if (e === undefined)
        return `memsqs: remove: message uid ${key} does not exist`;

      if (e === this.tail)
        this.tail = e.prev;
      else
        e.next.prev = e.prev;

      if (e === this.head)
        this.head = e.next;
      else
        e.prev.next = e.next;

      delete this.index[key];

      return null;
    }

  forEach(cb)
    {
      for (let p = this.head; p && cb(p.value); p = p.next)
        continue;
    }
}
<fim_middle>",correct,2498
void,void,ccee70850d7be59ff29044ffd01e8ec90a3de543,"<fim_prefix>// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

// to suit your point format, run search/replace for '[0]' and '[1]';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

type Point = [number, number];

// square distance between 2 points
const getSqDist = (p1, p2) => {
  const dx = p1[0] - p2[0];
  const dy = p1[1] - p2[1];
  return dx * dx + dy * dy;
};

// square distance from a point to a segment
const getSqSegDist = (p, p1, p2) => {
  let [x, y] = p1;
  let dx = p2[0] - x;
  let dy = p2[1] - y;
  if (dx !== 0 || dy !== 0) {
    const t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);
    if (t > 1) {
      [x, y] = p2;
    } else if (t > 0) {
      x += dx * t;
      y += dy * t;
    }
  }
  dx = p[0] - x;
  dy = p[1] - y;
  return dx * dx + dy * dy;
};
// rest of the code doesn't care about point format

// basic distance-based simplification
const simplifyRadialDist = (points, sqTolerance) => {
  if (points.length === 0) return [];

  let prevPoint = points[0];
  const newPoints = [prevPoint];
  let point: Point | null = null;

  points.forEach((d) => {
    point = d;
    if (getSqDist(point, prevPoint) > sqTolerance) {
      newPoints.push(point);
      prevPoint = point;
    }
  });

  if (prevPoint !== point) newPoints.push(point as unknown as Point);

  return newPoints;
};

const simplifyDPStep = (
  points,
  first,
  last,
  sqTolerance,
  simplified,
): <fim_suffix> => {
  let maxSqDist = sqTolerance;
  let index: number | null = null;

  for (let i = first + 1; i < last; i += 1) {
    const sqDist = getSqSegDist(points[i], points[first], points[last]);
    if (sqDist > maxSqDist) {
      index = i;
      maxSqDist = sqDist;
    }
  }

  if (maxSqDist > sqTolerance) {
    if ((index as number) - first > 1) {
      simplifyDPStep(points, first, (index as number), sqTolerance, simplified);
    }
    simplified.push(points[(index as number)]);
    if (last - (index as number) > 1) {
      simplifyDPStep(points, (index as number), last, sqTolerance, simplified);
    }
  }
};

// simplification using Ramer-Douglas-Peucker algorithm
const simplifyDouglasPeucker = (points, sqTolerance) => {
  const last = points.length - 1;

  const simplified = [points[0]];
  simplifyDPStep(points, 0, last, sqTolerance, simplified);
  simplified.push(points[last]);

  return simplified;
};

// both algorithms combined for awesome performance
export default (
  points,
  tolerance,
  highestQuality,
) => {
  if (points.length <= 2) return points;

  const sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;
  let simplified = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
  simplified = simplifyDouglasPeucker(points, sqTolerance);
  return simplified;
};
<fim_middle>",correct,2563
void,void,8c4ad7d6f662a709157f365f3614556f753aa573,"<fim_prefix>/** 
 * Copyright 2016 Jim Armstrong (www.algorithmist.net)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Typescript Math Toolkit: Binary heap that is optimized for nodes with a numerical value and optional data.  The
 * structure may be a min- or max-heap and all operations are supported on either type of heap.  A newly constructed
 * TSMT Heap instance is a min-heap.  Use the type accessor to change the heap type.
 *
 * Each heap node contains a numerical value (externally assigned) and optional Object data (refer to HeapData
 * interface).  An empty Object is created for a node's data if none is provided in an insert operation.
 *
 * @author Jim Armstrong (www.algorithmist.net)
 * 
 * @version 1.0
 */

export enum HeapType
{
  MIN,
  MAX
}

export interface HeapData
{
  value: number;
  data: object;
}

export class TSMT$Heap
{
  // node that heap begins at element 1 of the data array

  protected _position!: number;              // current position in array
  protected _data!: Array<HeapData>;         // node data
  protected _type: number;                   // heap type (min or max)

 /**
  * Create a new Heap
  */
  constructor()
  {
    this.clear();

    this._type = HeapType.MIN;
  }

 /**
  * Access the size of the heap
  */
  public get size()
  {
    return this._position;
  }

 /**
  * Access the number of levels in the heap  (the final level may not be complete)
  */
  public get levels()
  {
    if (this._position < 2) return this._position;

    const log2: number = Math.round( Math.log2(this._position) );

    return  this._position >= Math.pow(2,log2) ? log2+1 : log2;
  }

 /**
  * Access the heap type, i.e. {HeapType.MIN} if min-heap or {HeapType.MAX} if max-heaps
  */
  public get type()
  {
    return this._type;
  }

 /**
  * Assign the heap type.  This MUST be performed before any other operation; the heap type may
  * not be changed after data has been addded, although this may be relaxed in the future.
  *
  * @param {number} data: Either {HeapType.MIN} or {HeapType.MAX}
  */
  public set type(data)
  {
    this._type = data === HeapType.MIN || data === HeapType.MAX ? data : this._type;
  }

 /**
  * Construct a heap from a data array
  *
  * @param {Array<HeapData>} data An array of heap data
  */
  public fromArray(data)
  {
    const len: number = data.length;

    if (len > 0)
    {
      this.clear();

      let i: number;
      for (i = 0; i < len; ++i)
      {
        // insert elements sequentially
        this.insert(data[i].value, data[i].data);
      }
    }
  }

 /**
  * Return a (shallow) copy of the heap as an array
  */
  public toArray()
  {
    return this._data.slice().splice(1,this._position);
  }

 /**
  * Insert an element into the heap.  The internal structure is heapified if the value is valid.
  *
  * @param {number} x: Node value
  *
  * @param {object} data Optional data associated with this node
  */
  public insert(x, data?)
  {
    if (isNaN(x) || !isFinite(x)) return;

    const nodeData: object = data || {};

    // no heapify if first value
    if (this._position == 0)
    {
      this._data[1]  = {value: x, data: nodeData};
      this._position = 1;
    }
    else
    {
      this._data[++this._position] = {value: x, data: nodeData};

      // this is already modified to handle min- or max-heap
      this.__heapifyUp();
    }
  }

 /**
  * Examine the root value of the heap without modifying the internal structure.  Returns numerical value of root node, which will be minimum 
  * value for a min-heap and maximum value for a max-heap
  */
  public peek()
  {
    if (this._position > 0)
    {
      // return value of first node
      return <number> this._data[1].value;
    }
    else
    {
      // no data
      return 0;
    }
  }

 /**
  * Extract the root node of the heap or null if the heap is empty
  */
  public extractRoot()
  {
    if (this._data === undefined || this._data.length == 1)  return null;

    const root: HeapData = this._data[1];
    this._data[1]      = this._data[this._position];

    this._position--;

    if (this._position > 1)
    {
      // this call handles min- or max-heap
      this.__heapifyDn(1);
    }

    return root;
  }

 /**
  * Remove a node from the heap based on an input value.  The node with the specified value is searched for (within tolerance).  If found, 
  * that node is deleted and the internal structure is heapified.  Because of the search, the operation is O(n).  Delete is
  * expected to be an infrequent operation, otherwise another structure is likely a better application fit.
  *
  * @param {number} value Numerical value of node to search for and then delete
  */
  public delete(value)
  {
    // arbitrary delete should be an infrequent operation, otherwise a binary heap is not the best choice
    // of data structure.  so, this is not as efficient as it could be with more effort.
    if (this._position == 0)
    {
      // heap is empty; nothing to do
      return;
    }

    // step 1, find
    let index = 0;
    let i: number;

    for (i = 1; i <= this._position; ++i )
    {
      if (Math.abs(value - this._data[i].value) <= 0.0000001)
      {
        index = i;
        break;
      }
    }

    // step 2, remove and heapify if necessary - I don't like this, but again, delete is not a common op. for a
    // binary heap.
    if (index != 0)
    {
      this._data[index] = this._data[this._position];
      this._position--;

      if (this._position <= 1)
      {
        // heap is empty or a singleton; nothing left to do
        return;
      }

      // following already handles min- or max-heap
      this.__heapifyDn(index);
    }
  }

 /**
  * Clear the heap and prepare for new data. The current heap type remains unaltered.
  */
  public clear()
  {
    this._data     = new Array<HeapData>();
    this._position = 0;

    this._data.push( {value: 0, data: {}} );
  }

  protected __heapifyUp()
  {
    let pos: number = this._position;
    let p2: number  = Math.floor(0.5*pos);
    let h: HeapData;

    if (this._type == HeapType.MIN)
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value > <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2] = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
    else
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value < <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2]  = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
  }

  protected __heapifyDn(k): <fim_suffix>
  {
    let minIndex: number;
    let maxIndex: number;
    const left: number  = k + k;
    const right: number = left + 1;

    if (this._type == HeapType.MIN)
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          minIndex = left;
        }
      }
      else
      {
        // compute min-index
        minIndex = (this._data[left].value <= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value > this._data[minIndex].value)
      {
        const tmp: HeapData    = this._data[minIndex];
        this._data[minIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(minIndex);
      }
    }
    else
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          maxIndex = left;
        }
      }
      else
      {
        // compute max-index
        maxIndex = (this._data[left].value >= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value < this._data[maxIndex].value)
      {
        const tmp: HeapData    = this._data[maxIndex];
        this._data[maxIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(maxIndex);
      }
    }
  }
}
<fim_middle>",correct,2637
void,void,8c4ad7d6f662a709157f365f3614556f753aa573,"<fim_prefix>/** 
 * Copyright 2016 Jim Armstrong (www.algorithmist.net)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Typescript Math Toolkit: Binary heap that is optimized for nodes with a numerical value and optional data.  The
 * structure may be a min- or max-heap and all operations are supported on either type of heap.  A newly constructed
 * TSMT Heap instance is a min-heap.  Use the type accessor to change the heap type.
 *
 * Each heap node contains a numerical value (externally assigned) and optional Object data (refer to HeapData
 * interface).  An empty Object is created for a node's data if none is provided in an insert operation.
 *
 * @author Jim Armstrong (www.algorithmist.net)
 * 
 * @version 1.0
 */

export enum HeapType
{
  MIN,
  MAX
}

export interface HeapData
{
  value: number;
  data: object;
}

export class TSMT$Heap
{
  // node that heap begins at element 1 of the data array

  protected _position!: number;              // current position in array
  protected _data!: Array<HeapData>;         // node data
  protected _type: number;                   // heap type (min or max)

 /**
  * Create a new Heap
  */
  constructor()
  {
    this.clear();

    this._type = HeapType.MIN;
  }

 /**
  * Access the size of the heap
  */
  public get size()
  {
    return this._position;
  }

 /**
  * Access the number of levels in the heap  (the final level may not be complete)
  */
  public get levels()
  {
    if (this._position < 2) return this._position;

    const log2: number = Math.round( Math.log2(this._position) );

    return  this._position >= Math.pow(2,log2) ? log2+1 : log2;
  }

 /**
  * Access the heap type, i.e. {HeapType.MIN} if min-heap or {HeapType.MAX} if max-heaps
  */
  public get type()
  {
    return this._type;
  }

 /**
  * Assign the heap type.  This MUST be performed before any other operation; the heap type may
  * not be changed after data has been addded, although this may be relaxed in the future.
  *
  * @param {number} data: Either {HeapType.MIN} or {HeapType.MAX}
  */
  public set type(data)
  {
    this._type = data === HeapType.MIN || data === HeapType.MAX ? data : this._type;
  }

 /**
  * Construct a heap from a data array
  *
  * @param {Array<HeapData>} data An array of heap data
  */
  public fromArray(data)
  {
    const len: number = data.length;

    if (len > 0)
    {
      this.clear();

      let i: number;
      for (i = 0; i < len; ++i)
      {
        // insert elements sequentially
        this.insert(data[i].value, data[i].data);
      }
    }
  }

 /**
  * Return a (shallow) copy of the heap as an array
  */
  public toArray()
  {
    return this._data.slice().splice(1,this._position);
  }

 /**
  * Insert an element into the heap.  The internal structure is heapified if the value is valid.
  *
  * @param {number} x: Node value
  *
  * @param {object} data Optional data associated with this node
  */
  public insert(x, data?)
  {
    if (isNaN(x) || !isFinite(x)) return;

    const nodeData: object = data || {};

    // no heapify if first value
    if (this._position == 0)
    {
      this._data[1]  = {value: x, data: nodeData};
      this._position = 1;
    }
    else
    {
      this._data[++this._position] = {value: x, data: nodeData};

      // this is already modified to handle min- or max-heap
      this.__heapifyUp();
    }
  }

 /**
  * Examine the root value of the heap without modifying the internal structure.  Returns numerical value of root node, which will be minimum 
  * value for a min-heap and maximum value for a max-heap
  */
  public peek()
  {
    if (this._position > 0)
    {
      // return value of first node
      return <number> this._data[1].value;
    }
    else
    {
      // no data
      return 0;
    }
  }

 /**
  * Extract the root node of the heap or null if the heap is empty
  */
  public extractRoot()
  {
    if (this._data === undefined || this._data.length == 1)  return null;

    const root: HeapData = this._data[1];
    this._data[1]      = this._data[this._position];

    this._position--;

    if (this._position > 1)
    {
      // this call handles min- or max-heap
      this.__heapifyDn(1);
    }

    return root;
  }

 /**
  * Remove a node from the heap based on an input value.  The node with the specified value is searched for (within tolerance).  If found, 
  * that node is deleted and the internal structure is heapified.  Because of the search, the operation is O(n).  Delete is
  * expected to be an infrequent operation, otherwise another structure is likely a better application fit.
  *
  * @param {number} value Numerical value of node to search for and then delete
  */
  public delete(value): <fim_suffix>
  {
    // arbitrary delete should be an infrequent operation, otherwise a binary heap is not the best choice
    // of data structure.  so, this is not as efficient as it could be with more effort.
    if (this._position == 0)
    {
      // heap is empty; nothing to do
      return;
    }

    // step 1, find
    let index = 0;
    let i: number;

    for (i = 1; i <= this._position; ++i )
    {
      if (Math.abs(value - this._data[i].value) <= 0.0000001)
      {
        index = i;
        break;
      }
    }

    // step 2, remove and heapify if necessary - I don't like this, but again, delete is not a common op. for a
    // binary heap.
    if (index != 0)
    {
      this._data[index] = this._data[this._position];
      this._position--;

      if (this._position <= 1)
      {
        // heap is empty or a singleton; nothing left to do
        return;
      }

      // following already handles min- or max-heap
      this.__heapifyDn(index);
    }
  }

 /**
  * Clear the heap and prepare for new data. The current heap type remains unaltered.
  */
  public clear()
  {
    this._data     = new Array<HeapData>();
    this._position = 0;

    this._data.push( {value: 0, data: {}} );
  }

  protected __heapifyUp()
  {
    let pos: number = this._position;
    let p2: number  = Math.floor(0.5*pos);
    let h: HeapData;

    if (this._type == HeapType.MIN)
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value > <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2] = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
    else
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value < <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2]  = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
  }

  protected __heapifyDn(k)
  {
    let minIndex: number;
    let maxIndex: number;
    const left: number  = k + k;
    const right: number = left + 1;

    if (this._type == HeapType.MIN)
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          minIndex = left;
        }
      }
      else
      {
        // compute min-index
        minIndex = (this._data[left].value <= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value > this._data[minIndex].value)
      {
        const tmp: HeapData    = this._data[minIndex];
        this._data[minIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(minIndex);
      }
    }
    else
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          maxIndex = left;
        }
      }
      else
      {
        // compute max-index
        maxIndex = (this._data[left].value >= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value < this._data[maxIndex].value)
      {
        const tmp: HeapData    = this._data[maxIndex];
        this._data[maxIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(maxIndex);
      }
    }
  }
}
<fim_middle>",correct,2641
void,void,8c4ad7d6f662a709157f365f3614556f753aa573,"<fim_prefix>/** 
 * Copyright 2016 Jim Armstrong (www.algorithmist.net)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Typescript Math Toolkit: Binary heap that is optimized for nodes with a numerical value and optional data.  The
 * structure may be a min- or max-heap and all operations are supported on either type of heap.  A newly constructed
 * TSMT Heap instance is a min-heap.  Use the type accessor to change the heap type.
 *
 * Each heap node contains a numerical value (externally assigned) and optional Object data (refer to HeapData
 * interface).  An empty Object is created for a node's data if none is provided in an insert operation.
 *
 * @author Jim Armstrong (www.algorithmist.net)
 * 
 * @version 1.0
 */

export enum HeapType
{
  MIN,
  MAX
}

export interface HeapData
{
  value: number;
  data: object;
}

export class TSMT$Heap
{
  // node that heap begins at element 1 of the data array

  protected _position!: number;              // current position in array
  protected _data!: Array<HeapData>;         // node data
  protected _type: number;                   // heap type (min or max)

 /**
  * Create a new Heap
  */
  constructor()
  {
    this.clear();

    this._type = HeapType.MIN;
  }

 /**
  * Access the size of the heap
  */
  public get size()
  {
    return this._position;
  }

 /**
  * Access the number of levels in the heap  (the final level may not be complete)
  */
  public get levels()
  {
    if (this._position < 2) return this._position;

    const log2: number = Math.round( Math.log2(this._position) );

    return  this._position >= Math.pow(2,log2) ? log2+1 : log2;
  }

 /**
  * Access the heap type, i.e. {HeapType.MIN} if min-heap or {HeapType.MAX} if max-heaps
  */
  public get type()
  {
    return this._type;
  }

 /**
  * Assign the heap type.  This MUST be performed before any other operation; the heap type may
  * not be changed after data has been addded, although this may be relaxed in the future.
  *
  * @param {number} data: Either {HeapType.MIN} or {HeapType.MAX}
  */
  public set type(data)
  {
    this._type = data === HeapType.MIN || data === HeapType.MAX ? data : this._type;
  }

 /**
  * Construct a heap from a data array
  *
  * @param {Array<HeapData>} data An array of heap data
  */
  public fromArray(data)
  {
    const len: number = data.length;

    if (len > 0)
    {
      this.clear();

      let i: number;
      for (i = 0; i < len; ++i)
      {
        // insert elements sequentially
        this.insert(data[i].value, data[i].data);
      }
    }
  }

 /**
  * Return a (shallow) copy of the heap as an array
  */
  public toArray()
  {
    return this._data.slice().splice(1,this._position);
  }

 /**
  * Insert an element into the heap.  The internal structure is heapified if the value is valid.
  *
  * @param {number} x: Node value
  *
  * @param {object} data Optional data associated with this node
  */
  public insert(x, data?): <fim_suffix>
  {
    if (isNaN(x) || !isFinite(x)) return;

    const nodeData: object = data || {};

    // no heapify if first value
    if (this._position == 0)
    {
      this._data[1]  = {value: x, data: nodeData};
      this._position = 1;
    }
    else
    {
      this._data[++this._position] = {value: x, data: nodeData};

      // this is already modified to handle min- or max-heap
      this.__heapifyUp();
    }
  }

 /**
  * Examine the root value of the heap without modifying the internal structure.  Returns numerical value of root node, which will be minimum 
  * value for a min-heap and maximum value for a max-heap
  */
  public peek()
  {
    if (this._position > 0)
    {
      // return value of first node
      return <number> this._data[1].value;
    }
    else
    {
      // no data
      return 0;
    }
  }

 /**
  * Extract the root node of the heap or null if the heap is empty
  */
  public extractRoot()
  {
    if (this._data === undefined || this._data.length == 1)  return null;

    const root: HeapData = this._data[1];
    this._data[1]      = this._data[this._position];

    this._position--;

    if (this._position > 1)
    {
      // this call handles min- or max-heap
      this.__heapifyDn(1);
    }

    return root;
  }

 /**
  * Remove a node from the heap based on an input value.  The node with the specified value is searched for (within tolerance).  If found, 
  * that node is deleted and the internal structure is heapified.  Because of the search, the operation is O(n).  Delete is
  * expected to be an infrequent operation, otherwise another structure is likely a better application fit.
  *
  * @param {number} value Numerical value of node to search for and then delete
  */
  public delete(value)
  {
    // arbitrary delete should be an infrequent operation, otherwise a binary heap is not the best choice
    // of data structure.  so, this is not as efficient as it could be with more effort.
    if (this._position == 0)
    {
      // heap is empty; nothing to do
      return;
    }

    // step 1, find
    let index = 0;
    let i: number;

    for (i = 1; i <= this._position; ++i )
    {
      if (Math.abs(value - this._data[i].value) <= 0.0000001)
      {
        index = i;
        break;
      }
    }

    // step 2, remove and heapify if necessary - I don't like this, but again, delete is not a common op. for a
    // binary heap.
    if (index != 0)
    {
      this._data[index] = this._data[this._position];
      this._position--;

      if (this._position <= 1)
      {
        // heap is empty or a singleton; nothing left to do
        return;
      }

      // following already handles min- or max-heap
      this.__heapifyDn(index);
    }
  }

 /**
  * Clear the heap and prepare for new data. The current heap type remains unaltered.
  */
  public clear()
  {
    this._data     = new Array<HeapData>();
    this._position = 0;

    this._data.push( {value: 0, data: {}} );
  }

  protected __heapifyUp()
  {
    let pos: number = this._position;
    let p2: number  = Math.floor(0.5*pos);
    let h: HeapData;

    if (this._type == HeapType.MIN)
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value > <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2] = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
    else
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value < <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2]  = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
  }

  protected __heapifyDn(k)
  {
    let minIndex: number;
    let maxIndex: number;
    const left: number  = k + k;
    const right: number = left + 1;

    if (this._type == HeapType.MIN)
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          minIndex = left;
        }
      }
      else
      {
        // compute min-index
        minIndex = (this._data[left].value <= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value > this._data[minIndex].value)
      {
        const tmp: HeapData    = this._data[minIndex];
        this._data[minIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(minIndex);
      }
    }
    else
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          maxIndex = left;
        }
      }
      else
      {
        // compute max-index
        maxIndex = (this._data[left].value >= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value < this._data[maxIndex].value)
      {
        const tmp: HeapData    = this._data[maxIndex];
        this._data[maxIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(maxIndex);
      }
    }
  }
}
<fim_middle>",correct,2645
void,void,8c4ad7d6f662a709157f365f3614556f753aa573,"<fim_prefix>/** 
 * Copyright 2016 Jim Armstrong (www.algorithmist.net)
 *
 * Licensed under the Apache License, Version 2.0 (the ""License"");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an ""AS IS"" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Typescript Math Toolkit: Binary heap that is optimized for nodes with a numerical value and optional data.  The
 * structure may be a min- or max-heap and all operations are supported on either type of heap.  A newly constructed
 * TSMT Heap instance is a min-heap.  Use the type accessor to change the heap type.
 *
 * Each heap node contains a numerical value (externally assigned) and optional Object data (refer to HeapData
 * interface).  An empty Object is created for a node's data if none is provided in an insert operation.
 *
 * @author Jim Armstrong (www.algorithmist.net)
 * 
 * @version 1.0
 */

export enum HeapType
{
  MIN,
  MAX
}

export interface HeapData
{
  value: number;
  data: object;
}

export class TSMT$Heap
{
  // node that heap begins at element 1 of the data array

  protected _position!: number;              // current position in array
  protected _data!: Array<HeapData>;         // node data
  protected _type: number;                   // heap type (min or max)

 /**
  * Create a new Heap
  */
  constructor()
  {
    this.clear();

    this._type = HeapType.MIN;
  }

 /**
  * Access the size of the heap
  */
  public get size()
  {
    return this._position;
  }

 /**
  * Access the number of levels in the heap  (the final level may not be complete)
  */
  public get levels()
  {
    if (this._position < 2) return this._position;

    const log2: number = Math.round( Math.log2(this._position) );

    return  this._position >= Math.pow(2,log2) ? log2+1 : log2;
  }

 /**
  * Access the heap type, i.e. {HeapType.MIN} if min-heap or {HeapType.MAX} if max-heaps
  */
  public get type()
  {
    return this._type;
  }

 /**
  * Assign the heap type.  This MUST be performed before any other operation; the heap type may
  * not be changed after data has been addded, although this may be relaxed in the future.
  *
  * @param {number} data: Either {HeapType.MIN} or {HeapType.MAX}
  */
  public set type(data)
  {
    this._type = data === HeapType.MIN || data === HeapType.MAX ? data : this._type;
  }

 /**
  * Construct a heap from a data array
  *
  * @param {Array<HeapData>} data An array of heap data
  */
  public fromArray(data): <fim_suffix>
  {
    const len: number = data.length;

    if (len > 0)
    {
      this.clear();

      let i: number;
      for (i = 0; i < len; ++i)
      {
        // insert elements sequentially
        this.insert(data[i].value, data[i].data);
      }
    }
  }

 /**
  * Return a (shallow) copy of the heap as an array
  */
  public toArray()
  {
    return this._data.slice().splice(1,this._position);
  }

 /**
  * Insert an element into the heap.  The internal structure is heapified if the value is valid.
  *
  * @param {number} x: Node value
  *
  * @param {object} data Optional data associated with this node
  */
  public insert(x, data?)
  {
    if (isNaN(x) || !isFinite(x)) return;

    const nodeData: object = data || {};

    // no heapify if first value
    if (this._position == 0)
    {
      this._data[1]  = {value: x, data: nodeData};
      this._position = 1;
    }
    else
    {
      this._data[++this._position] = {value: x, data: nodeData};

      // this is already modified to handle min- or max-heap
      this.__heapifyUp();
    }
  }

 /**
  * Examine the root value of the heap without modifying the internal structure.  Returns numerical value of root node, which will be minimum 
  * value for a min-heap and maximum value for a max-heap
  */
  public peek()
  {
    if (this._position > 0)
    {
      // return value of first node
      return <number> this._data[1].value;
    }
    else
    {
      // no data
      return 0;
    }
  }

 /**
  * Extract the root node of the heap or null if the heap is empty
  */
  public extractRoot()
  {
    if (this._data === undefined || this._data.length == 1)  return null;

    const root: HeapData = this._data[1];
    this._data[1]      = this._data[this._position];

    this._position--;

    if (this._position > 1)
    {
      // this call handles min- or max-heap
      this.__heapifyDn(1);
    }

    return root;
  }

 /**
  * Remove a node from the heap based on an input value.  The node with the specified value is searched for (within tolerance).  If found, 
  * that node is deleted and the internal structure is heapified.  Because of the search, the operation is O(n).  Delete is
  * expected to be an infrequent operation, otherwise another structure is likely a better application fit.
  *
  * @param {number} value Numerical value of node to search for and then delete
  */
  public delete(value)
  {
    // arbitrary delete should be an infrequent operation, otherwise a binary heap is not the best choice
    // of data structure.  so, this is not as efficient as it could be with more effort.
    if (this._position == 0)
    {
      // heap is empty; nothing to do
      return;
    }

    // step 1, find
    let index = 0;
    let i: number;

    for (i = 1; i <= this._position; ++i )
    {
      if (Math.abs(value - this._data[i].value) <= 0.0000001)
      {
        index = i;
        break;
      }
    }

    // step 2, remove and heapify if necessary - I don't like this, but again, delete is not a common op. for a
    // binary heap.
    if (index != 0)
    {
      this._data[index] = this._data[this._position];
      this._position--;

      if (this._position <= 1)
      {
        // heap is empty or a singleton; nothing left to do
        return;
      }

      // following already handles min- or max-heap
      this.__heapifyDn(index);
    }
  }

 /**
  * Clear the heap and prepare for new data. The current heap type remains unaltered.
  */
  public clear()
  {
    this._data     = new Array<HeapData>();
    this._position = 0;

    this._data.push( {value: 0, data: {}} );
  }

  protected __heapifyUp()
  {
    let pos: number = this._position;
    let p2: number  = Math.floor(0.5*pos);
    let h: HeapData;

    if (this._type == HeapType.MIN)
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value > <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2] = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
    else
    {
      while (p2 > 0)
      {
        if (<number> this._data[p2].value < <number> this._data[pos].value)
        {
          h = this._data[pos];

          // swap
          this._data[pos] = this._data[p2];
          this._data[p2]  = h;

          pos = p2;
          p2  = Math.floor(0.5 * pos);
        }
        else
        {
          // force quit
          p2 = 0;
        }
      }
    }
  }

  protected __heapifyDn(k)
  {
    let minIndex: number;
    let maxIndex: number;
    const left: number  = k + k;
    const right: number = left + 1;

    if (this._type == HeapType.MIN)
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          minIndex = left;
        }
      }
      else
      {
        // compute min-index
        minIndex = (this._data[left].value <= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value > this._data[minIndex].value)
      {
        const tmp: HeapData    = this._data[minIndex];
        this._data[minIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(minIndex);
      }
    }
    else
    {
      if (right > this._position)
      {
        if (left > this._position)
        {
          // all levels tested
          return;
        }
        else
        {
          // set min-index to left as right node position is beyond heap bounds
          maxIndex = left;
        }
      }
      else
      {
        // compute max-index
        maxIndex = (this._data[left].value >= this._data[right].value) ? left : right;
      }

      // swap?
      if (this._data[k].value < this._data[maxIndex].value)
      {
        const tmp: HeapData    = this._data[maxIndex];
        this._data[maxIndex] = this._data[k];
        this._data[k]        = tmp;

        this.__heapifyDn(maxIndex);
      }
    }
  }
}
<fim_middle>",correct,2649
void,void,a6f9aec61c153682dc872f7fdabd8d491ac1618e,"<fim_prefix>export type Task = {
  taskId: number;
  estimatedTime: number;
  dependsOnTasks: number[];
};

export type ScheduledTask = {
  taskId: number;
  start: number;
  finish: number;
};

/**
 * Christmas is coming! Santa Claus and his elves have to produce all the presents before the D-day.
 * In order to be as efficient as possible they want to schedule and parallelize as many tasks as possible.
 *
 * So they come up with a precise list of all the tasks including their dependencies and the time they will take.
 * Now we have to suggest the ideal timetable to achieve this goal.
 *
 * @param tasks - Define the tasks to achieve.
 * Tasks should not define circular dependencies, one task cannot be dependant on itself (even indirectly).
 *
 * The following implementation is based on the one suggested at https://algs4.cs.princeton.edu/44sp/CPM.java.html.
 * It solves the ""parallel precedence-constrained job scheduling problem"".
 */
export function christmasFactorySchedule(tasks) {
  const g = buildDirectedGraphFromTasks(tasks);
  const distTo = computeAcyclicLongestPath(g);
  return tasks.map(
    (task) => ({
      taskId: task.taskId,
      start: distTo[g.startVertexFor(task.taskId)],
      finish: distTo[g.finishVertexFor(task.taskId)],
    })
  );
}

type InternalTask = {
  estimatedTime: number;
  dependsOnTasks: number[];
};

type DirectedEdge = {
  from: number;
  to: number;
  weight: number;
};

type DirectedGraph = {
  source: number;
  startVertexFor: (taskId) => number;
  finishVertexFor: (taskId) => number;
  numVertex: number;
  edges: DirectedEdge[];
};

function buildDirectedGraphFromTasks(tasks) {
  const n = tasks.length;
  const source = 2 * n;
  const sink = 2 * n + 1;
  const edges = tasks
    .map(
      (task) => ({
        estimatedTime: task.estimatedTime,
        dependsOnTasks: task.dependsOnTasks.map((taskId) =>
          tasks.findIndex((t) => t.taskId === taskId)
        ),
      })
    )
    .flatMap((task, index) => {
      return [
        { from: source, to: index, weight: 0 },
        { from: index + n, to: sink, weight: 0 },
        { from: index, to: index + n, weight: task.estimatedTime },
        //...task.dependsOnTasks.map((dependsOnTaskId) => ({ from: index + n, to: dependsOnTaskId, weight: 0 })),
        ...task.dependsOnTasks.map((dependsOnTaskId) => ({
          from: dependsOnTaskId + n,
          to: index,
          weight: 0,
        })),
      ];
    });

  return {
    numVertex: 2 * n + 2,
    edges,
    source,
    startVertexFor: (taskId) => tasks.findIndex((t) => t.taskId === taskId),
    finishVertexFor: (taskId) =>
      tasks.findIndex((t) => t.taskId === taskId) + n,
  };
}

function computeAcyclicLongestPath(g) {
  const distTo: number[] = Array(g.numVertex).fill(Number.NEGATIVE_INFINITY);
  distTo[g.source] = 0;

  for (const v of topologicalOrder(g)) {
    for (const e of g.edges.filter((e) => e.from === v)) {
      const w = e.to;
      if (distTo[w] < distTo[v] + e.weight) {
        distTo[w] = distTo[v] + e.weight;
      }
    }
  }

  return distTo;
}

function topologicalOrder(g) {
  const marked = new Set<number>();
  const postOrder: number[] = [];
  for (let v = 0; v !== g.numVertex; ++v) {
    if (!marked.has(v)) {
      postDfsInternal(g, v, marked, postOrder);
    }
  }
  return postOrder.reverse();
}

function postDfsInternal(
  g,
  v,
  marked,
  acc
): <fim_suffix> {
  marked.add(v);
  for (const adj of g.edges.filter((e) => e.from === v)) {
    if (!marked.has(adj.to)) {
      postDfsInternal(g, adj.to, marked, acc);
    }
  }
  acc.push(v);
}
<fim_middle>",correct,2857
void,void,e515e6724820dbd8b7832080af0a2b071e47ff1c,"<fim_prefix>export enum ChatContactGroupEvent {
  CONTACT_REMOVE,
  CONTACT_ACCEPT,
  CONTACT_DECLINE,
  CONTACT_BAN,
  CONTACT_ALLOW,
  GROUP_CREATE,
  GROUP_DESTROY,
  GROUP_JOIN,
  GROUP_LEAVE,
  GROUP_APPLY,
  GROUP_APPLY_ACCEPT,
  GROUP_APPLY_DECLINE,
  GROUP_INVITE,
  GROUP_INVITE_ACCEPT,
  GROUP_INVITE_DECLINE,
  GROUP_KICK,
  GROUP_BAN,
  GROUP_ALLOW,
  GROUP_BLOCK,
  GROUP_UNBLOCK,
  GROUP_ASSIGN_OWNER,
  GROUP_ADD_ADMIN,
  GROUP_REMOVE_ADMIN,
  GROUP_ADD_MUTE,
  GROUP_REMOVE_MUTE,
}

export function ChatContactGroupEventFromNumber(
  params
) {
  switch (params) {
    case 2:
      return ChatContactGroupEvent.CONTACT_REMOVE;
    case 3:
      return ChatContactGroupEvent.CONTACT_ACCEPT;
    case 4:
      return ChatContactGroupEvent.CONTACT_DECLINE;
    case 5:
      return ChatContactGroupEvent.CONTACT_BAN;
    case 6:
      return ChatContactGroupEvent.CONTACT_ALLOW;
    case 10:
      return ChatContactGroupEvent.GROUP_CREATE;
    case 11:
      return ChatContactGroupEvent.GROUP_DESTROY;
    case 12:
      return ChatContactGroupEvent.GROUP_JOIN;
    case 13:
      return ChatContactGroupEvent.GROUP_LEAVE;
    case 14:
      return ChatContactGroupEvent.GROUP_APPLY;
    case 15:
      return ChatContactGroupEvent.GROUP_APPLY_ACCEPT;
    case 16:
      return ChatContactGroupEvent.GROUP_APPLY_DECLINE;
    case 17:
      return ChatContactGroupEvent.GROUP_INVITE;
    case 18:
      return ChatContactGroupEvent.GROUP_INVITE_ACCEPT;
    case 19:
      return ChatContactGroupEvent.GROUP_INVITE_DECLINE;
    case 20:
      return ChatContactGroupEvent.GROUP_KICK;
    case 21:
      return ChatContactGroupEvent.GROUP_BAN;
    case 22:
      return ChatContactGroupEvent.GROUP_ALLOW;
    case 23:
      return ChatContactGroupEvent.GROUP_BLOCK;
    case 24:
      return ChatContactGroupEvent.GROUP_UNBLOCK;
    case 25:
      return ChatContactGroupEvent.GROUP_ASSIGN_OWNER;
    case 26:
      return ChatContactGroupEvent.GROUP_ADD_ADMIN;
    case 27:
      return ChatContactGroupEvent.GROUP_REMOVE_ADMIN;
    case 28:
      return ChatContactGroupEvent.GROUP_ADD_MUTE;
    case 29:
      return ChatContactGroupEvent.GROUP_REMOVE_MUTE;
    default:
      throw new Error(`not exist this type: ${params}`);
  }
}

/**
 * The chat connection listener.
 *
 * For the occasion of onDisconnected during unstable network condition, you
 * don't need to reconnect manually, the chat SDK will handle it automatically.
 *
 * There are only two states: onConnected, onDisconnected.
 *
 * Note: We recommend not to update UI based on those methods, because this
 * method is called on worker thread. If you update UI in those methods, other
 * UI errors might be invoked. Also do not insert heavy computation work here,
 * which might invoke other listeners to handle this connection event.
 *
 * Register:
 *  ```typescript
 *  let listener = new (class s implements ChatConnectionListener {
 *    onTokenWillExpire(): void {
 *      console.log('ConnectScreen.onTokenWillExpire');
 *    }
 *    onTokenDidExpire(): void {
 *      console.log('ConnectScreen.onTokenDidExpire');
 *    }
 *    onConnected(): void {
 *      console.log('ConnectScreen.onConnected');
 *    }
 *    onDisconnected(errorCode?: number): void {
 *      console.log('ConnectScreen.onDisconnected', errorCode);
 *    }
 *  })();
 *  ChatClient.getInstance().addConnectionListener(listener);
 *  ```
 * Unregister:
 *  ```typescript
 *  ChatClient.getInstance().removeConnectionListener(listener);
 *  ```
 */
export interface ChatConnectionListener {
  /**
   * Occurs when the SDK connects to the chat server successfully.
   */
  onConnected();

  /**
   * Occurs when the SDK disconnect from the chat server.
   *
   * Note that the logout may not be performed at the bottom level when the SDK is disconnected.
   *
   * @param errorCode The Error code, see {@link ChatError}
   */
  onDisconnected(errorCode?): <fim_suffix>;

  /**
   * Occurs when the token has expired.
   */
  onTokenWillExpire();

  /**
   * Occurs when the token is about to expire.
   */
  onTokenDidExpire();
}

export interface ChatMultiDeviceListener {
  onContactEvent(
    event?,
    target?,
    ext?
  );

  onGroupEvent(
    event?,
    target?,
    usernames?
  );
}

export interface ChatCustomListener {
  onDataReceived(map);
}

export interface ChatContactEventListener {
  /// 被[userName]添加为好友
  onContactAdded(userName?);

  /// 被[userName]从好友中删除
  onContactDeleted(userName?);

  /// 收到[userName]的好友申请，原因是[reason]
  onContactInvited(userName?, reason?);

  /// 发出的好友申请被[userName]同意
  onFriendRequestAccepted(userName?);

  /// 发出的好友申请被[userName]拒绝
  onFriendRequestDeclined(userName?);
}

export interface ChatConversationListener {
  onConversationUpdate();
}

export interface ChatRoomEventListener {
  /// id是[roomId],名称是[roomName]的聊天室被销毁
  onChatRoomDestroyed(roomId, roomName?);

  /// 有用户[participant]加入id是[roomId]的聊天室
  onMemberJoinedFromChatRoom(roomId, participant);

  /// 有用户[participant]离开id是[roomId]，名字是[roomName]的聊天室
  onMemberExitedFromChatRoom(
    roomId,
    roomName?,
    participant?
  );

  /// 用户[participant]被id是[roomId],名称[roomName]的聊天室删除
  onRemovedFromChatRoom(
    roomId,
    roomName?,
    participant?
  );

  /// @nodoc id是[roomId]的聊天室禁言列表[mutes]有增加
  onMuteListAddedFromChatRoom(
    roomId,
    mutes,
    expireTime?
  );

  /// @nodoc id是[roomId]的聊天室禁言列表[mutes]有减少
  onMuteListRemovedFromChatRoom(roomId, mutes);

  /// @nodoc id是[roomId]的聊天室增加id是[admin]管理员
  onAdminAddedFromChatRoom(roomId, admin);

  /// @nodoc id是[roomId]的聊天室移除id是[admin]管理员
  onAdminRemovedFromChatRoom(roomId, admin);

  /// @nodoc id是[roomId]的聊天室所有者由[oldOwner]变更为[newOwner]
  onOwnerChangedFromChatRoom(
    roomId,
    newOwner,
    oldOwner
  );

  /// @nodoc id是[roomId]的聊天室公告变为[announcement]
  onAnnouncementChangedFromChatRoom(roomId, announcement);

  /// 有用户被添加到聊天室白名单
  onWhiteListAddedFromChatRoom(roomId, members);

  /// 有用户从聊天室白名单被移除
  onWhiteListRemovedFromChatRoom(roomId, members);

  /// 聊天室禁言状态发生变化
  onAllChatRoomMemberMuteStateChanged(
    roomId,
    isAllMuted
  );
}
<fim_middle>",correct,3320
void,void,e5e071d82c234e126b482cc77c6bdea7b5f5be72,"<fim_prefix>export type CommandConstructor = { new (): LeafCommand | GroupCommand }

interface BaseCommand {
  readonly name: string
  readonly description: string
  readonly alias?: string
}

export interface GroupCommand extends BaseCommand {
  subCommandClasses: CommandConstructor[]
}

export interface LeafCommand extends BaseCommand {
  run()
}

export interface Argument<T = unknown> {
  key: string
  description: string
  type?: 'string' | 'boolean' | 'number' | 'bigint' | 'hex-string'
  required?: boolean | { when: string } | { unless: string }
  conflicts?: string
  default?: T
  defaultDescription?: string
  alias?: string
  envKey?: string
  minimum?: number | bigint
  maximum?: number | bigint
  length?: number
  minimumLength?: number
  maximumLength?: number
  oddLength?: boolean
  noErrors?: boolean
  autocompletePath?: boolean
  handler?: () => void
  global?: boolean
  array?: boolean
}

function prependName(group, name) {
  group.fullPath = name + ' ' + group.fullPath
  group.depth++
  for (const child of group.groups) {
    prependName(child, name)
  }
  for (const child of group.commands) {
    child.depth++
    child.fullPath = name + ' ' + child.fullPath
  }
}

export class Group {
  public key: string
  public description: string
  public groups: Group[]
  public commands: Command[]
  public fullPath: string
  public depth: number

  constructor(key, description) {
    this.key = key
    this.description = description
    this.groups = []
    this.commands = []
    this.fullPath = key
    this.depth = 0
  }

  public withGroup(group) {
    this.groups.push(group)
    prependName(group, this.fullPath)

    return this
  }
  public withCommand(command) {
    this.commands.push(command)
    command.depth++
    command.fullPath = this.key + ' ' + command.fullPath

    return this
  }
}

export class Command {
  public key: string
  public description: string
  public sibling?: string
  public alias?: string
  public options: Argument[]
  public arguments: Argument[]
  public fullPath: string
  public depth: number
  public leafCommand: LeafCommand

  constructor(
    key,
    description,
    leafCommand,
    settings?,
  ) {
    this.key = key
    this.description = description
    this.leafCommand = leafCommand

    if (settings) {
      this.sibling = settings.sibling
      this.alias = settings.alias
    }
    this.options = []
    this.arguments = []
    this.fullPath = key
    this.depth = 0
  }

  withOption(x) {
    this.options.push(x)

    return this
  }

  withPositional(x) {
    this.arguments.push(x)

    return this
  }
}

export type ParsedCommand = { command: Command; arguments: Record<string, unknown>; options: Record<string, unknown> }

export interface Context {
  exitReason?: string
  command?: Command | undefined
  group?: Group | undefined
  options: Record<string, unknown>
  arguments: Record<string, unknown>
  sourcemap: Record<string, 'default' | 'env' | 'explicit'>
  sibling?: ParsedCommand
  argumentIndex: number
}

export type ParsedContext = Context & { command: Command }

export interface Application {
  name: string
  command: string
  version: string
  description: string
}

export interface Parser {
  suggest(line, offset, trailing)
  parse(argv)
  addGroup(group)
  addCommand(command)
  addGlobalOption(option)
}

export interface Printer {
  print(text): <fim_suffix>
  printError(text)
  printHeading(text)
  formatDim(text)
  formatImportant(text)
}
<fim_middle>",correct,3343
void,void,fe48985f9ace65089aa5d0dd92573b69804e7a66,"<fim_prefix>export const Kind = 'Core#HostRule';

/**
 * API Client host rule definition.
 */
export interface IHostRule {
  kind?: typeof Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from: string;
  /**
   * replacement value
   */
  to: string;
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;
}

export class HostRule {
  kind = Kind;
  /**
   * The from rule (may contain asterisks)
   */
  from = '';
  /**
   * replacement value
   */
  to = '';
  /**
   * if false the rule is ignored
   */
  enabled?: boolean;
  /**
   * optional rule description
   */
  comment?: string;

  static fromValues(from, to ) {
    const result = new HostRule({
      kind: Kind,
      from,
      to,
      enabled: true,
    });
    return result;
  }

  /**
   * @param input The thing definition used to restore the state.
   */
  constructor(input?) {
    let init: IHostRule;
    if (typeof input === 'string') {
      init = JSON.parse(input);
    } else if (typeof input === 'object') {
      init = input;
    } else {
      init = {
        kind: Kind,
        from: '',
        to: '',
      };
    }
    this.new(init);
  }

  /**
   * Creates a new thing clearing anything that is so far defined.
   * 
   * Note, this throws an error when the server is not an API Client thing.
   */
  new(init): <fim_suffix> {
    if (!HostRule.isHostRule(init)) {
      throw new Error(`Not a HostRule.`);
    }
    const { from='', to='', enabled, comment } = init;
    this.kind = Kind;
    this.from = from;
    this.to = to;
    this.enabled = enabled;
    this.comment = comment;
  }

  /**
   * Checks whether the input is a definition of a host rule.
   */
  static isHostRule(input) {
    const typed = input as IHostRule;
    if (input && typed.kind && typed.kind === Kind) {
      return true;
    }
    return false;
  }

  toJSON() {
    const result: IHostRule = {
      kind: Kind,
      from : this.from,
      to : this.to,
    };
    if (typeof this.enabled === 'boolean') {
      result.enabled = this.enabled;
    }
    if (this.comment) {
      result.comment = this.comment;
    }
    return result;
  }

  /**
   * Applies `hosts` rules to the URL.
   *
   * @param value An URL to apply the rules to
   * @param rules List of host rules. It is a list of objects containing `from` and `to` properties.
   * @return Evaluated URL with hosts rules.
   */
  static applyHosts(value, rules) {
    if (!rules || !rules.length) {
      return value;
    }
    for (let i = 0; i < rules.length; i++) {
      const rule = rules[i];
      const result = HostRule.evaluateRule(value, rule);
      if (result) {
        value = result;
      }
    }
    return value;
  }

  /**
   * Evaluates hosts rule and applies it to the `url`.
   * @param {string} url The URL to evaluate
   * @param {HostRule} rule The host rule definition
   * @return {string} Processed url.
   */
  static evaluateRule(url, rule) {
    if (!rule || !rule.from || !rule.to) {
      return;
    }
    const re = HostRule.createRuleRe(rule.from);
    if (!re.test(url)) {
      return;
    }
    return url.replace(re, rule.to);
  }

  /**
   * @param input Rule body
   * @return Regular expression for the rule.
   */
  static createRuleRe(input) {
    input = input.replace(/\*/g, '(.*)');
    return new RegExp(input, 'gi');
  }
}
<fim_middle>",correct,3420
void,void,714b8e472bcd3cdcca43385f9d5d2554fc1780a1,"<fim_prefix>function split(input) {
    const LF = '\n';
    const CRLF = '\r\n';
    const a = [];

    let pL = 0;
    let p1 = input.indexOf(CRLF, pL);
    let p2 = input.indexOf(LF, pL);

    while (p1 !== -1 || p2 !== -1) {
        if (p1 !== -1 && p1 <= p2) {
            a.push(input.substring(pL, p1));
            pL = p1 + 2;
        } else {
            a.push(input.substring(pL, p2));
            pL = p2 + 1;
        }
        p1 = input.indexOf(CRLF, pL);
        p2 = input.indexOf(LF, pL);
    }
    if (pL < input.length) {
        a.push(input.substring(pL));
    }
    return a;
}

/**
 *
 */
export class BatchContent {
    type: number;
    stringData: string;
    stringSplit: any;
    pos: number;

    public constructor(data) {
        this.type = 0;
        this.stringData = data;
        this.stringSplit = split(data);
        this.pos = 0;
    }

    public lookLine() {
        return this.stringSplit[this.pos];
    }

    public readLine() {
        return this.stringSplit[this.pos++];
    }

    public inc(): <fim_suffix> {
        this.pos++;
    }
}

export class Batch {
    changeSetErrorResponse: any;
    parts: (BatchPart | Batch)[];
    public constructor(public isChangeSet, public boundary) {
        if (this.isChangeSet) {
            this.changeSetErrorResponse = null;
        }
        this.parts = [];
    }
}

export function getBoundary(headerValue) {
    const l = headerValue.split(';');

    for (const element of l) {
        const ll = element.split('=');
        if (ll[0].trim() === 'boundary') {
            return ll[1];
        }
    }
    return '';
}

function readHeader(line) {
    const colPos = line.indexOf(':');
    if (colPos === -1) {
        throw new Error('Invalid header ""content-type"" in batch part');
    }

    const s0 = line.substring(0, colPos);
    const s1 = line.substring(colPos + 1);
    return {
        name: s0.toLowerCase(),
        value: s1.trim()
    };
}
export type BatchPart = {
    url: string;
    method: string;
    body: any;
    headers: Record<string, string>;
    contentId?: string;
};

function readAppHttp(batchContent, boundary) {
    const headers: any = {};
    const payload = [];

    let state = 0; //read url
    const rawUrl = batchContent.readLine();

    state = 1; //read header
    let line = batchContent.lookLine();

    while (line !== null && line !== undefined && line.indexOf(boundary) !== 0) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            } else {
                const h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        } else if (state === 2) {
            payload.push(line);
            batchContent.inc();
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }

    const [method, url] = rawUrl.split(' ');

    let actualBody: any;
    if (payload.length > 0) {
        try {
            actualBody = JSON.parse(payload[0]);
        } catch (e) {
            actualBody = payload[0];
        }
    }
    return {
        url: `/${url}`,
        method: method,
        headers: headers,
        body: actualBody
    };
}

function extractContent(batchContent, headers, boundary) {
    let content;
    if (!headers['content-type']) {
        throw new Error('Missing header ""content-type"" in batch part');
    } else if (headers['content-type'] === 'application/http') {
        content = readAppHttp(batchContent, boundary);
        if (headers['content-id']) {
            content.contentId = headers['content-id'];
        }
    } else if (headers['content-type'].indexOf('multipart/mixed;') > -1) {
        const changeSetBoundary = getBoundary(headers['content-type']);
        content = parseBatch(batchContent, changeSetBoundary, true);
    }
    return content;
}

function parsePart(batchContent, boundary) {
    const boundaryNext = boundary;
    const boundaryEnd = boundary + '--';
    const headers: any = {};
    let content;

    let state = 1; //read header
    let line = batchContent.lookLine();

    while (line !== null && line !== undefined && line !== boundaryNext && line !== boundaryEnd) {
        if (state === 1) {
            if (line.length === 0) {
                state = 2; //read body
                batchContent.inc();
            } else {
                const h = readHeader(line);
                headers[h.name] = h.value;
                batchContent.inc();
            }
        } else if (state === 2) {
            content = extractContent(batchContent, headers, boundary);
        }
        line = batchContent.lookLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request. Expect boundary ' + boundary);
    }

    return content;
}

export function parseBatch(content, boundary, isChangeset = false) {
    const boundaryNext = '--' + boundary;
    const boundaryEnd = '--' + boundary + '--';

    const batch = new Batch(isChangeset, boundary);

    let part;

    let line = content.readLine();
    while (line !== null && line !== undefined && line !== boundaryNext) {
        //read lines before first boundary
        line = content.readLine();
    }
    if (line === undefined) {
        throw new Error('Invalid boundary while parsing batch request');
    }
    //line is now read boundary
    line = content.lookLine(); //read line behind

    while (line !== null && line !== undefined && line !== boundaryEnd) {
        part = parsePart(content, boundaryNext);
        if (part) {
            batch.parts.push(part);
        }
        line = content.lookLine(); //now on boundary
        if (line === boundaryNext) {
            line = content.readLine(); //consume boundaryNext
        }
    }

    content.readLine(); //consume boundaryEnd
    line = content.lookLine(); //read line behind
    while (line !== null && line !== undefined && line.length === 0) {
        //read empty lines after first boundary end
        content.readLine();
        line = content.lookLine();
    }

    return batch;
}
<fim_middle>",correct,3639
void,void,4ecebdfe2a83e32ca2665144d05b64c53181178a,"<fim_prefix>/**
 *
 *
 * Copied direcly from: https://github.com/pmndrs/jotai/blob/main/src/utils/weakCache.ts
 *
 * Eventually just import it from Jotai if it's exported.
 *
 *
 *
 */
export type WeakCache<T> = WeakMap<object, [WeakCache<T>] | [WeakCache<T>, T]>;

const getWeakCacheItem = <T>(
  cache,
  deps
) => {
  while (true) {
    const [dep, ...rest] = deps;
    const entry = cache.get(dep as object);
    if (!entry) {
      return;
    }
    if (!rest.length) {
      return entry[1];
    }
    cache = entry[0];
    deps = rest;
  }
};

const setWeakCacheItem = <T>(
  cache,
  deps,
  item
): <fim_suffix> => {
  while (true) {
    const [dep, ...rest] = deps;
    let entry = cache.get(dep as object);
    if (!entry) {
      entry = [new WeakMap()];
      cache.set(dep as object, entry);
    }
    if (!rest.length) {
      entry[1] = item;
      return;
    }
    cache = entry[0];
    deps = rest;
  }
};

export const createMemoizeAtom = () => {
  const cache: WeakCache<{}> = new WeakMap();
  const memoizeAtom = <T extends {}, Deps extends readonly object[]>(
    createAtom,
    deps
  ) => {
    const cachedAtom = getWeakCacheItem(cache, deps);
    if (cachedAtom) {
      return cachedAtom as T;
    }
    const createdAtom = createAtom();
    setWeakCacheItem(cache, deps, createdAtom);
    return createdAtom;
  };
  return memoizeAtom;
};
<fim_middle>",correct,3788
void,void,28042e807e39aced7ddb26e06c2b676a70d3199c,"<fim_prefix>type RawInfo = {
    x: number,
    y: number,
    labelWidth?: number,  // Optional. If setted, it will override the settings of the computer
    labelHeight?: number, // Optional. If setted, it will override the settings of the computer
    [redundantProp: string]: any,
};

type LayoutInfo = {
    x: number,
    y: number,
    left: boolean,  // indicate if label on the left or right
    controlPoints: { x:number, y: number}[],
    labelBBox: {
        x: number,
        y: number,
        width: number,
        height: number
    },
    rawInfo: RawInfo
};

// Since the following types facilitate developer to write code but users cannot read param and return types directly
// we remove these helper types
// type GetParamFunc<T> =  () => T;
// type SetParamFunc<T> =  (param: T) => T;
// type GetOrSetParamFunc<T> = GetParamFunc<T> & SetParamFunc<T>;

interface Computer {
    (rawInfos, cx, cy, isInfosFiltered);
    elementsNumInLens: (() => number);
    defaultLabelWidth: (() => number)
        & ((size) => Computer);
    defaultLabelHeight: (() => number)
        & ((size) => Computer);
    radius: (() => number)
        & ((radius) => Computer);
    maxLabelsNum: (() => number)
        & ((maxLabelsNum) => Computer);
    verticallyCoherent: (() => boolean)
        & ((verticallyCoherent) => Computer);
    horizontallyCoherent: (() => boolean)
        & ((horizontallyCoherent) => Computer);
    spaceBetweenLabels: (() => number)
        & ((spaceBetweenLabels) => Computer);
    leftSpace: (() => number)
        & ((space) => Computer);
    rightSpace: (() => number)
        & ((space) => Computer);
    leftAndRightSpace: (() => [number, number])
        & ((space) => Computer) 
        & ((space) => Computer);
}

/**
 * A dynamic technique to label a neighborhood of objects located around the cursor.
 * Paper link: https://dl.acm.org/doi/abs/10.1145/302979.303148
 * @returns Computed position for each label
 */
export default function excentricLabeling() {
    let _radius = 20;
    let _maxLabelsNum = 10;
    let _verticallyCoherent = true;
    let _horizontallyCoherent = false;
    let _spaceBetweenLabels = 3;
    let _leftSpace = 20;
    let _rightSpace = 20;
    let _defaultLabelWidth = 20;
    let _defaultLabelHeight = 10;
    let _elementsNumInLens = 0;

    const computeExcentricLabelingLayout: Computer = (rawInfos, cx, cy, isInfosFiltered = false) => {
        let filteredRawInfos = rawInfos;
        if(!isInfosFiltered) filteredRawInfos = filterElementsInLens(filteredRawInfos, cx, cy, _radius);
        _elementsNumInLens = filteredRawInfos.length;
        filteredRawInfos = filterElementsWithMaxNumber(filteredRawInfos, _maxLabelsNum);
        const layoutInfos = initLayoutInfos(filteredRawInfos, _defaultLabelWidth, _defaultLabelHeight);
        computeStartPoints(layoutInfos);
        if (!_verticallyCoherent) computePointsOnLens(layoutInfos, cx, cy, _radius);
        dividedIntoLeftOrRight(layoutInfos, cx, cy);
        computeMiddlePoints(layoutInfos, cx, cy, _radius, _spaceBetweenLabels, _leftSpace, _rightSpace);
        computeEndPoints(layoutInfos, cx, _horizontallyCoherent);
        computeLabelBBox(layoutInfos);
        return layoutInfos;
    }

    function elementsNumInLens(){
        return _elementsNumInLens;
    }

    function defaultLabelWidth();
    function defaultLabelWidth(defaultLabelWidth);
    function defaultLabelWidth(defaultLabelWidth?) {
        if (defaultLabelWidth === undefined) return _defaultLabelWidth;
        _defaultLabelWidth = defaultLabelWidth;
        return computeExcentricLabelingLayout;
    };

    function defaultLabelHeight();
    function defaultLabelHeight(defaultLabelHeight);
    function defaultLabelHeight(defaultLabelHeight?) {
        if (defaultLabelHeight === undefined) return _defaultLabelHeight;
        _defaultLabelHeight = defaultLabelHeight;
        return computeExcentricLabelingLayout;
    };

    function radius();
    function radius(radius);
    function radius(radius?) {
        if (radius === undefined) return _radius;
        _radius = radius;
        return computeExcentricLabelingLayout;
    };

    function maxLabelsNum();
    function maxLabelsNum(maxLabelsNum);
    function maxLabelsNum(maxLabelsNum?) {
        if (maxLabelsNum === undefined) return _maxLabelsNum;
        _maxLabelsNum = maxLabelsNum;
        return computeExcentricLabelingLayout;
    };

    function verticallyCoherent();
    function verticallyCoherent(verticallyCoherent);
    function verticallyCoherent(verticallyCoherent?) {
        if (verticallyCoherent === undefined) return _verticallyCoherent;
        _verticallyCoherent = verticallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function horizontallyCoherent();
    function horizontallyCoherent(horizontallyCoherent);
    function horizontallyCoherent(horizontallyCoherent?) {
        if (horizontallyCoherent === undefined) return _horizontallyCoherent;
        _horizontallyCoherent = horizontallyCoherent;
        return computeExcentricLabelingLayout;
    };

    function spaceBetweenLabels();
    function spaceBetweenLabels(spaceBetweenLabels);
    function spaceBetweenLabels(spaceBetweenLabels?) {
        if (spaceBetweenLabels === undefined) return _spaceBetweenLabels;
        _spaceBetweenLabels = spaceBetweenLabels;
        return computeExcentricLabelingLayout;
    };

    function leftSpace();
    function leftSpace(leftSpace);
    function leftSpace(leftSpace?) {
        if (leftSpace === undefined) return _leftSpace;
        _leftSpace = leftSpace;
        return computeExcentricLabelingLayout;
    };

    function rightSpace();
    function rightSpace(rightSpace);
    function rightSpace(rightSpace?) {
        if (rightSpace === undefined) return _rightSpace;
        _rightSpace = rightSpace;
        return computeExcentricLabelingLayout;
    };

    function leftAndRightSpace();
    function leftAndRightSpace(space);
    function leftAndRightSpace(space);
    function leftAndRightSpace(space?) {
        if (space === undefined) return [_leftSpace, _rightSpace];
        if (typeof space === ""number"") {
            _leftSpace = space;
            _rightSpace = space;
        } else {
            [_spaceBetweenLabels, _rightSpace] = space;
        }
        return computeExcentricLabelingLayout;
    };

    computeExcentricLabelingLayout.elementsNumInLens = elementsNumInLens;
    computeExcentricLabelingLayout.radius = radius;
    computeExcentricLabelingLayout.maxLabelsNum = maxLabelsNum;
    computeExcentricLabelingLayout.defaultLabelWidth = defaultLabelWidth;
    computeExcentricLabelingLayout.defaultLabelHeight = defaultLabelHeight;
    computeExcentricLabelingLayout.verticallyCoherent = verticallyCoherent;
    computeExcentricLabelingLayout.horizontallyCoherent = horizontallyCoherent;
    computeExcentricLabelingLayout.spaceBetweenLabels = spaceBetweenLabels;
    computeExcentricLabelingLayout.leftSpace = leftSpace;
    computeExcentricLabelingLayout.rightSpace = rightSpace;
    computeExcentricLabelingLayout.leftAndRightSpace = leftAndRightSpace;

    return computeExcentricLabelingLayout;
}

/**
 * RNN Search
 */
function filterElementsInLens(rawInfos, cx, cy, r) {
    return rawInfos.filter(rawInfo => Math.sqrt((rawInfo.x - cx) ** 2 + (rawInfo.y - cy) ** 2) <= r);
}

function filterElementsWithMaxNumber(rawInfos, maxLabelsNum) {
    return rawInfos.slice(0, maxLabelsNum);
}

function initLayoutInfos(rawInfos, _defaultLabelWidth, _defaultLabelHeight) {
    return rawInfos.map((rawInfo) => initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight));
}

function initLayoutInfo(rawInfo, _defaultLabelWidth, _defaultLabelHeight) {
    const { x, y, defaultLabelWidth, defaultLabelHeight } = rawInfo
    return {
        x, y,
        //name: labelName,
        controlPoints: [],
        left: true,
        labelBBox: {
            x: 0,
            y: 0,
            width: defaultLabelWidth ?? _defaultLabelWidth,
            height: defaultLabelHeight ?? _defaultLabelHeight,
        },
        rawInfo: rawInfo
    }
}

function computeStartPoints(layoutInfos) {
    for (const layoutInfo of layoutInfos) {
        layoutInfo.controlPoints.push({
            x: layoutInfo.x,
            y: layoutInfo.y,
        });
    }
}

function computePointsOnLens(layoutInfos, cx, cy, r) {
    for (const layoutInfo of layoutInfos) {
        const startPoint = layoutInfo.controlPoints[0];
        if (startPoint === undefined) throw Error(""no start points"");
        const rad = Math.atan2(startPoint.y - cy, startPoint.x - cx);
        const endPoint = {
            x: cx + r * Math.cos(rad),
            y: cy + r * Math.sin(rad)
        }
        layoutInfo.controlPoints.push(endPoint);
    }
}

function computeMiddlePoints(layoutInfos, cx, cy, r, spaceBetweenLabels, leftSpace, rightSpace) {
    const sortAccordingY = (li1, li2) => li1.controlPoints[li1.controlPoints.length - 1].y - li2.controlPoints[li2.controlPoints.length - 1].y;
    const computeSpaceHeight = (layoutInfos, spaceBetweenLabels) => layoutInfos.reduce((acc, layoutInfo) => acc + layoutInfo.labelBBox.height, 0) + spaceBetweenLabels * (layoutInfos.length - 1);

    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, spaceBetweenLabels, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, spaceBetweenLabels, false);

    function computeOneSide(layoutInfosOneSide, spaceBetweenLabels, left) {
        layoutInfosOneSide.sort(sortAccordingY);
        const spaceHeight = computeSpaceHeight(layoutInfosOneSide, spaceBetweenLabels);
        let labelY = cy - (spaceHeight / 2)
        layoutInfosOneSide.forEach((layoutInfo, i, layoutInfos) => {
            if (i !== 0) {
                labelY += layoutInfos[i - 1].labelBBox.height + spaceBetweenLabels;
            }
            layoutInfo.controlPoints.push({
                x: left ? cx - r - leftSpace : cx + r + rightSpace,
                y: labelY + (layoutInfo.labelBBox.height >> 1)
            });
        });
    }
}

function computeEndPoints(layoutInfos, cx, horizontallyCoherent): <fim_suffix> {
    const computeMaxLabelWidth = (layoutInfos) => Math.max(...layoutInfos.map(layoutInfo => layoutInfo.labelBBox.width));
    const layoutInfosLeft: LayoutInfo[] = [];
    const layoutInfosRight: LayoutInfo[] = [];
    layoutInfos.forEach(layoutInfo => layoutInfo.left ? layoutInfosLeft.push(layoutInfo) : layoutInfosRight.push(layoutInfo));

    if (layoutInfosLeft.length > 0) computeOneSide(layoutInfosLeft, true);
    if (layoutInfosRight.length > 0) computeOneSide(layoutInfosRight, false);
    if (horizontallyCoherent) moveHorizontally(layoutInfos);

    function computeOneSide(layoutInfosOneSide, left) {
        const maxWidth = computeMaxLabelWidth(layoutInfosOneSide);
        layoutInfosOneSide.forEach(layoutInfo => {
            const controlPointsNum = layoutInfo.controlPoints.length;
            const middleControlPoint = layoutInfo.controlPoints[controlPointsNum - 1];
            const space = maxWidth - layoutInfo.labelBBox.width;
            layoutInfo.controlPoints.push({
                x: middleControlPoint.x + (left ? -(space) : 0),
                y: middleControlPoint.y,
            })
        });
    }
    function moveHorizontally(layoutInfos) {
        layoutInfos.forEach(layoutInfo => {
            const endControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
            endControlPoint.x += layoutInfo.x - cx;
        })
    }
}

function dividedIntoLeftOrRight(layoutInfos, cx, cy) {
    layoutInfos.forEach(layoutInfo => {
        layoutInfo.left = layoutInfo.x < cx;
    });
}

function computeLabelBBox(layoutInfos) {
    layoutInfos.forEach(layoutInfo => {
        const bbox = layoutInfo.labelBBox;
        const lastControlPoint = layoutInfo.controlPoints[layoutInfo.controlPoints.length - 1];
        bbox.x = lastControlPoint.x + (layoutInfo.left ? -bbox.width : 0);
        bbox.y = lastControlPoint.y - (layoutInfo.labelBBox.height >> 1);
    });
}
<fim_middle>",correct,3928
void,void,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value) {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text) {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line) {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value): <fim_suffix> {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4189
void,void,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value) {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text) {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line): <fim_suffix> {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value) {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4202
void,void,9fc94cc878ab26c5eed76d6845a7080110869aa3,"<fim_prefix>// Copyright 2018 The Casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the ""License"");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an ""AS IS"" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// ConfigInterface defines the behavior of a Config implementation
export interface ConfigInterface {
  getString(key);

  getStrings(key);

  getBool(key);

  getInt(key);

  getFloat(key);

  set(key, value);
}

export class Config implements ConfigInterface {
  private static DEFAULT_SECTION = 'default';
  private static DEFAULT_COMMENT = '#';
  private static DEFAULT_COMMENT_SEM = ';';
  private static DEFAULT_MULTI_LINE_SEPARATOR = '\\';

  private data: Map<string, Map<string, string>>;

  private constructor() {
    this.data = new Map<string, Map<string, string>>();
  }

  /**
   * newConfig create an empty configuration representation from file.
   *
   * @param text the content of the model file.
   * @return the constructor of Config.
   */
  public static newConfig(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * newConfigFromText create an empty configuration representation from text.
   *
   * @param text the model text.
   * @return the constructor of Config.
   */
  public static newConfigFromText(text) {
    const config = new Config();
    config.parseText(text);
    return config;
  }

  /**
   * addConfig adds a new section->key:value to the configuration.
   */
  private addConfig(section, option, value) {
    if (section === '') {
      section = Config.DEFAULT_SECTION;
    }
    const hasKey = this.data.has(section);
    if (!hasKey) {
      this.data.set(section, new Map<string, string>());
    }

    const item = this.data.get(section);
    if (item) {
      item.set(option, value);
      return item.has(option);
    } else {
      return false;
    }
  }

  private parseText(text): <fim_suffix> {
    const lines = text.split('\n').filter((v) => v);
    const linesCount = lines.length;
    let section = '';
    let currentLine = '';

    lines.forEach((n, index) => {
      let commentPos = n.indexOf(Config.DEFAULT_COMMENT);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }
      commentPos = n.indexOf(Config.DEFAULT_COMMENT_SEM);
      if (commentPos > -1) {
        n = n.slice(0, commentPos);
      }

      const line = n.trim();
      if (!line) {
        return;
      }

      const lineNumber = index + 1;

      if (line.startsWith('[') && line.endsWith(']')) {
        if (currentLine.length !== 0) {
          this.write(section, lineNumber - 1, currentLine);
          currentLine = '';
        }
        section = line.substring(1, line.length - 1);
      } else {
        let shouldWrite = false;
        if (line.includes(Config.DEFAULT_MULTI_LINE_SEPARATOR)) {
          currentLine += line.substring(0, line.length - 1).trim();
        } else {
          currentLine += line;
          shouldWrite = true;
        }
        if (shouldWrite || lineNumber === linesCount) {
          this.write(section, lineNumber, currentLine);
          currentLine = '';
        }
      }
    });
  }

  private write(section, lineNum, line) {
    const equalIndex = line.indexOf('=');
    if (equalIndex === -1) {
      throw new Error(`parse the content error : line ${lineNum}`);
    }
    const key = line.substring(0, equalIndex);
    const value = line.substring(equalIndex + 1);
    this.addConfig(section, key.trim(), value.trim());
  }

  public getBool(key) {
    return !!this.get(key);
  }

  public getInt(key) {
    return Number.parseInt(this.get(key), 10);
  }

  public getFloat(key) {
    return Number.parseFloat(this.get(key));
  }

  public getString(key) {
    return this.get(key);
  }

  public getStrings(key) {
    const v = this.get(key);
    return v.split(',');
  }

  public set(key, value) {
    if (!key) {
      throw new Error('key is empty');
    }

    let section = '';
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      option = keys[0];
    }

    this.addConfig(section, option, value);
  }

  public get(key) {
    let section;
    let option;

    const keys = key.toLowerCase().split('::');
    if (keys.length >= 2) {
      section = keys[0];
      option = keys[1];
    } else {
      section = Config.DEFAULT_SECTION;
      option = keys[0];
    }

    const item = this.data.get(section);
    const itemChild = item && item.get(option);

    return itemChild ? itemChild : '';
  }
}
<fim_middle>",correct,4206
void,void,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset(): <fim_suffix> {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4531
void,void,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece): <fim_suffix> {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4536
void,void,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col): <fim_suffix> {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4542
void,void,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece): <fim_suffix> {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4547
void,void,6d441b29fca0323dd6b2933cf3ef36e507748d2d,"<fim_prefix>/* eslint-disable max-classes-per-file */
export type Move = readonly [number, number];

export enum Piece {
  EMPTY = 0,
  BLACK = 1,
  WHITE = 2,
  BOARDER = 3,
}

export class Board {
  static readonly SIZE = 15;

  private data: Uint8Array;

  constructor() {
    this.data = new Uint8Array(Board.SIZE * Board.SIZE);
  }

  get(row, col) {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return Piece.BOARDER;
    }
    return this.data[row * Board.SIZE + col];
  }

  set(row, col, piece): <fim_suffix> {
    if (row < 0 || row >= Board.SIZE || col < 0 || col >= Board.SIZE) {
      return;
    }
    this.data[row * Board.SIZE + col] = piece;
  }
}

export default class GomokuCore {
  private board: Board;
  
  private history: Move[];

  private winner: Piece;

  constructor() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }

  static fromHistory(history) {
    const board = new GomokuCore();
    for (let i = 0; i < history.length - 1; i += 1) {
      // board.move(history[i][0], history[i][1]);
      board.setBoardAt(history[i][0], history[i][1], board.getCurrentPlayer());
      board.pushMove(history[i][0], history[i][1]);
    }
    board.move(history[history.length - 1][0], history[history.length - 1][1]);
    return board;
  }

  getBoardAt(row, col) {
    return this.board.get(row, col);
  }

  private setBoardAt(row, col, piece) {
    this.board.set(row, col, piece);
  }

  getCurrentPlayer() {
    return this.history.length % 2 === 0 ? Piece.BLACK : Piece.WHITE;
  }

  getLastMove() {
    if (this.history.length === 0) {
      return null;
    }
    return this.history[this.history.length - 1];
  }

  private pushMove(row, col) {
    this.history.push([row, col]);
  }

  private popMove() {
    const last = this.history.pop();
    if (last) return last;
    return null;
  }

  getWinner() {
    return this.winner;
  }

  private checkWinner(row, col, piece) {
    // check horizontal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check vertical
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col + k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col + k + 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
    // check anti-diagonal
    for (let k = -5; k < 5; k += 1) {
      if (this.getBoardAt(row + k, col - k) === piece) {
        const start = k;
        while (this.getBoardAt(row + k + 1, col - k - 1) === piece) k += 1;
        const end = k;
        if (end - start + 1 >= 5) {
          this.winner = piece;
          return;
        }
      }
    }
  }

  move(row, col) {
    const piece = this.getCurrentPlayer();
    if (this.getBoardAt(row, col) === Piece.EMPTY) {
      this.setBoardAt(row, col, piece);
      this.pushMove(row, col);
      this.checkWinner(row, col, piece);
      return piece;
    }
    return null;
  }

  withdraw() {
    const lastMove = this.popMove();
    if (lastMove)
      this.setBoardAt(lastMove[0], lastMove[1], Piece.EMPTY);
      this.winner = Piece.EMPTY;
    return lastMove;
  }

  reset() {
    this.board = new Board();
    this.history = [];
    this.winner = Piece.EMPTY;
  }
}
<fim_middle>",correct,4556
void,void,f6127d3ca25913df8797295ddc538560f5ecbd34,"<fim_prefix>/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 任务存放的数据结构
 * 类似小顶堆 将heap中最小的节点放在第一个
 * @flow strict
 */

export type Heap = Array<Node>
export type Node = {
  id: number
  sortIndex: number
}

/**
 * push一个任务
 * 先将任务放在队列末尾
 * 然后进行二分遍历，将最小的任务放在第一个
 */
export function push(heap, node): <fim_suffix> {
  const index = heap.length

  heap.push(node)
  siftUp(heap, node, index)
}

// 查看小顶堆的第一个任务
export function peek(heap) {
  return heap.length === 0 ? null : heap[0]
}

// 推出第一个任务
export function pop(heap) {
  if (heap.length === 0) {
    return null
  }

  const first = heap[0]
  const last = heap.pop() as Node

  if (last !== first) {
    heap[0] = last
    siftDown(heap, last, 0)
  }

  return first
}

/**
 * 上浮元素
 * 确保队列的第一个始终是sortIndex最小的
 *
 * 之所以不将入队的node直接和head[0]进行比较
 * 是因为想要将入队的node放在一个比较合适的位置，避免后续siftdown操作进行更多的遍历
 */
function siftUp(heap, node, i) {
  let index = i

  while (index > 0) {
    // 获取队列中0到index的二分位置
    const parentIndex = (index - 1) >>> 1
    const parent = heap[parentIndex]

    /**
     * 如果中间位置的node和需要入队的node compare结果为正
     * 则表明需要入队的node需要继续往前移动
     * index为2或者1的时候 parentIndex会为0
     * 这样就比较了需要入队的node和head[0]
     */
    if (compare(parent, node) > 0) {
      // The parent is larger. Swap positions.
      heap[parentIndex] = node
      heap[index] = parent
      index = parentIndex
    } else {
      // The parent is smaller. Exit.
      return
    }
  }
}

/**
 * 通过小顶堆寻找队列中最小的最小的
 * 确保队列的第一个始终是sortIndex最小的
 */
function siftDown(heap, node, i) {
  let index = i

  debugger
  const length = heap.length
  const halfLength = length >>> 1

  while (index < halfLength) {
    const leftIndex = (index + 1) * 2 - 1
    const left = heap[leftIndex]
    const rightIndex = leftIndex + 1
    const right = heap[rightIndex]

    // If the left or right node is smaller, swap with the smaller of those.
    if (compare(left, node) < 0) {
      // 先找到右子树中最小的
      if (rightIndex < length && compare(right, left) < 0) {
        heap[index] = right
        heap[rightIndex] = node
        index = rightIndex
      } else {
        // 右子树中最小的找到以后 再来比较左子树
        heap[index] = left
        heap[leftIndex] = node
        index = leftIndex
      }
    } else if (rightIndex < length && compare(right, node) < 0) {
      heap[index] = right
      heap[rightIndex] = node
      index = rightIndex
    } else {
      // Neither child is smaller. Exit.
      return
    }
  }
}

// 比较两个节点: sortIndex优先 sortIndex相同的情况再比较id
function compare(a, b) {
  // Compare sort index first, then task id.
  const diff = a.sortIndex - b.sortIndex

  return diff !== 0 ? diff : a.id - b.id
}
<fim_middle>",correct,4788
