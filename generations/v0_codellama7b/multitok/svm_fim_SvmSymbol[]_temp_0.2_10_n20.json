{"content": ["\n  return {\n    type: 'array',\n    itemType: parseSvmType(type, components),\n    size: parseInt(length, 10),\n    originalType: rawType,\n  };\n", "\n  return {\n    type: 'array',\n    itemType: parseSvmType(type, components),\n    size: parseInt(length, 10),\n    originalType: rawType,\n  };\n", "\n  return {\n    type: 'array',\n    itemType: parseSvmType(type),\n    size: parseInt(length, 10),\n    originalType: rawType,\n  };\n}\n", "\n  return {\n    type: 'array',\n    itemType: parseSvmType(type),\n    size: parseInt(length, 10),\n    originalType: rawType,\n  };\n}\n", "\n  /**\n   * Parses the SvmType from the JSON ABI; recusively on non-primatives\n   */\n  parseSvmType,\n  /**\n   * Parses the SvmOutput", "\n  const components = [];\n  for (let i = 0; i < rawComponents.length; i++) {\n    const rawComponent = rawComponents[i];\n    const name = rawComponent.name;\n    const", "\n  const components = [];\n  for (const component of rawComponents) {\n    components.push({\n      type: parseSvmType(component.type),\n      name: component.name,\n    });\n  }", "\n  const components = [];\n  for (const [name, type] of Object.entries(abi.components)) {\n    components.push({\n      type: parseSvmType(type, components),\n      name,\n", "\n  }\n\n  return {\n    type: 'unknown',\n    originalType: rawType,\n  };\n}\n\n/**\n * Parses the SvmType from the JSON ABI; recusively on", "\n  /**\n   * The name of the function\n   */\n  name: string;\n  /**\n   * The type of the function\n   */\n  type: SvmType;\n  /**\n   * The name", "\n  //     return {\n  //       type: 'array',\n  //       itemType: parseSvmType(type, components),\n  //       size: parseInt(length, 10),\n  //      ", "\n  return {\n    ...parseSvmType(rawType, components),\n    name,\n  };\n}\n\n/**\n * Parses the SvmType from the JSON ABI; recusively on non-", "\n  const components = [];\n  for (let i = 0; i < type.components.length; i++) {\n    const component = type.components[i];\n    const name = component.name;\n    const", "\n  components: SvmSymbol[];\n  structName: string;\n}\n\nexport interface SvmSymbol {\n  type: SvmType;\n  name: string;\n}\n\nexport interface SvmType {", "\n\n  /**\n   * Parses the JSON ABI and returns a list of SvmSymbols\n   */\n  parse(abi: string): SvmSymbol[] {\n    const jsonAbi = JSON.parse(", "\n  const components = [];\n  for (const component of rawComponents) {\n    components.push({\n      name: component.name,\n      type: parseSvmType(component.type, components),\n    });\n", "\n  /**\n   * Parses the JSON ABI and returns a list of SvmSymbols\n   */\n  parse(json: string): SvmSymbol[] {\n    const parsed = JSON.parse(json);\n", "\n * @param {string} rawName\n * @returns {string}\n */\nexport function normalizeName(rawName: string): string {\n  const transformations: ((s: string) => string)[] = [\n   ", "\n  if (components.length === 0) {\n    throw new Error(`No components found for ${structName}`);\n  }\n\n  return {\n    type: 'tuple',\n    components,\n    originalType", "\n  /**\n   * Parses the ABI JSON and returns the SVM types\n   * @param abi JSON ABI\n   */\n  parse(abi: string): SvmSymbol[] {\n    const parsedAb"], "sampling_params": "{'greedy': SamplingParams(n=1, best_of=1, presence_penalty=0.0, frequency_penalty=0.0, repetition_penalty=1.0, temperature=0, top_p=1.0, top_k=-1, min_p=0.0, use_beam_search=False, length_penalty=1.0, early_stopping=False, stop=[], stop_token_ids=[], include_stop_str_in_output=False, ignore_eos=False, max_tokens=50, logprobs=None, prompt_logprobs=None, skip_special_tokens=True, spaces_between_special_tokens=True), 'temp_0.2': SamplingParams(n=20, best_of=20, presence_penalty=0.0, frequency_penalty=0.0, repetition_penalty=1.0, temperature=0.2, top_p=1.0, top_k=-1, min_p=0.0, use_beam_search=False, length_penalty=1.0, early_stopping=False, stop=[], stop_token_ids=[], include_stop_str_in_output=False, ignore_eos=False, max_tokens=50, logprobs=None, prompt_logprobs=None, skip_special_tokens=True, spaces_between_special_tokens=True), 'temp_0.8-top_p_0.95': SamplingParams(n=20, best_of=20, presence_penalty=0.0, frequency_penalty=0.0, repetition_penalty=1.0, temperature=0.8, top_p=0.95, top_k=-1, min_p=0.0, use_beam_search=False, length_penalty=1.0, early_stopping=False, stop=[], stop_token_ids=[], include_stop_str_in_output=False, ignore_eos=False, max_tokens=1, logprobs=None, prompt_logprobs=None, skip_special_tokens=True, spaces_between_special_tokens=True)}"}