{"hexsha": "199614470a268c39f9858a815b099f3ff800bdcc", "size": 3885, "ext": "ts", "lang": "TypeScript", "max_stars_repo_path": "src/electionguard/ballot/election-object-base.ts", "max_stars_repo_name": "DJunge-w/ElectionGuard-COMP413-clean", "max_stars_repo_head_hexsha": "6c4c7ce3b34097c29a772efeaa845ea8740ae1eb", "max_stars_repo_licenses": ["MIT"], "max_stars_count": 2.0, "max_stars_repo_stars_event_min_datetime": "2022-02-24T21:48:21.000Z", "max_stars_repo_stars_event_max_datetime": "2022-03-12T01:36:25.000Z", "max_issues_repo_path": "src/electionguard/ballot/election-object-base.ts", "max_issues_repo_name": "DJunge-w/ElectionGuard-COMP413-clean", "max_issues_repo_head_hexsha": "6c4c7ce3b34097c29a772efeaa845ea8740ae1eb", "max_issues_repo_licenses": ["MIT"], "max_issues_count": null, "max_issues_repo_issues_event_min_datetime": null, "max_issues_repo_issues_event_max_datetime": null, "max_forks_repo_path": "src/electionguard/ballot/election-object-base.ts", "max_forks_repo_name": "DJunge-w/ElectionGuard-COMP413-clean", "max_forks_repo_head_hexsha": "6c4c7ce3b34097c29a772efeaa845ea8740ae1eb", "max_forks_repo_licenses": ["MIT"], "max_forks_count": null, "max_forks_repo_forks_event_min_datetime": null, "max_forks_repo_forks_event_max_datetime": null, "content": "export interface Eq<T> {\n  /* Compares the other object to this one. */\n  equals(other: T): boolean;\n}\n/**\n * A base object to derive other election objects identifiable by object_id\n */\nexport interface ElectionObjectBase extends Eq<ElectionObjectBase> {\n  /** The object_id, should be a unique string. */\n  objectId: string;\n}\n\n/**\n * A ordered base object to derive other election objects.\n */\nexport interface OrderedObjectBase extends ElectionObjectBase {\n  /**\n   * Used for ordering in a ballot to ensure various encryption primitives are deterministic.\n   * The sequence order must be unique and should be representative of how the items are represented\n   * on a template ballot in an external system.  The sequence order is not required to be in the order\n   * in which they are displayed to a voter.  Any acceptable range of integer values may be provided.\n   */\n  sequenceOrder: number;\n}\n\n/** Sort an array of {@link OrderedObjectBase} in sequence order. Original is unchanged. */\nexport function sortedArrayOfOrderedElectionObjects<\n  T extends OrderedObjectBase\n>(unsorted: T[]): T[] {\n  const inputCopy = Array.from(unsorted);\n  return inputCopy.sort((a, b) => a.sequenceOrder - b.sequenceOrder);\n}\n\n/** Sort an array of {@link ElectionObjectBase} in lexical objectId order. Original is unchanged. */\nexport function sortedArrayOfAnyElectionObjects<T extends ElectionObjectBase>(\n  unsorted: T[]\n): T[] {\n  const inputCopy = Array.from(unsorted);\n  return inputCopy.sort((a, b) => a.objectId.localeCompare(b.objectId));\n}\n\n/**\n * Given an array of {@link OrderedObjectBase} objects, first sorts them\n * by their sequence order, then does pairwise comparison for equality.\n * The inputs are not mutated.\n */\nexport function matchingArraysOfOrderedElectionObjects<\n  T extends OrderedObjectBase\n>(a: T[], b: T[]): boolean {\n  const sortedA = sortedArrayOfOrderedElectionObjects(a);\n  const sortedB = sortedArrayOfOrderedElectionObjects(b);\n  if (sortedA.length !== sortedB.length) {\n    return false;\n  }\n  for (let i = 0; i < sortedA.length; i++) {\n    if (!sortedA[i].equals(sortedB[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n/**\n * Given an array of any {@link ElectionObjectBase} objects, first sorts them\n * by their objectId strings, then does pairwise comparison for equality.\n * The inputs are not mutated.\n */\nexport function matchingArraysOfAnyElectionObjects<\n  T extends ElectionObjectBase\n>(a: T[], b: T[]): boolean {\n  const sortedA = sortedArrayOfAnyElectionObjects(a);\n  const sortedB = sortedArrayOfAnyElectionObjects(b);\n  if (sortedA.length !== sortedB.length) {\n    return false;\n  }\n  for (let i = 0; i < sortedA.length; i++) {\n    if (!sortedA[i].equals(sortedB[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Given two arrays of a type that supports equals(), ({@link Eq}),\n * returns whether their contents are indeed equal. Arrays that might\n * include undefined are also supported.\n */\nexport function matchingArraysWithEquals<T extends Eq<T>>(\n  a: (T | undefined)[] | undefined,\n  b: (T | undefined)[] | undefined\n): boolean {\n  // having some fun here with union types!\n  if (a === undefined && b === undefined) {\n    return true;\n  }\n\n  if (a === undefined || b === undefined) {\n    return false;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let i = 0; i < a.length; i++) {\n      if (!objEqualsOrUndefEquals(a[i], b[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n/** Helper function: compares objects for equality, but also deals with `undefined` values.  */\nexport function objEqualsOrUndefEquals<T extends Eq<T>>(\n  a: T | undefined,\n  b: T | undefined\n): boolean {\n  const aUndef = a === undefined;\n  const bUndef = b === undefined;\n\n  if (aUndef && bUndef) {\n    return true;\n  }\n\n  if (aUndef || bUndef || !a.equals(b)) {\n    return false;\n  }\n\n  return true;\n}\n", "avg_line_length": 29.6564885496, "max_line_length": 103, "alphanum_fraction": 0.6862290862, "annotation_sites": 35, "type_definitions": 3, "loc": 77, "functions": 8, "loc_per_function": 6.625, "estimated_tokens": 1054}