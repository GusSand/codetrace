[
  {
    "prompt": "Security review of this code:\n\nstatic inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n                                         long width, long height,\n\n                                         long lumStride, long chromStride, long dstStride)\n\n{\n\n    RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n",
    "project": "FFmpeg",
    "function_name": "RENAME",
    "vulnerability_type": "general",
    "similarity": 1.0,
    "same_function": true,
    "idx": 0,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nbool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "bool timerlist_expired(QEMUTimerList *timer_list)\n\n{\n\n    int64_t expire_time;\n\n\n\n    if (!atomic_read(&timer_list->active_timers)) {\n\n        return false;\n\n    }\n\n\n\n    qemu_mutex_lock(&timer_list->active_timers_lock);\n\n    if (!timer_list->active_timers) {\n\n        qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n        return false;\n\n    }\n\n    expire_time = timer_list->active_timers->expire_time;\n\n    qemu_mutex_unlock(&timer_list->active_timers_lock);\n\n\n\n    return expire_time < qemu_clock_get_ns(timer_list->clock->type);\n\n}\n",
    "project": "qemu",
    "function_name": "timerlist_expired",
    "vulnerability_type": "general",
    "similarity": 1.0,
    "same_function": true,
    "idx": 1,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nstatic void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->ps.sps->direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->sei.unregistered.x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->sei.unregistered.x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "static void pred_spatial_direct_motion(const H264Context *const h, H264SliceContext *sl,\n\n                                       int *mb_type)\n\n{\n\n    int b8_stride = 2;\n\n    int b4_stride = h->b_stride;\n\n    int mb_xy = sl->mb_xy, mb_y = sl->mb_y;\n\n    int mb_type_col[2];\n\n    const int16_t (*l1mv0)[2], (*l1mv1)[2];\n\n    const int8_t *l1ref0, *l1ref1;\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    unsigned int sub_mb_type = MB_TYPE_L0L1;\n\n    int i8, i4;\n\n    int ref[2];\n\n    int mv[2];\n\n    int list;\n\n\n\n    assert(sl->ref_list[1][0].reference & 3);\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent,\n\n                           sl->mb_y + !!IS_INTERLACED(*mb_type));\n\n\n\n#define MB_TYPE_16x16_OR_INTRA (MB_TYPE_16x16 | MB_TYPE_INTRA4x4 | \\\n\n                                MB_TYPE_INTRA16x16 | MB_TYPE_INTRA_PCM)\n\n\n\n    /* ref = min(neighbors) */\n\n    for (list = 0; list < 2; list++) {\n\n        int left_ref     = sl->ref_cache[list][scan8[0] - 1];\n\n        int top_ref      = sl->ref_cache[list][scan8[0] - 8];\n\n        int refc         = sl->ref_cache[list][scan8[0] - 8 + 4];\n\n        const int16_t *C = sl->mv_cache[list][scan8[0]  - 8 + 4];\n\n        if (refc == PART_NOT_AVAILABLE) {\n\n            refc = sl->ref_cache[list][scan8[0] - 8 - 1];\n\n            C    = sl->mv_cache[list][scan8[0]  - 8 - 1];\n\n        }\n\n        ref[list] = FFMIN3((unsigned)left_ref,\n\n                           (unsigned)top_ref,\n\n                           (unsigned)refc);\n\n        if (ref[list] >= 0) {\n\n            /* This is just pred_motion() but with the cases removed that\n\n             * cannot happen for direct blocks. */\n\n            const int16_t *const A = sl->mv_cache[list][scan8[0] - 1];\n\n            const int16_t *const B = sl->mv_cache[list][scan8[0] - 8];\n\n\n\n            int match_count = (left_ref == ref[list]) +\n\n                              (top_ref  == ref[list]) +\n\n                              (refc     == ref[list]);\n\n\n\n            if (match_count > 1) { // most common\n\n                mv[list] = pack16to32(mid_pred(A[0], B[0], C[0]),\n\n                                      mid_pred(A[1], B[1], C[1]));\n\n            } else {\n\n                assert(match_count == 1);\n\n                if (left_ref == ref[list])\n\n                    mv[list] = AV_RN32A(A);\n\n                else if (top_ref == ref[list])\n\n                    mv[list] = AV_RN32A(B);\n\n                else\n\n                    mv[list] = AV_RN32A(C);\n\n            }\n\n        } else {\n\n            int mask = ~(MB_TYPE_L0 << (2 * list));\n\n            mv[list]  = 0;\n\n            ref[list] = -1;\n\n            if (!is_b8x8)\n\n                *mb_type &= mask;\n\n            sub_mb_type &= mask;\n\n        }\n\n    }\n\n    if (ref[0] < 0 && ref[1] < 0) {\n\n        ref[0] = ref[1] = 0;\n\n        if (!is_b8x8)\n\n            *mb_type |= MB_TYPE_L0L1;\n\n        sub_mb_type |= MB_TYPE_L0L1;\n\n    }\n\n\n\n    if (!(is_b8x8 | mv[0] | mv[1])) {\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n        *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                 MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                   MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n        return;\n\n    }\n\n\n\n    if (IS_INTERLACED(sl->ref_list[1][0].parent->mb_type[mb_xy])) { // AFL/AFR/FR/FL -> AFL/FL\n\n        if (!IS_INTERLACED(*mb_type)) {                    //     AFR/FR    -> AFL/FL\n\n            mb_y  = (sl->mb_y & ~1) + sl->col_parity;\n\n            mb_xy = sl->mb_x +\n\n                    ((sl->mb_y & ~1) + sl->col_parity) * h->mb_stride;\n\n            b8_stride = 0;\n\n        } else {\n\n            mb_y  += sl->col_fieldoff;\n\n            mb_xy += h->mb_stride * sl->col_fieldoff; // non-zero for FL -> FL & differ parity\n\n        }\n\n        goto single_col;\n\n    } else {                                             // AFL/AFR/FR/FL -> AFR/FR\n\n        if (IS_INTERLACED(*mb_type)) {                   // AFL       /FL -> AFR/FR\n\n            mb_y           =  sl->mb_y & ~1;\n\n            mb_xy          = (sl->mb_y & ~1) * h->mb_stride + sl->mb_x;\n\n            mb_type_col[0] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy + h->mb_stride];\n\n            b8_stride      = 2 + 4 * h->mb_stride;\n\n            b4_stride     *= 6;\n\n            if (IS_INTERLACED(mb_type_col[0]) !=\n\n                IS_INTERLACED(mb_type_col[1])) {\n\n                mb_type_col[0] &= ~MB_TYPE_INTERLACED;\n\n                mb_type_col[1] &= ~MB_TYPE_INTERLACED;\n\n            }\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if ((mb_type_col[0] & MB_TYPE_16x16_OR_INTRA) &&\n\n                (mb_type_col[1] & MB_TYPE_16x16_OR_INTRA) &&\n\n                !is_b8x8) {\n\n                *mb_type |= MB_TYPE_16x8 | MB_TYPE_DIRECT2;  /* B_16x8 */\n\n            } else {\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        } else {                                         //     AFR/FR    -> AFR/FR\n\nsingle_col:\n\n            mb_type_col[0] =\n\n            mb_type_col[1] = sl->ref_list[1][0].parent->mb_type[mb_xy];\n\n\n\n            sub_mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n            if (!is_b8x8 && (mb_type_col[0] & MB_TYPE_16x16_OR_INTRA)) {\n\n                *mb_type |= MB_TYPE_16x16 | MB_TYPE_DIRECT2; /* B_16x16 */\n\n            } else if (!is_b8x8 &&\n\n                       (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16))) {\n\n                *mb_type |= MB_TYPE_DIRECT2 |\n\n                            (mb_type_col[0] & (MB_TYPE_16x8 | MB_TYPE_8x16));\n\n            } else {\n\n                if (!h->sps.direct_8x8_inference_flag) {\n\n                    /* FIXME: Save sub mb types from previous frames (or derive\n\n                     * from MVs) so we know exactly what block size to use. */\n\n                    sub_mb_type += (MB_TYPE_8x8 - MB_TYPE_16x16); /* B_SUB_4x4 */\n\n                }\n\n                *mb_type |= MB_TYPE_8x8;\n\n            }\n\n        }\n\n    }\n\n\n\n    await_reference_mb_row(h, sl->ref_list[1][0].parent, mb_y);\n\n\n\n    l1mv0  = &sl->ref_list[1][0].parent->motion_val[0][h->mb2b_xy[mb_xy]];\n\n    l1mv1  = &sl->ref_list[1][0].parent->motion_val[1][h->mb2b_xy[mb_xy]];\n\n    l1ref0 = &sl->ref_list[1][0].parent->ref_index[0][4 * mb_xy];\n\n    l1ref1 = &sl->ref_list[1][0].parent->ref_index[1][4 * mb_xy];\n\n    if (!b8_stride) {\n\n        if (sl->mb_y & 1) {\n\n            l1ref0 += 2;\n\n            l1ref1 += 2;\n\n            l1mv0  += 2 * b4_stride;\n\n            l1mv1  += 2 * b4_stride;\n\n        }\n\n    }\n\n\n\n    if (IS_INTERLACED(*mb_type) != IS_INTERLACED(mb_type_col[0])) {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            int x8  = i8 & 1;\n\n            int y8  = i8 >> 1;\n\n            int xy8 = x8     + y8 * b8_stride;\n\n            int xy4 = x8 * 3 + y8 * b4_stride;\n\n            int a, b;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n            if (!IS_INTRA(mb_type_col[y8]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                ((l1ref0[xy8] == 0 &&\n\n                  FFABS(l1mv0[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv0[xy4][1]) <= 1) ||\n\n                 (l1ref0[xy8] < 0 &&\n\n                  l1ref1[xy8] == 0 &&\n\n                  FFABS(l1mv1[xy4][0]) <= 1 &&\n\n                  FFABS(l1mv1[xy4][1]) <= 1))) {\n\n                a =\n\n                b = 0;\n\n                if (ref[0] > 0)\n\n                    a = mv[0];\n\n                if (ref[1] > 0)\n\n                    b = mv[1];\n\n                n++;\n\n            } else {\n\n                a = mv[0];\n\n                b = mv[1];\n\n            }\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, a, 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, b, 4);\n\n        }\n\n        if (!is_b8x8 && !(n & 3))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    } else if (IS_16X16(*mb_type)) {\n\n        int a, b;\n\n\n\n        fill_rectangle(&sl->ref_cache[0][scan8[0]], 4, 4, 8, (uint8_t)ref[0], 1);\n\n        fill_rectangle(&sl->ref_cache[1][scan8[0]], 4, 4, 8, (uint8_t)ref[1], 1);\n\n        if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n            ((l1ref0[0] == 0 &&\n\n              FFABS(l1mv0[0][0]) <= 1 &&\n\n              FFABS(l1mv0[0][1]) <= 1) ||\n\n             (l1ref0[0] < 0 && !l1ref1[0] &&\n\n              FFABS(l1mv1[0][0]) <= 1 &&\n\n              FFABS(l1mv1[0][1]) <= 1 &&\n\n              h->x264_build > 33U))) {\n\n            a = b = 0;\n\n            if (ref[0] > 0)\n\n                a = mv[0];\n\n            if (ref[1] > 0)\n\n                b = mv[1];\n\n        } else {\n\n            a = mv[0];\n\n            b = mv[1];\n\n        }\n\n        fill_rectangle(&sl->mv_cache[0][scan8[0]], 4, 4, 8, a, 4);\n\n        fill_rectangle(&sl->mv_cache[1][scan8[0]], 4, 4, 8, b, 4);\n\n    } else {\n\n        int n = 0;\n\n        for (i8 = 0; i8 < 4; i8++) {\n\n            const int x8 = i8 & 1;\n\n            const int y8 = i8 >> 1;\n\n\n\n            if (is_b8x8 && !IS_DIRECT(sl->sub_mb_type[i8]))\n\n                continue;\n\n            sl->sub_mb_type[i8] = sub_mb_type;\n\n\n\n            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2, 8, mv[0], 4);\n\n            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2, 8, mv[1], 4);\n\n            fill_rectangle(&sl->ref_cache[0][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[0], 1);\n\n            fill_rectangle(&sl->ref_cache[1][scan8[i8 * 4]], 2, 2, 8,\n\n                           (uint8_t)ref[1], 1);\n\n\n\n            assert(b8_stride == 2);\n\n            /* col_zero_flag */\n\n            if (!IS_INTRA(mb_type_col[0]) && !sl->ref_list[1][0].parent->long_ref &&\n\n                (l1ref0[i8] == 0 ||\n\n                 (l1ref0[i8] < 0 &&\n\n                  l1ref1[i8] == 0 &&\n\n                  h->x264_build > 33U))) {\n\n                const int16_t (*l1mv)[2] = l1ref0[i8] == 0 ? l1mv0 : l1mv1;\n\n                if (IS_SUB_8X8(sub_mb_type)) {\n\n                    const int16_t *mv_col = l1mv[x8 * 3 + y8 * 3 * b4_stride];\n\n                    if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                        if (ref[0] == 0)\n\n                            fill_rectangle(&sl->mv_cache[0][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        if (ref[1] == 0)\n\n                            fill_rectangle(&sl->mv_cache[1][scan8[i8 * 4]], 2, 2,\n\n                                           8, 0, 4);\n\n                        n += 4;\n\n                    }\n\n                } else {\n\n                    int m = 0;\n\n                    for (i4 = 0; i4 < 4; i4++) {\n\n                        const int16_t *mv_col = l1mv[x8 * 2 + (i4 & 1) +\n\n                                                     (y8 * 2 + (i4 >> 1)) * b4_stride];\n\n                        if (FFABS(mv_col[0]) <= 1 && FFABS(mv_col[1]) <= 1) {\n\n                            if (ref[0] == 0)\n\n                                AV_ZERO32(sl->mv_cache[0][scan8[i8 * 4 + i4]]);\n\n                            if (ref[1] == 0)\n\n                                AV_ZERO32(sl->mv_cache[1][scan8[i8 * 4 + i4]]);\n\n                            m++;\n\n                        }\n\n                    }\n\n                    if (!(m & 3))\n\n                        sl->sub_mb_type[i8] += MB_TYPE_16x16 - MB_TYPE_8x8;\n\n                    n += m;\n\n                }\n\n            }\n\n        }\n\n        if (!is_b8x8 && !(n & 15))\n\n            *mb_type = (*mb_type & ~(MB_TYPE_8x8 | MB_TYPE_16x8 | MB_TYPE_8x16 |\n\n                                     MB_TYPE_P1L0 | MB_TYPE_P1L1)) |\n\n                       MB_TYPE_16x16 | MB_TYPE_DIRECT2;\n\n    }\n\n}\n",
    "project": "FFmpeg",
    "function_name": "pred_spatial_direct_motion",
    "vulnerability_type": "general",
    "similarity": 0.9973968501887284,
    "same_function": true,
    "idx": 2,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nint drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(buf, sizeof(buf), params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[nb_drives].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n",
    "project": "qemu",
    "function_name": "drive_init",
    "vulnerability_type": "general",
    "similarity": 0.9955906548206647,
    "same_function": true,
    "idx": 3,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nstatic void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n",
    "project": "qemu",
    "function_name": "gen_storeq_reg",
    "vulnerability_type": "general",
    "similarity": 0.9926739926739927,
    "same_function": true,
    "idx": 4,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nstatic void fill_coding_method_array(sb_int8_array tone_level_idx,\n\n                                     sb_int8_array tone_level_idx_temp,\n\n                                     sb_int8_array coding_method,\n\n                                     int nb_channels,\n\n                                     int c, int superblocktype_2_3,\n\n                                     int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "static void fill_coding_method_array (sb_int8_array tone_level_idx, sb_int8_array tone_level_idx_temp,\n\n                sb_int8_array coding_method, int nb_channels,\n\n                int c, int superblocktype_2_3, int cm_table_select)\n\n{\n\n    int ch, sb, j;\n\n    int tmp, acc, esp_40, comp;\n\n    int add1, add2, add3, add4;\n\n    int64_t multres;\n\n\n\n    // This should never happen\n\n    if (nb_channels <= 0)\n\n        return;\n\n\n\n    if (!superblocktype_2_3) {\n\n        /* This case is untested, no samples available */\n\n        SAMPLES_NEEDED\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++) {\n\n                for (j = 1; j < 63; j++) {  // The loop only iterates to 63 so the code doesn't overflow the buffer\n\n                    add1 = tone_level_idx[ch][sb][j] - 10;\n\n                    if (add1 < 0)\n\n                        add1 = 0;\n\n                    add2 = add3 = add4 = 0;\n\n                    if (sb > 1) {\n\n                        add2 = tone_level_idx[ch][sb - 2][j] + tone_level_idx_offset_table[sb][0] - 6;\n\n                        if (add2 < 0)\n\n                            add2 = 0;\n\n                    }\n\n                    if (sb > 0) {\n\n                        add3 = tone_level_idx[ch][sb - 1][j] + tone_level_idx_offset_table[sb][1] - 6;\n\n                        if (add3 < 0)\n\n                            add3 = 0;\n\n                    }\n\n                    if (sb < 29) {\n\n                        add4 = tone_level_idx[ch][sb + 1][j] + tone_level_idx_offset_table[sb][3] - 6;\n\n                        if (add4 < 0)\n\n                            add4 = 0;\n\n                    }\n\n                    tmp = tone_level_idx[ch][sb][j + 1] * 2 - add4 - add3 - add2 - add1;\n\n                    if (tmp < 0)\n\n                        tmp = 0;\n\n                    tone_level_idx_temp[ch][sb][j + 1] = tmp & 0xff;\n\n                }\n\n                tone_level_idx_temp[ch][sb][0] = tone_level_idx_temp[ch][sb][1];\n\n            }\n\n            acc = 0;\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        acc += tone_level_idx_temp[ch][sb][j];\n\n\n\n            multres = 0x66666667 * (acc * 10);\n\n            esp_40 = (multres >> 32) / 8 + ((multres & 0xffffffff) >> 31);\n\n            for (ch = 0;  ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++) {\n\n                        comp = tone_level_idx_temp[ch][sb][j]* esp_40 * 10;\n\n                        if (comp < 0)\n\n                            comp += 0xff;\n\n                        comp /= 256; // signed shift\n\n                        switch(sb) {\n\n                            case 0:\n\n                                if (comp < 30)\n\n                                    comp = 30;\n\n                                comp += 15;\n\n                                break;\n\n                            case 1:\n\n                                if (comp < 24)\n\n                                    comp = 24;\n\n                                comp += 10;\n\n                                break;\n\n                            case 2:\n\n                            case 3:\n\n                            case 4:\n\n                                if (comp < 16)\n\n                                    comp = 16;\n\n                        }\n\n                        if (comp <= 5)\n\n                            tmp = 0;\n\n                        else if (comp <= 10)\n\n                            tmp = 10;\n\n                        else if (comp <= 16)\n\n                            tmp = 16;\n\n                        else if (comp <= 24)\n\n                            tmp = -1;\n\n                        else\n\n                            tmp = 0;\n\n                        coding_method[ch][sb][j] = ((tmp & 0xfffa) + 30 )& 0xff;\n\n                    }\n\n            for (sb = 0; sb < 30; sb++)\n\n                fix_coding_method_array(sb, nb_channels, coding_method);\n\n            for (ch = 0; ch < nb_channels; ch++)\n\n                for (sb = 0; sb < 30; sb++)\n\n                    for (j = 0; j < 64; j++)\n\n                        if (sb >= 10) {\n\n                            if (coding_method[ch][sb][j] < 10)\n\n                                coding_method[ch][sb][j] = 10;\n\n                        } else {\n\n                            if (sb >= 2) {\n\n                                if (coding_method[ch][sb][j] < 16)\n\n                                    coding_method[ch][sb][j] = 16;\n\n                            } else {\n\n                                if (coding_method[ch][sb][j] < 30)\n\n                                    coding_method[ch][sb][j] = 30;\n\n                            }\n\n                        }\n\n    } else { // superblocktype_2_3 != 0\n\n        for (ch = 0; ch < nb_channels; ch++)\n\n            for (sb = 0; sb < 30; sb++)\n\n                for (j = 0; j < 64; j++)\n\n                    coding_method[ch][sb][j] = coding_method_table[cm_table_select][sb];\n\n    }\n\n\n\n    return;\n\n}\n",
    "project": "FFmpeg",
    "function_name": "fill_coding_method_array",
    "vulnerability_type": "general",
    "similarity": 0.9921323381077265,
    "same_function": true,
    "idx": 5,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nstatic int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n\n            goto out;\n\n        }\n\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n\n            goto out;\n\n        }\n\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n",
    "project": "qemu",
    "function_name": "xen_9pfs_connect",
    "vulnerability_type": "general",
    "similarity": 0.9918952618453866,
    "same_function": true,
    "idx": 6,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nstatic int read_gab2_sub(AVStream *st, AVPacket *pkt) {\n\n    if (!strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data+5) == 2) {\n\n        uint8_t desc[256];\n\n        int score = AVPROBE_SCORE_MAX / 2, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n\n                                              pkt->size - 7,\n\n                                              0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb      = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "static int read_gab2_sub(AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf      = pb->buf_ptr,\n\n                             .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n",
    "project": "FFmpeg",
    "function_name": "read_gab2_sub",
    "vulnerability_type": "general",
    "similarity": 0.9866666666666667,
    "same_function": true,
    "idx": 7,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nint attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n                                              int *got_picture_ptr,\n                                              AVPacket *avpkt)\n{\n    int ret;\n    *got_picture_ptr = 0;\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n        return -1;\n    avctx->pkt = avpkt;\n    apply_param_change(avctx, avpkt);\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n                                         avpkt);\n        else {\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n                                       avpkt);\n            picture->pkt_dts             = avpkt->dts;\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n            picture->width               = avctx->width;\n            picture->height              = avctx->height;\n            picture->format              = avctx->pix_fmt;\n        }\n        emms_c(); //needed to avoid an emms_c() call before every return;\n        if (*got_picture_ptr)\n            avctx->frame_number++;\n    } else\n        ret = 0;\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n     * make sure it's set correctly */\n    picture->extended_data = picture->data;\n    return ret;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,\n\n                                              int *got_picture_ptr,\n\n                                              AVPacket *avpkt)\n\n{\n\n    int ret;\n\n\n\n    *got_picture_ptr = 0;\n\n    if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx))\n\n        return -1;\n\n\n\n    avctx->pkt = avpkt;\n\n    apply_param_change(avctx, avpkt);\n\n\n\n    avcodec_get_frame_defaults(picture);\n\n\n\n    if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) {\n\n        if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME)\n\n            ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr,\n\n                                         avpkt);\n\n        else {\n\n            ret = avctx->codec->decode(avctx, picture, got_picture_ptr,\n\n                                       avpkt);\n\n            picture->pkt_dts             = avpkt->dts;\n\n            picture->sample_aspect_ratio = avctx->sample_aspect_ratio;\n\n            picture->width               = avctx->width;\n\n            picture->height              = avctx->height;\n\n            picture->format              = avctx->pix_fmt;\n\n        }\n\n\n\n        emms_c(); //needed to avoid an emms_c() call before every return;\n\n\n\n        if (*got_picture_ptr)\n\n            avctx->frame_number++;\n\n    } else\n\n        ret = 0;\n\n\n\n    /* many decoders assign whole AVFrames, thus overwriting extended_data;\n\n     * make sure it's set correctly */\n\n    picture->extended_data = picture->data;\n\n\n\n    return ret;\n\n}\n",
    "project": "FFmpeg",
    "function_name": "avcodec_decode_video2",
    "vulnerability_type": "general",
    "similarity": 0.9816377171215881,
    "same_function": true,
    "idx": 8,
    "typechecks": true
  },
  {
    "prompt": "Security review of this code:\n\nstatic void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGLabel *lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                TCGLabel *lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_ctzi_tl(cpu_R[rd], cpu_R[ra], -1);\n\n            tcg_gen_addi_tl(cpu_R[rd], cpu_R[rd], 1);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_clzi_tl(cpu_R[rd], cpu_R[ra], TARGET_LONG_BITS);\n\n            tcg_gen_subfi_tl(cpu_R[rd], TARGET_LONG_BITS, cpu_R[rd]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_trunc_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                int lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab0 = gen_new_label();\n\n                int lab1 = gen_new_label();\n\n                int lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                int lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                int lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_ff1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            gen_helper_fl1(cpu_R[rd], cpu_R[ra]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n",
    "project": "qemu",
    "function_name": "dec_calc",
    "vulnerability_type": "general",
    "similarity": 0.98067287043665,
    "same_function": true,
    "idx": 9,
    "typechecks": true
  }
]