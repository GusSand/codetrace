[
  {
    "original_program": "<fim_prefix>def words_in_sentence(sentence: str) -> str:\n    \"\"\"\n    You are given a string representing a sentence,\n    the sentence contains some words separated by a space,\n    and you have to return a string that contains the words from the original sentence,\n    whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original one.\n\n    Example 1:\n    >>> words_in_sentence('This is a test')\n    'is'\n\n    Example 2:\n    >>> words_in_sentence('lets go for swimming')\n    'go for'\n    \n    Constraints:\n        * 1 <= len(sentence) <= 100\n        * sentence contains only letters\n    \"\"\"\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, n):\n            if n % i == 0:\n                return False\n        return True\n\n    words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):<fim_suffix>    return ' '.join(prime_words)<fim_middle>",
    "mutated_program": "def __tmp0(__tmp1: str) -> int:\n    \"\"\"\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> closest_integer('10')\n    10\n    >>> closest_integer('15.3')\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example closest_integer(\"14.5\") should\n    return 15 and closest_integer(\"-14.5\") should return -15.\n    \"\"\"\n    value = float(value)\n    integer_val = int(value)_CodetraceSpecialPlaceholder_\n",
    "expected_type": "prefix",
    "original_prediction": "\n            prime_words.append(word)\n    return ' '.join(prime_words)\n\n",
    "mutated_prediction": "\n    if value == integer_val:\n        return integer_val\n    if value == integer_val",
    "original_correct": true,
    "mutated_correct": false
  },
  {
    "original_program": "<fim_prefix>def remove_vowels(text: str) -> str:\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B'\n    >>> remove_vowels('zbcd')\n    'zbcd'\n    \"\"\"\n<fim_suffix>    return ''.join(filter(lambda x: x not in vowels, text))\n<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp2(__tmp0: List[int], __tmp1: int) -> bool:\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for num in l:_CodetraceSpecialPlaceholder_            return False\n    return True\n",
    "expected_type": "prefix",
    "original_prediction": "",
    "mutated_prediction": "\n        if num < t:\n            return False\n    return True\n\ndef __tmp3(__tmp",
    "original_correct": false,
    "mutated_correct": false
  },
  {
    "original_program": "<fim_prefix>def file_name_check(file_name: str) -> str:\n    \"\"\"Create a function which takes a string representing a file's name, and returns\n    'Yes' if the the file's name is valid, and returns 'No' otherwise.\n    A file's name is considered to be valid if and only if all the following conditions \n    are met:\n    - There should not be more than three digits ('0'-'9') in the file's name.\n    - The file's name contains exactly one dot '.'\n    - The substring before the dot should not be empty, and it starts with a letter from \n    the latin alphapet ('a'-'z' and 'A'-'Z').\n    - The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n    Examples:\n    >>> file_name_check('example.txt')\n    'Yes'\n    >>> file_name_check('1example.dll')\n    'No'\n    \"\"\"\n    if not file_name:\n        return 'No'<fim_suffix>    e_count = 0\n    for i in file_name:\n        if i.isdigit():\n            s_count += 1\n        if i == '.':\n            e_count += 1\n    if s_count > 3 or e_count != 1:\n        return 'No'\n    s_name = file_name.split('.')[0]\n    e_name = file_name.split('.')[1]\n    if not s_name or not e_name or not s_name[0].isalpha():\n        return 'No'\n    if e_name not in ['txt', 'exe', 'dll']:\n        return 'No'\n    return 'Yes'\n\n<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp1(__tmp0: List[int]) -> List[int]:\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    p = []\n    for i in l:\n        if i > 0:\n            p.append(i)_CodetraceSpecialPlaceholder_",
    "expected_type": "prefix",
    "original_prediction": "\n    if len(file_name) > 3:\n        return 'No'\n    if file",
    "mutated_prediction": "\n    return p\n\ndef get_positive(l: List[int]) -> List[int",
    "original_correct": false,
    "mutated_correct": true
  },
  {
    "original_program": "<fim_prefix>from typing import List\n\ndef do_algebra(operator: List[str], operand: List[int]) -> int:\n    \"\"\"\n    Given two lists operator, and operand. The first list has basic algebra operations, and \n    the second list is a list of integers. Use the two given lists to build the algebric \n    expression and return the evaluation of this expression.\n\n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n\n    Example:\n    operator['+', '*', '-']\n    array = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n    => result = 9\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n\n    \"\"\"\n    if len(operator) != len(operand) - 1:\n        raise ValueError(\"Invalid number of operators\")\n    expr = [str(operand[0])]\n    for idx, op in enumerate(operator):\n        expr.append(op)<fim_suffix>    return eval(\"\".join(expr))<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp0(__tmp1: List[int]) -> float:\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    sorted_l = sorted(l)_CodetraceSpecialPlaceholder_",
    "expected_type": "prefix",
    "original_prediction": "\n        if op == '+':\n            expr.append(operand[idx + 1])\n        elif",
    "mutated_prediction": "\n    if len(sorted_l) % 2 == 0:\n        return (sorted_",
    "original_correct": false,
    "mutated_correct": false
  },
  {
    "original_program": "<fim_prefix>from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:    \n    >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n    [1, 2, 1]\n\n    >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n    [1]\n    \"\"\"\n    min_val = float('inf')\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                row = i\n                col = j\n    path = [min_val]\n    while len(path) < k:\n        min_val = float('inf')\n        for i, j in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):<fim_suffix>                min_val = grid[i][j]\n                row = i\n                col = j\n        path.append(min_val)\n    return path<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp1(__tmp0: List[int]) -> int:\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. \n    \n    Examples:\n    >>> lst\n    [1, 2, 3]\n    >>> lst\n    []\n    >>> lst\n    [-1, -5, 2, -1, -5]\n    \"\"\"\n    for index in range(len(lst)):\n        if index % 3 == 0:_CodetraceSpecialPlaceholder_        elif index % 4 == 0:\n            lst[index] = lst[index] ** 3\n    return sum(lst)",
    "expected_type": "prefix",
    "original_prediction": "\n            if 0 <= i < len(grid) and 0 <= j < len(grid",
    "mutated_prediction": "\n            lst[index] = lst[index] ** 2\n        elif index % 4 ==",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "original_program": "<fim_prefix>from typing import List\n\ndef match_parens(lst: List[str]) -> str:\n    \"\"\"\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    >>> match_parens(['()(', ')'])\n    'Yes'\n    >>> match_parens([')', ')'])\n    'No'\n    \"\"\"\n    s1, s2 = lst\n    strings = [s1 + s2, s2 + s1]\n    for s in strings:\n        open_parens = 0\n        close_parens = 0\n        for c in s:\n            if c == '(':\n                open_parens += 1<fim_suffix>                if open_parens:\n                    open_parens -= 1\n                else:\n                    close_parens += 1\n        if open_parens == 0 and close_parens == 0:\n            return 'Yes'\n    return 'No'\n<fim_middle>",
    "mutated_program": "def __tmp0(__tmp1: str) -> str:\n    \"\"\"You are given a string s.\n    if s[i] is a letter, reverse its case from lower to upper or vise versa, \n    otherwise keep it as it is.\n    If the string contains no letters, reverse the string.\n    The function should return the resulted string.\n    Examples\n    >>> solve('1234')\n    '4321'\n    >>> solve('ab')\n    'AB'\n    >>> solve('#a@C')\n    '#A@c'\n    \"\"\"\n    if not any(l.isalpha() for l in s):\n        return s[::-1]\n    else:_CodetraceSpecialPlaceholder_\n",
    "expected_type": "prefix",
    "original_prediction": "\n            elif c == ')':\n                close_parens += 1\n            else:\n                raise ValueError",
    "mutated_prediction": "\n        return s[0].upper() + s[1:]\n\n\ndef __tmp1(__",
    "original_correct": true,
    "mutated_correct": false
  },
  {
    "original_program": "<fim_prefix>def get_max_triples(n: int) -> int:\n    \"\"\"\n    You are given a positive integer n. You have to create an integer array a of length n.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, \n    and a[i] + a[j] + a[k] is a multiple of 3.\n\n    Example :\n    >>> get_max_triples(5)\n    1\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        The only valid triple is (1, 7, 13).\n    \"\"\"\n    a = [i * i - i + 1 for i in range(1, n + 1)]\n    i = 0\n    j = 1\n    k = 2\n    count = 0\n    while (i < n - 2):\n        while (j < n - 1):\n            while (k < n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:<fim_suffix>                k += 1\n            j += 1\n            k = j + 1\n        i += 1\n        j = i + 1\n        k = j + 1\n    return count\n\n<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp0(__tmp1: List[int]) -> int:\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([])\n    0\n    >>> count_nums([-1, 11, -11])\n    1\n    >>> count_nums([1, 1, 2])\n    3\n    \"\"\"\n    n = 0\n    for i in arr:_CodetraceSpecialPlaceholder_            i = abs(i)\n            s = -1 * int(str(i)[0])\n            for j in str(i)[1:]:\n                s += int(j)\n        else:\n            s = 0\n            for j in str(i):\n                s += int(j)\n        if s > 0:\n            n += 1\n    return n\n",
    "expected_type": "prefix",
    "original_prediction": "\n                    count += 1\n                k += 1\n            j += 1\n        i += 1",
    "mutated_prediction": "\n        if i >= 0:\n            n += 1\n    return n\n\ndef __tmp",
    "original_correct": true,
    "mutated_correct": false
  },
  {
    "original_program": "<fim_prefix>def check_if_last_char_is_a_letter(txt: str) -> bool:\n    \"\"\"\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    >>> check_if_last_char_is_a_letter('apple pie')\n    False\n    >>> check_if_last_char_is_a_letter('apple pi e')\n    True\n    >>> check_if_last_char_is_a_letter('apple pi e ')\n    False\n    >>> check_if_last_char_is_a_letter('')\n    False\n    \"\"\"\n    if len(txt) == 0:\n        return False\n    elif txt[-1].isalpha() and (len(txt) == 1 or not txt[-2].isalpha()):<fim_suffix>    else:\n        return False\n<fim_middle>",
    "mutated_program": "from typing import Tuple\n\ndef __tmp1(__tmp0: int) -> Tuple[int, int]:\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n    >>> even_odd_count(-12)\n    (1, 1)\n    >>> even_odd_count(123)\n    (1, 2)\n    \"\"\"\n    num_str = str(abs(num))\n    even_count = 0\n    odd_count = 0\n    for ch in num_str:\n        digit = int(ch)\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1_CodetraceSpecialPlaceholder_\n",
    "expected_type": "prefix",
    "original_prediction": "\n        return True\n    else:\n        return False\n\n\ndef check_if_last_char_",
    "mutated_prediction": "\n    return even_count, odd_count\n\ndef even_odd_count(num:",
    "original_correct": true,
    "mutated_correct": true
  },
  {
    "original_program": "<fim_prefix>def cycpattern_check(a: str, b: str) -> bool:\n    \"\"\"You are given 2 words. You need to return True if the second word or any of its rotations is a substring in the first word\n    >>> cycpattern_check('abcd', 'abd')\n    False\n    >>> cycpattern_check('hello', 'ell')\n    True\n    >>> cycpattern_check('whassup', 'psus')\n    False\n    >>> cycpattern_check('abab', 'baa')\n    True\n    >>> cycpattern_check('efef', 'eeff')\n    False\n    >>> cycpattern_check('himenss', 'simen')\n    True\n\n    \"\"\"\n    for i in range(len(b)):\n        if a.find(b) != -1:\n            return True<fim_suffix>    return False\n\n<fim_middle>",
    "mutated_program": "from typing import List\n\ndef __tmp0(__tmp1: List[int]) -> bool:\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n_CodetraceSpecialPlaceholder_        return True\n    return False\n",
    "expected_type": "prefix",
    "original_prediction": "\n    return False\n\n\ndef cycpattern_check_2(a: str, b:",
    "mutated_prediction": "\ndef monotonic(l: List[int]) -> bool:\n    \"\"\"Return True is list",
    "original_correct": false,
    "mutated_correct": false
  },
  {
    "original_program": "<fim_prefix>from typing import List\n\ndef minPath(grid: List[List[int]], k: int) -> List[int]:\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:    \n    >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n    [1, 2, 1]\n\n    >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n    [1]\n    \"\"\"\n    min_val = float('inf')\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if grid[i][j] < min_val:<fim_suffix>                row = i\n                col = j\n    path = [min_val]\n    while len(path) < k:\n        min_val = float('inf')\n        for i, j in (row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1):\n            if 0 <= i < len(grid) and 0 <= j < len(grid[0]) and grid[i][j] < min_val:\n                min_val = grid[i][j]\n                row = i\n                col = j\n        path.append(min_val)\n    return path<fim_middle>",
    "mutated_program": "from typing import Union\n\ndef __tmp0(__tmp2: Union[int, float, str], __tmp1: Union[int, float, str]) -> Union[int, float, str, None]:\n    \"\"\"\n    Create a function that takes integers, floats, or strings representing\n    real numbers, and returns the larger variable in its given variable type.\n    Return None if the values are equal.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    >>> compare_one(1, 2.5)\n    2.5\n    >>> compare_one(1, '2,3')\n    '2,3'\n    >>> compare_one('5,1', '6')\n    '6'\n    >>> compare_one('1', 1)\n    None\n    \"\"\"\n    if isinstance(a, int) and isinstance(b, int):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, float) and isinstance(b, float):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, str):\n        a_tmp = a.replace(',', '.')\n        b_tmp = b.replace(',', '.')\n        if float(a_tmp) > float(b_tmp):\n            return a\n        elif float(a_tmp) < float(b_tmp):\n            return b\n        else:\n            return None\n    elif isinstance(a, int) and isinstance(b, float):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, float) and isinstance(b, int):\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, int):\n        a_tmp = a.replace(',', '.')\n        if float(a_tmp) > b:\n            return a\n        elif float(a_tmp) < b:\n            return b\n        else:\n            return None\n    elif isinstance(a, int) and isinstance(b, str):_CodetraceSpecialPlaceholder_        if a > float(b_tmp):\n            return a\n        elif a < float(b_tmp):\n            return b\n        else:\n            return None\n    elif isinstance(a, str) and isinstance(b, float):\n        a_tmp = a.replace(',', '.')\n        if float(a_tmp) > b:\n            return a\n        elif float(a_tmp) < b:\n            return b",
    "expected_type": "prefix",
    "original_prediction": "\n                min_val = grid[i][j]\n                path = [i, j]\n           ",
    "mutated_prediction": "\n        if a > b:\n            return a\n        elif a < b:\n            return b\n        else",
    "original_correct": true,
    "mutated_correct": false
  }
]