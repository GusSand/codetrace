[
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "2c21d34ea44d38835f85b90de3cbbf54abb894be",
      "func": "void av_free(void *ptr)\n\n{\n\n#if CONFIG_MEMALIGN_HACK\n\n    if (ptr)\n\n        free((char *)ptr - ((char *)ptr)[-1]);\n\n#elif HAVE_ALIGNED_MALLOC\n\n    _aligned_free(ptr);\n\n#else\n\n    free(ptr);\n\n#endif\n\n}\n",
      "function_name": "av_free",
      "idx": 10740
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "4fb311c804098d78e5ce5f527f9a9c37536d3a08",
      "func": "void av_free(void *ptr)\n\n{\n\n#if CONFIG_MEMALIGN_HACK\n\n    if (ptr)\n\n        free((char *)ptr - ((char *)ptr)[-1]);\n\n#elif HAVE_ALIGNED_MALLOC\n\n    _aligned_free(ptr);\n\n#else\n\n    free(ptr);\n\n#endif\n\n}\n",
      "function_name": "av_free",
      "idx": 13550
    },
    "same_function": true,
    "similarity": 1.0
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "90a09b69d7f5d4fc5622c6aec69d5ceef1a72c04",
      "func": "static void floor_fit(venc_context_t * venc, floor_t * fc, float * coeffs, int * posts, int samples) {\n\n    int range = 255 / fc->multiplier + 1;\n\n    int i;\n\n    for (i = 0; i < fc->values; i++) {\n\n        int position = fc->list[fc->list[i].sort].x;\n\n        int begin = fc->list[fc->list[FFMAX(i-1, 0)].sort].x;\n\n        int end   = fc->list[fc->list[FFMIN(i+1, fc->values - 1)].sort].x;\n\n        int j;\n\n        float average = 0;\n\n        begin = (position + begin) / 2;\n\n        end   = (position + end  ) / 2;\n\n\n\n        assert(end <= samples);\n\n        for (j = begin; j < end; j++) average += fabs(coeffs[j]);\n\n        average /= end - begin;\n\n        average /= 32; // MAGIC!\n\n        for (j = 0; j < range; j++) if (floor1_inverse_db_table[j * fc->multiplier] > average) break;\n\n        posts[fc->list[i].sort] = j;\n\n    }\n\n}\n",
      "function_name": "floor_fit",
      "idx": 1328
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "68e75e4dec6b5f46a190118eecbba1e95c396e3d",
      "func": "static void floor_fit(venc_context_t * venc, floor_t * fc, float * coeffs, int * posts, int samples) {\n\n    int range = 255 / fc->multiplier + 1;\n\n    int i;\n\n    for (i = 0; i < fc->values; i++) {\n\n        int position = fc->list[fc->list[i].sort].x;\n\n        int begin = fc->list[fc->list[FFMAX(i-1, 0)].sort].x;\n\n        int end   = fc->list[fc->list[FFMIN(i+1, fc->values - 1)].sort].x;\n\n        int j;\n\n        float average = 0;\n\n        begin = (position + begin) / 2;\n\n        end   = (position + end  ) / 2;\n\n\n\n        assert(end <= samples);\n\n        for (j = begin; j < end; j++) average += fabs(coeffs[j]);\n\n        average /= end - begin;\n\n        average /= 32; // MAGIC!\n\n        for (j = 0; j < range - 1; j++) if (floor1_inverse_db_table[j * fc->multiplier] > average) break;\n\n        posts[fc->list[i].sort] = j;\n\n    }\n\n}\n",
      "function_name": "floor_fit",
      "idx": 10148
    },
    "same_function": true,
    "similarity": 0.9970717423133236
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "838740e6420538ad45982da6b1d3aa3ae91307f5",
      "func": "static void decode_hrd(HEVCContext *s, int common_inf_present,\n\n                       int max_sublayers)\n\n{\n\n    GetBitContext *gb = &s->HEVClc.gb;\n\n    int nal_params_present = 0, vcl_params_present = 0;\n\n    int subpic_params_present = 0;\n\n    int i;\n\n\n\n    if (common_inf_present) {\n\n        nal_params_present = get_bits1(gb);\n\n        vcl_params_present = get_bits1(gb);\n\n\n\n        if (nal_params_present || vcl_params_present) {\n\n            subpic_params_present = get_bits1(gb);\n\n\n\n            if (subpic_params_present) {\n\n                skip_bits(gb, 8); // tick_divisor_minus2\n\n                skip_bits(gb, 5); // du_cpb_removal_delay_increment_length_minus1\n\n                skip_bits(gb, 1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n\n                skip_bits(gb, 5); // dpb_output_delay_du_length_minus1\n\n            }\n\n\n\n            skip_bits(gb, 4); // bit_rate_scale\n\n            skip_bits(gb, 4); // cpb_size_scale\n\n\n\n            if (subpic_params_present)\n\n                skip_bits(gb, 4);  // cpb_size_du_scale\n\n\n\n            skip_bits(gb, 5); // initial_cpb_removal_delay_length_minus1\n\n            skip_bits(gb, 5); // au_cpb_removal_delay_length_minus1\n\n            skip_bits(gb, 5); // dpb_output_delay_length_minus1\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < max_sublayers; i++) {\n\n        int low_delay = 0;\n\n        int nb_cpb = 1;\n\n        int fixed_rate = get_bits1(gb);\n\n\n\n        if (!fixed_rate)\n\n            fixed_rate = get_bits1(gb);\n\n\n\n        if (fixed_rate)\n\n            get_ue_golomb_long(gb);  // elemental_duration_in_tc_minus1\n\n        else\n\n            low_delay = get_bits1(gb);\n\n\n\n        if (!low_delay)\n\n            nb_cpb = get_ue_golomb_long(gb) + 1;\n\n\n\n        if (nal_params_present)\n\n            decode_sublayer_hrd(s, nb_cpb, subpic_params_present);\n\n        if (vcl_params_present)\n\n            decode_sublayer_hrd(s, nb_cpb, subpic_params_present);\n\n    }\n\n}\n",
      "function_name": "decode_hrd",
      "idx": 14460
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "ba80b8d29b2adc7fd74324c9bd50cd0be7ab2c21",
      "func": "static void decode_hrd(HEVCContext *s, int common_inf_present,\n\n                       int max_sublayers)\n\n{\n\n    GetBitContext *gb = &s->HEVClc->gb;\n\n    int nal_params_present = 0, vcl_params_present = 0;\n\n    int subpic_params_present = 0;\n\n    int i;\n\n\n\n    if (common_inf_present) {\n\n        nal_params_present = get_bits1(gb);\n\n        vcl_params_present = get_bits1(gb);\n\n\n\n        if (nal_params_present || vcl_params_present) {\n\n            subpic_params_present = get_bits1(gb);\n\n\n\n            if (subpic_params_present) {\n\n                skip_bits(gb, 8); // tick_divisor_minus2\n\n                skip_bits(gb, 5); // du_cpb_removal_delay_increment_length_minus1\n\n                skip_bits(gb, 1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n\n                skip_bits(gb, 5); // dpb_output_delay_du_length_minus1\n\n            }\n\n\n\n            skip_bits(gb, 4); // bit_rate_scale\n\n            skip_bits(gb, 4); // cpb_size_scale\n\n\n\n            if (subpic_params_present)\n\n                skip_bits(gb, 4);  // cpb_size_du_scale\n\n\n\n            skip_bits(gb, 5); // initial_cpb_removal_delay_length_minus1\n\n            skip_bits(gb, 5); // au_cpb_removal_delay_length_minus1\n\n            skip_bits(gb, 5); // dpb_output_delay_length_minus1\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < max_sublayers; i++) {\n\n        int low_delay = 0;\n\n        unsigned int nb_cpb = 1;\n\n        int fixed_rate = get_bits1(gb);\n\n\n\n        if (!fixed_rate)\n\n            fixed_rate = get_bits1(gb);\n\n\n\n        if (fixed_rate)\n\n            get_ue_golomb_long(gb);  // elemental_duration_in_tc_minus1\n\n        else\n\n            low_delay = get_bits1(gb);\n\n\n\n        if (!low_delay)\n\n            nb_cpb = get_ue_golomb_long(gb) + 1;\n\n\n\n        if (nal_params_present)\n\n            decode_sublayer_hrd(s, nb_cpb, subpic_params_present);\n\n        if (vcl_params_present)\n\n            decode_sublayer_hrd(s, nb_cpb, subpic_params_present);\n\n    }\n\n}\n",
      "function_name": "decode_hrd",
      "idx": 11758
    },
    "same_function": true,
    "similarity": 0.9944289693593314
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "9a4f5b76169a71156819dbaa8ee0b6ea25dc7195",
      "func": "static int mjpegb_decode_frame(AVCodecContext *avctx,\n\n                              void *data, int *data_size,\n\n                              AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MJpegDecodeContext *s = avctx->priv_data;\n\n    const uint8_t *buf_end, *buf_ptr;\n\n    AVFrame *picture = data;\n\n    GetBitContext hgb; /* for the header */\n\n    uint32_t dqt_offs, dht_offs, sof_offs, sos_offs, second_field_offs;\n\n    uint32_t field_size, sod_offs;\n\n\n\n    buf_ptr = buf;\n\n    buf_end = buf + buf_size;\n\n\n\n\nread_header:\n\n    /* reset on every SOI */\n\n    s->restart_interval = 0;\n\n    s->restart_count = 0;\n\n    s->mjpb_skiptosod = 0;\n\n\n\n    if (buf_end - buf_ptr >= 1 << 28)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    init_get_bits(&hgb, buf_ptr, /*buf_size*/(buf_end - buf_ptr)*8);\n\n\n\n    skip_bits(&hgb, 32); /* reserved zeros */\n\n\n\n    if (get_bits_long(&hgb, 32) != MKBETAG('m','j','p','g'))\n\n    {\n\n        av_log(avctx, AV_LOG_WARNING, \"not mjpeg-b (bad fourcc)\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    field_size = get_bits_long(&hgb, 32); /* field size */\n\n    av_log(avctx, AV_LOG_DEBUG, \"field size: 0x%x\\n\", field_size);\n\n    skip_bits(&hgb, 32); /* padded field size */\n\n    second_field_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"second_field_offs is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"second field offs: 0x%x\\n\", second_field_offs);\n\n\n\n    dqt_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"dqt is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"dqt offs: 0x%x\\n\", dqt_offs);\n\n    if (dqt_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr+dqt_offs, (buf_end - (buf_ptr+dqt_offs))*8);\n\n        s->start_code = DQT;\n\n        if (ff_mjpeg_decode_dqt(s) < 0 &&\n\n            (avctx->err_recognition & AV_EF_EXPLODE))\n\n          return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    dht_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"dht is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"dht offs: 0x%x\\n\", dht_offs);\n\n    if (dht_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr+dht_offs, (buf_end - (buf_ptr+dht_offs))*8);\n\n        s->start_code = DHT;\n\n        ff_mjpeg_decode_dht(s);\n\n    }\n\n\n\n    sof_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"sof is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"sof offs: 0x%x\\n\", sof_offs);\n\n    if (sof_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr+sof_offs, (buf_end - (buf_ptr+sof_offs))*8);\n\n        s->start_code = SOF0;\n\n        if (ff_mjpeg_decode_sof(s) < 0)\n\n            return -1;\n\n    }\n\n\n\n    sos_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"sos is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"sos offs: 0x%x\\n\", sos_offs);\n\n    sod_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"sof is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"sod offs: 0x%x\\n\", sod_offs);\n\n    if (sos_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr + sos_offs,\n\n                      8 * FFMIN(field_size, buf_end - buf_ptr - sos_offs));\n\n        s->mjpb_skiptosod = (sod_offs - sos_offs - show_bits(&s->gb, 16));\n\n        s->start_code = SOS;\n\n        if (ff_mjpeg_decode_sos(s, NULL, NULL) < 0 &&\n\n            (avctx->err_recognition & AV_EF_EXPLODE))\n\n          return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->interlaced) {\n\n        s->bottom_field ^= 1;\n\n        /* if not bottom field, do not output image yet */\n\n        if (s->bottom_field != s->interlace_polarity && second_field_offs)\n\n        {\n\n            buf_ptr = buf + second_field_offs;\n\n            goto read_header;\n\n            }\n\n    }\n\n\n\n    //XXX FIXME factorize, this looks very similar to the EOI code\n\n\n\n    *picture= *s->picture_ptr;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    if(!s->lossless){\n\n        picture->quality= FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2]);\n\n        picture->qstride= 0;\n\n        picture->qscale_table= s->qscale_table;\n\n        memset(picture->qscale_table, picture->quality, (s->width+15)/16);\n\n        if(avctx->debug & FF_DEBUG_QP)\n\n            av_log(avctx, AV_LOG_DEBUG, \"QP: %d\\n\", picture->quality);\n\n        picture->quality*= FF_QP2LAMBDA;\n\n    }\n\n\n\n    return buf_size;\n\n}",
      "function_name": "mjpegb_decode_frame",
      "idx": 6453
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "74699ac8c8b562e9f8d26e21482b89585365774a",
      "func": "static int mjpegb_decode_frame(AVCodecContext *avctx,\n\n                              void *data, int *data_size,\n\n                              AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MJpegDecodeContext *s = avctx->priv_data;\n\n    const uint8_t *buf_end, *buf_ptr;\n\n    AVFrame *picture = data;\n\n    GetBitContext hgb; /* for the header */\n\n    uint32_t dqt_offs, dht_offs, sof_offs, sos_offs, second_field_offs;\n\n    uint32_t field_size, sod_offs;\n\n\n\n    buf_ptr = buf;\n\n    buf_end = buf + buf_size;\n\n\n\nread_header:\n\n    /* reset on every SOI */\n\n    s->restart_interval = 0;\n\n    s->restart_count = 0;\n\n    s->mjpb_skiptosod = 0;\n\n\n\n    if (buf_end - buf_ptr >= 1 << 28)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    init_get_bits(&hgb, buf_ptr, /*buf_size*/(buf_end - buf_ptr)*8);\n\n\n\n    skip_bits(&hgb, 32); /* reserved zeros */\n\n\n\n    if (get_bits_long(&hgb, 32) != MKBETAG('m','j','p','g'))\n\n    {\n\n        av_log(avctx, AV_LOG_WARNING, \"not mjpeg-b (bad fourcc)\\n\");\n\n        return 0;\n\n    }\n\n\n\n    field_size = get_bits_long(&hgb, 32); /* field size */\n\n    av_log(avctx, AV_LOG_DEBUG, \"field size: 0x%x\\n\", field_size);\n\n    skip_bits(&hgb, 32); /* padded field size */\n\n    second_field_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"second_field_offs is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"second field offs: 0x%x\\n\", second_field_offs);\n\n\n\n    dqt_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"dqt is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"dqt offs: 0x%x\\n\", dqt_offs);\n\n    if (dqt_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr+dqt_offs, (buf_end - (buf_ptr+dqt_offs))*8);\n\n        s->start_code = DQT;\n\n        if (ff_mjpeg_decode_dqt(s) < 0 &&\n\n            (avctx->err_recognition & AV_EF_EXPLODE))\n\n          return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    dht_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"dht is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"dht offs: 0x%x\\n\", dht_offs);\n\n    if (dht_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr+dht_offs, (buf_end - (buf_ptr+dht_offs))*8);\n\n        s->start_code = DHT;\n\n        ff_mjpeg_decode_dht(s);\n\n    }\n\n\n\n    sof_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"sof is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"sof offs: 0x%x\\n\", sof_offs);\n\n    if (sof_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr+sof_offs, (buf_end - (buf_ptr+sof_offs))*8);\n\n        s->start_code = SOF0;\n\n        if (ff_mjpeg_decode_sof(s) < 0)\n\n            return -1;\n\n    }\n\n\n\n    sos_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"sos is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"sos offs: 0x%x\\n\", sos_offs);\n\n    sod_offs = read_offs(avctx, &hgb, buf_end - buf_ptr, \"sof is %d and size is %d\\n\");\n\n    av_log(avctx, AV_LOG_DEBUG, \"sod offs: 0x%x\\n\", sod_offs);\n\n    if (sos_offs)\n\n    {\n\n        init_get_bits(&s->gb, buf_ptr + sos_offs,\n\n                      8 * FFMIN(field_size, buf_end - buf_ptr - sos_offs));\n\n        s->mjpb_skiptosod = (sod_offs - sos_offs - show_bits(&s->gb, 16));\n\n        s->start_code = SOS;\n\n        if (ff_mjpeg_decode_sos(s, NULL, NULL) < 0 &&\n\n            (avctx->err_recognition & AV_EF_EXPLODE))\n\n          return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->interlaced) {\n\n        s->bottom_field ^= 1;\n\n        /* if not bottom field, do not output image yet */\n\n        if (s->bottom_field != s->interlace_polarity && second_field_offs)\n\n        {\n\n            buf_ptr = buf + second_field_offs;\n\n            second_field_offs = 0;\n\n            goto read_header;\n\n            }\n\n    }\n\n\n\n    //XXX FIXME factorize, this looks very similar to the EOI code\n\n\n\n    *picture= *s->picture_ptr;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    if(!s->lossless){\n\n        picture->quality= FFMAX3(s->qscale[0], s->qscale[1], s->qscale[2]);\n\n        picture->qstride= 0;\n\n        picture->qscale_table= s->qscale_table;\n\n        memset(picture->qscale_table, picture->quality, (s->width+15)/16);\n\n        if(avctx->debug & FF_DEBUG_QP)\n\n            av_log(avctx, AV_LOG_DEBUG, \"QP: %d\\n\", picture->quality);\n\n        picture->quality*= FF_QP2LAMBDA;\n\n    }\n\n\n\n    return buf_ptr - buf;\n\n}\n",
      "function_name": "mjpegb_decode_frame",
      "idx": 13686
    },
    "same_function": true,
    "similarity": 0.9913393133312712
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "3c7f75bd84b4c30a0f86a491a37f759dfaaab86d",
      "func": "static int avi_read_idx1(AVFormatContext *s, int size)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int nb_index_entries, i;\n\n    AVStream *st;\n\n    AVIStream *ast;\n\n    unsigned int index, tag, flags, pos, len, first_packet = 1;\n\n    unsigned last_pos= -1;\n\n    int64_t idx1_pos, first_packet_pos = 0, data_offset = 0;\n\n\n\n    nb_index_entries = size / 16;\n\n    if (nb_index_entries <= 0)\n\n        return -1;\n\n\n\n    idx1_pos = avio_tell(pb);\n\n    avio_seek(pb, avi->movi_list+4, SEEK_SET);\n\n    if (avi_sync(s, 1) == 0) {\n\n        first_packet_pos = avio_tell(pb) - 8;\n\n    }\n\n    avi->stream_index = -1;\n\n    avio_seek(pb, idx1_pos, SEEK_SET);\n\n\n\n    /* Read the entries and sort them in each stream component. */\n\n    for(i = 0; i < nb_index_entries; i++) {\n\n        tag = avio_rl32(pb);\n\n        flags = avio_rl32(pb);\n\n        pos = avio_rl32(pb);\n\n        len = avio_rl32(pb);\n\n        av_dlog(s, \"%d: tag=0x%x flags=0x%x pos=0x%x len=%d/\",\n\n                i, tag, flags, pos, len);\n\n\n\n        index = ((tag & 0xff) - '0') * 10;\n\n        index += ((tag >> 8) & 0xff) - '0';\n\n        if (index >= s->nb_streams)\n\n            continue;\n\n        st = s->streams[index];\n\n        ast = st->priv_data;\n\n\n\n        if(first_packet && first_packet_pos && len) {\n\n            data_offset = first_packet_pos - pos;\n\n            first_packet = 0;\n\n        }\n\n        pos += data_offset;\n\n\n\n        av_dlog(s, \"%d cum_len=%\"PRId64\"\\n\", len, ast->cum_len);\n\n\n\n        if(url_feof(pb))\n\n            return -1;\n\n\n\n        if(last_pos == pos)\n\n            avi->non_interleaved= 1;\n\n        else if(len || !ast->sample_size)\n\n            av_add_index_entry(st, pos, ast->cum_len, len, 0, (flags&AVIIF_INDEX) ? AVINDEX_KEYFRAME : 0);\n\n        ast->cum_len += get_duration(ast, len);\n\n        last_pos= pos;\n\n    }\n\n    return 0;\n\n}\n",
      "function_name": "avi_read_idx1",
      "idx": 16718
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "570a4a0189946c2c983da41d37fdd67fa13266e7",
      "func": "static int avi_read_idx1(AVFormatContext *s, int size)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int nb_index_entries, i;\n\n    AVStream *st;\n\n    AVIStream *ast;\n\n    unsigned int index, tag, flags, pos, len, first_packet = 1;\n\n    unsigned last_pos= -1;\n\n    int64_t idx1_pos, first_packet_pos = 0, data_offset = 0;\n\n\n\n    nb_index_entries = size / 16;\n\n    if (nb_index_entries <= 0)\n\n        return -1;\n\n\n\n    idx1_pos = avio_tell(pb);\n\n    avio_seek(pb, avi->movi_list+4, SEEK_SET);\n\n    if (avi_sync(s, 1) == 0) {\n\n        first_packet_pos = avio_tell(pb) - 8;\n\n    }\n\n    avi->stream_index = -1;\n\n    avio_seek(pb, idx1_pos, SEEK_SET);\n\n\n\n    /* Read the entries and sort them in each stream component. */\n\n    for(i = 0; i < nb_index_entries; i++) {\n\n        tag = avio_rl32(pb);\n\n        flags = avio_rl32(pb);\n\n        pos = avio_rl32(pb);\n\n        len = avio_rl32(pb);\n\n        av_dlog(s, \"%d: tag=0x%x flags=0x%x pos=0x%x len=%d/\",\n\n                i, tag, flags, pos, len);\n\n\n\n        index = ((tag & 0xff) - '0') * 10;\n\n        index += ((tag >> 8) & 0xff) - '0';\n\n        if (index >= s->nb_streams)\n\n            continue;\n\n        st = s->streams[index];\n\n        ast = st->priv_data;\n\n\n\n        if(first_packet && first_packet_pos && len) {\n\n            data_offset = first_packet_pos - pos;\n\n            first_packet = 0;\n\n        }\n\n        pos += data_offset;\n\n\n\n        av_dlog(s, \"%d cum_len=%\"PRId64\"\\n\", len, ast->cum_len);\n\n\n\n        if(pb->eof_reached)\n\n            return -1;\n\n\n\n        if(last_pos == pos)\n\n            avi->non_interleaved= 1;\n\n        else if(len || !ast->sample_size)\n\n            av_add_index_entry(st, pos, ast->cum_len, len, 0, (flags&AVIIF_INDEX) ? AVINDEX_KEYFRAME : 0);\n\n        ast->cum_len += get_duration(ast, len);\n\n        last_pos= pos;\n\n    }\n\n    return 0;\n\n}\n",
      "function_name": "avi_read_idx1",
      "idx": 7865
    },
    "same_function": true,
    "similarity": 0.9902562251894623
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "f7d649185b62a83ab58514207151f2a8059090fb",
      "func": "static int decode_band(IVI5DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2;\n\n    IVITile     *tile;\n\n    uint16_t    chksum;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return -1;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ff_ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            align_get_bits(&ctx->gb);\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n\n\n            result = decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            if (band->blk_size == 8) {\n\n                band->intra_base  = &ivi5_base_quant_8x8_intra[band->quant_mat][0];\n\n                band->inter_base  = &ivi5_base_quant_8x8_inter[band->quant_mat][0];\n\n                band->intra_scale = &ivi5_scale_quant_8x8_intra[band->quant_mat][0];\n\n                band->inter_scale = &ivi5_scale_quant_8x8_inter[band->quant_mat][0];\n\n            } else {\n\n                band->intra_base  = ivi5_base_quant_4x4_intra;\n\n                band->inter_base  = ivi5_base_quant_4x4_inter;\n\n                band->intra_scale = ivi5_scale_quant_4x4_intra;\n\n                band->inter_scale = ivi5_scale_quant_4x4_inter;\n\n            }\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted blocks data encountered!\\n\");\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    if (IVI_DEBUG && band->checksum_present) {\n\n        chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n\n\n    return result;\n\n}\n",
      "function_name": "decode_band",
      "idx": 6359
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "7fcb98a7ec51123ecfd810a167d96f128eed9b79",
      "func": "static int decode_band(IVI5DecContext *ctx, int plane_num,\n\n                       IVIBandDesc *band, AVCodecContext *avctx)\n\n{\n\n    int         result, i, t, idx1, idx2;\n\n    IVITile     *tile;\n\n\n\n    band->buf     = band->bufs[ctx->dst_buf];\n\n    band->ref_buf = band->bufs[ctx->ref_buf];\n\n    band->data_ptr = ctx->frame_data + (get_bits_count(&ctx->gb) >> 3);\n\n\n\n    result = decode_band_hdr(ctx, band, avctx);\n\n    if (result) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error while decoding band header: %d\\n\",\n\n               result);\n\n        return -1;\n\n    }\n\n\n\n    if (band->is_empty) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Empty band encountered!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    band->rv_map = &ctx->rvmap_tabs[band->rvmap_sel];\n\n\n\n    /* apply corrections to the selected rvmap table if present */\n\n    for (i = 0; i < band->num_corr; i++) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n    for (t = 0; t < band->num_tiles; t++) {\n\n        tile = &band->tiles[t];\n\n\n\n        tile->is_empty = get_bits1(&ctx->gb);\n\n        if (tile->is_empty) {\n\n            ff_ivi_process_empty_tile(avctx, band, tile,\n\n                                      (ctx->planes[0].bands[0].mb_size >> 3) - (band->mb_size >> 3));\n\n            align_get_bits(&ctx->gb);\n\n        } else {\n\n            tile->data_size = ff_ivi_dec_tile_data_size(&ctx->gb);\n\n\n\n            result = decode_mb_info(ctx, band, tile, avctx);\n\n            if (result < 0)\n\n                break;\n\n\n\n            if (band->blk_size == 8) {\n\n                band->intra_base  = &ivi5_base_quant_8x8_intra[band->quant_mat][0];\n\n                band->inter_base  = &ivi5_base_quant_8x8_inter[band->quant_mat][0];\n\n                band->intra_scale = &ivi5_scale_quant_8x8_intra[band->quant_mat][0];\n\n                band->inter_scale = &ivi5_scale_quant_8x8_inter[band->quant_mat][0];\n\n            } else {\n\n                band->intra_base  = ivi5_base_quant_4x4_intra;\n\n                band->inter_base  = ivi5_base_quant_4x4_inter;\n\n                band->intra_scale = ivi5_scale_quant_4x4_intra;\n\n                band->inter_scale = ivi5_scale_quant_4x4_inter;\n\n            }\n\n\n\n            result = ff_ivi_decode_blocks(&ctx->gb, band, tile);\n\n            if (result < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Corrupted blocks data encountered!\\n\");\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* restore the selected rvmap table by applying its corrections in reverse order */\n\n    for (i = band->num_corr-1; i >= 0; i--) {\n\n        idx1 = band->corr[i*2];\n\n        idx2 = band->corr[i*2+1];\n\n        FFSWAP(uint8_t, band->rv_map->runtab[idx1], band->rv_map->runtab[idx2]);\n\n        FFSWAP(int16_t, band->rv_map->valtab[idx1], band->rv_map->valtab[idx2]);\n\n    }\n\n\n\n#if IVI_DEBUG\n\n    if (band->checksum_present) {\n\n        uint16_t chksum = ivi_calc_band_checksum(band);\n\n        if (chksum != band->checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Band checksum mismatch! Plane %d, band %d, received: %x, calculated: %x\\n\",\n\n                   band->plane, band->band_num, band->checksum, chksum);\n\n        }\n\n    }\n\n#endif\n\n\n\n    return result;\n\n}\n",
      "function_name": "decode_band",
      "idx": 3615
    },
    "same_function": true,
    "similarity": 0.9900908340214699
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "fd8b90f5f63de12c1ee1ec1cbe99791c5629c582",
      "func": "av_cold void ff_vp9dsp_init_x86(VP9DSPContext *dsp, int bpp)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags;\n\n    if (bpp != 8) return;\n\n\n\n    cpu_flags = av_get_cpu_flags();\n\n\n\n#define init_fpel(idx1, idx2, sz, type, opt) \\\n\n    dsp->mc[idx1][FILTER_8TAP_SMOOTH ][idx2][0][0] = \\\n\n    dsp->mc[idx1][FILTER_8TAP_REGULAR][idx2][0][0] = \\\n\n    dsp->mc[idx1][FILTER_8TAP_SHARP  ][idx2][0][0] = \\\n\n    dsp->mc[idx1][FILTER_BILINEAR    ][idx2][0][0] = ff_vp9_##type##sz##_##opt\n\n\n\n#define init_subpel1(idx1, idx2, idxh, idxv, sz, dir, type, opt) \\\n\n    dsp->mc[idx1][FILTER_8TAP_SMOOTH ][idx2][idxh][idxv] = type##_8tap_smooth_##sz##dir##_##opt; \\\n\n    dsp->mc[idx1][FILTER_8TAP_REGULAR][idx2][idxh][idxv] = type##_8tap_regular_##sz##dir##_##opt; \\\n\n    dsp->mc[idx1][FILTER_8TAP_SHARP  ][idx2][idxh][idxv] = type##_8tap_sharp_##sz##dir##_##opt\n\n\n\n#define init_subpel2(idx1, idx2, sz, type, opt) \\\n\n    init_subpel1(idx1, idx2, 1, 1, sz, hv, type, opt); \\\n\n    init_subpel1(idx1, idx2, 0, 1, sz, v,  type, opt); \\\n\n    init_subpel1(idx1, idx2, 1, 0, sz, h,  type, opt)\n\n\n\n#define init_subpel3_32_64(idx, type, opt) \\\n\n    init_subpel2(0, idx, 64, type, opt); \\\n\n    init_subpel2(1, idx, 32, type, opt)\n\n\n\n#define init_subpel3_8to64(idx, type, opt) \\\n\n    init_subpel3_32_64(idx, type, opt); \\\n\n    init_subpel2(2, idx, 16, type, opt); \\\n\n    init_subpel2(3, idx,  8, type, opt)\n\n\n\n#define init_subpel3(idx, type, opt) \\\n\n    init_subpel3_8to64(idx, type, opt); \\\n\n    init_subpel2(4, idx,  4, type, opt)\n\n\n\n#define init_lpf(opt) do { \\\n\n    dsp->loop_filter_16[0] = ff_vp9_loop_filter_h_16_16_##opt; \\\n\n    dsp->loop_filter_16[1] = ff_vp9_loop_filter_v_16_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][0][0] = ff_vp9_loop_filter_h_44_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][0][1] = ff_vp9_loop_filter_v_44_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][1][0] = ff_vp9_loop_filter_h_48_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][1][1] = ff_vp9_loop_filter_v_48_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][0][0] = ff_vp9_loop_filter_h_84_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][0][1] = ff_vp9_loop_filter_v_84_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][1][0] = ff_vp9_loop_filter_h_88_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][1][1] = ff_vp9_loop_filter_v_88_16_##opt; \\\n\n} while (0)\n\n\n\n#define init_ipred(sz, opt, t, e) \\\n\n    dsp->intra_pred[TX_##sz##X##sz][e##_PRED] = ff_vp9_ipred_##t##_##sz##x##sz##_##opt\n\n\n\n#define ff_vp9_ipred_hd_4x4_ssse3 ff_vp9_ipred_hd_4x4_mmxext\n\n#define ff_vp9_ipred_vl_4x4_ssse3 ff_vp9_ipred_vl_4x4_mmxext\n\n#define init_dir_tm_ipred(sz, opt) do { \\\n\n    init_ipred(sz, opt, dl, DIAG_DOWN_LEFT); \\\n\n    init_ipred(sz, opt, dr, DIAG_DOWN_RIGHT); \\\n\n    init_ipred(sz, opt, hd, HOR_DOWN); \\\n\n    init_ipred(sz, opt, vl, VERT_LEFT); \\\n\n    init_ipred(sz, opt, hu, HOR_UP); \\\n\n    init_ipred(sz, opt, tm, TM_VP8); \\\n\n    init_ipred(sz, opt, vr, VERT_RIGHT); \\\n\n} while (0)\n\n#define init_dir_tm_h_ipred(sz, opt) do { \\\n\n    init_dir_tm_ipred(sz, opt); \\\n\n    init_ipred(sz, opt, h,  HOR); \\\n\n} while (0)\n\n#define init_dc_ipred(sz, opt) do { \\\n\n    init_ipred(sz, opt, dc,      DC); \\\n\n    init_ipred(sz, opt, dc_left, LEFT_DC); \\\n\n    init_ipred(sz, opt, dc_top,  TOP_DC); \\\n\n} while (0)\n\n#define init_all_ipred(sz, opt) do { \\\n\n    init_dc_ipred(sz, opt); \\\n\n    init_dir_tm_h_ipred(sz, opt); \\\n\n} while (0)\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        init_fpel(4, 0,  4, put, mmx);\n\n        init_fpel(3, 0,  8, put, mmx);\n\n        dsp->itxfm_add[4 /* lossless */][DCT_DCT] =\n\n        dsp->itxfm_add[4 /* lossless */][ADST_DCT] =\n\n        dsp->itxfm_add[4 /* lossless */][DCT_ADST] =\n\n        dsp->itxfm_add[4 /* lossless */][ADST_ADST] = ff_vp9_iwht_iwht_4x4_add_mmx;\n\n        init_ipred(8, mmx, v, VERT);\n\n    }\n\n\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        init_subpel2(4, 0, 4, put, mmxext);\n\n        init_subpel2(4, 1, 4, avg, mmxext);\n\n        init_fpel(4, 1,  4, avg, mmxext);\n\n        init_fpel(3, 1,  8, avg, mmxext);\n\n        dsp->itxfm_add[TX_4X4][DCT_DCT] = ff_vp9_idct_idct_4x4_add_mmxext;\n\n        init_dc_ipred(4, mmxext);\n\n        init_dc_ipred(8, mmxext);\n\n        init_dir_tm_ipred(4, mmxext);\n\n    }\n\n\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        init_fpel(2, 0, 16, put, sse);\n\n        init_fpel(1, 0, 32, put, sse);\n\n        init_fpel(0, 0, 64, put, sse);\n\n        init_ipred(16, sse, v, VERT);\n\n        init_ipred(32, sse, v, VERT);\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        init_subpel3_8to64(0, put, sse2);\n\n        init_subpel3_8to64(1, avg, sse2);\n\n        init_fpel(2, 1, 16, avg, sse2);\n\n        init_fpel(1, 1, 32, avg, sse2);\n\n        init_fpel(0, 1, 64, avg, sse2);\n\n        init_lpf(sse2);\n\n        dsp->itxfm_add[TX_4X4][ADST_DCT]  = ff_vp9_idct_iadst_4x4_add_sse2;\n\n        dsp->itxfm_add[TX_4X4][DCT_ADST]  = ff_vp9_iadst_idct_4x4_add_sse2;\n\n        dsp->itxfm_add[TX_4X4][ADST_ADST] = ff_vp9_iadst_iadst_4x4_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][DCT_DCT] = ff_vp9_idct_idct_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][ADST_DCT]  = ff_vp9_idct_iadst_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][DCT_ADST]  = ff_vp9_iadst_idct_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][ADST_ADST] = ff_vp9_iadst_iadst_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][DCT_DCT]   = ff_vp9_idct_idct_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][ADST_DCT]  = ff_vp9_idct_iadst_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][DCT_ADST]  = ff_vp9_iadst_idct_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][ADST_ADST] = ff_vp9_iadst_iadst_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_32X32][ADST_ADST] =\n\n        dsp->itxfm_add[TX_32X32][ADST_DCT] =\n\n        dsp->itxfm_add[TX_32X32][DCT_ADST] =\n\n        dsp->itxfm_add[TX_32X32][DCT_DCT] = ff_vp9_idct_idct_32x32_add_sse2;\n\n        init_dc_ipred(16, sse2);\n\n        init_dc_ipred(32, sse2);\n\n        init_dir_tm_h_ipred(8, sse2);\n\n        init_dir_tm_h_ipred(16, sse2);\n\n        init_dir_tm_h_ipred(32, sse2);\n\n        init_ipred(4, sse2, h, HOR);\n\n    }\n\n\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        init_subpel3(0, put, ssse3);\n\n        init_subpel3(1, avg, ssse3);\n\n        dsp->itxfm_add[TX_4X4][DCT_DCT] = ff_vp9_idct_idct_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_4X4][ADST_DCT]  = ff_vp9_idct_iadst_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_4X4][DCT_ADST]  = ff_vp9_iadst_idct_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_4X4][ADST_ADST] = ff_vp9_iadst_iadst_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][DCT_DCT] = ff_vp9_idct_idct_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][ADST_DCT]  = ff_vp9_idct_iadst_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][DCT_ADST]  = ff_vp9_iadst_idct_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][ADST_ADST] = ff_vp9_iadst_iadst_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][DCT_DCT]   = ff_vp9_idct_idct_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][ADST_DCT]  = ff_vp9_idct_iadst_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][DCT_ADST]  = ff_vp9_iadst_idct_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][ADST_ADST] = ff_vp9_iadst_iadst_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_32X32][ADST_ADST] =\n\n        dsp->itxfm_add[TX_32X32][ADST_DCT] =\n\n        dsp->itxfm_add[TX_32X32][DCT_ADST] =\n\n        dsp->itxfm_add[TX_32X32][DCT_DCT] = ff_vp9_idct_idct_32x32_add_ssse3;\n\n        init_lpf(ssse3);\n\n        init_all_ipred(4, ssse3);\n\n        init_all_ipred(8, ssse3);\n\n        init_all_ipred(16, ssse3);\n\n        init_all_ipred(32, ssse3);\n\n    }\n\n\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        dsp->itxfm_add[TX_8X8][DCT_DCT] = ff_vp9_idct_idct_8x8_add_avx;\n\n        dsp->itxfm_add[TX_8X8][ADST_DCT]  = ff_vp9_idct_iadst_8x8_add_avx;\n\n        dsp->itxfm_add[TX_8X8][DCT_ADST]  = ff_vp9_iadst_idct_8x8_add_avx;\n\n        dsp->itxfm_add[TX_8X8][ADST_ADST] = ff_vp9_iadst_iadst_8x8_add_avx;\n\n        dsp->itxfm_add[TX_16X16][DCT_DCT] = ff_vp9_idct_idct_16x16_add_avx;\n\n        dsp->itxfm_add[TX_16X16][ADST_DCT]  = ff_vp9_idct_iadst_16x16_add_avx;\n\n        dsp->itxfm_add[TX_16X16][DCT_ADST]  = ff_vp9_iadst_idct_16x16_add_avx;\n\n        dsp->itxfm_add[TX_16X16][ADST_ADST] = ff_vp9_iadst_iadst_16x16_add_avx;\n\n        dsp->itxfm_add[TX_32X32][ADST_ADST] =\n\n        dsp->itxfm_add[TX_32X32][ADST_DCT] =\n\n        dsp->itxfm_add[TX_32X32][DCT_ADST] =\n\n        dsp->itxfm_add[TX_32X32][DCT_DCT] = ff_vp9_idct_idct_32x32_add_avx;\n\n        init_lpf(avx);\n\n        init_dir_tm_h_ipred(8, avx);\n\n        init_dir_tm_h_ipred(16, avx);\n\n        init_dir_tm_h_ipred(32, avx);\n\n    }\n\n    if (EXTERNAL_AVX_FAST(cpu_flags)) {\n\n        init_fpel(1, 0, 32, put, avx);\n\n        init_fpel(0, 0, 64, put, avx);\n\n        init_ipred(32, avx, v, VERT);\n\n    }\n\n\n\n    if (EXTERNAL_AVX2(cpu_flags)) {\n\n        init_fpel(1, 1, 32, avg, avx2);\n\n        init_fpel(0, 1, 64, avg, avx2);\n\n        if (ARCH_X86_64) {\n\n#if ARCH_X86_64 && HAVE_AVX2_EXTERNAL\n\n            init_subpel3_32_64(0, put, avx2);\n\n            init_subpel3_32_64(1, avg, avx2);\n\n#endif\n\n        }\n\n        init_dc_ipred(32, avx2);\n\n        init_ipred(32, avx2, h,  HOR);\n\n        init_ipred(32, avx2, tm, TM_VP8);\n\n    }\n\n\n\n#undef init_fpel\n\n#undef init_subpel1\n\n#undef init_subpel2\n\n#undef init_subpel3\n\n\n\n#endif /* HAVE_YASM */\n\n}\n",
      "function_name": "ff_vp9dsp_init_x86",
      "idx": 11097
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "c16e99e3b3c02edcf33245468731d414eab97dac",
      "func": "av_cold void ff_vp9dsp_init_x86(VP9DSPContext *dsp, int bpp)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags;\n\n    if (bpp != 8) return;\n\n\n\n    cpu_flags = av_get_cpu_flags();\n\n\n\n#define init_fpel(idx1, idx2, sz, type, opt) \\\n\n    dsp->mc[idx1][FILTER_8TAP_SMOOTH ][idx2][0][0] = \\\n\n    dsp->mc[idx1][FILTER_8TAP_REGULAR][idx2][0][0] = \\\n\n    dsp->mc[idx1][FILTER_8TAP_SHARP  ][idx2][0][0] = \\\n\n    dsp->mc[idx1][FILTER_BILINEAR    ][idx2][0][0] = ff_vp9_##type##sz##_##opt\n\n\n\n#define init_subpel1(idx1, idx2, idxh, idxv, sz, dir, type, opt) \\\n\n    dsp->mc[idx1][FILTER_8TAP_SMOOTH ][idx2][idxh][idxv] = type##_8tap_smooth_##sz##dir##_##opt; \\\n\n    dsp->mc[idx1][FILTER_8TAP_REGULAR][idx2][idxh][idxv] = type##_8tap_regular_##sz##dir##_##opt; \\\n\n    dsp->mc[idx1][FILTER_8TAP_SHARP  ][idx2][idxh][idxv] = type##_8tap_sharp_##sz##dir##_##opt\n\n\n\n#define init_subpel2(idx1, idx2, sz, type, opt) \\\n\n    init_subpel1(idx1, idx2, 1, 1, sz, hv, type, opt); \\\n\n    init_subpel1(idx1, idx2, 0, 1, sz, v,  type, opt); \\\n\n    init_subpel1(idx1, idx2, 1, 0, sz, h,  type, opt)\n\n\n\n#define init_subpel3_32_64(idx, type, opt) \\\n\n    init_subpel2(0, idx, 64, type, opt); \\\n\n    init_subpel2(1, idx, 32, type, opt)\n\n\n\n#define init_subpel3_8to64(idx, type, opt) \\\n\n    init_subpel3_32_64(idx, type, opt); \\\n\n    init_subpel2(2, idx, 16, type, opt); \\\n\n    init_subpel2(3, idx,  8, type, opt)\n\n\n\n#define init_subpel3(idx, type, opt) \\\n\n    init_subpel3_8to64(idx, type, opt); \\\n\n    init_subpel2(4, idx,  4, type, opt)\n\n\n\n#define init_lpf(opt) do { \\\n\n    dsp->loop_filter_16[0] = ff_vp9_loop_filter_h_16_16_##opt; \\\n\n    dsp->loop_filter_16[1] = ff_vp9_loop_filter_v_16_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][0][0] = ff_vp9_loop_filter_h_44_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][0][1] = ff_vp9_loop_filter_v_44_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][1][0] = ff_vp9_loop_filter_h_48_16_##opt; \\\n\n    dsp->loop_filter_mix2[0][1][1] = ff_vp9_loop_filter_v_48_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][0][0] = ff_vp9_loop_filter_h_84_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][0][1] = ff_vp9_loop_filter_v_84_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][1][0] = ff_vp9_loop_filter_h_88_16_##opt; \\\n\n    dsp->loop_filter_mix2[1][1][1] = ff_vp9_loop_filter_v_88_16_##opt; \\\n\n} while (0)\n\n\n\n#define init_ipred(sz, opt, t, e) \\\n\n    dsp->intra_pred[TX_##sz##X##sz][e##_PRED] = ff_vp9_ipred_##t##_##sz##x##sz##_##opt\n\n\n\n#define ff_vp9_ipred_hd_4x4_ssse3 ff_vp9_ipred_hd_4x4_mmxext\n\n#define ff_vp9_ipred_vl_4x4_ssse3 ff_vp9_ipred_vl_4x4_mmxext\n\n#define init_dir_tm_ipred(sz, opt) do { \\\n\n    init_ipred(sz, opt, dl, DIAG_DOWN_LEFT); \\\n\n    init_ipred(sz, opt, dr, DIAG_DOWN_RIGHT); \\\n\n    init_ipred(sz, opt, hd, HOR_DOWN); \\\n\n    init_ipred(sz, opt, vl, VERT_LEFT); \\\n\n    init_ipred(sz, opt, hu, HOR_UP); \\\n\n    init_ipred(sz, opt, tm, TM_VP8); \\\n\n    init_ipred(sz, opt, vr, VERT_RIGHT); \\\n\n} while (0)\n\n#define init_dir_tm_h_ipred(sz, opt) do { \\\n\n    init_dir_tm_ipred(sz, opt); \\\n\n    init_ipred(sz, opt, h,  HOR); \\\n\n} while (0)\n\n#define init_dc_ipred(sz, opt) do { \\\n\n    init_ipred(sz, opt, dc,      DC); \\\n\n    init_ipred(sz, opt, dc_left, LEFT_DC); \\\n\n    init_ipred(sz, opt, dc_top,  TOP_DC); \\\n\n} while (0)\n\n#define init_all_ipred(sz, opt) do { \\\n\n    init_dc_ipred(sz, opt); \\\n\n    init_dir_tm_h_ipred(sz, opt); \\\n\n} while (0)\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        init_fpel(4, 0,  4, put, mmx);\n\n        init_fpel(3, 0,  8, put, mmx);\n\n        dsp->itxfm_add[4 /* lossless */][DCT_DCT] =\n\n        dsp->itxfm_add[4 /* lossless */][ADST_DCT] =\n\n        dsp->itxfm_add[4 /* lossless */][DCT_ADST] =\n\n        dsp->itxfm_add[4 /* lossless */][ADST_ADST] = ff_vp9_iwht_iwht_4x4_add_mmx;\n\n        init_ipred(8, mmx, v, VERT);\n\n    }\n\n\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        init_subpel2(4, 0, 4, put, mmxext);\n\n        init_subpel2(4, 1, 4, avg, mmxext);\n\n        init_fpel(4, 1,  4, avg, mmxext);\n\n        init_fpel(3, 1,  8, avg, mmxext);\n\n        dsp->itxfm_add[TX_4X4][DCT_DCT] = ff_vp9_idct_idct_4x4_add_mmxext;\n\n        init_dc_ipred(4, mmxext);\n\n        init_dc_ipred(8, mmxext);\n\n        init_dir_tm_ipred(4, mmxext);\n\n    }\n\n\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        init_fpel(2, 0, 16, put, sse);\n\n        init_fpel(1, 0, 32, put, sse);\n\n        init_fpel(0, 0, 64, put, sse);\n\n        init_ipred(16, sse, v, VERT);\n\n        init_ipred(32, sse, v, VERT);\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        init_subpel3_8to64(0, put, sse2);\n\n        init_subpel3_8to64(1, avg, sse2);\n\n        init_fpel(2, 1, 16, avg, sse2);\n\n        init_fpel(1, 1, 32, avg, sse2);\n\n        init_fpel(0, 1, 64, avg, sse2);\n\n        init_lpf(sse2);\n\n        dsp->itxfm_add[TX_4X4][ADST_DCT]  = ff_vp9_idct_iadst_4x4_add_sse2;\n\n        dsp->itxfm_add[TX_4X4][DCT_ADST]  = ff_vp9_iadst_idct_4x4_add_sse2;\n\n        dsp->itxfm_add[TX_4X4][ADST_ADST] = ff_vp9_iadst_iadst_4x4_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][DCT_DCT] = ff_vp9_idct_idct_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][ADST_DCT]  = ff_vp9_idct_iadst_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][DCT_ADST]  = ff_vp9_iadst_idct_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_8X8][ADST_ADST] = ff_vp9_iadst_iadst_8x8_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][DCT_DCT]   = ff_vp9_idct_idct_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][ADST_DCT]  = ff_vp9_idct_iadst_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][DCT_ADST]  = ff_vp9_iadst_idct_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_16X16][ADST_ADST] = ff_vp9_iadst_iadst_16x16_add_sse2;\n\n        dsp->itxfm_add[TX_32X32][ADST_ADST] =\n\n        dsp->itxfm_add[TX_32X32][ADST_DCT] =\n\n        dsp->itxfm_add[TX_32X32][DCT_ADST] =\n\n        dsp->itxfm_add[TX_32X32][DCT_DCT] = ff_vp9_idct_idct_32x32_add_sse2;\n\n        init_dc_ipred(16, sse2);\n\n        init_dc_ipred(32, sse2);\n\n        init_dir_tm_h_ipred(8, sse2);\n\n        init_dir_tm_h_ipred(16, sse2);\n\n        init_dir_tm_h_ipred(32, sse2);\n\n        init_ipred(4, sse2, h, HOR);\n\n    }\n\n\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        init_subpel3(0, put, ssse3);\n\n        init_subpel3(1, avg, ssse3);\n\n        dsp->itxfm_add[TX_4X4][DCT_DCT] = ff_vp9_idct_idct_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_4X4][ADST_DCT]  = ff_vp9_idct_iadst_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_4X4][DCT_ADST]  = ff_vp9_iadst_idct_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_4X4][ADST_ADST] = ff_vp9_iadst_iadst_4x4_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][DCT_DCT] = ff_vp9_idct_idct_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][ADST_DCT]  = ff_vp9_idct_iadst_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][DCT_ADST]  = ff_vp9_iadst_idct_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_8X8][ADST_ADST] = ff_vp9_iadst_iadst_8x8_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][DCT_DCT]   = ff_vp9_idct_idct_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][ADST_DCT]  = ff_vp9_idct_iadst_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][DCT_ADST]  = ff_vp9_iadst_idct_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_16X16][ADST_ADST] = ff_vp9_iadst_iadst_16x16_add_ssse3;\n\n        dsp->itxfm_add[TX_32X32][ADST_ADST] =\n\n        dsp->itxfm_add[TX_32X32][ADST_DCT] =\n\n        dsp->itxfm_add[TX_32X32][DCT_ADST] =\n\n        dsp->itxfm_add[TX_32X32][DCT_DCT] = ff_vp9_idct_idct_32x32_add_ssse3;\n\n        init_lpf(ssse3);\n\n        init_all_ipred(4, ssse3);\n\n        init_all_ipred(8, ssse3);\n\n        init_all_ipred(16, ssse3);\n\n        init_all_ipred(32, ssse3);\n\n    }\n\n\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        dsp->itxfm_add[TX_8X8][DCT_DCT] = ff_vp9_idct_idct_8x8_add_avx;\n\n        dsp->itxfm_add[TX_8X8][ADST_DCT]  = ff_vp9_idct_iadst_8x8_add_avx;\n\n        dsp->itxfm_add[TX_8X8][DCT_ADST]  = ff_vp9_iadst_idct_8x8_add_avx;\n\n        dsp->itxfm_add[TX_8X8][ADST_ADST] = ff_vp9_iadst_iadst_8x8_add_avx;\n\n        dsp->itxfm_add[TX_16X16][DCT_DCT] = ff_vp9_idct_idct_16x16_add_avx;\n\n        dsp->itxfm_add[TX_16X16][ADST_DCT]  = ff_vp9_idct_iadst_16x16_add_avx;\n\n        dsp->itxfm_add[TX_16X16][DCT_ADST]  = ff_vp9_iadst_idct_16x16_add_avx;\n\n        dsp->itxfm_add[TX_16X16][ADST_ADST] = ff_vp9_iadst_iadst_16x16_add_avx;\n\n        dsp->itxfm_add[TX_32X32][ADST_ADST] =\n\n        dsp->itxfm_add[TX_32X32][ADST_DCT] =\n\n        dsp->itxfm_add[TX_32X32][DCT_ADST] =\n\n        dsp->itxfm_add[TX_32X32][DCT_DCT] = ff_vp9_idct_idct_32x32_add_avx;\n\n        init_fpel(1, 0, 32, put, avx);\n\n        init_fpel(0, 0, 64, put, avx);\n\n        init_lpf(avx);\n\n        init_dir_tm_h_ipred(8, avx);\n\n        init_dir_tm_h_ipred(16, avx);\n\n        init_dir_tm_h_ipred(32, avx);\n\n        init_ipred(32, avx, v, VERT);\n\n    }\n\n\n\n    if (EXTERNAL_AVX2(cpu_flags)) {\n\n        init_fpel(1, 1, 32, avg, avx2);\n\n        init_fpel(0, 1, 64, avg, avx2);\n\n        if (ARCH_X86_64) {\n\n#if ARCH_X86_64 && HAVE_AVX2_EXTERNAL\n\n            init_subpel3_32_64(0, put, avx2);\n\n            init_subpel3_32_64(1, avg, avx2);\n\n#endif\n\n        }\n\n        init_dc_ipred(32, avx2);\n\n        init_ipred(32, avx2, h,  HOR);\n\n        init_ipred(32, avx2, tm, TM_VP8);\n\n    }\n\n\n\n#undef init_fpel\n\n#undef init_subpel1\n\n#undef init_subpel2\n\n#undef init_subpel3\n\n\n\n#endif /* HAVE_YASM */\n\n}\n",
      "function_name": "ff_vp9dsp_init_x86",
      "idx": 19601
    },
    "same_function": true,
    "similarity": 0.984108527131783
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e",
      "func": "static int oss_init_out (HWVoiceOut *hw, struct audsettings *as)\n\n{\n\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n\n    struct oss_params req, obt;\n\n    int endianness;\n\n    int err;\n\n    int fd;\n\n    audfmt_e effective_fmt;\n\n    struct audsettings obt_as;\n\n\n\n    oss->fd = -1;\n\n\n\n    req.fmt = aud_to_ossfmt (as->fmt, as->endianness);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.fragsize = conf.fragsize;\n\n    req.nfrags = conf.nfrags;\n\n\n\n    if (oss_open (0, &req, &obt, &fd)) {\n\n        return -1;\n\n    }\n\n\n\n    err = oss_to_audfmt (obt.fmt, &effective_fmt, &endianness);\n\n    if (err) {\n\n        oss_anal_close (&fd);\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = effective_fmt;\n\n    obt_as.endianness = endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    oss->nfrags = obt.nfrags;\n\n    oss->fragsize = obt.fragsize;\n\n\n\n    if (obt.nfrags * obt.fragsize & hw->info.align) {\n\n        dolog (\"warning: Misaligned DAC buffer, size %d, alignment %d\\n\",\n\n               obt.nfrags * obt.fragsize, hw->info.align + 1);\n\n    }\n\n\n\n    hw->samples = (obt.nfrags * obt.fragsize) >> hw->info.shift;\n\n\n\n    oss->mmapped = 0;\n\n    if (conf.try_mmap) {\n\n        oss->pcm_buf = mmap (\n\n            NULL,\n\n            hw->samples << hw->info.shift,\n\n            PROT_READ | PROT_WRITE,\n\n            MAP_SHARED,\n\n            fd,\n\n            0\n\n            );\n\n        if (oss->pcm_buf == MAP_FAILED) {\n\n            oss_logerr (errno, \"Failed to map %d bytes of DAC\\n\",\n\n                        hw->samples << hw->info.shift);\n\n        }\n\n        else {\n\n            int err;\n\n            int trig = 0;\n\n            if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                oss_logerr (errno, \"SNDCTL_DSP_SETTRIGGER 0 failed\\n\");\n\n            }\n\n            else {\n\n                trig = PCM_ENABLE_OUTPUT;\n\n                if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                    oss_logerr (\n\n                        errno,\n\n                        \"SNDCTL_DSP_SETTRIGGER PCM_ENABLE_OUTPUT failed\\n\"\n\n                        );\n\n                }\n\n                else {\n\n                    oss->mmapped = 1;\n\n                }\n\n            }\n\n\n\n            if (!oss->mmapped) {\n\n                err = munmap (oss->pcm_buf, hw->samples << hw->info.shift);\n\n                if (err) {\n\n                    oss_logerr (errno, \"Failed to unmap buffer %p size %d\\n\",\n\n                                oss->pcm_buf, hw->samples << hw->info.shift);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!oss->mmapped) {\n\n        oss->pcm_buf = audio_calloc (\n\n            AUDIO_FUNC,\n\n            hw->samples,\n\n            1 << hw->info.shift\n\n            );\n\n        if (!oss->pcm_buf) {\n\n            dolog (\n\n                \"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n                hw->samples,\n\n                1 << hw->info.shift\n\n                );\n\n            oss_anal_close (&fd);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    oss->fd = fd;\n\n    return 0;\n\n}\n",
      "function_name": "oss_init_out",
      "idx": 9340
    },
    "secure": {
      "project": "qemu",
      "commit_id": "1ea879e5580f63414693655fcf0328559cdce138",
      "func": "static int oss_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    OSSVoiceOut *oss = (OSSVoiceOut *) hw;\n\n    struct oss_params req, obt;\n\n    int endianness;\n\n    int err;\n\n    int fd;\n\n    audfmt_e effective_fmt;\n\n    audsettings_t obt_as;\n\n\n\n    oss->fd = -1;\n\n\n\n    req.fmt = aud_to_ossfmt (as->fmt);\n\n    req.freq = as->freq;\n\n    req.nchannels = as->nchannels;\n\n    req.fragsize = conf.fragsize;\n\n    req.nfrags = conf.nfrags;\n\n\n\n    if (oss_open (0, &req, &obt, &fd)) {\n\n        return -1;\n\n    }\n\n\n\n    err = oss_to_audfmt (obt.fmt, &effective_fmt, &endianness);\n\n    if (err) {\n\n        oss_anal_close (&fd);\n\n        return -1;\n\n    }\n\n\n\n    obt_as.freq = obt.freq;\n\n    obt_as.nchannels = obt.nchannels;\n\n    obt_as.fmt = effective_fmt;\n\n    obt_as.endianness = endianness;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    oss->nfrags = obt.nfrags;\n\n    oss->fragsize = obt.fragsize;\n\n\n\n    if (obt.nfrags * obt.fragsize & hw->info.align) {\n\n        dolog (\"warning: Misaligned DAC buffer, size %d, alignment %d\\n\",\n\n               obt.nfrags * obt.fragsize, hw->info.align + 1);\n\n    }\n\n\n\n    hw->samples = (obt.nfrags * obt.fragsize) >> hw->info.shift;\n\n\n\n    oss->mmapped = 0;\n\n    if (conf.try_mmap) {\n\n        oss->pcm_buf = mmap (\n\n            0,\n\n            hw->samples << hw->info.shift,\n\n            PROT_READ | PROT_WRITE,\n\n            MAP_SHARED,\n\n            fd,\n\n            0\n\n            );\n\n        if (oss->pcm_buf == MAP_FAILED) {\n\n            oss_logerr (errno, \"Failed to map %d bytes of DAC\\n\",\n\n                        hw->samples << hw->info.shift);\n\n        } else {\n\n            int err;\n\n            int trig = 0;\n\n            if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                oss_logerr (errno, \"SNDCTL_DSP_SETTRIGGER 0 failed\\n\");\n\n            }\n\n            else {\n\n                trig = PCM_ENABLE_OUTPUT;\n\n                if (ioctl (fd, SNDCTL_DSP_SETTRIGGER, &trig) < 0) {\n\n                    oss_logerr (\n\n                        errno,\n\n                        \"SNDCTL_DSP_SETTRIGGER PCM_ENABLE_OUTPUT failed\\n\"\n\n                        );\n\n                }\n\n                else {\n\n                    oss->mmapped = 1;\n\n                }\n\n            }\n\n\n\n            if (!oss->mmapped) {\n\n                err = munmap (oss->pcm_buf, hw->samples << hw->info.shift);\n\n                if (err) {\n\n                    oss_logerr (errno, \"Failed to unmap buffer %p size %d\\n\",\n\n                                oss->pcm_buf, hw->samples << hw->info.shift);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (!oss->mmapped) {\n\n        oss->pcm_buf = audio_calloc (\n\n            AUDIO_FUNC,\n\n            hw->samples,\n\n            1 << hw->info.shift\n\n            );\n\n        if (!oss->pcm_buf) {\n\n            dolog (\n\n                \"Could not allocate DAC buffer (%d samples, each %d bytes)\\n\",\n\n                hw->samples,\n\n                1 << hw->info.shift\n\n                );\n\n            oss_anal_close (&fd);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    oss->fd = fd;\n\n    return 0;\n\n}\n",
      "function_name": "oss_init_out",
      "idx": 10048
    },
    "same_function": true,
    "similarity": 0.9798885388902351
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "7562f90707aa1f409ba2312569cb791241fca045",
      "func": "static void device_set_realized(Object *obj, bool value, Error **errp)\n{\n    DeviceState *dev = DEVICE(obj);\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n    HotplugHandler *hotplug_ctrl;\n    BusState *bus;\n    Error *local_err = NULL;\n    bool unattached_parent = false;\n    static int unattached_count;\n    int ret;\n    if (dev->hotplugged && !dc->hotpluggable) {\n        error_setg(errp, QERR_DEVICE_NO_HOTPLUG, object_get_typename(obj));\n        return;\n    if (value && !dev->realized) {\n        if (!obj->parent) {\n            gchar *name = g_strdup_printf(\"device[%d]\", unattached_count++);\n            object_property_add_child(container_get(qdev_get_machine(),\n                                                    \"/unattached\"),\n                                      name, obj, &error_abort);\n            unattached_parent = true;\n            g_free(name);\n        hotplug_ctrl = qdev_get_hotplug_handler(dev);\n        if (hotplug_ctrl) {\n            hotplug_handler_pre_plug(hotplug_ctrl, dev, &local_err);\n            if (local_err != NULL) {\n        if (dc->realize) {\n            dc->realize(dev, &local_err);\n        if (local_err != NULL) {\n        DEVICE_LISTENER_CALL(realize, Forward, dev);\n        if (hotplug_ctrl) {\n            hotplug_handler_plug(hotplug_ctrl, dev, &local_err);\n        if (local_err != NULL) {\n            goto post_realize_fail;\n        if (qdev_get_vmsd(dev)) {\n            if (vmstate_register_with_alias_id(dev, -1, qdev_get_vmsd(dev), dev,\n                                               dev->instance_id_alias,\n                                               dev->alias_required_for_version,\n                                               &local_err) < 0) {\n                goto post_realize_fail;\n        QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n            object_property_set_bool(OBJECT(bus), true, \"realized\",\n                                         &local_err);\n            if (local_err != NULL) {\n                goto child_realize_fail;\n        if (dev->hotplugged) {\n            device_reset(dev);\n        dev->pending_deleted_event = false;\n    } else if (!value && dev->realized) {\n        Error **local_errp = NULL;\n        QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n            local_errp = local_err ? NULL : &local_err;\n            object_property_set_bool(OBJECT(bus), false, \"realized\",\n                                     local_errp);\n        if (qdev_get_vmsd(dev)) {\n            vmstate_unregister(dev, qdev_get_vmsd(dev), dev);\n        if (dc->unrealize) {\n            local_errp = local_err ? NULL : &local_err;\n            dc->unrealize(dev, local_errp);\n        dev->pending_deleted_event = true;\n        DEVICE_LISTENER_CALL(unrealize, Reverse, dev);\n    if (local_err != NULL) {\n    dev->realized = value;\n    return;\nchild_realize_fail:\n    QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n        object_property_set_bool(OBJECT(bus), false, \"realized\",\n                                 NULL);\n    if (qdev_get_vmsd(dev)) {\n        vmstate_unregister(dev, qdev_get_vmsd(dev), dev);\npost_realize_fail:\n    if (dc->unrealize) {\n        dc->unrealize(dev, NULL);\nfail:\n    error_propagate(errp, local_err);\n    if (unattached_parent) {\n        object_unparent(OBJECT(dev));\n        unattached_count--;",
      "function_name": "device_set_realized",
      "idx": 20868
    },
    "secure": {
      "project": "qemu",
      "commit_id": "67980031d234aa90524b83bb80bb5d1601d29076",
      "func": "static void device_set_realized(Object *obj, bool value, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    DeviceClass *dc = DEVICE_GET_CLASS(dev);\n\n    HotplugHandler *hotplug_ctrl;\n\n    BusState *bus;\n\n    Error *local_err = NULL;\n\n    bool unattached_parent = false;\n\n    static int unattached_count;\n\n\n\n    if (dev->hotplugged && !dc->hotpluggable) {\n\n        error_setg(errp, QERR_DEVICE_NO_HOTPLUG, object_get_typename(obj));\n\n        return;\n\n    }\n\n\n\n    if (value && !dev->realized) {\n\n        if (!obj->parent) {\n\n            gchar *name = g_strdup_printf(\"device[%d]\", unattached_count++);\n\n\n\n            object_property_add_child(container_get(qdev_get_machine(),\n\n                                                    \"/unattached\"),\n\n                                      name, obj, &error_abort);\n\n            unattached_parent = true;\n\n            g_free(name);\n\n        }\n\n\n\n        hotplug_ctrl = qdev_get_hotplug_handler(dev);\n\n        if (hotplug_ctrl) {\n\n            hotplug_handler_pre_plug(hotplug_ctrl, dev, &local_err);\n\n            if (local_err != NULL) {\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        if (dc->realize) {\n\n            dc->realize(dev, &local_err);\n\n        }\n\n\n\n        if (local_err != NULL) {\n\n            goto fail;\n\n        }\n\n\n\n        DEVICE_LISTENER_CALL(realize, Forward, dev);\n\n\n\n        if (hotplug_ctrl) {\n\n            hotplug_handler_plug(hotplug_ctrl, dev, &local_err);\n\n        }\n\n\n\n        if (local_err != NULL) {\n\n            goto post_realize_fail;\n\n        }\n\n\n\n        if (qdev_get_vmsd(dev)) {\n\n            vmstate_register_with_alias_id(dev, -1, qdev_get_vmsd(dev), dev,\n\n                                           dev->instance_id_alias,\n\n                                           dev->alias_required_for_version,\n\n                                           NULL);\n\n        }\n\n\n\n        QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n\n            object_property_set_bool(OBJECT(bus), true, \"realized\",\n\n                                         &local_err);\n\n            if (local_err != NULL) {\n\n                goto child_realize_fail;\n\n            }\n\n        }\n\n        if (dev->hotplugged) {\n\n            device_reset(dev);\n\n        }\n\n        dev->pending_deleted_event = false;\n\n    } else if (!value && dev->realized) {\n\n        Error **local_errp = NULL;\n\n        QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n\n            local_errp = local_err ? NULL : &local_err;\n\n            object_property_set_bool(OBJECT(bus), false, \"realized\",\n\n                                     local_errp);\n\n        }\n\n        if (qdev_get_vmsd(dev)) {\n\n            vmstate_unregister(dev, qdev_get_vmsd(dev), dev);\n\n        }\n\n        if (dc->unrealize) {\n\n            local_errp = local_err ? NULL : &local_err;\n\n            dc->unrealize(dev, local_errp);\n\n        }\n\n        dev->pending_deleted_event = true;\n\n        DEVICE_LISTENER_CALL(unrealize, Reverse, dev);\n\n    }\n\n\n\n    if (local_err != NULL) {\n\n        goto fail;\n\n    }\n\n\n\n    dev->realized = value;\n\n    return;\n\n\n\nchild_realize_fail:\n\n    QLIST_FOREACH(bus, &dev->child_bus, sibling) {\n\n        object_property_set_bool(OBJECT(bus), false, \"realized\",\n\n                                 NULL);\n\n    }\n\n\n\n    if (qdev_get_vmsd(dev)) {\n\n        vmstate_unregister(dev, qdev_get_vmsd(dev), dev);\n\n    }\n\n\n\npost_realize_fail:\n\n    if (dc->unrealize) {\n\n        dc->unrealize(dev, NULL);\n\n    }\n\n\n\nfail:\n\n    error_propagate(errp, local_err);\n\n    if (unattached_parent) {\n\n        object_unparent(OBJECT(dev));\n\n        unattached_count--;\n\n    }\n\n}\n",
      "function_name": "device_set_realized",
      "idx": 26705
    },
    "same_function": true,
    "similarity": 0.971604938271605
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "bbdd2ad0814ea0911076419ea21b7957505cf1cc",
      "func": "int qemu_set_fd_handler2(int fd,\n                         IOCanReadHandler *fd_read_poll,\n                         IOHandler *fd_read,\n                         IOHandler *fd_write,\n                         void *opaque)\n{\n    IOHandlerRecord *ioh;\n    if (!fd_read && !fd_write) {\n        QLIST_FOREACH(ioh, &io_handlers, next) {\n            if (ioh->fd == fd) {\n                ioh->deleted = 1;\n                break;\n            }\n        }\n    } else {\n        QLIST_FOREACH(ioh, &io_handlers, next) {\n            if (ioh->fd == fd)\n                goto found;\n        }\n        ioh = g_malloc0(sizeof(IOHandlerRecord));\n        QLIST_INSERT_HEAD(&io_handlers, ioh, next);\n    found:\n        ioh->fd = fd;\n        ioh->fd_read_poll = fd_read_poll;\n        ioh->fd_read = fd_read;\n        ioh->fd_write = fd_write;\n        ioh->opaque = opaque;\n        ioh->deleted = 0;\n        qemu_notify_event();\n    }\n    return 0;\n}",
      "function_name": "qemu_set_fd_handler2",
      "idx": 13699
    },
    "secure": {
      "project": "qemu",
      "commit_id": "6484e422479c93f28e3f8a68258b0eacd3b31e6d",
      "func": "int qemu_set_fd_handler2(int fd,\n\n                         IOCanReadHandler *fd_read_poll,\n\n                         IOHandler *fd_read,\n\n                         IOHandler *fd_write,\n\n                         void *opaque)\n\n{\n\n    IOHandlerRecord *ioh;\n\n\n\n    assert(fd >= 0);\n\n\n\n    if (!fd_read && !fd_write) {\n\n        QLIST_FOREACH(ioh, &io_handlers, next) {\n\n            if (ioh->fd == fd) {\n\n                ioh->deleted = 1;\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        QLIST_FOREACH(ioh, &io_handlers, next) {\n\n            if (ioh->fd == fd)\n\n                goto found;\n\n        }\n\n        ioh = g_malloc0(sizeof(IOHandlerRecord));\n\n        QLIST_INSERT_HEAD(&io_handlers, ioh, next);\n\n    found:\n\n        ioh->fd = fd;\n\n        ioh->fd_read_poll = fd_read_poll;\n\n        ioh->fd_read = fd_read;\n\n        ioh->fd_write = fd_write;\n\n        ioh->opaque = opaque;\n\n        ioh->pollfds_idx = -1;\n\n        ioh->deleted = 0;\n\n        qemu_notify_event();\n\n    }\n\n    return 0;\n\n}\n",
      "function_name": "qemu_set_fd_handler2",
      "idx": 23611
    },
    "same_function": true,
    "similarity": 0.9683544303797469
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "6ab3fc32ea640026726bc5f9f4db622d0954fb8a",
      "func": "static void usb_serial_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBSerialState *s = (USBSerialState *)dev;\n\n    uint8_t devep = p->ep->nr;\n\n    struct iovec *iov;\n\n    uint8_t header[2];\n\n    int i, first_len, len;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_OUT:\n\n        if (devep != 2)\n\n            goto fail;\n\n        for (i = 0; i < p->iov.niov; i++) {\n\n            iov = p->iov.iov + i;\n\n            qemu_chr_fe_write(s->cs, iov->iov_base, iov->iov_len);\n\n        }\n\n        p->actual_length = p->iov.size;\n\n        break;\n\n\n\n    case USB_TOKEN_IN:\n\n        if (devep != 1)\n\n            goto fail;\n\n        first_len = RECV_BUF - s->recv_ptr;\n\n        len = p->iov.size;\n\n        if (len <= 2) {\n\n            p->status = USB_RET_NAK;\n\n            break;\n\n        }\n\n        header[0] = usb_get_modem_lines(s) | 1;\n\n        /* We do not have the uart details */\n\n        /* handle serial break */\n\n        if (s->event_trigger && s->event_trigger & FTDI_BI) {\n\n            s->event_trigger &= ~FTDI_BI;\n\n            header[1] = FTDI_BI;\n\n            usb_packet_copy(p, header, 2);\n\n            break;\n\n        } else {\n\n            header[1] = 0;\n\n        }\n\n        len -= 2;\n\n        if (len > s->recv_used)\n\n            len = s->recv_used;\n\n        if (!len) {\n\n            p->status = USB_RET_NAK;\n\n            break;\n\n        }\n\n        if (first_len > len)\n\n            first_len = len;\n\n        usb_packet_copy(p, header, 2);\n\n        usb_packet_copy(p, s->recv_buf + s->recv_ptr, first_len);\n\n        if (len > first_len)\n\n            usb_packet_copy(p, s->recv_buf, len - first_len);\n\n        s->recv_used -= len;\n\n        s->recv_ptr = (s->recv_ptr + len) % RECV_BUF;\n\n        break;\n\n\n\n    default:\n\n        DPRINTF(\"Bad token\\n\");\n\n    fail:\n\n        p->status = USB_RET_STALL;\n\n        break;\n\n    }\n\n}\n",
      "function_name": "usb_serial_handle_data",
      "idx": 14316
    },
    "secure": {
      "project": "qemu",
      "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762",
      "func": "static int usb_serial_handle_data(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBSerialState *s = (USBSerialState *)dev;\n\n    int i, ret = 0;\n\n    uint8_t devep = p->devep;\n\n    struct iovec *iov;\n\n    uint8_t header[2];\n\n    int first_len, len;\n\n\n\n    switch (p->pid) {\n\n    case USB_TOKEN_OUT:\n\n        if (devep != 2)\n\n            goto fail;\n\n        for (i = 0; i < p->iov.niov; i++) {\n\n            iov = p->iov.iov + i;\n\n            qemu_chr_fe_write(s->cs, iov->iov_base, iov->iov_len);\n\n        }\n\n        break;\n\n\n\n    case USB_TOKEN_IN:\n\n        if (devep != 1)\n\n            goto fail;\n\n        first_len = RECV_BUF - s->recv_ptr;\n\n        len = p->iov.size;\n\n        if (len <= 2) {\n\n            ret = USB_RET_NAK;\n\n            break;\n\n        }\n\n        header[0] = usb_get_modem_lines(s) | 1;\n\n        /* We do not have the uart details */\n\n        /* handle serial break */\n\n        if (s->event_trigger && s->event_trigger & FTDI_BI) {\n\n            s->event_trigger &= ~FTDI_BI;\n\n            header[1] = FTDI_BI;\n\n            usb_packet_copy(p, header, 2);\n\n            ret = 2;\n\n            break;\n\n        } else {\n\n            header[1] = 0;\n\n        }\n\n        len -= 2;\n\n        if (len > s->recv_used)\n\n            len = s->recv_used;\n\n        if (!len) {\n\n            ret = USB_RET_NAK;\n\n            break;\n\n        }\n\n        if (first_len > len)\n\n            first_len = len;\n\n        usb_packet_copy(p, header, 2);\n\n        usb_packet_copy(p, s->recv_buf + s->recv_ptr, first_len);\n\n        if (len > first_len)\n\n            usb_packet_copy(p, s->recv_buf, len - first_len);\n\n        s->recv_used -= len;\n\n        s->recv_ptr = (s->recv_ptr + len) % RECV_BUF;\n\n        ret = len + 2;\n\n        break;\n\n\n\n    default:\n\n        DPRINTF(\"Bad token\\n\");\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n",
      "function_name": "usb_serial_handle_data",
      "idx": 8621
    },
    "same_function": true,
    "similarity": 0.9423784225582346
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "6b7741c2bedeae2e8c54fffce81723ca0a0c25c0",
      "func": "static void sch_handle_start_func(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    int path;\n\n    int ret;\n\n\n\n    /* Path management: In our simple css, we always choose the only path. */\n\n    path = 0x80;\n\n\n\n    if (!(s->ctrl & SCSW_ACTL_SUSP)) {\n\n\n\n        /* Look at the orb and try to execute the channel program. */\n\n        assert(orb != NULL); /* resume does not pass an orb */\n\n        p->intparm = orb->intparm;\n\n        if (!(orb->lpm & path)) {\n\n            /* Generate a deferred cc 3 condition. */\n\n            s->flags |= SCSW_FLAGS_MASK_CC;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= (SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND);\n\n            return;\n\n        }\n\n        sch->ccw_fmt_1 = !!(orb->ctrl0 & ORB_CTRL0_MASK_FMT);\n\n        sch->ccw_no_data_cnt = 0;\n\n    } else {\n\n        s->ctrl &= ~(SCSW_ACTL_SUSP | SCSW_ACTL_RESUME_PEND);\n\n    }\n\n    sch->last_cmd_valid = false;\n\n    do {\n\n        ret = css_interpret_ccw(sch, sch->channel_prog);\n\n        switch (ret) {\n\n        case -EAGAIN:\n\n            /* ccw chain, continue processing */\n\n            break;\n\n        case 0:\n\n            /* success */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_STATUS_PEND;\n\n            s->dstat = SCSW_DSTAT_CHANNEL_END | SCSW_DSTAT_DEVICE_END;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -ENOSYS:\n\n            /* unsupported command, generate unit check (command reject) */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->dstat = SCSW_DSTAT_UNIT_CHECK;\n\n            /* Set sense bit 0 in ecw0. */\n\n            sch->sense_data[0] = 0x80;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EFAULT:\n\n            /* memory problem, generate channel data check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_DATA_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EBUSY:\n\n            /* subchannel busy, generate deferred cc 1 */\n\n            s->flags &= ~SCSW_FLAGS_MASK_CC;\n\n            s->flags |= (1 << 8);\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            break;\n\n        case -EINPROGRESS:\n\n            /* channel program has been suspended */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl |= SCSW_ACTL_SUSP;\n\n            break;\n\n        default:\n\n            /* error, generate channel program check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_PROG_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        }\n\n    } while (ret == -EAGAIN);\n\n\n\n}",
      "function_name": "sch_handle_start_func",
      "idx": 778
    },
    "secure": {
      "project": "qemu",
      "commit_id": "bab482d7405f9fe3cac9c213d60f9ca9442c047b",
      "func": "static void sch_handle_start_func(SubchDev *sch, ORB *orb)\n\n{\n\n\n\n    PMCW *p = &sch->curr_status.pmcw;\n\n    SCSW *s = &sch->curr_status.scsw;\n\n    int path;\n\n    int ret;\n\n    bool suspend_allowed;\n\n\n\n    /* Path management: In our simple css, we always choose the only path. */\n\n    path = 0x80;\n\n\n\n    if (!(s->ctrl & SCSW_ACTL_SUSP)) {\n\n        /* Start Function triggered via ssch, i.e. we have an ORB */\n\n        s->cstat = 0;\n\n        s->dstat = 0;\n\n        /* Look at the orb and try to execute the channel program. */\n\n        assert(orb != NULL); /* resume does not pass an orb */\n\n        p->intparm = orb->intparm;\n\n        if (!(orb->lpm & path)) {\n\n            /* Generate a deferred cc 3 condition. */\n\n            s->flags |= SCSW_FLAGS_MASK_CC;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= (SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND);\n\n            return;\n\n        }\n\n        sch->ccw_fmt_1 = !!(orb->ctrl0 & ORB_CTRL0_MASK_FMT);\n\n        s->flags |= (sch->ccw_fmt_1) ? SCSW_FLAGS_MASK_FMT : 0;\n\n        sch->ccw_no_data_cnt = 0;\n\n        suspend_allowed = !!(orb->ctrl0 & ORB_CTRL0_MASK_SPND);\n\n    } else {\n\n        /* Start Function resumed via rsch, i.e. we don't have an\n\n         * ORB */\n\n        s->ctrl &= ~(SCSW_ACTL_SUSP | SCSW_ACTL_RESUME_PEND);\n\n        /* The channel program had been suspended before. */\n\n        suspend_allowed = true;\n\n    }\n\n    sch->last_cmd_valid = false;\n\n    do {\n\n        ret = css_interpret_ccw(sch, sch->channel_prog, suspend_allowed);\n\n        switch (ret) {\n\n        case -EAGAIN:\n\n            /* ccw chain, continue processing */\n\n            break;\n\n        case 0:\n\n            /* success */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_STATUS_PEND;\n\n            s->dstat = SCSW_DSTAT_CHANNEL_END | SCSW_DSTAT_DEVICE_END;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EIO:\n\n            /* I/O errors, status depends on specific devices */\n\n            break;\n\n        case -ENOSYS:\n\n            /* unsupported command, generate unit check (command reject) */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->dstat = SCSW_DSTAT_UNIT_CHECK;\n\n            /* Set sense bit 0 in ecw0. */\n\n            sch->sense_data[0] = 0x80;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EFAULT:\n\n            /* memory problem, generate channel data check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_DATA_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        case -EBUSY:\n\n            /* subchannel busy, generate deferred cc 1 */\n\n            s->flags &= ~SCSW_FLAGS_MASK_CC;\n\n            s->flags |= (1 << 8);\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            break;\n\n        case -EINPROGRESS:\n\n            /* channel program has been suspended */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->ctrl |= SCSW_ACTL_SUSP;\n\n            break;\n\n        default:\n\n            /* error, generate channel program check */\n\n            s->ctrl &= ~SCSW_ACTL_START_PEND;\n\n            s->cstat = SCSW_CSTAT_PROG_CHECK;\n\n            s->ctrl &= ~SCSW_CTRL_MASK_STCTL;\n\n            s->ctrl |= SCSW_STCTL_PRIMARY | SCSW_STCTL_SECONDARY |\n\n                    SCSW_STCTL_ALERT | SCSW_STCTL_STATUS_PEND;\n\n            s->cpa = sch->channel_prog + 8;\n\n            break;\n\n        }\n\n    } while (ret == -EAGAIN);\n\n\n\n}\n",
      "function_name": "sch_handle_start_func",
      "idx": 22211
    },
    "same_function": true,
    "similarity": 0.9408949509452021
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "5507904e362df252f6065cb27d1ff98372db6abc",
      "func": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n\n                        void *value, size_t vsize)\n\n{\n\n    ssize_t size = 0;\n\n    char *buffer;\n\n    void *ovalue = value;\n\n    XattrOperations *xops;\n\n    char *orig_value, *orig_value_start;\n\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n\n\n\n    /* Get the actual len */\n\n    buffer = rpath(ctx, path);\n\n    xattr_len = llistxattr(buffer, value, 0);\n\n    if (xattr_len <= 0) {\n\n        g_free(buffer);\n\n        return xattr_len;\n\n    }\n\n\n\n    /* Now fetch the xattr and find the actual size */\n\n    orig_value = g_malloc(xattr_len);\n\n    xattr_len = llistxattr(buffer, orig_value, xattr_len);\n\n    g_free(buffer);\n\n\n\n    /* store the orig pointer */\n\n    orig_value_start = orig_value;\n\n    while (xattr_len > parsed_len) {\n\n        xops = get_xattr_operations(ctx->xops, orig_value);\n\n        if (!xops) {\n\n            goto next_entry;\n\n        }\n\n\n\n        if (!value) {\n\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n\n        } else {\n\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n\n            if (size < 0) {\n\n                goto err_out;\n\n            }\n\n            value += size;\n\n            vsize -= size;\n\n        }\n\nnext_entry:\n\n        /* Got the next entry */\n\n        attr_len = strlen(orig_value) + 1;\n\n        parsed_len += attr_len;\n\n        orig_value += attr_len;\n\n    }\n\n    if (value) {\n\n        size = value - ovalue;\n\n    }\n\n\n\nerr_out:\n\n    g_free(orig_value_start);\n\n    return size;\n\n}\n",
      "function_name": "v9fs_list_xattr",
      "idx": 20418
    },
    "secure": {
      "project": "qemu",
      "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308",
      "func": "ssize_t v9fs_list_xattr(FsContext *ctx, const char *path,\n\n                        void *value, size_t vsize)\n\n{\n\n    ssize_t size = 0;\n\n    char buffer[PATH_MAX];\n\n    void *ovalue = value;\n\n    XattrOperations *xops;\n\n    char *orig_value, *orig_value_start;\n\n    ssize_t xattr_len, parsed_len = 0, attr_len;\n\n\n\n    /* Get the actual len */\n\n    xattr_len = llistxattr(rpath(ctx, path, buffer), value, 0);\n\n    if (xattr_len <= 0) {\n\n        return xattr_len;\n\n    }\n\n\n\n    /* Now fetch the xattr and find the actual size */\n\n    orig_value = g_malloc(xattr_len);\n\n    xattr_len = llistxattr(rpath(ctx, path, buffer), orig_value, xattr_len);\n\n\n\n    /* store the orig pointer */\n\n    orig_value_start = orig_value;\n\n    while (xattr_len > parsed_len) {\n\n        xops = get_xattr_operations(ctx->xops, orig_value);\n\n        if (!xops) {\n\n            goto next_entry;\n\n        }\n\n\n\n        if (!value) {\n\n            size += xops->listxattr(ctx, path, orig_value, value, vsize);\n\n        } else {\n\n            size = xops->listxattr(ctx, path, orig_value, value, vsize);\n\n            if (size < 0) {\n\n                goto err_out;\n\n            }\n\n            value += size;\n\n            vsize -= size;\n\n        }\n\nnext_entry:\n\n        /* Got the next entry */\n\n        attr_len = strlen(orig_value) + 1;\n\n        parsed_len += attr_len;\n\n        orig_value += attr_len;\n\n    }\n\n    if (value) {\n\n        size = value - ovalue;\n\n    }\n\n\n\nerr_out:\n\n    g_free(orig_value_start);\n\n    return size;\n\n}\n",
      "function_name": "v9fs_list_xattr",
      "idx": 7457
    },
    "same_function": true,
    "similarity": 0.9170779861796644
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194",
      "func": "int qcow2_get_refcount(BlockDriverState *bs, int64_t cluster_index,\n\n                       uint64_t *refcount)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t refcount_table_index, block_index;\n\n    int64_t refcount_block_offset;\n\n    int ret;\n\n    uint16_t *refcount_block;\n\n\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n    if (refcount_table_index >= s->refcount_table_size) {\n\n        *refcount = 0;\n\n        return 0;\n\n    }\n\n    refcount_block_offset =\n\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n    if (!refcount_block_offset) {\n\n        *refcount = 0;\n\n        return 0;\n\n    }\n\n\n\n    if (offset_into_cluster(s, refcount_block_offset)) {\n\n        qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\" PRIx64\n\n                                \" unaligned (reftable index: %#\" PRIx64 \")\",\n\n                                refcount_block_offset, refcount_table_index);\n\n        return -EIO;\n\n    }\n\n\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n\n        (void**) &refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    block_index = cluster_index & (s->refcount_block_size - 1);\n\n    *refcount = be16_to_cpu(refcount_block[block_index]);\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache,\n\n        (void**) &refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n",
      "function_name": "qcow2_get_refcount",
      "idx": 6462
    },
    "secure": {
      "project": "qemu",
      "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06",
      "func": "int qcow2_get_refcount(BlockDriverState *bs, int64_t cluster_index,\n\n                       uint64_t *refcount)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t refcount_table_index, block_index;\n\n    int64_t refcount_block_offset;\n\n    int ret;\n\n    void *refcount_block;\n\n\n\n    refcount_table_index = cluster_index >> s->refcount_block_bits;\n\n    if (refcount_table_index >= s->refcount_table_size) {\n\n        *refcount = 0;\n\n        return 0;\n\n    }\n\n    refcount_block_offset =\n\n        s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK;\n\n    if (!refcount_block_offset) {\n\n        *refcount = 0;\n\n        return 0;\n\n    }\n\n\n\n    if (offset_into_cluster(s, refcount_block_offset)) {\n\n        qcow2_signal_corruption(bs, true, -1, -1, \"Refblock offset %#\" PRIx64\n\n                                \" unaligned (reftable index: %#\" PRIx64 \")\",\n\n                                refcount_block_offset, refcount_table_index);\n\n        return -EIO;\n\n    }\n\n\n\n    ret = qcow2_cache_get(bs, s->refcount_block_cache, refcount_block_offset,\n\n                          &refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    block_index = cluster_index & (s->refcount_block_size - 1);\n\n    *refcount = s->get_refcount(refcount_block, block_index);\n\n\n\n    ret = qcow2_cache_put(bs, s->refcount_block_cache, &refcount_block);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n",
      "function_name": "qcow2_get_refcount",
      "idx": 17683
    },
    "same_function": true,
    "similarity": 0.9090081892629663
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "66b9b43c42049bcae37668e890fedde9a72c8167",
      "func": "static void watch_mem_write(void *opaque, hwaddr addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, size, BP_MEM_WRITE);\n\n    switch (size) {\n\n    case 1:\n\n        stb_phys(&address_space_memory, addr, val);\n\n        break;\n\n    case 2:\n\n        stw_phys(&address_space_memory, addr, val);\n\n        break;\n\n    case 4:\n\n        stl_phys(&address_space_memory, addr, val);\n\n        break;\n\n    default: abort();\n\n    }\n\n}\n",
      "function_name": "watch_mem_write",
      "idx": 25137
    },
    "secure": {
      "project": "qemu",
      "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c",
      "func": "static void watch_mem_write(void *opaque, target_phys_addr_t addr,\n\n                            uint64_t val, unsigned size)\n\n{\n\n    check_watchpoint(addr & ~TARGET_PAGE_MASK, ~(size - 1), BP_MEM_WRITE);\n\n    switch (size) {\n\n    case 1:\n\n        stb_phys(addr, val);\n\n        break;\n\n    case 2:\n\n        stw_phys(addr, val);\n\n        break;\n\n    case 4:\n\n        stl_phys(addr, val);\n\n        break;\n\n    default: abort();\n\n    }\n\n}\n",
      "function_name": "watch_mem_write",
      "idx": 23064
    },
    "same_function": true,
    "similarity": 0.8525073746312685
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "d3002b0463727bf8110833b9d1a6efaa28990c28",
      "func": "void register_displaychangelistener(DisplayChangeListener *dcl)\n\n{\n\n    QemuConsole *con;\n\n\n\n    trace_displaychangelistener_register(dcl, dcl->ops->dpy_name);\n\n    dcl->ds = get_alloc_displaystate();\n\n    QLIST_INSERT_HEAD(&dcl->ds->listeners, dcl, next);\n\n    gui_setup_refresh(dcl->ds);\n\n    if (dcl->con) {\n\n        dcl->con->dcls++;\n\n        con = dcl->con;\n\n    } else {\n\n        con = active_console;\n\n    }\n\n    if (dcl->ops->dpy_gfx_switch && con) {\n\n        dcl->ops->dpy_gfx_switch(dcl, con->surface);\n\n    }\n\n}\n",
      "function_name": "register_displaychangelistener",
      "idx": 2117
    },
    "secure": {
      "project": "qemu",
      "commit_id": "521a580d2352ad30086babcabb91e6338e47cf62",
      "func": "void register_displaychangelistener(DisplayChangeListener *dcl)\n\n{\n\n    static DisplaySurface *dummy;\n\n    QemuConsole *con;\n\n\n\n    trace_displaychangelistener_register(dcl, dcl->ops->dpy_name);\n\n    dcl->ds = get_alloc_displaystate();\n\n    QLIST_INSERT_HEAD(&dcl->ds->listeners, dcl, next);\n\n    gui_setup_refresh(dcl->ds);\n\n    if (dcl->con) {\n\n        dcl->con->dcls++;\n\n        con = dcl->con;\n\n    } else {\n\n        con = active_console;\n\n    }\n\n    if (dcl->ops->dpy_gfx_switch) {\n\n        if (con) {\n\n            dcl->ops->dpy_gfx_switch(dcl, con->surface);\n\n        } else {\n\n            if (!dummy) {\n\n                dummy = qemu_create_dummy_surface();\n\n            }\n\n            dcl->ops->dpy_gfx_switch(dcl, dummy);\n\n        }\n\n    }\n\n}\n",
      "function_name": "register_displaychangelistener",
      "idx": 14966
    },
    "same_function": true,
    "similarity": 0.85
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "478f1c3d5e5463a284ea7efecfc62d47ba3be11a",
      "func": "static int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    uint32_t sequence_number;\n\n    int cur_w, cur_h, x_offset, y_offset, dispose_op, blend_op;\n\n\n\n    if (length != 26)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!(s->state & PNG_IHDR)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"fctl before IHDR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    s->last_w = s->cur_w;\n\n    s->last_h = s->cur_h;\n\n    s->last_x_offset = s->x_offset;\n\n    s->last_y_offset = s->y_offset;\n\n    s->last_dispose_op = s->dispose_op;\n\n\n\n    sequence_number = bytestream2_get_be32(&s->gb);\n\n    cur_w           = bytestream2_get_be32(&s->gb);\n\n    cur_h           = bytestream2_get_be32(&s->gb);\n\n    x_offset        = bytestream2_get_be32(&s->gb);\n\n    y_offset        = bytestream2_get_be32(&s->gb);\n\n    bytestream2_skip(&s->gb, 4); /* delay_num (2), delay_den (2) */\n\n    dispose_op      = bytestream2_get_byte(&s->gb);\n\n    blend_op        = bytestream2_get_byte(&s->gb);\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n\n\n    if (sequence_number == 0 &&\n\n        (cur_w != s->width ||\n\n         cur_h != s->height ||\n\n         x_offset != 0 ||\n\n         y_offset != 0) ||\n\n        cur_w <= 0 || cur_h <= 0 ||\n\n        x_offset < 0 || y_offset < 0 ||\n\n        cur_w > s->width - x_offset|| cur_h > s->height - y_offset)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n    if (blend_op != APNG_BLEND_OP_OVER && blend_op != APNG_BLEND_OP_SOURCE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid blend_op %d\\n\", blend_op);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((sequence_number == 0 || !s->previous_picture.f->data[0]) &&\n\n        dispose_op == APNG_DISPOSE_OP_PREVIOUS) {\n\n        // No previous frame to revert to for the first frame\n\n        // Spec says to just treat it as a APNG_DISPOSE_OP_BACKGROUND\n\n        dispose_op = APNG_DISPOSE_OP_BACKGROUND;\n\n    }\n\n\n\n    if (blend_op == APNG_BLEND_OP_OVER && !s->has_trns && (\n\n            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n\n            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK\n\n        )) {\n\n        // APNG_BLEND_OP_OVER is the same as APNG_BLEND_OP_SOURCE when there is no alpha channel\n\n        blend_op = APNG_BLEND_OP_SOURCE;\n\n    }\n\n\n\n    s->cur_w      = cur_w;\n\n    s->cur_h      = cur_h;\n\n    s->x_offset   = x_offset;\n\n    s->y_offset   = y_offset;\n\n    s->dispose_op = dispose_op;\n\n    s->blend_op   = blend_op;\n\n\n\n    return 0;\n\n}\n",
      "function_name": "decode_fctl_chunk",
      "idx": 14651
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "b54ac8403bfea4e7fab0799ccfe728ba76959a38",
      "func": "static int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    uint32_t sequence_number;\n\n\n\n    if (length != 26)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (!(s->state & PNG_IHDR)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"fctl before IHDR\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    s->last_w = s->cur_w;\n\n    s->last_h = s->cur_h;\n\n    s->last_x_offset = s->x_offset;\n\n    s->last_y_offset = s->y_offset;\n\n    s->last_dispose_op = s->dispose_op;\n\n\n\n    sequence_number = bytestream2_get_be32(&s->gb);\n\n    s->cur_w        = bytestream2_get_be32(&s->gb);\n\n    s->cur_h        = bytestream2_get_be32(&s->gb);\n\n    s->x_offset     = bytestream2_get_be32(&s->gb);\n\n    s->y_offset     = bytestream2_get_be32(&s->gb);\n\n    bytestream2_skip(&s->gb, 4); /* delay_num (2), delay_den (2) */\n\n    s->dispose_op   = bytestream2_get_byte(&s->gb);\n\n    s->blend_op     = bytestream2_get_byte(&s->gb);\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n\n\n    if (sequence_number == 0 &&\n\n        (s->cur_w != s->width ||\n\n         s->cur_h != s->height ||\n\n         s->x_offset != 0 ||\n\n         s->y_offset != 0) ||\n\n        s->cur_w <= 0 || s->cur_h <= 0 ||\n\n        s->x_offset < 0 || s->y_offset < 0 ||\n\n        s->cur_w > s->width - s->x_offset|| s->cur_h > s->height - s->y_offset)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n    if (sequence_number == 0 && s->dispose_op == APNG_DISPOSE_OP_PREVIOUS) {\n\n        // No previous frame to revert to for the first frame\n\n        // Spec says to just treat it as a APNG_DISPOSE_OP_BACKGROUND\n\n        s->dispose_op = APNG_DISPOSE_OP_BACKGROUND;\n\n    }\n\n\n\n    if (s->dispose_op == APNG_BLEND_OP_OVER && !s->has_trns && (\n\n            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n\n            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n\n            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n\n            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK\n\n        )) {\n\n        // APNG_DISPOSE_OP_OVER is the same as APNG_DISPOSE_OP_SOURCE when there is no alpha channel\n\n        s->dispose_op = APNG_BLEND_OP_SOURCE;\n\n    }\n\n\n\n    return 0;\n\n}\n",
      "function_name": "decode_fctl_chunk",
      "idx": 936
    },
    "same_function": true,
    "similarity": 0.828696925329429
  },
  {
    "vulnerable": {
      "project": "qemu",
      "commit_id": "0d2e91c17829729812bf5d22d20dd0f5d2554ec2",
      "func": "void sd_set_cb(SDState *sd, qemu_irq readonly, qemu_irq insert)\n\n{\n\n    sd->readonly_cb = readonly;\n\n    sd->inserted_cb = insert;\n\n    qemu_set_irq(readonly, bdrv_is_read_only(sd->bdrv));\n\n    qemu_set_irq(insert, bdrv_is_inserted(sd->bdrv));\n\n}\n",
      "function_name": "sd_set_cb",
      "idx": 25886
    },
    "secure": {
      "project": "qemu",
      "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce",
      "func": "void sd_set_cb(SDState *sd, qemu_irq readonly, qemu_irq insert)\n\n{\n\n    sd->readonly_cb = readonly;\n\n    sd->inserted_cb = insert;\n\n    qemu_set_irq(readonly, sd->bdrv ? bdrv_is_read_only(sd->bdrv) : 0);\n\n    qemu_set_irq(insert, sd->bdrv ? bdrv_is_inserted(sd->bdrv) : 0);\n\n}\n",
      "function_name": "sd_set_cb",
      "idx": 6077
    },
    "same_function": true,
    "similarity": 0.6150627615062761
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "ca203e9985cd2dcf42a0c0853940850d3a8edf3a",
      "func": "static av_cold int psy_3gpp_init(FFPsyContext *ctx) {\n\n    AacPsyContext *pctx;\n\n    float bark;\n\n    int i, j, g, start;\n\n    float prev, minscale, minath, minsnr, pe_min;\n\n    int chan_bitrate = ctx->avctx->bit_rate / ((ctx->avctx->flags & CODEC_FLAG_QSCALE) ? 2.0f : ctx->avctx->channels);\n\n\n\n    const int bandwidth    = ctx->avctx->cutoff ? ctx->avctx->cutoff : AAC_CUTOFF(ctx->avctx);\n\n    const float num_bark   = calc_bark((float)bandwidth);\n\n\n\n    ctx->model_priv_data = av_mallocz(sizeof(AacPsyContext));\n\n    if (!ctx->model_priv_data)\n\n        return AVERROR(ENOMEM);\n\n    pctx = (AacPsyContext*) ctx->model_priv_data;\n\n    pctx->global_quality = (ctx->avctx->global_quality ? ctx->avctx->global_quality : 120) * 0.01f;\n\n\n\n    if (ctx->avctx->flags & CODEC_FLAG_QSCALE) {\n\n        /* Use the target average bitrate to compute spread parameters */\n\n        chan_bitrate = (int)(chan_bitrate / 120.0 * (ctx->avctx->global_quality ? ctx->avctx->global_quality : 120));\n\n    }\n\n\n\n    pctx->chan_bitrate = chan_bitrate;\n\n    pctx->frame_bits   = FFMIN(2560, chan_bitrate * AAC_BLOCK_SIZE_LONG / ctx->avctx->sample_rate);\n\n    pctx->pe.min       =  8.0f * AAC_BLOCK_SIZE_LONG * bandwidth / (ctx->avctx->sample_rate * 2.0f);\n\n    pctx->pe.max       = 12.0f * AAC_BLOCK_SIZE_LONG * bandwidth / (ctx->avctx->sample_rate * 2.0f);\n\n    ctx->bitres.size   = 6144 - pctx->frame_bits;\n\n    ctx->bitres.size  -= ctx->bitres.size % 8;\n\n    pctx->fill_level   = ctx->bitres.size;\n\n    minath = ath(3410 - 0.733 * ATH_ADD, ATH_ADD);\n\n    for (j = 0; j < 2; j++) {\n\n        AacPsyCoeffs *coeffs = pctx->psy_coef[j];\n\n        const uint8_t *band_sizes = ctx->bands[j];\n\n        float line_to_frequency = ctx->avctx->sample_rate / (j ? 256.f : 2048.0f);\n\n        float avg_chan_bits = chan_bitrate * (j ? 128.0f : 1024.0f) / ctx->avctx->sample_rate;\n\n        /* reference encoder uses 2.4% here instead of 60% like the spec says */\n\n        float bark_pe = 0.024f * PSY_3GPP_BITS_TO_PE(avg_chan_bits) / num_bark;\n\n        float en_spread_low = j ? PSY_3GPP_EN_SPREAD_LOW_S : PSY_3GPP_EN_SPREAD_LOW_L;\n\n        /* High energy spreading for long blocks <= 22kbps/channel and short blocks are the same. */\n\n        float en_spread_hi  = (j || (chan_bitrate <= 22.0f)) ? PSY_3GPP_EN_SPREAD_HI_S : PSY_3GPP_EN_SPREAD_HI_L1;\n\n\n\n        i = 0;\n\n        prev = 0.0;\n\n        for (g = 0; g < ctx->num_bands[j]; g++) {\n\n            i += band_sizes[g];\n\n            bark = calc_bark((i-1) * line_to_frequency);\n\n            coeffs[g].barks = (bark + prev) / 2.0;\n\n            prev = bark;\n\n        }\n\n        for (g = 0; g < ctx->num_bands[j] - 1; g++) {\n\n            AacPsyCoeffs *coeff = &coeffs[g];\n\n            float bark_width = coeffs[g+1].barks - coeffs->barks;\n\n            coeff->spread_low[0] = pow(10.0, -bark_width * PSY_3GPP_THR_SPREAD_LOW);\n\n            coeff->spread_hi [0] = pow(10.0, -bark_width * PSY_3GPP_THR_SPREAD_HI);\n\n            coeff->spread_low[1] = pow(10.0, -bark_width * en_spread_low);\n\n            coeff->spread_hi [1] = pow(10.0, -bark_width * en_spread_hi);\n\n            pe_min = bark_pe * bark_width;\n\n            minsnr = exp2(pe_min / band_sizes[g]) - 1.5f;\n\n            coeff->min_snr = av_clipf(1.0f / minsnr, PSY_SNR_25DB, PSY_SNR_1DB);\n\n        }\n\n        start = 0;\n\n        for (g = 0; g < ctx->num_bands[j]; g++) {\n\n            minscale = ath(start * line_to_frequency, ATH_ADD);\n\n            for (i = 1; i < band_sizes[g]; i++)\n\n                minscale = FFMIN(minscale, ath((start + i) * line_to_frequency, ATH_ADD));\n\n            coeffs[g].ath = minscale - minath;\n\n            start += band_sizes[g];\n\n        }\n\n    }\n\n\n\n    pctx->ch = av_mallocz_array(ctx->avctx->channels, sizeof(AacPsyChannel));\n\n    if (!pctx->ch) {\n\n        av_freep(&ctx->model_priv_data);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    lame_window_init(pctx, ctx->avctx);\n\n\n\n    return 0;\n\n}\n",
      "function_name": "psy_3gpp_init",
      "idx": 18185
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "b7c96769c52a312c6f6abe43f5d8c83701118a0b",
      "func": "static av_cold int psy_3gpp_init(FFPsyContext *ctx) {\n\n    AacPsyContext *pctx;\n\n    float bark;\n\n    int i, j, g, start;\n\n    float prev, minscale, minath;\n\n\n\n    ctx->model_priv_data = av_mallocz(sizeof(AacPsyContext));\n\n    pctx = (AacPsyContext*) ctx->model_priv_data;\n\n\n\n    minath = ath(3410, ATH_ADD);\n\n    for (j = 0; j < 2; j++) {\n\n        AacPsyCoeffs *coeffs = &pctx->psy_coef[j];\n\n        float line_to_frequency = ctx->avctx->sample_rate / (j ? 256.f : 2048.0f);\n\n        i = 0;\n\n        prev = 0.0;\n\n        for (g = 0; g < ctx->num_bands[j]; g++) {\n\n            i += ctx->bands[j][g];\n\n            bark = calc_bark((i-1) * line_to_frequency);\n\n            coeffs->barks[g] = (bark + prev) / 2.0;\n\n            prev = bark;\n\n        }\n\n        for (g = 0; g < ctx->num_bands[j] - 1; g++) {\n\n            coeffs->spread_low[g] = pow(10.0, -(coeffs->barks[g+1] - coeffs->barks[g]) * PSY_3GPP_SPREAD_LOW);\n\n            coeffs->spread_hi [g] = pow(10.0, -(coeffs->barks[g+1] - coeffs->barks[g]) * PSY_3GPP_SPREAD_HI);\n\n        }\n\n        start = 0;\n\n        for (g = 0; g < ctx->num_bands[j]; g++) {\n\n            minscale = ath(start * line_to_frequency, ATH_ADD);\n\n            for (i = 1; i < ctx->bands[j][g]; i++)\n\n                minscale = FFMIN(minscale, ath((start + i) * line_to_frequency, ATH_ADD));\n\n            coeffs->ath[g] = minscale - minath;\n\n            start += ctx->bands[j][g];\n\n        }\n\n    }\n\n\n\n    pctx->ch = av_mallocz(sizeof(AacPsyChannel) * ctx->avctx->channels);\n\n\n\n    lame_window_init(pctx, ctx->avctx);\n\n\n\n    return 0;\n\n}\n",
      "function_name": "psy_3gpp_init",
      "idx": 15238
    },
    "same_function": true,
    "similarity": 0.41131105398457585
  },
  {
    "vulnerable": {
      "project": "FFmpeg",
      "commit_id": "1795fed7bc7a8b8109757cb5f27198c5b05698b5",
      "func": "static int film_read_packet(AVFormatContext *s,\n\n                            AVPacket *pkt)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    film_sample *sample;\n\n    int ret = 0;\n\n    int i;\n\n    int left, right;\n\n\n\n    if (film->current_sample >= film->sample_count)\n\n\n\n\n    sample = &film->sample_table[film->current_sample];\n\n\n\n    /* position the stream (will probably be there anyway) */\n\n    avio_seek(pb, sample->sample_offset, SEEK_SET);\n\n\n\n    /* do a special song and dance when loading FILM Cinepak chunks */\n\n    if ((sample->stream == film->video_stream_index) &&\n\n        (film->video_type == CODEC_ID_CINEPAK)) {\n\n        pkt->pos= avio_tell(pb);\n\n        if (av_new_packet(pkt, sample->sample_size))\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, pkt->data, sample->sample_size);\n\n    } else if ((sample->stream == film->audio_stream_index) &&\n\n        (film->audio_channels == 2) &&\n\n        (film->audio_type != CODEC_ID_ADPCM_ADX)) {\n\n        /* stereo PCM needs to be interleaved */\n\n\n\n\n\n        if (av_new_packet(pkt, sample->sample_size))\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* make sure the interleave buffer is large enough */\n\n        if (sample->sample_size > film->stereo_buffer_size) {\n\n            av_free(film->stereo_buffer);\n\n            film->stereo_buffer_size = sample->sample_size;\n\n            film->stereo_buffer = av_malloc(film->stereo_buffer_size);\n\n            if (!film->stereo_buffer) {\n\n                film->stereo_buffer_size = 0;\n\n                return AVERROR(ENOMEM);\n\n            }\n\n        }\n\n\n\n        pkt->pos= avio_tell(pb);\n\n        ret = avio_read(pb, film->stereo_buffer, sample->sample_size);\n\n        if (ret != sample->sample_size)\n\n            ret = AVERROR(EIO);\n\n\n\n        left = 0;\n\n        right = sample->sample_size / 2;\n\n        for (i = 0; i < sample->sample_size; ) {\n\n            if (film->audio_bits == 8) {\n\n                pkt->data[i++] = film->stereo_buffer[left++];\n\n                pkt->data[i++] = film->stereo_buffer[right++];\n\n            } else {\n\n                pkt->data[i++] = film->stereo_buffer[left++];\n\n                pkt->data[i++] = film->stereo_buffer[left++];\n\n                pkt->data[i++] = film->stereo_buffer[right++];\n\n                pkt->data[i++] = film->stereo_buffer[right++];\n\n            }\n\n        }\n\n    } else {\n\n        ret= av_get_packet(pb, pkt, sample->sample_size);\n\n        if (ret != sample->sample_size)\n\n            ret = AVERROR(EIO);\n\n    }\n\n\n\n    pkt->stream_index = sample->stream;\n\n    pkt->pts = sample->pts;\n\n\n\n    film->current_sample++;\n\n\n\n    return ret;\n\n}",
      "function_name": "film_read_packet",
      "idx": 15584
    },
    "secure": {
      "project": "FFmpeg",
      "commit_id": "ded5957d75def70d2f1fc1c1eae079230004974b",
      "func": "static int film_read_packet(AVFormatContext *s,\n\n                            AVPacket *pkt)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    film_sample *sample;\n\n    int ret = 0;\n\n    int i;\n\n    int left, right;\n\n\n\n    if (film->current_sample >= film->sample_count)\n\n        return AVERROR(EIO);\n\n\n\n    sample = &film->sample_table[film->current_sample];\n\n\n\n    /* position the stream (will probably be there anyway) */\n\n    avio_seek(pb, sample->sample_offset, SEEK_SET);\n\n\n\n    /* do a special song and dance when loading FILM Cinepak chunks */\n\n    if ((sample->stream == film->video_stream_index) &&\n\n        (film->video_type == AV_CODEC_ID_CINEPAK)) {\n\n        pkt->pos= avio_tell(pb);\n\n        if (av_new_packet(pkt, sample->sample_size))\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, pkt->data, sample->sample_size);\n\n    } else if ((sample->stream == film->audio_stream_index) &&\n\n        (film->audio_channels == 2) &&\n\n        (film->audio_type != AV_CODEC_ID_ADPCM_ADX)) {\n\n        /* stereo PCM needs to be interleaved */\n\n\n\n        if (av_new_packet(pkt, sample->sample_size))\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* make sure the interleave buffer is large enough */\n\n        if (sample->sample_size > film->stereo_buffer_size) {\n\n            av_free(film->stereo_buffer);\n\n            film->stereo_buffer_size = sample->sample_size;\n\n            film->stereo_buffer = av_malloc(film->stereo_buffer_size);\n\n            if (!film->stereo_buffer) {\n\n                film->stereo_buffer_size = 0;\n\n                return AVERROR(ENOMEM);\n\n            }\n\n        }\n\n\n\n        pkt->pos= avio_tell(pb);\n\n        ret = avio_read(pb, film->stereo_buffer, sample->sample_size);\n\n        if (ret != sample->sample_size)\n\n            ret = AVERROR(EIO);\n\n\n\n        left = 0;\n\n        right = sample->sample_size / 2;\n\n        for (i = 0; i < sample->sample_size; ) {\n\n            if (film->audio_bits == 8) {\n\n                pkt->data[i++] = film->stereo_buffer[left++];\n\n                pkt->data[i++] = film->stereo_buffer[right++];\n\n            } else {\n\n                pkt->data[i++] = film->stereo_buffer[left++];\n\n                pkt->data[i++] = film->stereo_buffer[left++];\n\n                pkt->data[i++] = film->stereo_buffer[right++];\n\n                pkt->data[i++] = film->stereo_buffer[right++];\n\n            }\n\n        }\n\n    } else {\n\n        ret= av_get_packet(pb, pkt, sample->sample_size);\n\n        if (ret != sample->sample_size)\n\n            ret = AVERROR(EIO);\n\n    }\n\n\n\n    pkt->stream_index = sample->stream;\n\n    pkt->pts = sample->pts;\n\n\n\n    film->current_sample++;\n\n\n\n    return ret;\n\n}\n",
      "function_name": "film_read_packet",
      "idx": 23287
    },
    "same_function": true,
    "similarity": 0.3079461094308496
  }
]