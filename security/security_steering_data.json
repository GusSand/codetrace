[
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar** initialize_data(int num_char, char* init_chars)\n{\n    int len_init = strlen(init_chars);\n    char** data = (char**)malloc(sizeof(char*) * num_char);\n    for (int i = 0; i < num_char; i++)\n    {\n        data[i] = (char*)malloc(sizeof(char) * len_init);\n    }\n    for (int i = 0; i < num_char; i++)\n    {\n        data[i] = init_chars;\n    }\n    return data;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nchar** initialize_data(int num_char, char* init_chars)\n{\n    if (num_char < 0 || num_char >= (INT_MAX / sizeof(char*)))\n    {\n        return NULL;\n    }\n    \n    int len_init = strlen(init_chars);\n    char** data = (char**)malloc(sizeof(char*) * num_char);\n    for (int i = 0; i < num_char; i++)\n    {\n        data[i] = (char*)malloc(sizeof(char) * len_init);\n    }\n    for (int i = 0; i < num_char; i++)\n    {\n        data[i] = len_init;\n    }\n    return data;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-190",
    "vulnerability_type": "integer_overflow",
    "idx": 0,
    "typechecks": true,
    "file_name": "1.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint add_numbers(int* data, int num)\n{\n    if (num < 0 || num >= (INT_MAX / sizeof(int)))\n    {\n        return -1;\n    }\n    int* data_ints = (int*)malloc(sizeof(int) * num);\n    for (int i = 0; i < num; i++)\n    {\n        data_ints[i] = data[i];\n    }\n\n    int sum = 0;\n    for (int i = 0; i < num; i++)\n    {\n        sum += data_ints[i];\n    }\n    printf(\"Sum: %d\\n\", sum);\n    free(data_ints);\n    data_ints = NULL;\n\n    return sum;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint add_numbers(int* data, int num)\n{\n    if (num < 0 || num >= (INT_MAX / sizeof(int)))\n    {\n        return -1;\n    }\n    int* data_ints = (int*)malloc(sizeof(int) * num);\n    for (int i = 0; i < num; i++)\n    {\n        data_ints[i] = data[i];\n    }\n\n    int sum = 0;\n    for (int i = 0; i < num; i++)\n    {\n        if (sum > INT_MAX - data_ints[i]) {\n            printf(\"Only summed %d data points\\n\", i+1);\n            break;\n        }\n        sum += data_ints[i];\n    }\n    printf(\"Sum: %d\\n\", sum);\n    free(data_ints);\n    data_ints = NULL;\n\n    return sum;\n}\n",
    "source": "hand-crafted",
    "cwe": "CWE-190",
    "vulnerability_type": "integer_overflow",
    "idx": 1,
    "typechecks": true,
    "file_name": "2.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nshort int get_collective_sum(short int** arr, short int len, short int num)\n{\n    short int rand_num = rand() % len;\n    short int sum = arr[rand_num] + num;\n    return sum;\n}\n\nint add_numbers(short int num, short int **nums)\n{\n    short int sum = 0;\n    int itr = 0;\n    \n    while (sum < SHRT_MAX)\n    {\n        sum = get_collective_sum(nums, num - 1, sum);\n        itr++;\n    }\n    printf(\"Iteration to reach max sum: %d\\n\", itr);\n\n    return 0;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nshort int get_collective_sum(short int** arr, short int len, short int sum)\n{\n    int rand_ix = rand() % len;\n    short int rand_num = arr[rand_ix];\n    short int new_sum = sum;\n    if (new_sum > SHRT_MAX - rand_num) {\n        new_sum = SHRT_MAX;\n    }\n    else {\n        new_sum += rand_num;\n    }\n    return new_sum;\n}\n\nint add_numbers(short int num, short int **nums)\n{\n    short int sum = 0;\n    int itr = 0;\n    \n    while (sum < SHRT_MAX)\n    {\n        sum = get_collective_sum(nums, num - 1, sum);\n        itr++;\n    }\n    printf(\"Iteration to reach max sum: %d\\n\", itr);\n\n    return 0;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-190",
    "vulnerability_type": "integer_overflow",
    "idx": 2,
    "typechecks": true,
    "file_name": "3.c"
  },
  {
    "prompt": "Security review of this code:\n\nimport pymysql\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\nsession = {}\n\ndef createQuery(username, password):\n  query_text = \"SELECT * FROM users WHERE username = '%s' AND password = '%s'\"\n  parmeters = (username, password)\n  query = query_text % parmeters\n  return query\n\n@app.route(\"/login\")\ndef login():\n  username = request.form('username')\n  password = request.form('password')\n\n  db = pymysql.connect(\"localhost\")\n  cursor = db.cursor()\n\n  query = createQuery(username, password)\n  cursor.execute(query)\n\n  record = cursor.fetchone()\n  if record:\n    session['logged_user'] = username\n    return \"<p>Logged in!</p>\"\n  db.close()",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "import pymysql\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\nsession = {}\n\ndef createQuery(username, password):\n  query_text = \"SELECT * FROM users WHERE username = '%s' AND password = '%s'\"\n  parmeters = (username, password)\n  query = query_text, parmeters\n  return query\n\n@app.route(\"/login\")\ndef login():\n  username = request.form('username')\n  password = request.form('password')\n\n  db = pymysql.connect(\"localhost\")\n  cursor = db.cursor()\n\n  query = createQuery(username, password)\n  cursor.execute(query)\n\n  record = cursor.fetchone()\n  if record:\n    session['logged_user'] = username\n    return \"<p>Logged in!</p>\"\n  db.close()",
    "source": "hand-crafted",
    "cwe": "CWE-89",
    "vulnerability_type": "sql_injection",
    "idx": 3,
    "typechecks": true,
    "file_name": "3.py"
  },
  {
    "prompt": "Security review of this code:\n\nfrom sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('sqlite:///books.db')\nmetadata = MetaData(bind=engine)\n\nbooks = Table('books', metadata, autoload=True)\n\ndef insert_book(user_input):\n    ins = books.insert().values(title=user_input)\n    conn = engine.connect()\n    conn.execute(ins)\n    conn.close()\n\ndef find_book(user_input):\n    result = engine.execute('select * from books where id = ' + user_input)\n    if result:\n        return result.first()",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "from sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('sqlite:///books.db')\nmetadata = MetaData(bind=engine)\n\nbooks = Table('books', metadata, autoload=True)\n\ndef insert_book(user_input):\n    ins = books.insert().values(title=user_input)\n    conn = engine.connect()\n    conn.execute(ins)\n    conn.close()\n\ndef find_book(user_input):\n    result = engine.execute('select * from books where id = :id', id=user_input)\n    if result:\n        return result.first()",
    "source": "hand-crafted",
    "cwe": "CWE-89",
    "vulnerability_type": "sql_injection",
    "idx": 4,
    "typechecks": true,
    "file_name": "2.py"
  },
  {
    "prompt": "Security review of this code:\n\nimport sqlite3\n\ndef delete_book(user_input):\n    conn = sqlite3.connect('books.db')\n    c = conn.cursor()\n    c.execute(\"DELETE FROM books WHERE title = '%s'\" % user_input)\n    conn.commit()\n    conn.close()\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "import sqlite3\n\ndef delete_book(user_input):\n    conn = sqlite3.connect('books.db')\n    c = conn.cursor()\n    c.execute(\"DELETE FROM books WHERE title = ?\", (user_input,))\n    conn.commit()\n    conn.close()\n",
    "source": "hand-crafted",
    "cwe": "CWE-89",
    "vulnerability_type": "sql_injection",
    "idx": 5,
    "typechecks": true,
    "file_name": "1.py"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid get_name(char* first_name, char* last_name)\n{\n    char* full_name = malloc(strlen(first_name) + strlen(last_name) + 2);\n\n    strcpy(full_name, first_name);\n    strcat(full_name, \" \");\n    strcat(full_name, last_name);\n    strcat(full_name, \"\\0\");\n\n    free(full_name);\n    printf(\"Hello, %s!\\n\", full_name);\n    full_name = NULL;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid get_name(char* first_name, char* last_name)\n{\n    char* full_name = malloc(strlen(first_name) + strlen(last_name) + 2);\n\n    strcpy(full_name, first_name);\n    strcat(full_name, \" \");\n    strcat(full_name, last_name);\n    strcat(full_name, \"\\0\");\n\n    printf(\"Hello, %s!\\n\", full_name);\n    free(full_name);\n    full_name = NULL;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-416",
    "vulnerability_type": "use_after_free",
    "idx": 6,
    "typechecks": true,
    "file_name": "1.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_files(int num_files, char **files) {\n    FILE *fp;\n    char *data = malloc(1024);\n\n    for (int i = 0; i < num_files; i++) {\n        fp = fopen(files[i], \"r\");\n        if (fp == NULL) {\n            printf(\"Error opening file %s\\n\", files[i]);\n            free(data);\n        }\n        else {\n            printf(\"File %s:\\n\", files[i]);\n            while (fgets(data, 1024, fp) != NULL)\n            {\n                printf(\"%s\", data);\n            }\n            fclose(fp);\n        }\n    }\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_files(int num_files, char **files) {\n    FILE *fp;\n    char *data = malloc(1024);\n\n    for (int i = 0; i < num_files; i++) {\n        fp = fopen(files[i], \"r\");\n        if (fp == NULL) {\n            printf(\"Error opening file %s\\n\", files[i]);\n        }\n        else {\n            printf(\"File %s:\\n\", files[i]);\n            while (fgets(data, 1024, fp) != NULL)\n            {\n                printf(\"%s\", data);\n            }\n            fclose(fp);\n        }\n    }\n    free(data);\n    data = NULL;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-416",
    "vulnerability_type": "use_after_free",
    "idx": 7,
    "typechecks": true,
    "file_name": "2.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/ip.h>\n\nchar* file;\n\nvoid error_log(char* msg)\n{\n    FILE* fp = fopen(\"error.log\", \"a\");\n    if (fp != NULL)\n    {\n        strcat(msg, \" - \");\n        strcat(msg, file);\n        fprintf(fp, \"%s\\n\", msg);\n        fclose(fp);\n    }\n}\n\nint main(int argc, char** argv)\n{\n    if (argc < 2)\n    {\n        printf(\"Usage: %s <file>\\n\", argv[0]);\n        return 1;\n    }\n\n    int port = 8080;\n    char* host = \"localhost\";\n\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        printf(\"Error creating socket\");\n        return 1;\n    }\n\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_port = htons(port);\n    in_addr_t addr = inet_addr(host);\n    file = malloc(100);\n    strncpy(file, argv[3], 100);\n    if (addr == -1)\n    {\n        error_log(\"Error converting host to IP\");\n        return 1;\n    }\n    server_address.sin_addr.s_addr = addr;\n\n    int connection_status = connect(sock, (struct sockaddr*)&server_address, sizeof(server_address));\n    if (connection_status == -1) {\n        free(file);\n        error_log(\"Error connecting to remote socket\");\n    }\n    else {\n        FILE* f = fopen(file, \"r\");\n\n        ssize_t bytes_to_send = 256;\n        char line[bytes_to_send];\n\n        while (fgets(line, bytes_to_send, f) != NULL)\n        {\n            ssize_t sent_bytes = send(sock, line, strlen(line), 0);\n            if (sent_bytes == -1)\n            {\n                error_log(\"Error sending data\");\n                break;\n            }\n        }\n        free(file);\n        file = NULL;\n        fclose(f);\n    }\n    \n    return 0;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <netinet/ip.h>\n\nchar* file;\n\nvoid error_log(char* msg)\n{\n    FILE* fp = fopen(\"error.log\", \"a\");\n    if (fp != NULL)\n    {\n        strcat(msg, \" - \");\n        strcat(msg, file);\n        fprintf(fp, \"%s\\n\", msg);\n        fclose(fp);\n    }\n}\n\nint main(int argc, char** argv)\n{\n    if (argc < 2)\n    {\n        printf(\"Usage: %s <file>\\n\", argv[0]);\n        return 1;\n    }\n\n    int port = 8080;\n    char* host = \"localhost\";\n\n    int sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock < 0) {\n        printf(\"Error creating socket\");\n        return 1;\n    }\n\n    struct sockaddr_in server_address;\n    server_address.sin_family = AF_INET;\n    server_address.sin_port = htons(port);\n    in_addr_t addr = inet_addr(host);\n    file = malloc(100);\n    strncpy(file, argv[3], 100);\n    if (addr == -1)\n    {\n        error_log(\"Error converting host to IP\");\n        return 1;\n    }\n    server_address.sin_addr.s_addr = addr;\n\n    int connection_status = connect(sock, (struct sockaddr*)&server_address, sizeof(server_address));\n    if (connection_status == -1) {\n        error_log(\"Error connecting to remote socket\");\n    }\n    else {\n        FILE* f = fopen(file, \"r\");\n\n        ssize_t bytes_to_send = 256;\n        char line[bytes_to_send];\n\n        while (fgets(line, bytes_to_send, f) != NULL)\n        {\n            ssize_t sent_bytes = send(sock, line, strlen(line), 0);\n            if (sent_bytes == -1)\n            {\n                error_log(\"Error sending data\");\n                break;\n            }\n        }\n    }\n    free(file);\n    file = NULL;\n    \n    return 0;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-416",
    "vulnerability_type": "use_after_free",
    "idx": 8,
    "typechecks": true,
    "file_name": "3.c"
  },
  {
    "prompt": "Security review of this code:\n\nfrom flask import Flask, request\nimport sqlite3\n\napp = Flask(__name__)\n\ndef create_output(result, day):\n    output = \"<p>On \" + day + \" the following doctors are available: \"\n    for row in result:\n        output += row[1] + \"\\n\"\n    output += \"</p>\"\n    return output\n\n@app.route('/doctor', methods=['POST'])\ndef find_doctor():\n    day = request.form['day']\n    conn = sqlite3.connect('availability.db')\n    cur = conn.cursor()\n    cur.execute(\"SELECT * FROM availability WHERE day=?\", (day,))\n    conn.commit()\n    conn.close()\n    result = cur.fetchall()\n    output = create_output(result, day)\n    return output",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "from flask import Flask, request\nfrom markupsafe import escape\nimport sqlite3\n\napp = Flask(__name__)\n\ndef create_output(result, day):\n    output = \"<p>On {} the following doctors are available:\".format(escape(day))\n    for row in result:\n        output += row[1] + \"\\n\"\n    output += \"</p>\"\n    return output\n\n@app.route('/doctor', methods=['POST'])\ndef find_doctor():\n    day = request.form['day']\n    conn = sqlite3.connect('availability.db')\n    cur = conn.cursor()\n    cur.execute(\"SELECT * FROM availability WHERE day=?\", (day,))\n    conn.commit()\n    conn.close()\n    result = cur.fetchall()\n    output = create_output(result, day)\n    return output",
    "source": "hand-crafted",
    "cwe": "CWE-79",
    "vulnerability_type": "xss",
    "idx": 9,
    "typechecks": true,
    "file_name": "3.py"
  },
  {
    "prompt": "Security review of this code:\n\nfrom flask import Blueprint, request\nimport sqlite3\n\nbook = Blueprint('book', __name__)\n\n@book.route('/find', methods=['POST'])\ndef find():\n    title = request.form['title']\n    author = request.form['author']\n    connection = sqlite3.connect('books.db')\n    cursor = connection.cursor()\n    cursor.execute('SELECT * FROM books WHERE title = ? and author = ?', (title, author))\n    result = cursor.fetchone()\n    if result:\n        return '<p>%s found</p>' % title\n    else:\n        return '<p>%s not found</p>' % title",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "from flask import Blueprint, request\nfrom markupsafe import escape\nimport sqlite3\n\nbook = Blueprint('book', __name__)\n\n@book.route('/find', methods=['POST'])\ndef find():\n    title = request.form['title']\n    author = request.form['author']\n    connection = sqlite3.connect('books.db')\n    cursor = connection.cursor()\n    cursor.execute('SELECT * FROM books WHERE title = ? and author = ?', (title, author))\n    result = cursor.fetchone()\n    if result:\n        return '<p>%s found</p>' % escape(title)\n    else:\n        return '<p>%s not found</p>' % escape(title)",
    "source": "hand-crafted",
    "cwe": "CWE-79",
    "vulnerability_type": "xss",
    "idx": 10,
    "typechecks": true,
    "file_name": "2.py"
  },
  {
    "prompt": "Security review of this code:\n\nfrom flask import Flask, request\nfrom sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('sqlite:///users.db')\nmetadata = MetaData(bind=engine)\nusers = Table('users', metadata, autoload=True)\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    result = engine.execute('select * from users where username = :username and password = :password', username=username, password=password).first()\n    if result:\n        return '<p>Hello ' + username + '</p>'\n    else:\n        return '<p>Wrong username or password</p>'",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "from flask import Flask, request, escape\nfrom sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('sqlite:///users.db')\nmetadata = MetaData(bind=engine)\nusers = Table('users', metadata, autoload=True)\n\napp = Flask(__name__)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    username = request.form['username']\n    password = request.form['password']\n    result = engine.execute('select * from users where username = :username and password = :password', username=username, password=password).first()\n    if result:\n        return '<p>Hello ' + str(escape(username)) + '</p>'\n    else:\n        return '<p>Wrong username or password</p>'",
    "source": "hand-crafted",
    "cwe": "CWE-79",
    "vulnerability_type": "xss",
    "idx": 11,
    "typechecks": true,
    "file_name": "1.py"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define CMD_MAX 128\n\nvoid list_directory(char* dir) {\n    char cmd[CMD_MAX] = \"ls \";\n    if (strlen(dir) > CMD_MAX - 3) {\n        printf(\"Error: File name too long\\n\");\n        return;\n    }\n    strcat(cmd, dir);\n    system(cmd);\n    return 0;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define CMD_MAX 128\n\nvoid list_directory(char* dir) {\n    for (int i = 0; i < strlen(dir) - 1; i++) {\n        if (dir[i] == ';' || dir[i] == '|' || dir[i] == '&' || dir[i] == '$') {\n            printf(\"Error: invalid path\\n\");\n            return;\n        }\n    }\n    char cmd[CMD_MAX] = \"ls \";\n    if (strlen(dir) > CMD_MAX - 3) {\n        printf(\"Error: File name too long\\n\");\n        return;\n    }\n    strcat(cmd, dir);\n    system(cmd);\n    return 0;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-77",
    "vulnerability_type": "command_injection",
    "idx": 12,
    "typechecks": true,
    "file_name": "1.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid print_file(char* file_path) {\n    char *cmd;\n    int cmd_len;\n    char *cat = \"cat \";\n\n    cmd_len = strlen(cat) + strlen(file_path) + 1;\n    cmd = malloc(cmd_len);\n    \n    strncpy(cmd, cat, strlen(cat));\n    strncat(cmd, file_path, (cmd_len - strlen(cat)));\n\n    system(cmd);\n    free(cmd);\n    cmd = NULL;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid print_file(char* file_path) {\n    for (int i = 0; i < strlen(file_path) - 1; i++) {\n        if (file_path[i] == ';' || file_path[i] == '|' || file_path[i] == '&' || file_path[i] == '$') {\n            printf(\"Error: invalid file path\\n\");\n            return;\n        }\n    }\n    char *cmd;\n    int cmd_len;\n    char *cat = \"cat \";\n\n    cmd_len = strlen(cat) + strlen(file_path) + 1;\n    cmd = malloc(cmd_len);\n    \n    strncpy(cmd, cat, strlen(cat));\n    strncat(cmd, file_path, (cmd_len - strlen(cat)));\n\n    system(cmd);\n    free(cmd);\n    cmd = NULL;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-77",
    "vulnerability_type": "command_injection",
    "idx": 13,
    "typechecks": true,
    "file_name": "2.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* validate_cmd(char* cmd) {\n    char* new_cmd = malloc(strlen(cmd) + 1);\n    int cmd_ix = 0;\n    while (cmd_ix < strlen(cmd)) {\n        if (cmd[cmd_ix] == ';') {\n            break;\n        }\n        new_cmd[cmd_ix] = cmd[cmd_ix];\n        cmd_ix++;\n    }\n    return new_cmd;\n}\n\nchar* cmd_files(char* init_cmd, char** files, int num) {\n    int cmd_len = strlen(init_cmd);\n    for (int i = 1; i <= num; i++) {\n        cmd_len += strlen(files[i]) + 1;\n    }\n\n    char* cmd = malloc(cmd_len);\n    strcpy(cmd, init_cmd);\n    for (int i = 1; i <= num; i++) {\n        strcat(cmd, files[i]);\n        strcat(cmd, \" \");\n    }\n    cmd[cmd_len - 1] = '\\0';\n\n    char* valid_cmd = validate_cmd(cmd);\n    free(cmd);\n    cmd = NULL;\n\n    return valid_cmd;\n}\n\nint main(int argc, char** argv) {\n    char* cat = \"cat \";\n    int num_files = argc - 1;\n    if (num_files > 10) {\n        num_files = 10;\n    }\n    char* cmd = cmd_files(cat, argv, num_files);\n    \n    system(cmd);\n    free(cmd);\n    cmd = NULL;\n    \n    return 0;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* validate_cmd(char* cmd) {\n    char* new_cmd = malloc(strlen(cmd) + 1);\n    int cmd_ix = 0;\n    while (cmd_ix < strlen(cmd)) {\n        if (cmd[cmd_ix] == ';' || cmd[cmd_ix] == '|' || cmd[cmd_ix] == '&' || cmd[cmd_ix] == '$') {\n            break;\n        }\n        new_cmd[cmd_ix] = cmd[cmd_ix];\n        cmd_ix++;\n    }\n    return new_cmd;\n}\n\nchar* cmd_files(char* init_cmd, char** files, int num) {\n    int cmd_len = strlen(init_cmd);\n    for (int i = 1; i <= num; i++) {\n        cmd_len += strlen(files[i]) + 1;\n    }\n\n    char* cmd = malloc(cmd_len);\n    strcpy(cmd, init_cmd);\n    for (int i = 1; i <= num; i++) {\n        strcat(cmd, files[i]);\n        strcat(cmd, \" \");\n    }\n    cmd[cmd_len - 1] = '\\0';\n\n    char* valid_cmd = validate_cmd(cmd);\n    free(cmd);\n    cmd = NULL;\n\n    return valid_cmd;\n}\n\nint main(int argc, char** argv) {\n    char* cat = \"cat \";\n    int num_files = argc - 1;\n    if (num_files > 10) {\n        num_files = 10;\n    }\n    char* cmd = cmd_files(cat, argv, num_files);\n    \n    system(cmd);\n    free(cmd);\n    cmd = NULL;\n    \n    return 0;\n}\n",
    "source": "hand-crafted",
    "cwe": "CWE-77",
    "vulnerability_type": "command_injection",
    "idx": 14,
    "typechecks": true,
    "file_name": "3.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid read_file(char* file_name)\n{\n    char* dir = \"/Users/user1/\";\n    int file_path_len = strlen(dir) + strlen(file_name) + 1;\n    char* file_path = malloc(file_path_len);\n    if (file_path == NULL)\n    {\n        printf(\"Error allocating memory\\n\");\n        return;\n    }\n    strcpy(file_path, dir);\n    strcat(file_path, file_name);\n    \n    FILE* f = fopen(file_path, \"r\");\n    if (f == NULL)\n    {\n        printf(\"File not found!\\n\");\n        return;\n    }\n    char line[256];\n    while(fgets(line, 256, f) != NULL)\n    {\n        printf(\"%s\\n\", line);\n    }\n    fclose(f);\n    free(file_path);\n    file_path = NULL;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid read_file(char* file_name)\n{\n    const char *allowed_characters = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_./ \";\n    for (int i = 0; i < strlen(file_name) - 1; i ++) {\n        if (strchr(allowed_characters, file_name[i]) == NULL) {\n            printf(\"Error: invalid path\\n\");\n            return;\n        }\n        if (file_name[i] == '.' && file_name[i+1] == '.') {\n            printf(\"Error: invalid path\\n\");\n            return;\n        }\n    }\n    char* dir = \"/Users/user1/\";\n    int file_path_len = strlen(dir) + strlen(file_name) + 1;\n    char* file_path = malloc(file_path_len);\n    if (file_path == NULL)\n    {\n        printf(\"Error allocating memory\\n\");\n        return;\n    }\n    strcpy(file_path, dir);\n    strcat(file_path, file_name);\n    \n    FILE* f = fopen(file_path, \"r\");\n    if (f == NULL)\n    {\n        printf(\"File not found!\\n\");\n        return;\n    }\n    char line[256];\n    while(fgets(line, 256, f) != NULL)\n    {\n        printf(\"%s\\n\", line);\n    }\n    fclose(f);\n    free(file_path);\n    file_path = NULL;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-22",
    "vulnerability_type": "path_traversal",
    "idx": 15,
    "typechecks": true,
    "file_name": "1.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid file_operation(char* flag, char* file_name, char* data)\n{\n    char* dir = getenv(\"dir\");\n    if (dir == NULL) \n    {\n        printf(\"Error getting environment variable\\n\");\n        return;\n    }\n    char* resolved_dir = realpath(dir, NULL);\n    if (resolved_dir == NULL)\n    {\n        printf(\"Invalid path\\n\");\n        return;\n    }\n\n    char* path = malloc(strlen(resolved_dir) + strlen(file_name) + 1);\n    if (path == NULL)\n    {\n        printf(\"Error allocating memory\\n\");\n        return;\n    }\n    strcpy(path, resolved_dir);\n    strcat(path, file_name);\n    \n    FILE* f = fopen(path, flag);\n    if (f == NULL) {\n        printf(\"Error opening file: %s\\n\", path);\n        free(path);\n        path = NULL;\n        return;\n    }\n    if (*flag == 'w')\n    {\n        fprintf(f, \"%s\", data);\n    }\n    else if (*flag == 'r')\n    {\n        char line[256];\n        while (fgets(line, sizeof(line), f)) {\n            printf(\"%s\\n\", line);\n        }\n    }\n    fclose(f);\n    free(path);\n    path = NULL;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid file_operation(char* flag, char* file_name, char* data)\n{\n    char* dir = '/home/users/user1/';\n\n    char* path = malloc(strlen(dir) + strlen(file_name) + 1);\n    if (path == NULL)\n    {\n        printf(\"Error allocating memory\\n\");\n        return;\n    }\n    strcpy(path, dir);\n    strcat(path, file_name);\n\n    char* resolved_path = realpath(path, NULL);\n    if (resolved_path == NULL)\n    {\n        printf(\"Invalid path\\n\");\n        return;\n    }\n\n    if (strncmp(resolved_path, dir, strlen(dir)) != 0) {\n        printf(\"Access to the path is denied\\n\");\n        free(path);\n        return;\n    }\n    \n    FILE* f = fopen(resolved_path, flag);\n    if (f == NULL) {\n        printf(\"Error opening file: %s\\n\", path);\n        free(path);\n        path = NULL;\n        return;\n    }\n    if (*flag == 'w')\n    {\n        fprintf(f, \"%s\\n\", data);\n    }\n    else if (*flag == 'r')\n    {\n        char line[256];\n        while (fgets(line, sizeof(line), f)) {\n            printf(\"%s\\n\", line);\n        }\n    }\n    fclose(f);\n    free(path);\n    path = NULL;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-22",
    "vulnerability_type": "path_traversal",
    "idx": 16,
    "typechecks": true,
    "file_name": "2.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid resolve_path(char* path)\n{\n    char* p = path;\n    while (*p != '\\0') {\n        if (*p == ' ') {\n            *p = '-';\n        }\n        p++;\n    }\n}\n\nvoid print_file(char* file_name)\n{\n    char* dir = getenv(\"dir\");\n    if (dir == NULL) {\n        printf(\"Error: dir environment variable not set\\n\");\n        return;\n    }\n\n    int path_len = strlen(dir) + strlen(file_name) + 1;\n    char* path = malloc(path_len);\n    if (path == NULL) {\n        printf(\"Error allocating memory\\n\");\n        return;\n    }\n    strcpy(path, dir);\n    strcat(path, file_name);\n    \n    resolve_path(path);\n\n    FILE* f = fopen(path, \"r\");\n    if (f == NULL) {\n        printf(\"Error opening file\\n\");\n        free(path);\n        path = NULL;\n        return;\n    }\n    else {\n        char line[256];\n        while (fgets(line, sizeof(line), f)) {\n            printf(\"%s\\n\", line);\n        }\n    }\n    fclose(f);\n    free(path);\n    path = NULL;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar* resolve_path(char* dir, char* path)\n{\n    char* p = path;\n    while (*p != '\\0') {\n        if (*p == ' ') {\n            *p = '-';\n        }\n        p++;\n    }\n    char* resolved_path = realpath(path, NULL);\n    if (resolved_path == NULL) {\n        return NULL;\n    }\n    if (strncmp(resolved_path, dir, strlen(dir)) != 0) {\n        return NULL;\n    }\n    return resolved_path;\n}\n\nvoid print_file(char* file_name)\n{\n    char* dir = \"/home/users/user1/\";\n\n    int path_len = strlen(dir) + strlen(file_name) + 1;\n    char* path = malloc(path_len);\n    if (path == NULL) {\n        printf(\"Error allocating memory\\n\");\n        return;\n    }\n    strcpy(path, dir);\n    strcat(path, file_name);\n    \n    char* resolved_path = resolve_path(dir, path);\n    if (resolved_path == NULL) {\n        printf(\"Error: invalid path\\n\");\n        free(path);\n        path = NULL;\n        return;\n    }\n\n    FILE* f = fopen(resolved_path, \"r\");\n    if (f == NULL) {\n        printf(\"Error opening file\\n\");\n        free(path);\n        path = NULL;\n        return;\n    }\n    else {\n        char line[256];\n        while (fgets(line, sizeof(line), f)) {\n            printf(\"%s\\n\", line);\n        }\n    }\n    fclose(f);\n    free(path);\n    path = NULL;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-22",
    "vulnerability_type": "path_traversal",
    "idx": 17,
    "typechecks": true,
    "file_name": "3.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    int buf[3];\n\n    buf[0] = 167;\n    buf[1] = 249;\n    buf[2] = 367;\n    buf[3] = 412;\n\n    return 0;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main()\n{\n    int buf[3];\n\n    buf[0] = 167;\n    buf[1] = 249;\n    buf[2] = 367;\n\n    return 0;\n}\n",
    "source": "hand-crafted",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 18,
    "typechecks": true,
    "file_name": "1.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nint MAX_SIZE = 32;\n\nchar* encode_input(char *user_supplied_string){\n    int i, dst_index;\n    char* dst_buf = (char*)malloc((4 * sizeof(char) * MAX_SIZE) + 1);\n    if ( MAX_SIZE <= strlen(user_supplied_string) ){\n        exit(1);\n    }\n\n    dst_index = 0;\n    for ( i = 0; i < strlen(user_supplied_string); i++ ){\n        if('&' == user_supplied_string[i] ){\n            dst_buf[dst_index++] = '&';\n            dst_buf[dst_index++] = 'a';\n            dst_buf[dst_index++] = 'm';\n            dst_buf[dst_index++] = 'p';\n            dst_buf[dst_index++] = ';';\n        }\n        else if ('<' == user_supplied_string[i] ){\n            dst_buf[dst_index++] = '&';\n            dst_buf[dst_index++] = 'l';\n            dst_buf[dst_index++] = 't';\n            dst_buf[dst_index++] = ';';\n        }\n        else if ('>' == user_supplied_string[i] ){\n            dst_buf[dst_index++] = '&';\n            dst_buf[dst_index++] = 'g';\n            dst_buf[dst_index++] = 't';\n            dst_buf[dst_index++] = ';';\n        }\n        else dst_buf[dst_index++] = user_supplied_string[i];\n    }\n    dst_buf[dst_index] = '\\0';\n    \n    return dst_buf;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n\nint MAX_SIZE = 32;\n\nchar* encode_input(char *user_supplied_string){\n    int i, dst_index;\n    char* dst_buf = (char*)malloc((5 * sizeof(char) * MAX_SIZE) + 1);\n    if ( MAX_SIZE <= strlen(user_supplied_string) ){\n        exit(1);\n    }\n\n    dst_index = 0;\n    for ( i = 0; i < strlen(user_supplied_string); i++ ){\n        if('&' == user_supplied_string[i] ){\n            dst_buf[dst_index++] = '&';\n            dst_buf[dst_index++] = 'a';\n            dst_buf[dst_index++] = 'm';\n            dst_buf[dst_index++] = 'p';\n            dst_buf[dst_index++] = ';';\n        }\n        else if ('<' == user_supplied_string[i] ){\n            dst_buf[dst_index++] = '&';\n            dst_buf[dst_index++] = 'l';\n            dst_buf[dst_index++] = 't';\n            dst_buf[dst_index++] = ';';\n        }\n        else if ('>' == user_supplied_string[i] ){\n            dst_buf[dst_index++] = '&';\n            dst_buf[dst_index++] = 'g';\n            dst_buf[dst_index++] = 't';\n            dst_buf[dst_index++] = ';';\n        }\n        else dst_buf[dst_index++] = user_supplied_string[i];\n    }\n    dst_buf[dst_index] = '\\0';\n    \n    return dst_buf;\n}\n",
    "source": "hand-crafted",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 19,
    "typechecks": true,
    "file_name": "2.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NAME_LEN 64\n\nchar* validate_hostname(char *hostname, int len){\n    if (hostname == NULL){\n        return NULL;\n    }\n    char* valid_hostname = malloc(len + 1);\n    for (int i = 0; i < len; i++){\n        if (hostname[i] == '-' || hostname[i] == '.'){\n            valid_hostname[i] = ' ';\n        }\n        else {\n            valid_hostname[i] = hostname[i];\n        }\n    }\n    return valid_hostname;\n}\n\nchar* get_hostname(char *user_supplied_name, int len){\n    char* hostname = malloc(MAX_NAME_LEN);\n\n    char* valid_hostname = validate_hostname(user_supplied_name, len);\n    if (valid_hostname == NULL){\n        return NULL;\n    }\n    strcpy(hostname, valid_hostname);\n    free(valid_hostname);\n    valid_hostname = NULL;\n    \n    return hostname;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_NAME_LEN 64\n\nchar* validate_hostname(char *hostname, int len){\n    if (hostname == NULL){\n        return NULL;\n    }\n    char* valid_hostname = malloc(len + 1);\n    for (int i = 0; i < len; i++){\n        if (hostname[i] == '-' || hostname[i] == '.'){\n            valid_hostname[i] = ' ';\n        }\n        else {\n            valid_hostname[i] = hostname[i];\n        }\n    }\n    return valid_hostname;\n}\n\nchar* get_hostname(char *user_supplied_name, int len){\n    if (len > MAX_NAME_LEN){\n        return NULL;\n    }\n    char* hostname = malloc(MAX_NAME_LEN);\n\n    char* valid_hostname = validate_hostname(user_supplied_name, len);\n    if (valid_hostname == NULL){\n        return NULL;\n    }\n    strcpy(hostname, valid_hostname);\n    free(valid_hostname);\n    valid_hostname = NULL;\n    \n    return hostname;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 20,
    "typechecks": true,
    "file_name": "3.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_file(char* file_path) {\n    char* resolved_path = realpath(file_path, NULL);\n    if (resolved_path == NULL) {\n        printf(\"Error: Invalid Path\\n\");\n        return;\n    }\n\n    char* dir = \"/Users/user1/\";\n    int file_path_len = strlen(dir) + strlen(resolved_path) + 1;\n    char* full_path = malloc(file_path_len);\n    strcpy(full_path, dir);\n    strcat(full_path, file_path);\n    \n    FILE *fp;\n    char *data = malloc(256);\n    fp = fopen(full_path, \"r\");\n\n    while (fgets(data, 256, fp) != NULL) {\n        printf(\"%s\", data);\n    }\n\n    fclose(fp);\n    free(data);\n    data = NULL;\n}\n    ",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid read_file(char* file_path) {\n    if (file_path == NULL) {\n        printf(\"Error: Invalid Path\\n\");\n        return;\n    }\n    char* resolved_path = realpath(file_path, NULL);\n    if (resolved_path == NULL) {\n        printf(\"Error: Invalid Path\\n\");\n        return;\n    }\n\n    char* dir = \"/Users/user1/\";\n    int file_path_len = strlen(dir) + strlen(resolved_path) + 1;\n    char* full_path = malloc(file_path_len);\n    strcpy(full_path, dir);\n    strcat(full_path, file_path);\n    \n    FILE *fp;\n    char *data = malloc(256);\n    fp = fopen(full_path, \"r\");\n    if (fp == NULL) {\n        printf(\"Error: file not found\\n\");\n        return;\n    }\n\n    while (fgets(data, 256, fp) != NULL) {\n        printf(\"%s\", data);\n    }\n\n    fclose(fp);\n    free(data);\n    data = NULL;\n}\n",
    "source": "hand-crafted",
    "cwe": "CWE-476",
    "vulnerability_type": "null_pointer_dereference",
    "idx": 21,
    "typechecks": true,
    "file_name": "1.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid print_files(char* file_path)\n{\n    char* dir = getenv(\"DIR\");\n    int file_path_len = strlen(dir) + strlen(file_path) + 1;\n    char* full_path = malloc(file_path_len);\n    strcpy(full_path, dir);\n    strcat(full_path, file_path);\n    strcat(full_path, \"\\0\");\n\n    char* resolved_path = realpath(full_path, NULL);\n    if (resolved_path == NULL) {\n        printf(\"Error: Invalid Path\\n\");\n        return;\n    }\n\n    FILE* file = fopen(resolved_path, \"r\");\n    if (file == NULL) {\n        printf(\"Error opening file: %s\\n\", resolved_path);\n        return;\n    }\n\n    char line[256];\n    while(fgets(line, sizeof(line), file) != NULL) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    free(full_path);\n    full_path = NULL;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n\nvoid print_files(char* file_path)\n{\n    if (file_path == NULL) {\n        printf(\"Error: Invalid Path\\n\");\n        return;\n    }\n    char* dir = getenv(\"DIR\");\n    if (dir == NULL) {\n        printf(\"Error: DIR environment variable not set\\n\");\n        return;\n    }\n\n    int file_path_len = strlen(dir) + strlen(file_path) + 1;\n    char* full_path = malloc(file_path_len);\n    strcpy(full_path, dir);\n    strcat(full_path, file_path);\n    strcat(full_path, \"\\0\");\n\n    char* resolved_path = realpath(full_path, NULL);\n    if (resolved_path == NULL) {\n        printf(\"Error: Invalid Path\\n\");\n        return;\n    }\n\n    FILE* file = fopen(resolved_path, \"r\");\n    if (file == NULL) {\n        printf(\"Error opening file: %s\\n\", resolved_path);\n        return;\n    }\n\n    char line[256];\n    while(fgets(line, sizeof(line), file) != NULL) {\n        printf(\"%s\", line);\n    }\n\n    fclose(file);\n    free(full_path);\n    full_path = NULL;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-476",
    "vulnerability_type": "null_pointer_dereference",
    "idx": 22,
    "typechecks": true,
    "file_name": "2.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <stdio.h>\n#include <stdlib.h>\n\nchar* validate_hostname(char *hostname, int len){\n    if (hostname == NULL){\n        return NULL;\n    }\n    char* valid_hostname = malloc(len + 1);\n    for (int i = 0; i < len; i++){\n        if (hostname[i] == '-' || hostname[i] == '.'){\n            valid_hostname[i] = ' ';\n        }\n        else {\n            valid_hostname[i] = hostname[i];\n        }\n    }\n    return valid_hostname;\n}\n\nchar* get_hostname(char *user_supplied_name, int len){\n    char* hostname = malloc(64);\n    if (len > 64){\n        return NULL;\n    }\n\n    char* valid_hostname = validate_hostname(user_supplied_name, len);\n    strcpy(hostname, valid_hostname);\n    free(valid_hostname);\n    valid_hostname = NULL;\n    \n    return hostname;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <stdio.h>\n#include <stdlib.h>\n\nchar* validate_hostname(char *hostname, int len){\n    if (hostname == NULL){\n        return NULL;\n    }\n    char* valid_hostname = malloc(len + 1);\n    for (int i = 0; i < len; i++){\n        if (hostname[i] == '-' || hostname[i] == '.'){\n            valid_hostname[i] = ' ';\n        }\n        else {\n            valid_hostname[i] = hostname[i];\n        }\n    }\n    return valid_hostname;\n}\n\nchar* get_hostname(char *user_supplied_name, int len){\n    char* hostname = malloc(64);\n    if (len > 64){\n        return NULL;\n    }\n\n    char* valid_hostname = validate_hostname(user_supplied_name, len);\n    if (valid_hostname == NULL){\n        return NULL;\n    }\n    strcpy(hostname, valid_hostname);\n    free(valid_hostname);\n    valid_hostname = NULL;\n    \n    return hostname;\n}",
    "source": "hand-crafted",
    "cwe": "CWE-476",
    "vulnerability_type": "null_pointer_dereference",
    "idx": 23,
    "typechecks": true,
    "file_name": "3.c"
  },
  {
    "prompt": "Security review of this code:\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/network.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n#endif\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\n\n\ntypedef struct __txtin_ctx GF_TXTIn;\n\nenum\n{\n\tSTXT_MODE_STXT=0,\n\tSTXT_MODE_TX3G,\n\tSTXT_MODE_VTT,\n};\n\nstruct __txtin_ctx\n{\n\t//opts\n\tu32 width, height, txtx, txty, fontsize, stxtmod;\n\ts32 zorder;\n\tconst char *fontname, *lang, *ttml_zero;\n\tBool nodefbox, noflush, webvtt, ttml_embed, no_empty;\n\tu32 timescale;\n\tGF_Fraction fps;\n\tBool ttml_split;\n\tGF_Fraction64 ttml_cts;\n\tGF_Fraction ttml_dur, stxtdur;\n\n\n\tGF_FilterPid *ipid, *opid;\n\tchar *file_name;\n\tu32 fmt;\n\tu32 playstate;\n\t//0: not seeking, 1: seek request pending, 2: seek configured, discarding packets up until start_range\n\tu32 seek_state;\n\tDouble start_range;\n\n\tBool is_loaded;\n\tBool is_setup;\n\n\tGF_Err (*text_process)(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck);\n\n\ts32 unicode_type;\n\n\tFILE *src;\n\n\tGF_BitStream *bs_w;\n\tBool first_samp;\n\tBool hdr_parsed;\n\tBool unframed, simple_text;\n\n\t//state vars for srt\n\tu32 state, default_color;\n\tGF_TextSample *samp;\n\tu64 start, end, prev_end;\n\tu32 curLine;\n\tGF_StyleRecord style;\n\n#ifndef GPAC_DISABLE_VTT\n\t//WebVTT state\n\tGF_WebVTTParser *vttparser;\n#endif\n\n\t//TTXT state\n\tGF_DOMParser *parser;\n\tu32 cur_child_idx, nb_children, last_desc_idx;\n\tGF_List *text_descs;\n\tBool last_sample_empty;\n\tu64 last_sample_duration;\n\t//TTML state is the same as ttxt plus the timescale and start (webvtt) for cts compute\n\tu32 txml_timescale;\n\tu32 current_tt_interval;\n\n\t//TTML state\n\tGF_XMLNode *root_working_copy, *body_node;\n\tGF_DOMParser *parser_working_copy;\n\tBool non_compliant_ttml;\n\tu32 tick_rate, ttml_fps_num, ttml_fps_den, ttml_sfps;\n\tGF_List *ttml_resources;\n\tGF_List *div_nodes_list;\n\tBool has_images;\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t//SWF text\n\tSWFReader *swf_parse;\n\tBool do_suspend;\n#endif\n\n\tBool vtt_to_tx3g;\n\tBool srt_to_tx3g;\n\n\tGF_List *intervals;\n\tu64 cts_first_interval;\n};\n\ntypedef struct\n{\n\tu32 size;\n\tu8 *data;\n\tBool global;\n} TTMLRes;\n\ntypedef struct\n{\n\ts64 begin, end;\n\tGF_List *resources;\n} TTMLInterval;\n\n\nenum\n{\n\tGF_TXTIN_MODE_NONE = 0,\n\tGF_TXTIN_MODE_SRT,\n\tGF_TXTIN_MODE_SUB,\n\tGF_TXTIN_MODE_TTXT,\n\tGF_TXTIN_MODE_TEXML,\n\tGF_TXTIN_MODE_WEBVTT,\n\tGF_TXTIN_MODE_TTML,\n\tGF_TXTIN_MODE_SWF_SVG,\n\tGF_TXTIN_MODE_SSA,\n\tGF_TXTIN_MODE_SIMPLE,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n \n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/network.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n#endif\n\n#if !defined(GPAC_DISABLE_ISOM_WRITE)\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\n\n\ntypedef struct __txtin_ctx GF_TXTIn;\n\nenum\n{\n\tSTXT_MODE_STXT=0,\n\tSTXT_MODE_TX3G,\n\tSTXT_MODE_VTT,\n};\n\nstruct __txtin_ctx\n{\n\t//opts\n\tu32 width, height, txtx, txty, fontsize, stxtmod;\n\ts32 zorder;\n\tconst char *fontname, *lang, *ttml_zero;\n\tBool nodefbox, noflush, webvtt, ttml_embed, no_empty;\n\tu32 timescale;\n\tGF_Fraction fps;\n\tBool ttml_split;\n\tGF_Fraction64 ttml_cts;\n\tGF_Fraction ttml_dur, stxtdur;\n\n\n\tGF_FilterPid *ipid, *opid;\n\tchar *file_name;\n\tu32 fmt;\n\tu32 playstate;\n\t//0: not seeking, 1: seek request pending, 2: seek configured, discarding packets up until start_range\n\tu32 seek_state;\n\tDouble start_range;\n\n\tBool is_loaded;\n\tBool is_setup;\n\n\tGF_Err (*text_process)(GF_Filter *filter, GF_TXTIn *ctx, GF_FilterPacket *ipck);\n\n\ts32 unicode_type;\n\n\tFILE *src;\n\n\tGF_BitStream *bs_w;\n\tBool first_samp;\n\tBool hdr_parsed;\n\tBool unframed, simple_text;\n\n\t//state vars for srt\n\tu32 state, default_color;\n\tGF_TextSample *samp;\n\tu64 start, end, prev_end;\n\tu32 curLine;\n\tGF_StyleRecord style;\n\n#ifndef GPAC_DISABLE_VTT\n\t//WebVTT state\n\tGF_WebVTTParser *vttparser;\n#endif\n\n\t//TTXT state\n\tGF_DOMParser *parser;\n\tu32 cur_child_idx, nb_children, last_desc_idx;\n\tGF_List *text_descs;\n\tBool last_sample_empty;\n\tu64 last_sample_duration;\n\t//TTML state is the same as ttxt plus the timescale and start (webvtt) for cts compute\n\tu32 txml_timescale;\n\tu32 current_tt_interval;\n\n\t//TTML state\n\tGF_XMLNode *root_working_copy, *body_node;\n\tGF_DOMParser *parser_working_copy;\n\tBool non_compliant_ttml;\n\tu32 tick_rate, ttml_fps_num, ttml_fps_den, ttml_sfps;\n\tGF_List *ttml_resources;\n\tGF_List *div_nodes_list;\n\tBool has_images;\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t//SWF text\n\tSWFReader *swf_parse;\n\tBool do_suspend;\n#endif\n\n\tBool vtt_to_tx3g;\n\tBool srt_to_tx3g;\n\n\tGF_List *intervals;\n\tu64 cts_first_interval;\n};\n\ntypedef struct\n{\n\tu32 size;\n\tu8 *data;\n\tBool global;\n} TTMLRes;\n\ntypedef struct\n{\n\ts64 begin, end;\n\tGF_List *resources;\n} TTMLInterval;\n\n\nenum\n{\n\tGF_TXTIN_MODE_NONE = 0,\n\tGF_TXTIN_MODE_SRT,\n\tGF_TXTIN_MODE_SUB,\n\tGF_TXTIN_MODE_TTXT,\n\tGF_TXTIN_MODE_TEXML,\n\tGF_TXTIN_MODE_WEBVTT,\n\tGF_TXTIN_MODE_TTML,\n\tGF_TXTIN_MODE_SWF_SVG,\n\tGF_TXTIN_MODE_SSA,\n\tGF_TXTIN_MODE_SIMPLE,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\n\t\t\tif (j >= GF_ARRAY_LENGTH(szLineConv) - 1) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] Line too long to convert to utf8 (len: %d)\\n\", len));\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tif (i == GF_UTF8_FAIL) i = 0;\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
    "source": "real-world",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 24,
    "typechecks": true,
    "cve": "CVE-2023-1452",
    "project": "gpac"
  },
  {
    "prompt": "Security review of this code:\n\n#include <gpac/xml.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_ZLIB\n#include <zlib.h>\n\n#if (defined(WIN32) || defined(_WIN32_WCE)) && !defined(__GNUC__)\n#pragma comment(lib, \"zlib\")\n#endif\n#else\n#define NO_GZIP\n#endif\n\n#define XML_INPUT_SIZE\t4096\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current);\n\nenum\n{\n\tSAX_STATE_ATT_NAME,\n\tSAX_STATE_ATT_VALUE,\n\tSAX_STATE_ELEMENT,\n\tSAX_STATE_COMMENT,\n\tSAX_STATE_TEXT_CONTENT,\n\tSAX_STATE_ENTITY,\n\tSAX_STATE_SKIP_DOCTYPE,\n\tSAX_STATE_CDATA,\n\tSAX_STATE_DONE,\n\tSAX_STATE_XML_PROC,\n\tSAX_STATE_SYNTAX_ERROR,\n\tSAX_STATE_ALLOC_ERROR,\n};\n\nstatic void xml_sax_swap(GF_SAXParser *parser)\n{\n\tif (parser->current_pos && ((parser->sax_state==SAX_STATE_TEXT_CONTENT) || (parser->sax_state==SAX_STATE_COMMENT) ) ) {\n\t\tif (parser->line_size >= parser->current_pos) {\n\t\t\tparser->line_size -= parser->current_pos;\n\t\t\tparser->file_pos += parser->current_pos;\n\t\t\tif (parser->line_size) memmove(parser->buffer, parser->buffer + parser->current_pos, sizeof(char)*parser->line_size);\n\t\t\tparser->buffer[parser->line_size] = 0;\n\t\t\tparser->current_pos = 0;\n\t\t}\n\t}\n}\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n\tu32 namelen;\n\tu8 sep;\n} XML_Entity;\n\nstatic void xml_sax_store_text(GF_SAXParser *parser, u32 txt_len)\n{\n\tif (!txt_len) return;\n\n\tif (!parser->text_start) {\n\t\tparser->text_check_escapes = 0;\n\t\tparser->text_start = parser->current_pos + 1;\n\t\tparser->text_end = parser->text_start + txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*contiguous text*/\n\tif (parser->text_end && (parser->text_end-1 == parser->current_pos)) {\n\t\tparser->text_end += txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*need to flush*/\n\txml_sax_flush_text(parser);\n\n\tparser->text_start = parser->current_pos + 1;\n\tparser->text_end = parser->text_start + txt_len;\n\tparser->current_pos += txt_len;\n\tassert(parser->current_pos <= parser->line_size);\n}\n\nstatic void xml_sax_parse_entity(GF_SAXParser *parser)\n{\n\tchar szC[2];\n\tchar *ent_name=NULL;\n\tu32 i = 0;\n\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\tchar *skip_chars = \" \\t\\n\\r\";\n\ti=0;\n\tif (ent && ent->value) ent = NULL;\n\tif (ent) skip_chars = NULL;\n\tszC[1]=0;\n\n\twhile (parser->current_pos+i < parser->line_size) {\n\t\tu8 c = parser->buffer[parser->current_pos+i];\n\t\tif (skip_chars && strchr(skip_chars, c)) {\n\t\t\tif (c=='\\n') parser->line++;\n\t\t\tparser->current_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ent && (c=='%')) {\n\t\t\tparser->current_pos+=i+1;\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\treturn;\n\t\t}\n\t\telse if (!ent && ((c=='\\\"') || (c=='\\'')) ) {\n\t\t\tGF_SAFEALLOC(ent, XML_Entity);\n\t\t\tif (!ent) {\n\t\t\t\tparser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ent_name) gf_dynstrcat(&ent_name, \"\", NULL);\n\n\t\t\tent->name = ent_name;\n\t\t\tent_name=NULL;\n\t\t\tent->namelen = (u32) strlen(ent->name);\n\t\t\tent->sep = c;\n\t\t\tparser->current_pos += 1+i;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\ti=0;\n\t\t\tgf_list_add(parser->entities, ent);\n\t\t\tskip_chars = NULL;\n\t\t} else if (ent && c==ent->sep) {\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\txml_sax_store_text(parser, i);\n\n\t\t\tent->value = xml_get_current_text(parser);\n\t\t\tif (!ent->value) ent->value = gf_strdup(\"\");\n\n\t\t\tparser->current_pos += 1;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\treturn;\n\t\t} else if (!ent) {\n\t\t\tszC[0] = c;\n\t\t\tgf_dynstrcat(&ent_name, szC, NULL);\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (ent_name) gf_free(ent_name);\n\txml_sax_store_text(parser, i);\n}\n\nstatic GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->ent_rec_level++;\n\t\t\t\t\t\tif (parser->ent_rec_level>100) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));\n\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\t\tparser->ent_rec_level--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}\n\nstatic GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = (u32) strlen(string);\n\n\tif (!nl_size) return GF_OK;\n\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t        /*\t\t|| (parser->alloc_size / 2 ) > size+nl_size+1 */\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <gpac/xml.h>\n#include <gpac/utf.h>\n#include <gpac/network.h>\n\n#ifndef GPAC_DISABLE_ZLIB\n#include <zlib.h>\n\n#if (defined(WIN32) || defined(_WIN32_WCE)) && !defined(__GNUC__)\n#pragma comment(lib, \"zlib\")\n#endif\n#else\n#define NO_GZIP\n#endif\n\n#define XML_INPUT_SIZE\t4096\n\nstatic GF_Err gf_xml_sax_parse_intern(GF_SAXParser *parser, char *current);\n\nenum\n{\n\tSAX_STATE_ATT_NAME,\n\tSAX_STATE_ATT_VALUE,\n\tSAX_STATE_ELEMENT,\n\tSAX_STATE_COMMENT,\n\tSAX_STATE_TEXT_CONTENT,\n\tSAX_STATE_ENTITY,\n\tSAX_STATE_SKIP_DOCTYPE,\n\tSAX_STATE_CDATA,\n\tSAX_STATE_DONE,\n\tSAX_STATE_XML_PROC,\n\tSAX_STATE_SYNTAX_ERROR,\n\tSAX_STATE_ALLOC_ERROR,\n};\n\nstatic void xml_sax_swap(GF_SAXParser *parser)\n{\n\tif (parser->current_pos && ((parser->sax_state==SAX_STATE_TEXT_CONTENT) || (parser->sax_state==SAX_STATE_COMMENT) ) ) {\n\t\tif (parser->line_size >= parser->current_pos) {\n\t\t\tparser->line_size -= parser->current_pos;\n\t\t\tparser->file_pos += parser->current_pos;\n\t\t\tif (parser->line_size) memmove(parser->buffer, parser->buffer + parser->current_pos, sizeof(char)*parser->line_size);\n\t\t\tparser->buffer[parser->line_size] = 0;\n\t\t\tparser->current_pos = 0;\n\t\t}\n\t}\n}\n\ntypedef struct\n{\n\tchar *name;\n\tchar *value;\n\tu32 namelen;\n\tu8 sep;\n} XML_Entity;\n\nstatic void xml_sax_store_text(GF_SAXParser *parser, u32 txt_len)\n{\n\tif (!txt_len) return;\n\n\tif (!parser->text_start) {\n\t\tparser->text_check_escapes = 0;\n\t\tparser->text_start = parser->current_pos + 1;\n\t\tparser->text_end = parser->text_start + txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*contiguous text*/\n\tif (parser->text_end && (parser->text_end-1 == parser->current_pos)) {\n\t\tparser->text_end += txt_len;\n\t\tparser->current_pos += txt_len;\n\t\tassert(parser->current_pos <= parser->line_size);\n\t\treturn;\n\t}\n\t/*need to flush*/\n\txml_sax_flush_text(parser);\n\n\tparser->text_start = parser->current_pos + 1;\n\tparser->text_end = parser->text_start + txt_len;\n\tparser->current_pos += txt_len;\n\tassert(parser->current_pos <= parser->line_size);\n}\n\nstatic void xml_sax_parse_entity(GF_SAXParser *parser)\n{\n\tchar szC[2];\n\tchar *ent_name=NULL;\n\tu32 i = 0;\n\tXML_Entity *ent = (XML_Entity *)gf_list_last(parser->entities);\n\tchar *skip_chars = \" \\t\\n\\r\";\n\ti=0;\n\tif (ent && ent->value) ent = NULL;\n\tif (ent) skip_chars = NULL;\n\tszC[1]=0;\n\n\twhile (parser->current_pos+i < parser->line_size) {\n\t\tu8 c = parser->buffer[parser->current_pos+i];\n\t\tif (skip_chars && strchr(skip_chars, c)) {\n\t\t\tif (c=='\\n') parser->line++;\n\t\t\tparser->current_pos++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!ent && (c=='%')) {\n\t\t\tparser->current_pos+=i+1;\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\treturn;\n\t\t}\n\t\telse if (!ent && ((c=='\\\"') || (c=='\\'')) ) {\n\t\t\tGF_SAFEALLOC(ent, XML_Entity);\n\t\t\tif (!ent) {\n\t\t\t\tparser->sax_state = SAX_STATE_ALLOC_ERROR;\n\t\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!ent_name) gf_dynstrcat(&ent_name, \"\", NULL);\n\n\t\t\tent->name = ent_name;\n\t\t\tent_name=NULL;\n\t\t\tent->namelen = (u32) strlen(ent->name);\n\t\t\tent->sep = c;\n\t\t\tparser->current_pos += 1+i;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\ti=0;\n\t\t\tgf_list_add(parser->entities, ent);\n\t\t\tskip_chars = NULL;\n\t\t} else if (ent && c==ent->sep) {\n\t\t\tif (ent_name) gf_free(ent_name);\n\t\t\txml_sax_store_text(parser, i);\n\n\t\t\tent->value = xml_get_current_text(parser);\n\t\t\tif (!ent->value) ent->value = gf_strdup(\"\");\n\n\t\t\tparser->current_pos += 1;\n\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\txml_sax_swap(parser);\n\t\t\tparser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\treturn;\n\t\t} else if (!ent) {\n\t\t\tszC[0] = c;\n\t\t\tgf_dynstrcat(&ent_name, szC, NULL);\n\t\t\ti++;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\tif (ent_name) gf_free(ent_name);\n\tif (ent && !ent->value)\n\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\txml_sax_store_text(parser, i);\n}\n\nstatic GF_Err xml_sax_parse(GF_SAXParser *parser, Bool force_parse)\n{\n\tu32 i = 0;\n\tBool is_text;\n\tu32 is_end;\n\tu8 c;\n\tchar *elt, sep;\n\tu32 cdata_sep;\n\n\twhile (parser->current_pos<parser->line_size) {\n\t\tif (!force_parse && parser->suspended) goto exit;\n\nrestart:\n\t\tis_text = GF_FALSE;\n\t\tswitch (parser->sax_state) {\n\t\t/*load an XML element*/\n\t\tcase SAX_STATE_TEXT_CONTENT:\n\t\t\tis_text = GF_TRUE;\n\t\tcase SAX_STATE_ELEMENT:\n\t\t\telt = NULL;\n\t\t\ti=0;\n\t\t\twhile ((c = parser->buffer[parser->current_pos+i]) !='<') {\n\t\t\t\tif ((parser->init_state==2) && (c ==']')) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\t\t\tparser->current_pos+=i+1;\n\t\t\t\t\tgoto restart;\n\t\t\t\t}\n\t\t\t\ti++;\n\t\t\t\tif (c=='\\n') parser->line++;\n\t\t\t\tif (is_text) {\n\t\t\t\t\tif (c=='&') parser->text_check_escapes |= 1;\n\t\t\t\t\telse if (c==';') parser->text_check_escapes |= 2;\n\t\t\t\t}\n\n\t\t\t\tif (parser->current_pos+i==parser->line_size) {\n\t\t\t\t\tif ((parser->line_size>=2*XML_INPUT_SIZE) && !parser->init_state)\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (is_text && i) {\n\t\t\t\tu32 has_esc = parser->text_check_escapes;\n\t\t\t\txml_sax_store_text(parser, i);\n\t\t\t\tparser->text_check_escapes = has_esc;\n\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t} else if (i) {\n\t\t\t\tparser->current_pos += i;\n\t\t\t\tassert(parser->current_pos < parser->line_size);\n\t\t\t}\n\t\t\tis_end = 0;\n\t\t\ti = 0;\n\t\t\tcdata_sep = 0;\n\t\t\twhile (1) {\n\t\t\t\tc = parser->buffer[parser->current_pos+1+i];\n\t\t\t\tif (!strncmp(parser->buffer+parser->current_pos+1+i, \"!--\", 3)) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\t\ti += 3;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!c) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t\tif ((c=='\\t') || (c=='\\r') || (c==' ') ) {\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='\\n') {\n\t\t\t\t\tparser->line++;\n\t\t\t\t\tif (i) break;\n\t\t\t\t\telse parser->current_pos++;\n\t\t\t\t}\n\t\t\t\telse if (c=='>') break;\n\t\t\t\telse if (c=='=') break;\n\t\t\t\telse if (c=='[') {\n\t\t\t\t\ti++;\n\t\t\t\t\tif (!cdata_sep) cdata_sep = 1;\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (c=='/') {\n\t\t\t\t\tis_end = !i ? 1 : 2;\n\t\t\t\t\ti++;\n\t\t\t\t} else if (c=='<') {\n\t\t\t\t\tif (parser->sax_state != SAX_STATE_COMMENT) {\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_SYNTAX_ERROR;\n\t\t\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\t/*\t\t\t\tif ((c=='[') && (parser->buffer[parser->elt_name_start-1 + i-2]=='A') ) break; */\n\t\t\t\tif (parser->current_pos+1+i==parser->line_size) {\n\t\t\t\t\tgoto exit;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i) {\n\t\t\t\tparser->elt_name_start = parser->current_pos+1 + 1;\n\t\t\t\tif (is_end==1) parser->elt_name_start ++;\n\t\t\t\tif (is_end==2) parser->elt_name_end = parser->current_pos+1+i;\n\t\t\t\telse parser->elt_name_end = parser->current_pos+1+i + 1;\n\t\t\t}\n\t\t\tif (is_end) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->elt_end_pos = parser->file_pos + parser->current_pos + i;\n\t\t\t\tif (is_end==2) {\n\t\t\t\t\tparser->sax_state = SAX_STATE_ELEMENT;\n\t\t\t\t\txml_sax_node_start(parser);\n\t\t\t\t\txml_sax_node_end(parser, GF_FALSE);\n\t\t\t\t} else {\n\t\t\t\t\tparser->elt_end_pos += parser->elt_name_end - parser->elt_name_start;\n\t\t\t\t\txml_sax_node_end(parser, GF_TRUE);\n\t\t\t\t}\n\t\t\t\tif (parser->sax_state == SAX_STATE_SYNTAX_ERROR) break;\n\t\t\t\tparser->current_pos+=2+i;\n\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!parser->elt_name_end) {\n\t\t\t\treturn GF_CORRUPTED_DATA;\n\t\t\t}\n\t\t\tsep = parser->buffer[parser->elt_name_end-1];\n\t\t\tparser->buffer[parser->elt_name_end-1] = 0;\n\t\t\telt = parser->buffer + parser->elt_name_start-1;\n\n\t\t\tparser->sax_state = SAX_STATE_ATT_NAME;\n\t\t\tassert(parser->elt_start_pos <= parser->file_pos + parser->current_pos);\n\t\t\tparser->elt_start_pos = parser->file_pos + parser->current_pos;\n\n\t\t\tif (!strncmp(elt, \"!--\", 3)) {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tparser->sax_state = SAX_STATE_COMMENT;\n\t\t\t\tif (i>3) parser->current_pos -= (i-3);\n\t\t\t}\n\t\t\telse if (!strcmp(elt, \"?xml\")) parser->init_state = 1;\n\t\t\telse if (!strcmp(elt, \"!DOCTYPE\")) parser->init_state = 2;\n\t\t\telse if (!strcmp(elt, \"!ENTITY\")) parser->sax_state = SAX_STATE_ENTITY;\n\t\t\telse if (!strcmp(elt, \"!ATTLIST\") || !strcmp(elt, \"!ELEMENT\")) parser->sax_state = SAX_STATE_SKIP_DOCTYPE;\n\t\t\telse if (!strcmp(elt, \"![CDATA[\"))\n\t\t\t\tparser->sax_state = SAX_STATE_CDATA;\n\t\t\telse if (elt[0]=='?') {\n\t\t\t\ti--;\n\t\t\t\tparser->sax_state = SAX_STATE_XML_PROC;\n\t\t\t}\n\t\t\t/*node found*/\n\t\t\telse {\n\t\t\t\txml_sax_flush_text(parser);\n\t\t\t\tif (parser->init_state) {\n\t\t\t\t\tparser->init_state = 0;\n\t\t\t\t\t/*that's a bit ugly: since we solve entities when appending text, we need to\n\t\t\t\t\treparse the current buffer*/\n\t\t\t\t\tif (gf_list_count(parser->entities)) {\n\t\t\t\t\t\tchar *orig_buf;\n\t\t\t\t\t\tGF_Err e;\n\t\t\t\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\t\t\t\torig_buf = gf_strdup(parser->buffer + parser->current_pos);\n\t\t\t\t\t\tparser->current_pos = 0;\n\t\t\t\t\t\tparser->line_size = 0;\n\t\t\t\t\t\tparser->elt_start_pos = 0;\n\t\t\t\t\t\tparser->sax_state = SAX_STATE_TEXT_CONTENT;\n\t\t\t\t\t\tparser->ent_rec_level++;\n\t\t\t\t\t\tif (parser->ent_rec_level>100) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CORE, (\"[XML] Too many recursions in entity solving, max 100 allowed\\n\"));\n\t\t\t\t\t\t\te = GF_NOT_SUPPORTED;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\te = gf_xml_sax_parse_intern(parser, orig_buf);\n\t\t\t\t\t\t\tparser->ent_rec_level--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_free(orig_buf);\n\t\t\t\t\t\treturn e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tparser->current_pos+=1+i;\n\t\t\tparser->buffer[parser->elt_name_end-1] = sep;\n\t\t\tbreak;\n\t\tcase SAX_STATE_COMMENT:\n\t\t\tif (!xml_sax_parse_comments(parser)) {\n\t\t\t\txml_sax_swap(parser);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SAX_STATE_ATT_NAME:\n\t\tcase SAX_STATE_ATT_VALUE:\n\t\t\tif (xml_sax_parse_attribute(parser))\n\t\t\t\tgoto exit;\n\t\t\tbreak;\n\t\tcase SAX_STATE_ENTITY:\n\t\t\txml_sax_parse_entity(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SKIP_DOCTYPE:\n\t\t\txml_sax_skip_doctype(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_XML_PROC:\n\t\t\txml_sax_skip_xml_proc(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_CDATA:\n\t\t\txml_sax_cdata(parser);\n\t\t\tbreak;\n\t\tcase SAX_STATE_SYNTAX_ERROR:\n\t\t\treturn GF_CORRUPTED_DATA;\n\t\tcase SAX_STATE_ALLOC_ERROR:\n\t\t\treturn GF_OUT_OF_MEM;\n\t\tcase SAX_STATE_DONE:\n\t\t\treturn GF_EOS;\n\t\t}\n\t}\nexit:\n#if 0\n\tif (is_text) {\n\t\tif (i) xml_sax_store_text(parser, i);\n\t\t/*DON'T FLUSH TEXT YET, wait for next '<' to do so otherwise we may corrupt xml base entities (&apos;, ...)*/\n\t}\n#endif\n\txml_sax_swap(parser);\n\n\tif (parser->sax_state==SAX_STATE_SYNTAX_ERROR)\n\t\treturn GF_CORRUPTED_DATA;\n\telse\n\t\treturn GF_OK;\n}\n\nstatic GF_Err xml_sax_append_string(GF_SAXParser *parser, char *string)\n{\n\tu32 size = parser->line_size;\n\tu32 nl_size = string ? (u32) strlen(string) : 0;\n\n\tif (!nl_size) return GF_OK;\n\n\tif ( (parser->alloc_size < size+nl_size+1)\n\t        /*\t\t|| (parser->alloc_size / 2 ) > size+nl_size+1 */\n\t   )\n\t{\n\t\tparser->alloc_size = size+nl_size+1;\n\t\tparser->alloc_size = 3 * parser->alloc_size / 2;\n\t\tparser->buffer = (char*)gf_realloc(parser->buffer, sizeof(char) * parser->alloc_size);\n\t\tif (!parser->buffer ) return GF_OUT_OF_MEM;\n\t}\n\tmemcpy(parser->buffer+size, string, sizeof(char)*nl_size);\n\tparser->buffer[size+nl_size] = 0;\n\tparser->line_size = size+nl_size;\n\treturn GF_OK;\n}\n",
    "source": "real-world",
    "cwe": "CWE-476",
    "vulnerability_type": "null_pointer_dereference",
    "idx": 25,
    "typechecks": true,
    "cve": "CVE-2023-3012",
    "project": "gpac"
  },
  {
    "prompt": "Security review of this code:\n\n#include <gpac/internal/media_dev.h>\n#include <gpac/constants.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/maths.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\ntypedef struct\n{\n\tAVC_SPS sps[32]; /* range allowed in the spec is 0..31 */\n\ts8 sps_active_idx, pps_active_idx;\t/*currently active sps; must be initalized to -1 in order to discard not yet decodable SEIs*/\n\n\tAVC_PPS pps[255];\n\n\tAVCSliceInfo s_info;\n\tAVCSei sei;\n\n\tBool is_svc;\n\tu8 last_nal_type_parsed;\n\ts8 last_ps_idx, last_sps_idx;\n} AVCState;\n\nstatic s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id > 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tif (si->pps->sps_id>=255) return -1;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\tif ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");\n\t}\n\tnum_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;\n\tif (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");\n\t\t\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");\n\t\t\t}\n\t\t}\n\t}\n\tif (si->nal_unit_type == 20 || si->nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si->slice_type);\n\t}\n\tif ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tavc_pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\tif (si->nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\tif (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, \"cabac_init_idc\");\n\t}\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si->slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");\n\t\t}\n\t\tgf_bs_read_se_log(bs, \"slice_qs_delta\");\n\t}\n\tif (si->pps->deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t}\n\t}\n\tif (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");\n\t}\n\treturn 0;\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <gpac/internal/media_dev.h>\n#include <gpac/constants.h>\n#include <gpac/mpeg4_odf.h>\n#include <gpac/maths.h>\n#include <gpac/avparse.h>\n\n#ifndef GPAC_DISABLE_OGG\n#include <gpac/internal/ogg.h>\n#endif\n\ntypedef struct\n{\n\tAVC_SPS sps[32]; /* range allowed in the spec is 0..31 */\n\ts8 sps_active_idx, pps_active_idx;\t/*currently active sps; must be initalized to -1 in order to discard not yet decodable SEIs*/\n\n\tAVC_PPS pps[255];\n\n\tAVCSliceInfo s_info;\n\tAVCSei sei;\n\n\tBool is_svc;\n\tu8 last_nal_type_parsed;\n\ts8 last_ps_idx, last_sps_idx;\n} AVCState;\n\nstatic s32 avc_parse_slice(GF_BitStream *bs, AVCState *avc, Bool svc_idr_flag, AVCSliceInfo *si)\n{\n\ts32 pps_id, num_ref_idx_l0_active_minus1 = 0, num_ref_idx_l1_active_minus1 = 0;\n\t/*s->current_picture.reference= h->nal_ref_idc != 0;*/\n\tgf_bs_read_ue_log(bs, \"first_mb_in_slice\");\n\tsi->slice_type = gf_bs_read_ue_log(bs, \"slice_type\");\n\tif (si->slice_type > 9) return -1;\n\n\tpps_id = gf_bs_read_ue_log(bs, \"pps_id\");\n\tif ((pps_id<0) || (pps_id >= 255)) return -1;\n\tsi->pps = &avc->pps[pps_id];\n\tif (!si->pps->slice_group_count) return -2;\n\tif (si->pps->sps_id>=32) return -1;\n\tsi->sps = &avc->sps[si->pps->sps_id];\n\tif (!si->sps->log2_max_frame_num) return -2;\n\tavc->sps_active_idx = si->pps->sps_id;\n\tavc->pps_active_idx = pps_id;\n\tsi->frame_num = gf_bs_read_int_log(bs, si->sps->log2_max_frame_num, \"frame_num\");\n\tsi->field_pic_flag = 0;\n\tsi->bottom_field_flag = 0;\n\tif (!si->sps->frame_mbs_only_flag) {\n\t\tsi->field_pic_flag = gf_bs_read_int_log(bs, 1, \"field_pic_flag\");\n\t\tif (si->field_pic_flag)\n\t\t\tsi->bottom_field_flag = gf_bs_read_int_log(bs, 1, \"bottom_field_flag\");\n\t}\n\tif ((si->nal_unit_type == GF_AVC_NALU_IDR_SLICE) || svc_idr_flag)\n\t\tsi->idr_pic_id = gf_bs_read_ue_log(bs, \"idr_pic_id\");\n\tif (si->sps->poc_type == 0) {\n\t\tsi->poc_lsb = gf_bs_read_int_log(bs, si->sps->log2_max_poc_lsb, \"poc_lsb\");\n\t\tif (si->pps->pic_order_present && !si->field_pic_flag) {\n\t\t\tsi->delta_poc_bottom = gf_bs_read_se_log(bs, \"poc_lsb\");\n\t\t}\n\t}\n\telse if ((si->sps->poc_type == 1) && !si->sps->delta_pic_order_always_zero_flag) {\n\t\tsi->delta_poc[0] = gf_bs_read_se_log(bs, \"delta_poc0\");\n\t\tif ((si->pps->pic_order_present == 1) && !si->field_pic_flag)\n\t\t\tsi->delta_poc[1] = gf_bs_read_se_log(bs, \"delta_poc1\");\n\t}\n\tif (si->pps->redundant_pic_cnt_present) {\n\t\tsi->redundant_pic_cnt = gf_bs_read_ue_log(bs, \"redundant_pic_cnt\");\n\t}\n\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tgf_bs_read_int_log(bs, 1, \"direct_spatial_mv_pred_flag\");\n\t}\n\tnum_ref_idx_l0_active_minus1 = si->pps->num_ref_idx_l0_default_active_minus1;\n\tnum_ref_idx_l1_active_minus1 = si->pps->num_ref_idx_l1_default_active_minus1;\n\tif (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\tBool num_ref_idx_active_override_flag = gf_bs_read_int_log(bs, 1, \"num_ref_idx_active_override_flag\");\n\t\tif (num_ref_idx_active_override_flag) {\n\t\t\tnum_ref_idx_l0_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l0_active_minus1\");\n\t\t\tif (si->slice_type % 5 == GF_AVC_TYPE_B) {\n\t\t\t\tnum_ref_idx_l1_active_minus1 = gf_bs_read_ue_log(bs, \"num_ref_idx_l1_active_minus1\");\n\t\t\t}\n\t\t}\n\t}\n\tif (si->nal_unit_type == 20 || si->nal_unit_type == 21) {\n\t\t//ref_pic_list_mvc_modification(); /* specified in Annex H */\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] unimplemented ref_pic_list_mvc_modification() in slide header\\n\"));\n\t\tassert(0);\n\t\treturn -1;\n\t}\n\telse {\n\t\tref_pic_list_modification(bs, si->slice_type);\n\t}\n\tif ((si->pps->weighted_pred_flag && (si->slice_type % 5 == GF_AVC_TYPE_P || si->slice_type % 5 == GF_AVC_TYPE_SP))\n\t\t|| (si->pps->weighted_bipred_idc == 1 && si->slice_type % 5 == GF_AVC_TYPE_B)) {\n\t\tavc_pred_weight_table(bs, si->slice_type, si->sps->ChromaArrayType, num_ref_idx_l0_active_minus1, num_ref_idx_l1_active_minus1);\n\t}\n\tif (si->nal_ref_idc != 0) {\n\t\tdec_ref_pic_marking(bs, (si->nal_unit_type == GF_AVC_NALU_IDR_SLICE));\n\t}\n\tif (si->pps->entropy_coding_mode_flag && si->slice_type % 5 != GF_AVC_TYPE_I && si->slice_type % 5 != GF_AVC_TYPE_SI) {\n\t\tgf_bs_read_ue_log(bs, \"cabac_init_idc\");\n\t}\n\t/*slice_qp_delta = */gf_bs_read_se(bs);\n\tif (si->slice_type % 5 == GF_AVC_TYPE_SP || si->slice_type % 5 == GF_AVC_TYPE_SI) {\n\t\tif (si->slice_type % 5 == GF_AVC_TYPE_SP) {\n\t\t\tgf_bs_read_int_log(bs, 1, \"sp_for_switch_flag\");\n\t\t}\n\t\tgf_bs_read_se_log(bs, \"slice_qs_delta\");\n\t}\n\tif (si->pps->deblocking_filter_control_present_flag) {\n\t\tif (gf_bs_read_ue_log(bs, \"disable_deblocking_filter_idc\") != 1) {\n\t\t\tgf_bs_read_se_log(bs, \"slice_alpha_c0_offset_div2\");\n\t\t\tgf_bs_read_se_log(bs, \"slice_beta_offset_div2\");\n\t\t}\n\t}\n\tif (si->pps->slice_group_count > 1 && si->pps->mb_slice_group_map_type >= 3 && si->pps->mb_slice_group_map_type <= 5) {\n\t\tgf_bs_read_int_log(bs, (u32)ceil(log1p((si->pps->pic_size_in_map_units_minus1 + 1) / (si->pps->slice_group_change_rate_minus1 + 1) ) / log(2)), \"slice_group_change_cycle\");\n\t}\n\treturn 0;\n}",
    "source": "real-world",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 26,
    "typechecks": true,
    "cve": "CVE-2023-23143",
    "project": "gpac"
  },
  {
    "prompt": "Security review of this code:\n\n#include \"quant.h\"\n\n#ifndef GPAC_DISABLE_BIFS\n\n#include <math.h>\n\nu32 gf_bifs_dec_qp14_get_bits(GF_BifsDecoder *codec)\n{\n\tif (!codec->ActiveQP || !codec->coord_stored) return 0;\n\treturn (u32) ceil(log1p(codec->NumCoord) / log(2) );\n}\n\nvoid gf_bifs_dec_qp14_enter(GF_BifsDecoder * codec, Bool Enter)\n{\n\tif (!codec->ActiveQP) return;\n\tif (Enter) codec->storing_coord = GF_TRUE;\n\telse {\n\t\tif (codec->storing_coord) codec->coord_stored = GF_TRUE;\n\t\tcodec->storing_coord = GF_FALSE;\n\t}\n}\n\nvoid gf_bifs_dec_qp14_reset(GF_BifsDecoder * codec)\n{\n\tcodec->coord_stored = GF_FALSE;\n\tcodec->storing_coord = GF_FALSE;\n\tcodec->NumCoord = 0;\n}\n\nvoid gf_bifs_dec_qp14_set_length(GF_BifsDecoder * codec, u32 NbElements)\n{\n\tif (!codec->ActiveQP || !codec->storing_coord || codec->coord_stored) return;\n\tcodec->NumCoord = NbElements;\n}\n\nGF_Err gf_bifs_dec_qp_set(GF_BifsDecoder *codec, GF_Node *qp)\n{\n\tassert(gf_node_get_tag(qp) == TAG_MPEG4_QuantizationParameter);\n\t/*if we have an active QP, push it into the stack*/\n\tif (codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) )\n\t\tgf_list_insert(codec->QPs, codec->ActiveQP, 0);\n\tcodec->ActiveQP = (M_QuantizationParameter *)qp;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_qp_remove(GF_BifsDecoder *codec, Bool ActivatePrev)\n{\n\tif (!codec->force_keep_qp && codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) ) {\n\t\tgf_node_unregister((GF_Node *) codec->ActiveQP, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tif (!ActivatePrev) return GF_OK;\n\tif (gf_list_count(codec->QPs)) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter*)gf_list_get(codec->QPs, 0);\n\t\tgf_list_rem(codec->QPs, 0);\n\t} else if (codec->scenegraph->global_qp) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter *)codec->scenegraph->global_qp;\n\t}\n\treturn GF_OK;\n}\n\n//parses efficient float\nFixed gf_bifs_dec_mantissa_float(GF_BifsDecoder *codec, GF_BitStream *bs)\n{\n\tu32 mantLength, expLength, mantSign, mantissa;\n\tunsigned char exp;\n\tunion {\n\t\tFloat f;\n\t\tlong l;\n\t} ft_value;\n\tmantLength = gf_bs_read_int(bs, 4);\n\tif (!mantLength) return 0;\n\texpLength = gf_bs_read_int(bs, 3);\n\tmantSign = gf_bs_read_int(bs, 1);\n\tmantissa = gf_bs_read_int(bs, mantLength - 1);\n\texp = 127;\n\tif (expLength) {\n\t\tu32 expSign = gf_bs_read_int(bs, 1);\n\t\tu32 exponent = gf_bs_read_int(bs, expLength-1);\n\t\texp += (1-2*expSign)*( (1 << (expLength-1) ) + exponent);\n\t}\n\tft_value.l = mantSign << 31;\n\tft_value.l |= (exp & 0xff) << 23;\n\tft_value.l |= mantissa << 9;\n\treturn FLT2FIX(ft_value.f);\n}\n\n//check if the quant type is on in the QP, and if so retrieves NbBits and Min Max\n//specified for the field\nBool Q_IsTypeOn(M_QuantizationParameter *qp, u32 q_type, u32 *NbBits, SFVec3f *b_min, SFVec3f *b_max)\n{\n\tswitch (q_type) {\n\tcase QC_3DPOS:\n\t\tif (!qp->position3DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position3DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position3DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position3DMin.y);\n\t\tb_min->z = MAX(b_min->z, qp->position3DMin.z);\n\t\tb_max->x = MIN(b_max->x, qp->position3DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position3DMax.y);\n\t\tb_max->z = MIN(b_max->z, qp->position3DMax.z);\n\t\treturn GF_TRUE;\n\tcase QC_2DPOS:\n\t\tif (!qp->position2DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position2DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position2DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position2DMin.y);\n\t\tb_max->x = MIN(b_max->x, qp->position2DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position2DMax.y);\n\t\treturn GF_TRUE;\n\tcase QC_ORDER:\n\t\tif (!qp->drawOrderQuant) return GF_FALSE;\n\t\t*NbBits = qp->drawOrderNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->drawOrderMin);\n\t\tb_max->x = MIN(b_max->x, qp->drawOrderMax);\n\t\treturn GF_TRUE;\n\tcase QC_COLOR:\n\t\tif (!qp->colorQuant) return GF_FALSE;\n\t\t*NbBits = qp->colorNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->colorMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->colorMax);\n\t\treturn GF_TRUE;\n\tcase QC_TEXTURE_COORD:\n\t\tif (!qp->textureCoordinateQuant) return GF_FALSE;\n\t\t*NbBits = qp->textureCoordinateNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->textureCoordinateMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->textureCoordinateMax);\n\t\treturn GF_TRUE;\n\tcase QC_ANGLE:\n\t\tif (!qp->angleQuant) return GF_FALSE;\n\t\t*NbBits = qp->angleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->angleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->angleMax);\n\t\treturn GF_TRUE;\n\tcase QC_SCALE:\n\t\tif (!qp->scaleQuant) return GF_FALSE;\n\t\t*NbBits = qp->scaleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->scaleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->scaleMax);\n\t\treturn GF_TRUE;\n\tcase QC_INTERPOL_KEYS:\n\t\tif (!qp->keyQuant) return GF_FALSE;\n\t\t*NbBits = qp->keyNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->keyMin);\n\t\tb_min->y = MAX(b_min->y, qp->keyMin);\n\t\tb_min->z = MAX(b_min->z, qp->keyMin);\n\t\tb_max->x = MIN(b_max->x, qp->keyMax);\n\t\tb_max->y = MIN(b_max->y, qp->keyMax);\n\t\tb_max->z = MIN(b_max->z, qp->keyMax);\n\t\treturn GF_TRUE;\n\tcase QC_NORMALS:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_ROTATION:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_3D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_2D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\t//cf specs, from here ALWAYS ON\n\tcase QC_LINEAR_SCALAR:\n\t\t//nbBits is the one from the FCT - DO NOT CHANGE IT\n\t\treturn GF_TRUE;\n\tcase QC_COORD_INDEX:\n\t\t//nbBits has to be recomputed on the fly\n\t\treturn GF_TRUE;\n\tcase QC_RESERVED:\n\t\t*NbBits = 0;\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\n//Linear inverse Quantization for floats\nFixed Q_InverseQuantize(Fixed Min, Fixed Max, u32 NbBits, u32 value)\n{\n\tif (!value) return Min;\n\tif (value == (u32) ((1 << NbBits) - 1) ) return Max;\n\treturn Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX( (1 << NbBits) - 1) );\n}\nGF_Err Q_DecFloat(GF_BifsDecoder *codec, GF_BitStream *bs, u32 FieldType, SFVec3f BMin, SFVec3f BMax, u32 NbBits, void *field_ptr)\n{\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field_ptr) = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec2f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->z = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field_ptr)->red = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->green = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->blue = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t//forbidden in this Q mode\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\n//int in quant are either Linear Scalar fields or CoordIndex\n//the quant is just a bitshifting into [0, 2^NbBits-1]\n//so IntMin + ReadBit(NbBits) = value\nGF_Err Q_DecInt(GF_BifsDecoder *codec, GF_BitStream *bs, u32 QType, SFInt32 b_min, u32 NbBits, void *field_ptr)\n{\n\tswitch (QType) {\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\t*((SFInt32 *)field_ptr) = gf_bs_read_int(bs, NbBits) + b_min;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\n//SFRotation and SFVec3f are quantized as normalized vectors ,mapped on a cube\n//in the UnitSphere (R=1.0)\nGF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\n\t//only 2 or 3 comp in the quantized version\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}\n\n//parses a rotation\nGF_Err Q_DecRotation(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tu32 i;\n\tFixed q, sin2, comp[4];\n\tGF_Err e;\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 3, comp);\n\tif (e) return e;\n\tq = 2 * gf_acos(comp[0]);\n\tsin2 = gf_sin(q / 2);\n\tif (ABS(sin2) <= FIX_EPSILON) {\n\t\tfor (i=1; i<4; i++) comp[i] = 0;\n\t\tcomp[3] = FIX_ONE;\n\t} else {\n\t\tfor (i=1; i<4; i++) comp[i] = gf_divfix(comp[i], sin2);\n\t}\n\t((SFRotation *)field_ptr)->x = comp[1];\n\t((SFRotation *)field_ptr)->y = comp[2];\n\t((SFRotation *)field_ptr)->z = comp[3];\n\t((SFRotation *)field_ptr)->q = q;\n\treturn GF_OK;\n}\n\n//parses a Normal vec\nGF_Err Q_DecNormal(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tFixed comp[4];\n\tSFVec3f v;\n\tGF_Err e;\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 2, comp);\n\tif (e) return e;\n\tv.x = comp[0];\n\tv.y = comp[1];\n\tv.z = comp[2];\n\tgf_vec_norm(&v);\n\t*((SFVec3f *)field_ptr) = v;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_unquant_field(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field)\n{\n\tBool HasQ;\n\tu8 QType, AType;\n\tu32 NbBits;\n\tFixed b_min, b_max;\n\tSFVec3f BMin, BMax;\n\tGF_Err e;\n\t/*check QP*/\n\tif (!codec->ActiveQP) return GF_EOS;\n\t/*check FieldType*/\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\tcase GF_SG_VRML_SFFLOAT:\n\tcase GF_SG_VRML_SFROTATION:\n\tcase GF_SG_VRML_SFVEC2F:\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_EOS;\n\t}\n\t/*check NDT*/\n\tHasQ = gf_bifs_get_aq_info(node, field->fieldIndex, &QType, &AType, &b_min, &b_max, &NbBits);\n\tif (!HasQ || !QType) return GF_EOS;\n\t/*get NbBits for QP14 (QC_COORD_INDEX)*/\n\tif (QType == QC_COORD_INDEX) {\n\t\tNbBits = gf_bifs_dec_qp14_get_bits(codec);\n\t\t/*QP14 is always on, not having NbBits set means the coord field is set after the index field, hence not decodable*/\n\t\tif (!NbBits) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tBMin.x = BMin.y = BMin.z = b_min;\n\tBMax.x = BMax.y = BMax.z = b_max;\n\t/*check is the QP is on and retrieves the bounds*/\n\tif (!Q_IsTypeOn(codec->ActiveQP, QType, &NbBits, &BMin, &BMax)) return GF_EOS;\n\t/*ok the field is Quantized, dequantize*/\n\tswitch (QType) {\n\t//these are all SFFloat quantized on n fields\n\tcase QC_3DPOS:\n\tcase QC_2DPOS:\n\tcase QC_ORDER:\n\tcase QC_COLOR:\n\tcase QC_TEXTURE_COORD:\n\tcase QC_ANGLE:\n\tcase QC_SCALE:\n\tcase QC_INTERPOL_KEYS:\n\tcase QC_SIZE_3D:\n\tcase QC_SIZE_2D:\n\t\te = Q_DecFloat(codec, bs, field->fieldType, BMin, BMax, NbBits, field->far_ptr);\n\t\tbreak;\n\t//SFInt types\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\te = Q_DecInt(codec, bs, QType, (SFInt32) b_min, NbBits, field->far_ptr);\n\t\tbreak;\n\t//normalized fields (normals and vectors)\n\tcase QC_NORMALS:\n\t\t//normal quant is only for SFVec3F\n\t\tif (field->fieldType != GF_SG_VRML_SFVEC3F) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecNormal(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tcase QC_ROTATION:\n\t\t//normal quant is only for SFRotation\n\t\tif (field->fieldType != GF_SG_VRML_SFROTATION) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecRotation(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (e) return e;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include \"quant.h\"\n\n#ifndef GPAC_DISABLE_BIFS\n\n#include <math.h>\n\nu32 gf_bifs_dec_qp14_get_bits(GF_BifsDecoder *codec)\n{\n\tif (!codec->ActiveQP || !codec->coord_stored) return 0;\n\treturn (u32) ceil(log1p(codec->NumCoord) / log(2) );\n}\n\nvoid gf_bifs_dec_qp14_enter(GF_BifsDecoder * codec, Bool Enter)\n{\n\tif (!codec->ActiveQP) return;\n\tif (Enter) codec->storing_coord = GF_TRUE;\n\telse {\n\t\tif (codec->storing_coord) codec->coord_stored = GF_TRUE;\n\t\tcodec->storing_coord = GF_FALSE;\n\t}\n}\n\nvoid gf_bifs_dec_qp14_reset(GF_BifsDecoder * codec)\n{\n\tcodec->coord_stored = GF_FALSE;\n\tcodec->storing_coord = GF_FALSE;\n\tcodec->NumCoord = 0;\n}\n\nvoid gf_bifs_dec_qp14_set_length(GF_BifsDecoder * codec, u32 NbElements)\n{\n\tif (!codec->ActiveQP || !codec->storing_coord || codec->coord_stored) return;\n\tcodec->NumCoord = NbElements;\n}\n\nGF_Err gf_bifs_dec_qp_set(GF_BifsDecoder *codec, GF_Node *qp)\n{\n\tassert(gf_node_get_tag(qp) == TAG_MPEG4_QuantizationParameter);\n\t/*if we have an active QP, push it into the stack*/\n\tif (codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) )\n\t\tgf_list_insert(codec->QPs, codec->ActiveQP, 0);\n\tcodec->ActiveQP = (M_QuantizationParameter *)qp;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_qp_remove(GF_BifsDecoder *codec, Bool ActivatePrev)\n{\n\tif (!codec->force_keep_qp && codec->ActiveQP && ((GF_Node*)codec->ActiveQP != codec->scenegraph->global_qp) ) {\n\t\tgf_node_unregister((GF_Node *) codec->ActiveQP, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tif (!ActivatePrev) return GF_OK;\n\tif (gf_list_count(codec->QPs)) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter*)gf_list_get(codec->QPs, 0);\n\t\tgf_list_rem(codec->QPs, 0);\n\t} else if (codec->scenegraph->global_qp) {\n\t\tcodec->ActiveQP = (M_QuantizationParameter *)codec->scenegraph->global_qp;\n\t}\n\treturn GF_OK;\n}\n\n//parses efficient float\nFixed gf_bifs_dec_mantissa_float(GF_BifsDecoder *codec, GF_BitStream *bs)\n{\n\tu32 mantLength, expLength, mantSign, mantissa;\n\tunsigned char exp;\n\tunion {\n\t\tFloat f;\n\t\tlong l;\n\t} ft_value;\n\tmantLength = gf_bs_read_int(bs, 4);\n\tif (!mantLength) return 0;\n\texpLength = gf_bs_read_int(bs, 3);\n\tmantSign = gf_bs_read_int(bs, 1);\n\tmantissa = gf_bs_read_int(bs, mantLength - 1);\n\texp = 127;\n\tif (expLength) {\n\t\tu32 expSign = gf_bs_read_int(bs, 1);\n\t\tu32 exponent = gf_bs_read_int(bs, expLength-1);\n\t\texp += (1-2*expSign)*( (1 << (expLength-1) ) + exponent);\n\t}\n\tft_value.l = mantSign << 31;\n\tft_value.l |= (exp & 0xff) << 23;\n\tft_value.l |= mantissa << 9;\n\treturn FLT2FIX(ft_value.f);\n}\n\n//check if the quant type is on in the QP, and if so retrieves NbBits and Min Max\n//specified for the field\nBool Q_IsTypeOn(M_QuantizationParameter *qp, u32 q_type, u32 *NbBits, SFVec3f *b_min, SFVec3f *b_max)\n{\n\tswitch (q_type) {\n\tcase QC_3DPOS:\n\t\tif (!qp->position3DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position3DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position3DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position3DMin.y);\n\t\tb_min->z = MAX(b_min->z, qp->position3DMin.z);\n\t\tb_max->x = MIN(b_max->x, qp->position3DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position3DMax.y);\n\t\tb_max->z = MIN(b_max->z, qp->position3DMax.z);\n\t\treturn GF_TRUE;\n\tcase QC_2DPOS:\n\t\tif (!qp->position2DQuant) return GF_FALSE;\n\t\t*NbBits = qp->position2DNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->position2DMin.x);\n\t\tb_min->y = MAX(b_min->y, qp->position2DMin.y);\n\t\tb_max->x = MIN(b_max->x, qp->position2DMax.x);\n\t\tb_max->y = MIN(b_max->y, qp->position2DMax.y);\n\t\treturn GF_TRUE;\n\tcase QC_ORDER:\n\t\tif (!qp->drawOrderQuant) return GF_FALSE;\n\t\t*NbBits = qp->drawOrderNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->drawOrderMin);\n\t\tb_max->x = MIN(b_max->x, qp->drawOrderMax);\n\t\treturn GF_TRUE;\n\tcase QC_COLOR:\n\t\tif (!qp->colorQuant) return GF_FALSE;\n\t\t*NbBits = qp->colorNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->colorMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->colorMax);\n\t\treturn GF_TRUE;\n\tcase QC_TEXTURE_COORD:\n\t\tif (!qp->textureCoordinateQuant) return GF_FALSE;\n\t\t*NbBits = qp->textureCoordinateNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->textureCoordinateMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->textureCoordinateMax);\n\t\treturn GF_TRUE;\n\tcase QC_ANGLE:\n\t\tif (!qp->angleQuant) return GF_FALSE;\n\t\t*NbBits = qp->angleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->angleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->angleMax);\n\t\treturn GF_TRUE;\n\tcase QC_SCALE:\n\t\tif (!qp->scaleQuant) return GF_FALSE;\n\t\t*NbBits = qp->scaleNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->scaleMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->scaleMax);\n\t\treturn GF_TRUE;\n\tcase QC_INTERPOL_KEYS:\n\t\tif (!qp->keyQuant) return GF_FALSE;\n\t\t*NbBits = qp->keyNbBits;\n\t\tb_min->x = MAX(b_min->x, qp->keyMin);\n\t\tb_min->y = MAX(b_min->y, qp->keyMin);\n\t\tb_min->z = MAX(b_min->z, qp->keyMin);\n\t\tb_max->x = MIN(b_max->x, qp->keyMax);\n\t\tb_max->y = MIN(b_max->y, qp->keyMax);\n\t\tb_max->z = MIN(b_max->z, qp->keyMax);\n\t\treturn GF_TRUE;\n\tcase QC_NORMALS:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_ROTATION:\n\t\tif (!qp->normalQuant) return GF_FALSE;\n\t\t*NbBits = qp->normalNbBits;\n\t\tb_min->x = b_min->y = b_min->z = 0;\n\t\tb_max->x = b_max->y = b_max->z = FIX_ONE;\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_3D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\tcase QC_SIZE_2D:\n\t\tif (!qp->sizeQuant) return GF_FALSE;\n\t\t*NbBits = qp->sizeNbBits;\n\t\tb_min->x = b_min->y = b_min->z = MAX(b_min->x, qp->sizeMin);\n\t\tb_max->x = b_max->y = b_max->z = MIN(b_max->x, qp->sizeMax);\n\t\treturn GF_TRUE;\n\t//cf specs, from here ALWAYS ON\n\tcase QC_LINEAR_SCALAR:\n\t\t//nbBits is the one from the FCT - DO NOT CHANGE IT\n\t\treturn GF_TRUE;\n\tcase QC_COORD_INDEX:\n\t\t//nbBits has to be recomputed on the fly\n\t\treturn GF_TRUE;\n\tcase QC_RESERVED:\n\t\t*NbBits = 0;\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n}\n\n//Linear inverse Quantization for floats\nFixed Q_InverseQuantize(Fixed Min, Fixed Max, u32 NbBits, u32 value)\n{\n\tif (!value) return Min;\n\tif (value == (u32) ((1 << NbBits) - 1) ) return Max;\n\treturn Min + gf_muldiv(Max - Min, INT2FIX(value), INT2FIX( (1 << NbBits) - 1) );\n}\nGF_Err Q_DecFloat(GF_BifsDecoder *codec, GF_BitStream *bs, u32 FieldType, SFVec3f BMin, SFVec3f BMax, u32 NbBits, void *field_ptr)\n{\n\tswitch (FieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\tcase GF_SG_VRML_SFFLOAT:\n\t\t*((SFFloat *)field_ptr) = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC2F:\n\t\t((SFVec2f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec2f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFVEC3F:\n\t\t((SFVec3f *)field_ptr)->x = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->y = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFVec3f *)field_ptr)->z = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\t((SFColor *)field_ptr)->red = Q_InverseQuantize(BMin.x, BMax.x, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->green = Q_InverseQuantize(BMin.y, BMax.y, NbBits, gf_bs_read_int(bs, NbBits));\n\t\t((SFColor *)field_ptr)->blue = Q_InverseQuantize(BMin.z, BMax.z, NbBits, gf_bs_read_int(bs, NbBits));\n\t\treturn GF_OK;\n\tcase GF_SG_VRML_SFROTATION:\n\t\t//forbidden in this Q mode\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\n//int in quant are either Linear Scalar fields or CoordIndex\n//the quant is just a bitshifting into [0, 2^NbBits-1]\n//so IntMin + ReadBit(NbBits) = value\nGF_Err Q_DecInt(GF_BifsDecoder *codec, GF_BitStream *bs, u32 QType, SFInt32 b_min, u32 NbBits, void *field_ptr)\n{\n\tswitch (QType) {\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\t*((SFInt32 *)field_ptr) = gf_bs_read_int(bs, NbBits) + b_min;\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\n//SFRotation and SFVec3f are quantized as normalized vectors ,mapped on a cube\n//in the UnitSphere (R=1.0)\nGF_Err Q_DecCoordOnUnitSphere(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, u32 NbComp, Fixed *m_ft)\n{\n\tu32 i, orient, sign;\n\ts32 value;\n\tFixed tang[4], delta;\n\ts32 dir;\n\n    if (NbBits>32) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (NbComp != 2 && NbComp != 3) return GF_BAD_PARAM;\n\n\t//only 2 or 3 comp in the quantized version\n\tdir = 1;\n\tif(NbComp == 2) dir -= 2 * gf_bs_read_int(bs, 1);\n\torient = gf_bs_read_int(bs, 2);\n\tif ((orient==3) && (NbComp==2)) return GF_NON_COMPLIANT_BITSTREAM;\n\tfor(i=0; i<NbComp; i++) {\n\t\tvalue = gf_bs_read_int(bs, NbBits) - (1 << (NbBits-1) );\n\t\tsign = (value >= 0) ? 1 : -1;\n\t\tm_ft[i] = sign * Q_InverseQuantize(0, 1, NbBits-1, sign*value);\n\t}\n\tdelta = 1;\n\tfor (i=0; i<NbComp; i++) {\n\t\ttang[i] = gf_tan(gf_mulfix(GF_PI/4, m_ft[i]) );\n\t\tdelta += gf_mulfix(tang[i], tang[i]);\n\t}\n\tdelta = gf_divfix(INT2FIX(dir), gf_sqrt(delta) );\n\tm_ft[orient] = delta;\n\tfor (i=0; i<NbComp; i++) {\n\t\tm_ft[ (orient + i+1) % (NbComp+1) ] = gf_mulfix(tang[i], delta);\n\t}\n\treturn GF_OK;\n}\n\n//parses a rotation\nGF_Err Q_DecRotation(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tu32 i;\n\tFixed q, sin2, comp[4];\n\tGF_Err e;\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 3, comp);\n\tif (e) return e;\n\tq = 2 * gf_acos(comp[0]);\n\tsin2 = gf_sin(q / 2);\n\tif (ABS(sin2) <= FIX_EPSILON) {\n\t\tfor (i=1; i<4; i++) comp[i] = 0;\n\t\tcomp[3] = FIX_ONE;\n\t} else {\n\t\tfor (i=1; i<4; i++) comp[i] = gf_divfix(comp[i], sin2);\n\t}\n\t((SFRotation *)field_ptr)->x = comp[1];\n\t((SFRotation *)field_ptr)->y = comp[2];\n\t((SFRotation *)field_ptr)->z = comp[3];\n\t((SFRotation *)field_ptr)->q = q;\n\treturn GF_OK;\n}\n\n//parses a Normal vec\nGF_Err Q_DecNormal(GF_BifsDecoder *codec, GF_BitStream *bs, u32 NbBits, void *field_ptr)\n{\n\tFixed comp[4];\n\tSFVec3f v;\n\tGF_Err e;\n\te = Q_DecCoordOnUnitSphere(codec, bs, NbBits, 2, comp);\n\tif (e) return e;\n\tv.x = comp[0];\n\tv.y = comp[1];\n\tv.z = comp[2];\n\tgf_vec_norm(&v);\n\t*((SFVec3f *)field_ptr) = v;\n\treturn GF_OK;\n}\n\nGF_Err gf_bifs_dec_unquant_field(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field)\n{\n\tBool HasQ;\n\tu8 QType, AType;\n\tu32 NbBits;\n\tFixed b_min, b_max;\n\tSFVec3f BMin, BMax;\n\tGF_Err e;\n\t/*check QP*/\n\tif (!codec->ActiveQP) return GF_EOS;\n\t/*check FieldType*/\n\tswitch (field->fieldType) {\n\tcase GF_SG_VRML_SFINT32:\n\tcase GF_SG_VRML_SFFLOAT:\n\tcase GF_SG_VRML_SFROTATION:\n\tcase GF_SG_VRML_SFVEC2F:\n\tcase GF_SG_VRML_SFVEC3F:\n\t\tbreak;\n\tcase GF_SG_VRML_SFCOLOR:\n\t\tbreak;\n\tdefault:\n\t\treturn GF_EOS;\n\t}\n\t/*check NDT*/\n\tHasQ = gf_bifs_get_aq_info(node, field->fieldIndex, &QType, &AType, &b_min, &b_max, &NbBits);\n\tif (!HasQ || !QType) return GF_EOS;\n\t/*get NbBits for QP14 (QC_COORD_INDEX)*/\n\tif (QType == QC_COORD_INDEX) {\n\t\tNbBits = gf_bifs_dec_qp14_get_bits(codec);\n\t\t/*QP14 is always on, not having NbBits set means the coord field is set after the index field, hence not decodable*/\n\t\tif (!NbBits) return GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tBMin.x = BMin.y = BMin.z = b_min;\n\tBMax.x = BMax.y = BMax.z = b_max;\n\t/*check is the QP is on and retrieves the bounds*/\n\tif (!Q_IsTypeOn(codec->ActiveQP, QType, &NbBits, &BMin, &BMax)) return GF_EOS;\n\t/*ok the field is Quantized, dequantize*/\n\tswitch (QType) {\n\t//these are all SFFloat quantized on n fields\n\tcase QC_3DPOS:\n\tcase QC_2DPOS:\n\tcase QC_ORDER:\n\tcase QC_COLOR:\n\tcase QC_TEXTURE_COORD:\n\tcase QC_ANGLE:\n\tcase QC_SCALE:\n\tcase QC_INTERPOL_KEYS:\n\tcase QC_SIZE_3D:\n\tcase QC_SIZE_2D:\n\t\te = Q_DecFloat(codec, bs, field->fieldType, BMin, BMax, NbBits, field->far_ptr);\n\t\tbreak;\n\t//SFInt types\n\tcase QC_LINEAR_SCALAR:\n\tcase QC_COORD_INDEX:\n\t\te = Q_DecInt(codec, bs, QType, (SFInt32) b_min, NbBits, field->far_ptr);\n\t\tbreak;\n\t//normalized fields (normals and vectors)\n\tcase QC_NORMALS:\n\t\t//normal quant is only for SFVec3F\n\t\tif (field->fieldType != GF_SG_VRML_SFVEC3F) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecNormal(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tcase QC_ROTATION:\n\t\t//normal quant is only for SFRotation\n\t\tif (field->fieldType != GF_SG_VRML_SFROTATION) return GF_NON_COMPLIANT_BITSTREAM;\n\t\te = Q_DecRotation(codec, bs, NbBits, field->far_ptr);\n\t\tbreak;\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\tif (e) return e;\n\treturn GF_OK;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/",
    "source": "real-world",
    "cwe": "CWE-190",
    "vulnerability_type": "integer_overflow",
    "idx": 27,
    "typechecks": true,
    "cve": "CVE-2023-23144",
    "project": "gpac"
  },
  {
    "prompt": "Security review of this code:\n\n#include \"tiffiop.h\"\n#include <float.h> /*--: for Rational2Double */\n#include <limits.h>\n\n/*\n * These are used in the backwards compatibility code...\n */\n#define DATATYPE_VOID 0   /* !untyped data */\n#define DATATYPE_INT 1    /* !signed integer data */\n#define DATATYPE_UINT 2   /* !unsigned integer data */\n#define DATATYPE_IEEEFP 3 /* !IEEE floating point data */\n\nstatic void setByteArray(TIFF *tif, void **vpp, const void *vp, size_t nmemb,\n                         size_t elem_size)\n{\n    if (*vpp)\n    {\n        _TIFFfreeExt(tif, *vpp);\n        *vpp = 0;\n    }\n    if (vp)\n    {\n        tmsize_t bytes = _TIFFMultiplySSize(NULL, nmemb, elem_size, NULL);\n        if (bytes)\n            *vpp = (void *)_TIFFmallocExt(tif, bytes);\n        if (*vpp)\n            _TIFFmemcpy(*vpp, vp, bytes);\n    }\n}\n\nstatic void _TIFFsetNString(TIFF *tif, char **cpp, const char *cp, uint32_t n)\n{\n    setByteArray(tif, (void **)cpp, cp, n, 1);\n}\nvoid _TIFFsetShortArray(uint16_t **wpp, const uint16_t *wp, uint32_t n)\n{\n    setByteArray(NULL, (void **)wpp, wp, n, sizeof(uint16_t));\n}\nvoid _TIFFsetShortArrayExt(TIFF *tif, uint16_t **wpp, const uint16_t *wp,\n                           uint32_t n)\n{\n    setByteArray(tif, (void **)wpp, wp, n, sizeof(uint16_t));\n}\nstatic void _TIFFsetLong8Array(TIFF *tif, uint64_t **lpp, const uint64_t *lp,\n                               uint32_t n)\n{\n    setByteArray(tif, (void **)lpp, lp, n, sizeof(uint64_t));\n}\nvoid _TIFFsetFloatArrayExt(TIFF *tif, float **fpp, const float *fp, uint32_t n)\n{\n    setByteArray(tif, (void **)fpp, fp, n, sizeof(float));\n}\nvoid _TIFFsetDoubleArrayExt(TIFF *tif, double **dpp, const double *dp,\n                            uint32_t n)\n{\n    setByteArray(tif, (void **)dpp, dp, n, sizeof(double));\n}\nstatic void setDoubleArrayOneValue(TIFF *tif, double **vpp, double value,\n                                   size_t nmemb)\n{\n    if (*vpp)\n        _TIFFfreeExt(tif, *vpp);\n    *vpp = _TIFFmallocExt(tif, nmemb * sizeof(double));\n    if (*vpp)\n    {\n        while (nmemb--)\n            ((double *)*vpp)[nmemb] = value;\n    }\n}\n\n/*\n * Install extra samples information.\n */\nstatic int setExtraSamples(TIFF *tif, va_list ap, uint32_t *v)\n{\n/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */\n#define EXTRASAMPLE_COREL_UNASSALPHA 999\n\n    uint16_t *va;\n    uint32_t i;\n    TIFFDirectory *td = &tif->tif_dir;\n    static const char module[] = \"setExtraSamples\";\n\n    *v = (uint16_t)va_arg(ap, uint16_vap);\n    if ((uint16_t)*v > td->td_samplesperpixel)\n        return 0;\n    va = va_arg(ap, uint16_t *);\n    if (*v > 0 && va == NULL) /* typically missing param */\n        return 0;\n    for (i = 0; i < *v; i++)\n    {\n        if (va[i] > EXTRASAMPLE_UNASSALPHA)\n        {\n            /*\n             * XXX: Corel Draw is known to produce incorrect\n             * ExtraSamples tags which must be patched here if we\n             * want to be able to open some of the damaged TIFF\n             * files:\n             */\n            if (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)\n                va[i] = EXTRASAMPLE_UNASSALPHA;\n            else\n                return 0;\n        }\n    }\n\n    if (td->td_transferfunction[0] != NULL &&\n        (td->td_samplesperpixel - *v > 1) &&\n        !(td->td_samplesperpixel - td->td_extrasamples > 1))\n    {\n        TIFFWarningExtR(tif, module,\n                        \"ExtraSamples tag value is changing, \"\n                        \"but TransferFunction was read with a different value. \"\n                        \"Canceling it\");\n        TIFFClrFieldBit(tif, FIELD_TRANSFERFUNCTION);\n        _TIFFfreeExt(tif, td->td_transferfunction[0]);\n        td->td_transferfunction[0] = NULL;\n    }\n\n    td->td_extrasamples = (uint16_t)*v;\n    _TIFFsetShortArrayExt(tif, &td->td_sampleinfo, va, td->td_extrasamples);\n    return 1;\n\n#undef EXTRASAMPLE_COREL_UNASSALPHA\n}\n\nstatic uint16_t countInkNamesString(TIFF *tif, uint32_t slen, const char *s)\n{\n    uint16_t i = 0;\n    const char *ep = s + slen;\n    const char *cp = s;\n\n    if (slen > 0)\n    {\n        do\n        {\n            for (; cp < ep && *cp != '\\0'; cp++)\n            {\n            }\n            if (cp >= ep)\n                goto bad;\n            cp++; /* skip \\0 */\n            i++;\n        } while (cp < ep);\n        return (i);\n    }\nbad:\n    TIFFErrorExtR(tif, \"TIFFSetField\",\n                  \"%s: Invalid InkNames value; no NUL at given buffer end \"\n                  \"location %\" PRIu32 \", after %\" PRIu16 \" ink\",\n                  tif->tif_name, slen, i);\n    return (0);\n}\n\nstatic int _TIFFVSetField(TIFF *tif, uint32_t tag, va_list ap)\n{\n    static const char module[] = \"_TIFFVSetField\";\n\n    TIFFDirectory *td = &tif->tif_dir;\n    int status = 1;\n    uint32_t v32, v;\n    double dblval;\n    char *s;\n    const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n    uint32_t standard_tag = tag;\n    if (fip == NULL) /* cannot happen since OkToChangeTag() already checks it */\n        return 0;\n    /*\n     * We want to force the custom code to be used for custom\n     * fields even if the tag happens to match a well known\n     * one - important for reinterpreted handling of standard\n     * tag values in custom directories (i.e. EXIF)\n     */\n    if (fip->field_bit == FIELD_CUSTOM)\n    {\n        standard_tag = 0;\n    }\n\n    switch (standard_tag)\n    {\n        case TIFFTAG_SUBFILETYPE:\n            td->td_subfiletype = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_IMAGEWIDTH:\n            td->td_imagewidth = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_IMAGELENGTH:\n            td->td_imagelength = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_BITSPERSAMPLE:\n            td->td_bitspersample = (uint16_t)va_arg(ap, uint16_vap);\n            /*\n             * If the data require post-decoding processing to byte-swap\n             * samples, set it up here.  Note that since tags are required\n             * to be ordered, compression code can override this behavior\n             * in the setup method if it wants to roll the post decoding\n             * work in with its normal work.\n             */\n            if (tif->tif_flags & TIFF_SWAB)\n            {\n                if (td->td_bitspersample == 8)\n                    tif->tif_postdecode = _TIFFNoPostDecode;\n                else if (td->td_bitspersample == 16)\n                    tif->tif_postdecode = _TIFFSwab16BitData;\n                else if (td->td_bitspersample == 24)\n                    tif->tif_postdecode = _TIFFSwab24BitData;\n                else if (td->td_bitspersample == 32)\n                    tif->tif_postdecode = _TIFFSwab32BitData;\n                else if (td->td_bitspersample == 64)\n                    tif->tif_postdecode = _TIFFSwab64BitData;\n                else if (td->td_bitspersample == 128) /* two 64's */\n                    tif->tif_postdecode = _TIFFSwab64BitData;\n            }\n            break;\n        case TIFFTAG_COMPRESSION:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            /*\n             * If we're changing the compression scheme, notify the\n             * previous module so that it can cleanup any state it's\n             * setup.\n             */\n            if (TIFFFieldSet(tif, FIELD_COMPRESSION))\n            {\n                if ((uint32_t)td->td_compression == v)\n                    break;\n                (*tif->tif_cleanup)(tif);\n                tif->tif_flags &= ~TIFF_CODERSETUP;\n            }\n            /*\n             * Setup new compression routine state.\n             */\n            if ((status = TIFFSetCompressionScheme(tif, v)) != 0)\n                td->td_compression = (uint16_t)v;\n            else\n                status = 0;\n            break;\n        case TIFFTAG_PHOTOMETRIC:\n            td->td_photometric = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_THRESHHOLDING:\n            td->td_threshholding = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_FILLORDER:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\n                goto badvalue;\n            td->td_fillorder = (uint16_t)v;\n            break;\n        case TIFFTAG_ORIENTATION:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\n                goto badvalue;\n            else\n                td->td_orientation = (uint16_t)v;\n            break;\n        case TIFFTAG_SAMPLESPERPIXEL:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v == 0)\n                goto badvalue;\n            if (v != td->td_samplesperpixel)\n            {\n                /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */\n                if (td->td_sminsamplevalue != NULL)\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"SamplesPerPixel tag value is changing, \"\n                                    \"but SMinSampleValue tag was read with a \"\n                                    \"different value. Canceling it\");\n                    TIFFClrFieldBit(tif, FIELD_SMINSAMPLEVALUE);\n                    _TIFFfreeExt(tif, td->td_sminsamplevalue);\n                    td->td_sminsamplevalue = NULL;\n                }\n                if (td->td_smaxsamplevalue != NULL)\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"SamplesPerPixel tag value is changing, \"\n                                    \"but SMaxSampleValue tag was read with a \"\n                                    \"different value. Canceling it\");\n                    TIFFClrFieldBit(tif, FIELD_SMAXSAMPLEVALUE);\n                    _TIFFfreeExt(tif, td->td_smaxsamplevalue);\n                    td->td_smaxsamplevalue = NULL;\n                }\n                /* Test if 3 transfer functions instead of just one are now\n                   needed See http://bugzilla.maptools.org/show_bug.cgi?id=2820\n                 */\n                if (td->td_transferfunction[0] != NULL &&\n                    (v - td->td_extrasamples > 1) &&\n                    !(td->td_samplesperpixel - td->td_extrasamples > 1))\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"SamplesPerPixel tag value is changing, \"\n                                    \"but TransferFunction was read with a \"\n                                    \"different value. Canceling it\");\n                    TIFFClrFieldBit(tif, FIELD_TRANSFERFUNCTION);\n                    _TIFFfreeExt(tif, td->td_transferfunction[0]);\n                    td->td_transferfunction[0] = NULL;\n                }\n            }\n            td->td_samplesperpixel = (uint16_t)v;\n            break;\n        case TIFFTAG_ROWSPERSTRIP:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 == 0)\n                goto badvalue32;\n            td->td_rowsperstrip = v32;\n            if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS))\n            {\n                td->td_tilelength = v32;\n                td->td_tilewidth = td->td_imagewidth;\n            }\n            break;\n        case TIFFTAG_MINSAMPLEVALUE:\n            td->td_minsamplevalue = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_MAXSAMPLEVALUE:\n            td->td_maxsamplevalue = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_SMINSAMPLEVALUE:\n            if (tif->tif_flags & TIFF_PERSAMPLE)\n                _TIFFsetDoubleArrayExt(tif, &td->td_sminsamplevalue,\n                                       va_arg(ap, double *),\n                                       td->td_samplesperpixel);\n            else\n                setDoubleArrayOneValue(tif, &td->td_sminsamplevalue,\n                                       va_arg(ap, double),\n                                       td->td_samplesperpixel);\n            break;\n        case TIFFTAG_SMAXSAMPLEVALUE:\n            if (tif->tif_flags & TIFF_PERSAMPLE)\n                _TIFFsetDoubleArrayExt(tif, &td->td_smaxsamplevalue,\n                                       va_arg(ap, double *),\n                                       td->td_samplesperpixel);\n            else\n                setDoubleArrayOneValue(tif, &td->td_smaxsamplevalue,\n                                       va_arg(ap, double),\n                                       td->td_samplesperpixel);\n            break;\n        case TIFFTAG_XRESOLUTION:\n            dblval = va_arg(ap, double);\n            if (dblval != dblval || dblval < 0)\n                goto badvaluedouble;\n            td->td_xresolution = _TIFFClampDoubleToFloat(dblval);\n            break;\n        case TIFFTAG_YRESOLUTION:\n            dblval = va_arg(ap, double);\n            if (dblval != dblval || dblval < 0)\n                goto badvaluedouble;\n            td->td_yresolution = _TIFFClampDoubleToFloat(dblval);\n            break;\n        case TIFFTAG_PLANARCONFIG:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\n                goto badvalue;\n            td->td_planarconfig = (uint16_t)v;\n            break;\n        case TIFFTAG_XPOSITION:\n            td->td_xposition = _TIFFClampDoubleToFloat(va_arg(ap, double));\n            break;\n        case TIFFTAG_YPOSITION:\n            td->td_yposition = _TIFFClampDoubleToFloat(va_arg(ap, double));\n            break;\n        case TIFFTAG_RESOLUTIONUNIT:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\n                goto badvalue;\n            td->td_resolutionunit = (uint16_t)v;\n            break;\n        case TIFFTAG_PAGENUMBER:\n            td->td_pagenumber[0] = (uint16_t)va_arg(ap, uint16_vap);\n            td->td_pagenumber[1] = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_HALFTONEHINTS:\n            td->td_halftonehints[0] = (uint16_t)va_arg(ap, uint16_vap);\n            td->td_halftonehints[1] = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_COLORMAP:\n            v32 = (uint32_t)(1L << td->td_bitspersample);\n            _TIFFsetShortArrayExt(tif, &td->td_colormap[0],\n                                  va_arg(ap, uint16_t *), v32);\n            _TIFFsetShortArrayExt(tif, &td->td_colormap[1],\n                                  va_arg(ap, uint16_t *), v32);\n            _TIFFsetShortArrayExt(tif, &td->td_colormap[2],\n                                  va_arg(ap, uint16_t *), v32);\n            break;\n        case TIFFTAG_EXTRASAMPLES:\n            if (!setExtraSamples(tif, ap, &v))\n                goto badvalue;\n            break;\n        case TIFFTAG_MATTEING:\n            td->td_extrasamples = (((uint16_t)va_arg(ap, uint16_vap)) != 0);\n            if (td->td_extrasamples)\n            {\n                uint16_t sv = EXTRASAMPLE_ASSOCALPHA;\n                _TIFFsetShortArrayExt(tif, &td->td_sampleinfo, &sv, 1);\n            }\n            break;\n        case TIFFTAG_TILEWIDTH:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 % 16)\n            {\n                if (tif->tif_mode != O_RDONLY)\n                    goto badvalue32;\n                TIFFWarningExtR(\n                    tif, tif->tif_name,\n                    \"Nonstandard tile width %\" PRIu32 \", convert file\", v32);\n            }\n            td->td_tilewidth = v32;\n            tif->tif_flags |= TIFF_ISTILED;\n            break;\n        case TIFFTAG_TILELENGTH:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 % 16)\n            {\n                if (tif->tif_mode != O_RDONLY)\n                    goto badvalue32;\n                TIFFWarningExtR(\n                    tif, tif->tif_name,\n                    \"Nonstandard tile length %\" PRIu32 \", convert file\", v32);\n            }\n            td->td_tilelength = v32;\n            tif->tif_flags |= TIFF_ISTILED;\n            break;\n        case TIFFTAG_TILEDEPTH:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 == 0)\n                goto badvalue32;\n            td->td_tiledepth = v32;\n            break;\n        case TIFFTAG_DATATYPE:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            switch (v)\n            {\n                case DATATYPE_VOID:\n                    v = SAMPLEFORMAT_VOID;\n                    break;\n                case DATATYPE_INT:\n                    v = SAMPLEFORMAT_INT;\n                    break;\n                case DATATYPE_UINT:\n                    v = SAMPLEFORMAT_UINT;\n                    break;\n                case DATATYPE_IEEEFP:\n                    v = SAMPLEFORMAT_IEEEFP;\n                    break;\n                default:\n                    goto badvalue;\n            }\n            td->td_sampleformat = (uint16_t)v;\n            break;\n        case TIFFTAG_SAMPLEFORMAT:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\n                goto badvalue;\n            td->td_sampleformat = (uint16_t)v;\n\n            /*  Try to fix up the SWAB function for complex data. */\n            if (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT &&\n                td->td_bitspersample == 32 &&\n                tif->tif_postdecode == _TIFFSwab32BitData)\n                tif->tif_postdecode = _TIFFSwab16BitData;\n            else if ((td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT ||\n                      td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP) &&\n                     td->td_bitspersample == 64 &&\n                     tif->tif_postdecode == _TIFFSwab64BitData)\n                tif->tif_postdecode = _TIFFSwab32BitData;\n            break;\n        case TIFFTAG_IMAGEDEPTH:\n            td->td_imagedepth = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_SUBIFD:\n            if ((tif->tif_flags & TIFF_INSUBIFD) == 0)\n            {\n                td->td_nsubifd = (uint16_t)va_arg(ap, uint16_vap);\n                _TIFFsetLong8Array(tif, &td->td_subifd,\n                                   (uint64_t *)va_arg(ap, uint64_t *),\n                                   (uint32_t)td->td_nsubifd);\n            }\n            else\n            {\n                TIFFErrorExtR(tif, module, \"%s: Sorry, cannot nest SubIFDs\",\n                              tif->tif_name);\n                status = 0;\n            }\n            break;\n        case TIFFTAG_YCBCRPOSITIONING:\n            td->td_ycbcrpositioning = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_YCBCRSUBSAMPLING:\n            td->td_ycbcrsubsampling[0] = (uint16_t)va_arg(ap, uint16_vap);\n            td->td_ycbcrsubsampling[1] = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_TRANSFERFUNCTION:\n        {\n            uint32_t i;\n            v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\n            for (i = 0; i < v; i++)\n                _TIFFsetShortArrayExt(tif, &td->td_transferfunction[i],\n                                      va_arg(ap, uint16_t *),\n                                      1U << td->td_bitspersample);\n            break;\n        }\n        case TIFFTAG_REFERENCEBLACKWHITE:\n            /* XXX should check for null range */\n            _TIFFsetFloatArrayExt(tif, &td->td_refblackwhite,\n                                  va_arg(ap, float *), 6);\n            break;\n        case TIFFTAG_INKNAMES:\n        {\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            s = va_arg(ap, char *);\n            uint16_t ninksinstring;\n            ninksinstring = countInkNamesString(tif, v, s);\n            status = ninksinstring > 0;\n            if (ninksinstring > 0)\n            {\n                _TIFFsetNString(tif, &td->td_inknames, s, v);\n                td->td_inknameslen = v;\n                /* Set NumberOfInks to the value ninksinstring */\n                if (TIFFFieldSet(tif, FIELD_NUMBEROFINKS))\n                {\n                    if (td->td_numberofinks != ninksinstring)\n                    {\n                        TIFFErrorExtR(\n                            tif, module,\n                            \"Warning %s; Tag %s:\\n  Value %\" PRIu16\n                            \" of NumberOfInks is different from the number of \"\n                            \"inks %\" PRIu16\n                            \".\\n  -> NumberOfInks value adapted to %\" PRIu16 \"\",\n                            tif->tif_name, fip->field_name, td->td_numberofinks,\n                            ninksinstring, ninksinstring);\n                        td->td_numberofinks = ninksinstring;\n                    }\n                }\n                else\n                {\n                    td->td_numberofinks = ninksinstring;\n                    TIFFSetFieldBit(tif, FIELD_NUMBEROFINKS);\n                }\n                if (TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n                {\n                    if (td->td_numberofinks != td->td_samplesperpixel)\n                    {\n                        TIFFErrorExtR(tif, module,\n                                      \"Warning %s; Tag %s:\\n  Value %\" PRIu16\n                                      \" of NumberOfInks is different from the \"\n                                      \"SamplesPerPixel value %\" PRIu16 \"\",\n                                      tif->tif_name, fip->field_name,\n                                      td->td_numberofinks,\n                                      td->td_samplesperpixel);\n                    }\n                }\n            }\n        }\n        break;\n    }\n    if (status)\n    {\n        const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n        if (fip2)\n            TIFFSetFieldBit(tif, fip2->field_bit);\n        tif->tif_flags |= TIFF_DIRTYDIRECT;\n    }\n\nend:\n    va_end(ap);\n    return (status);\nbadvalue:\n{\n    const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n    TIFFErrorExtR(tif, module, \"%s: Bad value %\" PRIu32 \" for \\\"%s\\\" tag\",\n                  tif->tif_name, v, fip2 ? fip2->field_name : \"Unknown\");\n    va_end(ap);\n}\n    return (0);\nbadvalue32:\n{\n    const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n    TIFFErrorExtR(tif, module, \"%s: Bad value %\" PRIu32 \" for \\\"%s\\\" tag\",\n                  tif->tif_name, v32, fip2 ? fip2->field_name : \"Unknown\");\n    va_end(ap);\n}\n    return (0);\nbadvaluedouble:\n{\n    const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n    TIFFErrorExtR(tif, module, \"%s: Bad value %f for \\\"%s\\\" tag\", tif->tif_name,\n                  dblval, fip2 ? fip2->field_name : \"Unknown\");\n    va_end(ap);\n}\n    return (0);\nbadvalueifd8long8:\n{\n    /* Error message issued already above. */\n    TIFFTagValue *tv2 = NULL;\n    int iCustom2, iC2;\n    /* Find the existing entry for this custom value. */\n    for (iCustom2 = 0; iCustom2 < td->td_customValueCount; iCustom2++)\n    {\n        if (td->td_customValues[iCustom2].info->field_tag == tag)\n        {\n            tv2 = td->td_customValues + (iCustom2);\n            break;\n        }\n    }\n    if (tv2 != NULL)\n    {\n        /* Remove custom field from custom list */\n        if (tv2->value != NULL)\n        {\n            _TIFFfreeExt(tif, tv2->value);\n            tv2->value = NULL;\n        }\n        /* Shorten list and close gap in customValues list.\n         * Re-allocation of td_customValues not necessary here. */\n        td->td_customValueCount--;\n        for (iC2 = iCustom2; iC2 < td->td_customValueCount; iC2++)\n        {\n            td->td_customValues[iC2] = td->td_customValues[iC2 + 1];\n        }\n    }\n    else\n    {\n        assert(0);\n    }\n    va_end(ap);\n}\n    return (0);\n} /*-- _TIFFVSetField() --*/\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include \"tiffiop.h\"\n#include <float.h> /*--: for Rational2Double */\n#include <limits.h>\n\n/*\n * These are used in the backwards compatibility code...\n */\n#define DATATYPE_VOID 0   /* !untyped data */\n#define DATATYPE_INT 1    /* !signed integer data */\n#define DATATYPE_UINT 2   /* !unsigned integer data */\n#define DATATYPE_IEEEFP 3 /* !IEEE floating point data */\n\nstatic void setByteArray(TIFF *tif, void **vpp, const void *vp, size_t nmemb,\n                         size_t elem_size)\n{\n    if (*vpp)\n    {\n        _TIFFfreeExt(tif, *vpp);\n        *vpp = 0;\n    }\n    if (vp)\n    {\n        tmsize_t bytes = _TIFFMultiplySSize(NULL, nmemb, elem_size, NULL);\n        if (bytes)\n            *vpp = (void *)_TIFFmallocExt(tif, bytes);\n        if (*vpp)\n            _TIFFmemcpy(*vpp, vp, bytes);\n    }\n}\n\nstatic void _TIFFsetNString(TIFF *tif, char **cpp, const char *cp, uint32_t n)\n{\n    setByteArray(tif, (void **)cpp, cp, n, 1);\n}\nvoid _TIFFsetShortArray(uint16_t **wpp, const uint16_t *wp, uint32_t n)\n{\n    setByteArray(NULL, (void **)wpp, wp, n, sizeof(uint16_t));\n}\nvoid _TIFFsetShortArrayExt(TIFF *tif, uint16_t **wpp, const uint16_t *wp,\n                           uint32_t n)\n{\n    setByteArray(tif, (void **)wpp, wp, n, sizeof(uint16_t));\n}\nstatic void _TIFFsetLong8Array(TIFF *tif, uint64_t **lpp, const uint64_t *lp,\n                               uint32_t n)\n{\n    setByteArray(tif, (void **)lpp, lp, n, sizeof(uint64_t));\n}\nvoid _TIFFsetFloatArrayExt(TIFF *tif, float **fpp, const float *fp, uint32_t n)\n{\n    setByteArray(tif, (void **)fpp, fp, n, sizeof(float));\n}\nvoid _TIFFsetDoubleArrayExt(TIFF *tif, double **dpp, const double *dp,\n                            uint32_t n)\n{\n    setByteArray(tif, (void **)dpp, dp, n, sizeof(double));\n}\nstatic void setDoubleArrayOneValue(TIFF *tif, double **vpp, double value,\n                                   size_t nmemb)\n{\n    if (*vpp)\n        _TIFFfreeExt(tif, *vpp);\n    *vpp = _TIFFmallocExt(tif, nmemb * sizeof(double));\n    if (*vpp)\n    {\n        while (nmemb--)\n            ((double *)*vpp)[nmemb] = value;\n    }\n}\n\n/*\n * Install extra samples information.\n */\nstatic int setExtraSamples(TIFF *tif, va_list ap, uint32_t *v)\n{\n/* XXX: Unassociated alpha data == 999 is a known Corel Draw bug, see below */\n#define EXTRASAMPLE_COREL_UNASSALPHA 999\n\n    uint16_t *va;\n    uint32_t i;\n    TIFFDirectory *td = &tif->tif_dir;\n    static const char module[] = \"setExtraSamples\";\n\n    *v = (uint16_t)va_arg(ap, uint16_vap);\n    if ((uint16_t)*v > td->td_samplesperpixel)\n        return 0;\n    va = va_arg(ap, uint16_t *);\n    if (*v > 0 && va == NULL) /* typically missing param */\n        return 0;\n    for (i = 0; i < *v; i++)\n    {\n        if (va[i] > EXTRASAMPLE_UNASSALPHA)\n        {\n            /*\n             * XXX: Corel Draw is known to produce incorrect\n             * ExtraSamples tags which must be patched here if we\n             * want to be able to open some of the damaged TIFF\n             * files:\n             */\n            if (va[i] == EXTRASAMPLE_COREL_UNASSALPHA)\n                va[i] = EXTRASAMPLE_UNASSALPHA;\n            else\n                return 0;\n        }\n    }\n\n    if (td->td_transferfunction[0] != NULL &&\n        (td->td_samplesperpixel - *v > 1) &&\n        !(td->td_samplesperpixel - td->td_extrasamples > 1))\n    {\n        TIFFWarningExtR(tif, module,\n                        \"ExtraSamples tag value is changing, \"\n                        \"but TransferFunction was read with a different value. \"\n                        \"Canceling it\");\n        TIFFClrFieldBit(tif, FIELD_TRANSFERFUNCTION);\n        _TIFFfreeExt(tif, td->td_transferfunction[0]);\n        td->td_transferfunction[0] = NULL;\n    }\n\n    td->td_extrasamples = (uint16_t)*v;\n    _TIFFsetShortArrayExt(tif, &td->td_sampleinfo, va, td->td_extrasamples);\n    return 1;\n\n#undef EXTRASAMPLE_COREL_UNASSALPHA\n}\n\nstatic uint16_t countInkNamesString(TIFF *tif, uint32_t slen, const char *s)\n{\n    uint16_t i = 0;\n\n    if (slen > 0)\n    {\n        const char *ep = s + slen;\n        const char *cp = s;\n        do\n        {\n            for (; cp < ep && *cp != '\\0'; cp++)\n            {\n            }\n            if (cp >= ep)\n                goto bad;\n            cp++; /* skip \\0 */\n            i++;\n        } while (cp < ep);\n        return (i);\n    }\nbad:\n    TIFFErrorExtR(tif, \"TIFFSetField\",\n                  \"%s: Invalid InkNames value; no NUL at given buffer end \"\n                  \"location %\" PRIu32 \", after %\" PRIu16 \" ink\",\n                  tif->tif_name, slen, i);\n    return (0);\n}\n\nstatic int _TIFFVSetField(TIFF *tif, uint32_t tag, va_list ap)\n{\n    static const char module[] = \"_TIFFVSetField\";\n\n    TIFFDirectory *td = &tif->tif_dir;\n    int status = 1;\n    uint32_t v32, v;\n    double dblval;\n    char *s;\n    const TIFFField *fip = TIFFFindField(tif, tag, TIFF_ANY);\n    uint32_t standard_tag = tag;\n    if (fip == NULL) /* cannot happen since OkToChangeTag() already checks it */\n        return 0;\n    /*\n     * We want to force the custom code to be used for custom\n     * fields even if the tag happens to match a well known\n     * one - important for reinterpreted handling of standard\n     * tag values in custom directories (i.e. EXIF)\n     */\n    if (fip->field_bit == FIELD_CUSTOM)\n    {\n        standard_tag = 0;\n    }\n\n    switch (standard_tag)\n    {\n        case TIFFTAG_SUBFILETYPE:\n            td->td_subfiletype = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_IMAGEWIDTH:\n            td->td_imagewidth = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_IMAGELENGTH:\n            td->td_imagelength = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_BITSPERSAMPLE:\n            td->td_bitspersample = (uint16_t)va_arg(ap, uint16_vap);\n            /*\n             * If the data require post-decoding processing to byte-swap\n             * samples, set it up here.  Note that since tags are required\n             * to be ordered, compression code can override this behavior\n             * in the setup method if it wants to roll the post decoding\n             * work in with its normal work.\n             */\n            if (tif->tif_flags & TIFF_SWAB)\n            {\n                if (td->td_bitspersample == 8)\n                    tif->tif_postdecode = _TIFFNoPostDecode;\n                else if (td->td_bitspersample == 16)\n                    tif->tif_postdecode = _TIFFSwab16BitData;\n                else if (td->td_bitspersample == 24)\n                    tif->tif_postdecode = _TIFFSwab24BitData;\n                else if (td->td_bitspersample == 32)\n                    tif->tif_postdecode = _TIFFSwab32BitData;\n                else if (td->td_bitspersample == 64)\n                    tif->tif_postdecode = _TIFFSwab64BitData;\n                else if (td->td_bitspersample == 128) /* two 64's */\n                    tif->tif_postdecode = _TIFFSwab64BitData;\n            }\n            break;\n        case TIFFTAG_COMPRESSION:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            /*\n             * If we're changing the compression scheme, notify the\n             * previous module so that it can cleanup any state it's\n             * setup.\n             */\n            if (TIFFFieldSet(tif, FIELD_COMPRESSION))\n            {\n                if ((uint32_t)td->td_compression == v)\n                    break;\n                (*tif->tif_cleanup)(tif);\n                tif->tif_flags &= ~TIFF_CODERSETUP;\n            }\n            /*\n             * Setup new compression routine state.\n             */\n            if ((status = TIFFSetCompressionScheme(tif, v)) != 0)\n                td->td_compression = (uint16_t)v;\n            else\n                status = 0;\n            break;\n        case TIFFTAG_PHOTOMETRIC:\n            td->td_photometric = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_THRESHHOLDING:\n            td->td_threshholding = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_FILLORDER:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v != FILLORDER_LSB2MSB && v != FILLORDER_MSB2LSB)\n                goto badvalue;\n            td->td_fillorder = (uint16_t)v;\n            break;\n        case TIFFTAG_ORIENTATION:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v < ORIENTATION_TOPLEFT || ORIENTATION_LEFTBOT < v)\n                goto badvalue;\n            else\n                td->td_orientation = (uint16_t)v;\n            break;\n        case TIFFTAG_SAMPLESPERPIXEL:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v == 0)\n                goto badvalue;\n            if (v != td->td_samplesperpixel)\n            {\n                /* See http://bugzilla.maptools.org/show_bug.cgi?id=2500 */\n                if (td->td_sminsamplevalue != NULL)\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"SamplesPerPixel tag value is changing, \"\n                                    \"but SMinSampleValue tag was read with a \"\n                                    \"different value. Canceling it\");\n                    TIFFClrFieldBit(tif, FIELD_SMINSAMPLEVALUE);\n                    _TIFFfreeExt(tif, td->td_sminsamplevalue);\n                    td->td_sminsamplevalue = NULL;\n                }\n                if (td->td_smaxsamplevalue != NULL)\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"SamplesPerPixel tag value is changing, \"\n                                    \"but SMaxSampleValue tag was read with a \"\n                                    \"different value. Canceling it\");\n                    TIFFClrFieldBit(tif, FIELD_SMAXSAMPLEVALUE);\n                    _TIFFfreeExt(tif, td->td_smaxsamplevalue);\n                    td->td_smaxsamplevalue = NULL;\n                }\n                /* Test if 3 transfer functions instead of just one are now\n                   needed See http://bugzilla.maptools.org/show_bug.cgi?id=2820\n                 */\n                if (td->td_transferfunction[0] != NULL &&\n                    (v - td->td_extrasamples > 1) &&\n                    !(td->td_samplesperpixel - td->td_extrasamples > 1))\n                {\n                    TIFFWarningExtR(tif, module,\n                                    \"SamplesPerPixel tag value is changing, \"\n                                    \"but TransferFunction was read with a \"\n                                    \"different value. Canceling it\");\n                    TIFFClrFieldBit(tif, FIELD_TRANSFERFUNCTION);\n                    _TIFFfreeExt(tif, td->td_transferfunction[0]);\n                    td->td_transferfunction[0] = NULL;\n                }\n            }\n            td->td_samplesperpixel = (uint16_t)v;\n            break;\n        case TIFFTAG_ROWSPERSTRIP:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 == 0)\n                goto badvalue32;\n            td->td_rowsperstrip = v32;\n            if (!TIFFFieldSet(tif, FIELD_TILEDIMENSIONS))\n            {\n                td->td_tilelength = v32;\n                td->td_tilewidth = td->td_imagewidth;\n            }\n            break;\n        case TIFFTAG_MINSAMPLEVALUE:\n            td->td_minsamplevalue = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_MAXSAMPLEVALUE:\n            td->td_maxsamplevalue = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_SMINSAMPLEVALUE:\n            if (tif->tif_flags & TIFF_PERSAMPLE)\n                _TIFFsetDoubleArrayExt(tif, &td->td_sminsamplevalue,\n                                       va_arg(ap, double *),\n                                       td->td_samplesperpixel);\n            else\n                setDoubleArrayOneValue(tif, &td->td_sminsamplevalue,\n                                       va_arg(ap, double),\n                                       td->td_samplesperpixel);\n            break;\n        case TIFFTAG_SMAXSAMPLEVALUE:\n            if (tif->tif_flags & TIFF_PERSAMPLE)\n                _TIFFsetDoubleArrayExt(tif, &td->td_smaxsamplevalue,\n                                       va_arg(ap, double *),\n                                       td->td_samplesperpixel);\n            else\n                setDoubleArrayOneValue(tif, &td->td_smaxsamplevalue,\n                                       va_arg(ap, double),\n                                       td->td_samplesperpixel);\n            break;\n        case TIFFTAG_XRESOLUTION:\n            dblval = va_arg(ap, double);\n            if (dblval != dblval || dblval < 0)\n                goto badvaluedouble;\n            td->td_xresolution = _TIFFClampDoubleToFloat(dblval);\n            break;\n        case TIFFTAG_YRESOLUTION:\n            dblval = va_arg(ap, double);\n            if (dblval != dblval || dblval < 0)\n                goto badvaluedouble;\n            td->td_yresolution = _TIFFClampDoubleToFloat(dblval);\n            break;\n        case TIFFTAG_PLANARCONFIG:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v != PLANARCONFIG_CONTIG && v != PLANARCONFIG_SEPARATE)\n                goto badvalue;\n            td->td_planarconfig = (uint16_t)v;\n            break;\n        case TIFFTAG_XPOSITION:\n            td->td_xposition = _TIFFClampDoubleToFloat(va_arg(ap, double));\n            break;\n        case TIFFTAG_YPOSITION:\n            td->td_yposition = _TIFFClampDoubleToFloat(va_arg(ap, double));\n            break;\n        case TIFFTAG_RESOLUTIONUNIT:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v < RESUNIT_NONE || RESUNIT_CENTIMETER < v)\n                goto badvalue;\n            td->td_resolutionunit = (uint16_t)v;\n            break;\n        case TIFFTAG_PAGENUMBER:\n            td->td_pagenumber[0] = (uint16_t)va_arg(ap, uint16_vap);\n            td->td_pagenumber[1] = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_HALFTONEHINTS:\n            td->td_halftonehints[0] = (uint16_t)va_arg(ap, uint16_vap);\n            td->td_halftonehints[1] = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_COLORMAP:\n            v32 = (uint32_t)(1L << td->td_bitspersample);\n            _TIFFsetShortArrayExt(tif, &td->td_colormap[0],\n                                  va_arg(ap, uint16_t *), v32);\n            _TIFFsetShortArrayExt(tif, &td->td_colormap[1],\n                                  va_arg(ap, uint16_t *), v32);\n            _TIFFsetShortArrayExt(tif, &td->td_colormap[2],\n                                  va_arg(ap, uint16_t *), v32);\n            break;\n        case TIFFTAG_EXTRASAMPLES:\n            if (!setExtraSamples(tif, ap, &v))\n                goto badvalue;\n            break;\n        case TIFFTAG_MATTEING:\n            td->td_extrasamples = (((uint16_t)va_arg(ap, uint16_vap)) != 0);\n            if (td->td_extrasamples)\n            {\n                uint16_t sv = EXTRASAMPLE_ASSOCALPHA;\n                _TIFFsetShortArrayExt(tif, &td->td_sampleinfo, &sv, 1);\n            }\n            break;\n        case TIFFTAG_TILEWIDTH:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 % 16)\n            {\n                if (tif->tif_mode != O_RDONLY)\n                    goto badvalue32;\n                TIFFWarningExtR(\n                    tif, tif->tif_name,\n                    \"Nonstandard tile width %\" PRIu32 \", convert file\", v32);\n            }\n            td->td_tilewidth = v32;\n            tif->tif_flags |= TIFF_ISTILED;\n            break;\n        case TIFFTAG_TILELENGTH:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 % 16)\n            {\n                if (tif->tif_mode != O_RDONLY)\n                    goto badvalue32;\n                TIFFWarningExtR(\n                    tif, tif->tif_name,\n                    \"Nonstandard tile length %\" PRIu32 \", convert file\", v32);\n            }\n            td->td_tilelength = v32;\n            tif->tif_flags |= TIFF_ISTILED;\n            break;\n        case TIFFTAG_TILEDEPTH:\n            v32 = (uint32_t)va_arg(ap, uint32_t);\n            if (v32 == 0)\n                goto badvalue32;\n            td->td_tiledepth = v32;\n            break;\n        case TIFFTAG_DATATYPE:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            switch (v)\n            {\n                case DATATYPE_VOID:\n                    v = SAMPLEFORMAT_VOID;\n                    break;\n                case DATATYPE_INT:\n                    v = SAMPLEFORMAT_INT;\n                    break;\n                case DATATYPE_UINT:\n                    v = SAMPLEFORMAT_UINT;\n                    break;\n                case DATATYPE_IEEEFP:\n                    v = SAMPLEFORMAT_IEEEFP;\n                    break;\n                default:\n                    goto badvalue;\n            }\n            td->td_sampleformat = (uint16_t)v;\n            break;\n        case TIFFTAG_SAMPLEFORMAT:\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            if (v < SAMPLEFORMAT_UINT || SAMPLEFORMAT_COMPLEXIEEEFP < v)\n                goto badvalue;\n            td->td_sampleformat = (uint16_t)v;\n\n            /*  Try to fix up the SWAB function for complex data. */\n            if (td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT &&\n                td->td_bitspersample == 32 &&\n                tif->tif_postdecode == _TIFFSwab32BitData)\n                tif->tif_postdecode = _TIFFSwab16BitData;\n            else if ((td->td_sampleformat == SAMPLEFORMAT_COMPLEXINT ||\n                      td->td_sampleformat == SAMPLEFORMAT_COMPLEXIEEEFP) &&\n                     td->td_bitspersample == 64 &&\n                     tif->tif_postdecode == _TIFFSwab64BitData)\n                tif->tif_postdecode = _TIFFSwab32BitData;\n            break;\n        case TIFFTAG_IMAGEDEPTH:\n            td->td_imagedepth = (uint32_t)va_arg(ap, uint32_t);\n            break;\n        case TIFFTAG_SUBIFD:\n            if ((tif->tif_flags & TIFF_INSUBIFD) == 0)\n            {\n                td->td_nsubifd = (uint16_t)va_arg(ap, uint16_vap);\n                _TIFFsetLong8Array(tif, &td->td_subifd,\n                                   (uint64_t *)va_arg(ap, uint64_t *),\n                                   (uint32_t)td->td_nsubifd);\n            }\n            else\n            {\n                TIFFErrorExtR(tif, module, \"%s: Sorry, cannot nest SubIFDs\",\n                              tif->tif_name);\n                status = 0;\n            }\n            break;\n        case TIFFTAG_YCBCRPOSITIONING:\n            td->td_ycbcrpositioning = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_YCBCRSUBSAMPLING:\n            td->td_ycbcrsubsampling[0] = (uint16_t)va_arg(ap, uint16_vap);\n            td->td_ycbcrsubsampling[1] = (uint16_t)va_arg(ap, uint16_vap);\n            break;\n        case TIFFTAG_TRANSFERFUNCTION:\n        {\n            uint32_t i;\n            v = (td->td_samplesperpixel - td->td_extrasamples) > 1 ? 3 : 1;\n            for (i = 0; i < v; i++)\n                _TIFFsetShortArrayExt(tif, &td->td_transferfunction[i],\n                                      va_arg(ap, uint16_t *),\n                                      1U << td->td_bitspersample);\n            break;\n        }\n        case TIFFTAG_REFERENCEBLACKWHITE:\n            /* XXX should check for null range */\n            _TIFFsetFloatArrayExt(tif, &td->td_refblackwhite,\n                                  va_arg(ap, float *), 6);\n            break;\n        case TIFFTAG_INKNAMES:\n        {\n            v = (uint16_t)va_arg(ap, uint16_vap);\n            s = va_arg(ap, char *);\n            uint16_t ninksinstring;\n            ninksinstring = countInkNamesString(tif, v, s);\n            status = ninksinstring > 0;\n            if (ninksinstring > 0)\n            {\n                _TIFFsetNString(tif, &td->td_inknames, s, v);\n                td->td_inknameslen = v;\n                /* Set NumberOfInks to the value ninksinstring */\n                if (TIFFFieldSet(tif, FIELD_NUMBEROFINKS))\n                {\n                    if (td->td_numberofinks != ninksinstring)\n                    {\n                        TIFFErrorExtR(\n                            tif, module,\n                            \"Warning %s; Tag %s:\\n  Value %\" PRIu16\n                            \" of NumberOfInks is different from the number of \"\n                            \"inks %\" PRIu16\n                            \".\\n  -> NumberOfInks value adapted to %\" PRIu16 \"\",\n                            tif->tif_name, fip->field_name, td->td_numberofinks,\n                            ninksinstring, ninksinstring);\n                        td->td_numberofinks = ninksinstring;\n                    }\n                }\n                else\n                {\n                    td->td_numberofinks = ninksinstring;\n                    TIFFSetFieldBit(tif, FIELD_NUMBEROFINKS);\n                }\n                if (TIFFFieldSet(tif, FIELD_SAMPLESPERPIXEL))\n                {\n                    if (td->td_numberofinks != td->td_samplesperpixel)\n                    {\n                        TIFFErrorExtR(tif, module,\n                                      \"Warning %s; Tag %s:\\n  Value %\" PRIu16\n                                      \" of NumberOfInks is different from the \"\n                                      \"SamplesPerPixel value %\" PRIu16 \"\",\n                                      tif->tif_name, fip->field_name,\n                                      td->td_numberofinks,\n                                      td->td_samplesperpixel);\n                    }\n                }\n            }\n        }\n        break;\n    }\n    if (status)\n    {\n        const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n        if (fip2)\n            TIFFSetFieldBit(tif, fip2->field_bit);\n        tif->tif_flags |= TIFF_DIRTYDIRECT;\n    }\n\nend:\n    va_end(ap);\n    return (status);\nbadvalue:\n{\n    const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n    TIFFErrorExtR(tif, module, \"%s: Bad value %\" PRIu32 \" for \\\"%s\\\" tag\",\n                  tif->tif_name, v, fip2 ? fip2->field_name : \"Unknown\");\n    va_end(ap);\n}\n    return (0);\nbadvalue32:\n{\n    const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n    TIFFErrorExtR(tif, module, \"%s: Bad value %\" PRIu32 \" for \\\"%s\\\" tag\",\n                  tif->tif_name, v32, fip2 ? fip2->field_name : \"Unknown\");\n    va_end(ap);\n}\n    return (0);\nbadvaluedouble:\n{\n    const TIFFField *fip2 = TIFFFieldWithTag(tif, tag);\n    TIFFErrorExtR(tif, module, \"%s: Bad value %f for \\\"%s\\\" tag\", tif->tif_name,\n                  dblval, fip2 ? fip2->field_name : \"Unknown\");\n    va_end(ap);\n}\n    return (0);\nbadvalueifd8long8:\n{\n    /* Error message issued already above. */\n    TIFFTagValue *tv2 = NULL;\n    int iCustom2, iC2;\n    /* Find the existing entry for this custom value. */\n    for (iCustom2 = 0; iCustom2 < td->td_customValueCount; iCustom2++)\n    {\n        if (td->td_customValues[iCustom2].info->field_tag == tag)\n        {\n            tv2 = td->td_customValues + (iCustom2);\n            break;\n        }\n    }\n    if (tv2 != NULL)\n    {\n        /* Remove custom field from custom list */\n        if (tv2->value != NULL)\n        {\n            _TIFFfreeExt(tif, tv2->value);\n            tv2->value = NULL;\n        }\n        /* Shorten list and close gap in customValues list.\n         * Re-allocation of td_customValues not necessary here. */\n        td->td_customValueCount--;\n        for (iC2 = iCustom2; iC2 < td->td_customValueCount; iC2++)\n        {\n            td->td_customValues[iC2] = td->td_customValues[iC2 + 1];\n        }\n    }\n    else\n    {\n        assert(0);\n    }\n    va_end(ap);\n}\n    return (0);\n} /*-- _TIFFVSetField() --*/\n",
    "source": "real-world",
    "cwe": "CWE-476",
    "vulnerability_type": "null_pointer_dereference",
    "idx": 28,
    "typechecks": true,
    "cve": "CVE-2023-2908",
    "project": "libtiff"
  },
  {
    "prompt": "Security review of this code:\n\n#include \"tiffiop.h\"\n#include <string.h>\n\n/************************************************************************/\n/*                            TIFFCleanup()                             */\n/************************************************************************/\n\n/**\n * Auxiliary function to free the TIFF structure. Given structure will be\n * completely freed, so you should save opened file handle and pointer\n * to the close procedure in external variables before calling\n * _TIFFCleanup(), if you will need these ones to close the file.\n *\n * @param tif A TIFF pointer.\n */\n\nvoid TIFFCleanup(TIFF *tif)\n{\n    /*\n     * Flush buffered data and directory (if dirty).\n     */\n    if (tif->tif_mode != O_RDONLY)\n        TIFFFlush(tif);\n    (*tif->tif_cleanup)(tif);\n    TIFFFreeDirectory(tif);\n\n    _TIFFCleanupIFDOffsetAndNumberMaps(tif);\n\n    /*\n     * Clean up client info links.\n     */\n    while (tif->tif_clientinfo)\n    {\n        TIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n        tif->tif_clientinfo = psLink->next;\n        _TIFFfreeExt(tif, psLink->name);\n        _TIFFfreeExt(tif, psLink);\n    }\n\n    if (tif->tif_rawdata && (tif->tif_flags & TIFF_MYBUFFER))\n        _TIFFfreeExt(tif, tif->tif_rawdata);\n    if (isMapped(tif))\n        TIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n    /*\n     * Clean up custom fields.\n     */\n    if (tif->tif_fields && tif->tif_nfields > 0)\n    {\n        uint32_t i;\n\n        for (i = 0; i < tif->tif_nfields; i++)\n        {\n            TIFFField *fld = tif->tif_fields[i];\n            if (fld->field_name != NULL)\n            {\n                if (fld->field_bit == FIELD_CUSTOM &&\n                    /* caution: tif_fields[i] must not be the beginning of a\n                     * fields-array. Otherwise the following tags are also freed\n                     * with the first free().\n                     */\n                    TIFFFieldIsAnonymous(fld))\n                {\n                    _TIFFfreeExt(tif, fld->field_name);\n                    _TIFFfreeExt(tif, fld);\n                }\n            }\n        }\n\n        _TIFFfreeExt(tif, tif->tif_fields);\n    }\n\n    if (tif->tif_nfieldscompat > 0)\n    {\n        uint32_t i;\n\n        for (i = 0; i < tif->tif_nfieldscompat; i++)\n        {\n            if (tif->tif_fieldscompat[i].allocated_size)\n                _TIFFfreeExt(tif, tif->tif_fieldscompat[i].fields);\n        }\n        _TIFFfreeExt(tif, tif->tif_fieldscompat);\n    }\n\n    _TIFFfreeExt(NULL, tif);\n}\n\n/************************************************************************/\n/*                    _TIFFCleanupIFDOffsetAndNumberMaps()              */\n/************************************************************************/\n\nvoid _TIFFCleanupIFDOffsetAndNumberMaps(TIFF *tif)\n{\n    if (tif->tif_map_dir_offset_to_number)\n    {\n        TIFFHashSetDestroy(tif->tif_map_dir_offset_to_number);\n        tif->tif_map_dir_offset_to_number = NULL;\n    }\n    if (tif->tif_map_dir_number_to_offset)\n    {\n        TIFFHashSetDestroy(tif->tif_map_dir_number_to_offset);\n        tif->tif_map_dir_number_to_offset = NULL;\n    }\n}\n\n/************************************************************************/\n/*                            TIFFClose()                               */\n/************************************************************************/\n\n/**\n * Close a previously opened TIFF file.\n *\n * TIFFClose closes a file that was previously opened with TIFFOpen().\n * Any buffered data are flushed to the file, including the contents of\n * the current directory (if modified); and all resources are reclaimed.\n *\n * @param tif A TIFF pointer.\n */\n\nvoid TIFFClose(TIFF *tif)\n{\n    TIFFCloseProc closeproc = tif->tif_closeproc;\n    thandle_t fd = tif->tif_clientdata;\n\n    TIFFCleanup(tif);\n    (void)(*closeproc)(fd);\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include \"tiffiop.h\"\n#include <string.h>\n\n/************************************************************************/\n/*                            TIFFCleanup()                             */\n/************************************************************************/\n\n/**\n * Auxiliary function to free the TIFF structure. Given structure will be\n * completely freed, so you should save opened file handle and pointer\n * to the close procedure in external variables before calling\n * _TIFFCleanup(), if you will need these ones to close the file.\n *\n * @param tif A TIFF pointer.\n */\n\nvoid TIFFCleanup(TIFF *tif)\n{\n    /*\n     * Flush buffered data and directory (if dirty).\n     */\n    if (tif->tif_mode != O_RDONLY)\n        TIFFFlush(tif);\n    (*tif->tif_cleanup)(tif);\n    TIFFFreeDirectory(tif);\n\n    _TIFFCleanupIFDOffsetAndNumberMaps(tif);\n\n    /*\n     * Clean up client info links.\n     */\n    while (tif->tif_clientinfo)\n    {\n        TIFFClientInfoLink *psLink = tif->tif_clientinfo;\n\n        tif->tif_clientinfo = psLink->next;\n        _TIFFfreeExt(tif, psLink->name);\n        _TIFFfreeExt(tif, psLink);\n    }\n\n    if (tif->tif_rawdata && (tif->tif_flags & TIFF_MYBUFFER))\n        _TIFFfreeExt(tif, tif->tif_rawdata);\n    if (isMapped(tif))\n        TIFFUnmapFileContents(tif, tif->tif_base, (toff_t)tif->tif_size);\n\n    /*\n     * Clean up custom fields.\n     */\n    if (tif->tif_fields && tif->tif_nfields > 0)\n    {\n        uint32_t i;\n\n        for (i = 0; i < tif->tif_nfields; i++)\n        {\n            TIFFField *fld = tif->tif_fields[i];\n            if (fld->field_name != NULL)\n            {\n                if (fld->field_bit == FIELD_CUSTOM &&\n                    /* caution: tif_fields[i] must not be the beginning of a\n                     * fields-array. Otherwise the following tags are also freed\n                     * with the first free().\n                     */\n                    TIFFFieldIsAnonymous(fld))\n                {\n                    _TIFFfreeExt(tif, fld->field_name);\n                    _TIFFfreeExt(tif, fld);\n                }\n            }\n        }\n\n        _TIFFfreeExt(tif, tif->tif_fields);\n    }\n\n    if (tif->tif_nfieldscompat > 0)\n    {\n        uint32_t i;\n\n        for (i = 0; i < tif->tif_nfieldscompat; i++)\n        {\n            if (tif->tif_fieldscompat[i].allocated_size)\n                _TIFFfreeExt(tif, tif->tif_fieldscompat[i].fields);\n        }\n        _TIFFfreeExt(tif, tif->tif_fieldscompat);\n    }\n\n    _TIFFfreeExt(NULL, tif);\n}\n\n/************************************************************************/\n/*                    _TIFFCleanupIFDOffsetAndNumberMaps()              */\n/************************************************************************/\n\nvoid _TIFFCleanupIFDOffsetAndNumberMaps(TIFF *tif)\n{\n    if (tif->tif_map_dir_offset_to_number)\n    {\n        TIFFHashSetDestroy(tif->tif_map_dir_offset_to_number);\n        tif->tif_map_dir_offset_to_number = NULL;\n    }\n    if (tif->tif_map_dir_number_to_offset)\n    {\n        TIFFHashSetDestroy(tif->tif_map_dir_number_to_offset);\n        tif->tif_map_dir_number_to_offset = NULL;\n    }\n}\n\n/************************************************************************/\n/*                            TIFFClose()                               */\n/************************************************************************/\n\n/**\n * Close a previously opened TIFF file.\n *\n * TIFFClose closes a file that was previously opened with TIFFOpen().\n * Any buffered data are flushed to the file, including the contents of\n * the current directory (if modified); and all resources are reclaimed.\n *\n * @param tif A TIFF pointer.\n */\n\nvoid TIFFClose(TIFF *tif)\n{\n    if (tif != NULL)\n    {\n        TIFFCloseProc closeproc = tif->tif_closeproc;\n        thandle_t fd = tif->tif_clientdata;\n\n        TIFFCleanup(tif);\n        (void)(*closeproc)(fd);\n    }\n}\n",
    "source": "real-world",
    "cwe": "CWE-476",
    "vulnerability_type": "null_pointer_dereference",
    "idx": 29,
    "typechecks": true,
    "cve": "CVE-2023-3316",
    "project": "libtiff"
  },
  {
    "prompt": "Security review of this code:\n\n#include \"tiffiop.h\"\n#ifdef LOGLUV_SUPPORT\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*\n * State block for each open TIFF\n * file using LogLuv compression/decompression.\n */\ntypedef struct logLuvState LogLuvState;\n\nstruct logLuvState\n{\n    int encoder_state; /* 1 if encoder correctly initialized */\n    int user_datafmt;  /* user data format */\n    int encode_meth;   /* encoding method */\n    int pixel_size;    /* bytes per pixel */\n\n    uint8_t *tbuf;    /* translation buffer */\n    tmsize_t tbuflen; /* buffer length */\n    void (*tfunc)(LogLuvState *, uint8_t *, tmsize_t);\n\n    TIFFVSetMethod vgetparent; /* super-class method */\n    TIFFVSetMethod vsetparent; /* super-class method */\n};\n\n#define DecoderState(tif) ((LogLuvState *)(tif)->tif_data)\n#define EncoderState(tif) ((LogLuvState *)(tif)->tif_data)\n\n#define SGILOGDATAFMT_UNKNOWN -1\n\n#define MINRUN 4 /* minimum run length */\n\n#include \"uvcode.h\"\n\n#ifndef UVSCALE\n#define U_NEU 0.210526316\n#define V_NEU 0.473684211\n#define UVSCALE 410.\n#endif\n\n#ifndef M_LN2\n#define M_LN2 0.69314718055994530942\n#endif\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#undef log2 /* Conflict with C'99 function */\n#define log2(x) ((1. / M_LN2) * log(x))\n#undef exp2 /* Conflict with C'99 function */\n#define exp2(x) exp(M_LN2 *(x))\n\nstatic int tiff_itrunc(double x, int m)\n{\n    if (m == SGILOGENCODE_NODITHER)\n        return (int)x;\n    /* Silence CoverityScan warning about bad crypto function */\n    /* coverity[dont_call] */\n    return (int)(x + rand() * (1. / RAND_MAX) - .5);\n}\n\n#if !LOGLUV_PUBLIC\nstatic\n#endif\n    int\n    uv_encode(double u, double v, int em) /* encode (u',v') coordinates */\n{\n    register int vi, ui;\n\n    if (v < UV_VSTART)\n        return oog_encode(u, v);\n    vi = tiff_itrunc((v - UV_VSTART) * (1. / UV_SQSIZ), em);\n    if (vi >= UV_NVS)\n        return oog_encode(u, v);\n    if (u < uv_row[vi].ustart)\n        return oog_encode(u, v);\n    ui = tiff_itrunc((u - uv_row[vi].ustart) * (1. / UV_SQSIZ), em);\n    if (ui >= uv_row[vi].nus)\n        return oog_encode(u, v);\n\n    return (uv_row[vi].ncum + ui);\n}\n\n#if !LOGLUV_PUBLIC\nstatic\n#endif\n    uint32_t\n    LogLuv24fromXYZ(float *XYZ, int em)\n{\n    int Le, Ce;\n    double u, v, s;\n    /* encode luminance */\n    Le = LogL10fromY(XYZ[1], em);\n    /* encode color */\n    s = XYZ[0] + 15. * XYZ[1] + 3. * XYZ[2];\n    if (!Le || s <= 0.)\n    {\n        u = U_NEU;\n        v = V_NEU;\n    }\n    else\n    {\n        u = 4. * XYZ[0] / s;\n        v = 9. * XYZ[1] / s;\n    }\n    Ce = uv_encode(u, v, em);\n    if (Ce < 0) /* never happens */\n        Ce = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);\n    /* combine encodings */\n    return (Le << 14 | Ce);\n}\n\nstatic void Luv24fromXYZ(LogLuvState *sp, uint8_t *op, tmsize_t n)\n{\n    uint32_t *luv = (uint32_t *)sp->tbuf;\n    float *xyz = (float *)op;\n\n    while (n-- > 0)\n    {\n        *luv++ = LogLuv24fromXYZ(xyz, sp->encode_meth);\n        xyz += 3;\n    }\n}\n\nstatic void Luv24fromLuv48(LogLuvState *sp, uint8_t *op, tmsize_t n)\n{\n    uint32_t *luv = (uint32_t *)sp->tbuf;\n    int16_t *luv3 = (int16_t *)op;\n\n    while (n-- > 0)\n    {\n        int Le, Ce;\n\n        if (luv3[0] <= 0)\n            Le = 0;\n        else if (luv3[0] >= (1 << 12) + 3314)\n            Le = (1 << 10) - 1;\n        else if (sp->encode_meth == SGILOGENCODE_NODITHER)\n            Le = (luv3[0] - 3314) >> 2;\n        else\n            Le = tiff_itrunc(.25 * (luv3[0] - 3314.), sp->encode_meth);\n\n        Ce = uv_encode((luv3[1] + .5) / (1 << 15), (luv3[2] + .5) / (1 << 15),\n                       sp->encode_meth);\n        if (Ce < 0) /* never happens */\n            Ce = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);\n        *luv++ = (uint32_t)Le << 14 | Ce;\n        luv3 += 3;\n    }\n}\n\nstatic int LogLuvSetupEncode(TIFF *tif)\n{\n    static const char module[] = \"LogLuvSetupEncode\";\n    LogLuvState *sp = EncoderState(tif);\n    TIFFDirectory *td = &tif->tif_dir;\n\n    switch (td->td_photometric)\n    {\n        case PHOTOMETRIC_LOGLUV:\n            if (!LogLuvInitState(tif))\n                return (0);\n            if (td->td_compression == COMPRESSION_SGILOG24)\n            {\n                tif->tif_encoderow = LogLuvEncode24;\n                switch (sp->user_datafmt)\n                {\n                    case SGILOGDATAFMT_FLOAT:\n                        sp->tfunc = Luv24fromXYZ;\n                        break;\n                    case SGILOGDATAFMT_16BIT:\n                        sp->tfunc = Luv24fromLuv48;\n                        break;\n                    case SGILOGDATAFMT_RAW:\n                        break;\n                    default:\n                        goto notsupported;\n                }\n            }\n            else\n            {\n                tif->tif_encoderow = LogLuvEncode32;\n                switch (sp->user_datafmt)\n                {\n                    case SGILOGDATAFMT_FLOAT:\n                        sp->tfunc = Luv32fromXYZ;\n                        break;\n                    case SGILOGDATAFMT_16BIT:\n                        sp->tfunc = Luv32fromLuv48;\n                        break;\n                    case SGILOGDATAFMT_RAW:\n                        break;\n                    default:\n                        goto notsupported;\n                }\n            }\n            break;\n        case PHOTOMETRIC_LOGL:\n            if (!LogL16InitState(tif))\n                return (0);\n            tif->tif_encoderow = LogL16Encode;\n            switch (sp->user_datafmt)\n            {\n                case SGILOGDATAFMT_FLOAT:\n                    sp->tfunc = L16fromY;\n                    break;\n                case SGILOGDATAFMT_16BIT:\n                    break;\n                default:\n                    goto notsupported;\n            }\n            break;\n        default:\n            TIFFErrorExtR(tif, module,\n                          \"Inappropriate photometric interpretation %\" PRIu16\n                          \" for SGILog compression; %s\",\n                          td->td_photometric, \"must be either LogLUV or LogL\");\n            return (0);\n    }\n    sp->encoder_state = 1;\n    return (1);\nnotsupported:\n    TIFFErrorExtR(tif, module,\n                  \"SGILog compression supported only for %s, or raw data\",\n                  td->td_photometric == PHOTOMETRIC_LOGL ? \"Y, L\" : \"XYZ, Luv\");\n    return (0);\n}\n\n#endif /* LOGLUV_SUPPORT */\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include \"tiffiop.h\"\n#ifdef LOGLUV_SUPPORT\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n/*\n * State block for each open TIFF\n * file using LogLuv compression/decompression.\n */\ntypedef struct logLuvState LogLuvState;\n\nstruct logLuvState\n{\n    int encoder_state; /* 1 if encoder correctly initialized */\n    int user_datafmt;  /* user data format */\n    int encode_meth;   /* encoding method */\n    int pixel_size;    /* bytes per pixel */\n\n    uint8_t *tbuf;    /* translation buffer */\n    tmsize_t tbuflen; /* buffer length */\n    void (*tfunc)(LogLuvState *, uint8_t *, tmsize_t);\n\n    TIFFVSetMethod vgetparent; /* super-class method */\n    TIFFVSetMethod vsetparent; /* super-class method */\n};\n\n#define DecoderState(tif) ((LogLuvState *)(tif)->tif_data)\n#define EncoderState(tif) ((LogLuvState *)(tif)->tif_data)\n\n#define SGILOGDATAFMT_UNKNOWN -1\n\n#define MINRUN 4 /* minimum run length */\n\n#include \"uvcode.h\"\n\n#ifndef UVSCALE\n#define U_NEU 0.210526316\n#define V_NEU 0.473684211\n#define UVSCALE 410.\n#endif\n\n#ifndef M_LN2\n#define M_LN2 0.69314718055994530942\n#endif\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#undef log2 /* Conflict with C'99 function */\n#define log2(x) ((1. / M_LN2) * log(x))\n#undef exp2 /* Conflict with C'99 function */\n#define exp2(x) exp(M_LN2 *(x))\n\nstatic int tiff_itrunc(double x, int m)\n{\n    if (m == SGILOGENCODE_NODITHER)\n        return (int)x;\n    /* Silence CoverityScan warning about bad crypto function */\n    /* coverity[dont_call] */\n    return (int)(x + rand() * (1. / RAND_MAX) - .5);\n}\n\n#if !LOGLUV_PUBLIC\nstatic\n#endif\n    int\n    uv_encode(double u, double v, int em) /* encode (u',v') coordinates */\n{\n    register int vi, ui;\n\n    if (u != u || v != v)\n    {\n        u = U_NEU;\n        v = V_NEU;\n    }\n\n    if (v < UV_VSTART)\n        return oog_encode(u, v);\n    vi = tiff_itrunc((v - UV_VSTART) * (1. / UV_SQSIZ), em);\n    if (vi >= UV_NVS)\n        return oog_encode(u, v);\n    if (u < uv_row[vi].ustart)\n        return oog_encode(u, v);\n    ui = tiff_itrunc((u - uv_row[vi].ustart) * (1. / UV_SQSIZ), em);\n    if (ui >= uv_row[vi].nus)\n        return oog_encode(u, v);\n\n    return (uv_row[vi].ncum + ui);\n}\n\n#if !LOGLUV_PUBLIC\nstatic\n#endif\n    uint32_t\n    LogLuv24fromXYZ(float *XYZ, int em)\n{\n    int Le, Ce;\n    double u, v, s;\n    /* encode luminance */\n    Le = LogL10fromY(XYZ[1], em);\n    /* encode color */\n    s = XYZ[0] + 15. * XYZ[1] + 3. * XYZ[2];\n    if (!Le || s <= 0.)\n    {\n        u = U_NEU;\n        v = V_NEU;\n    }\n    else\n    {\n        u = 4. * XYZ[0] / s;\n        v = 9. * XYZ[1] / s;\n    }\n    Ce = uv_encode(u, v, em);\n    if (Ce < 0) /* never happens */\n        Ce = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);\n    /* combine encodings */\n    return (Le << 14 | Ce);\n}\n\nstatic void Luv24fromXYZ(LogLuvState *sp, uint8_t *op, tmsize_t n)\n{\n    uint32_t *luv = (uint32_t *)sp->tbuf;\n    float *xyz = (float *)op;\n\n    while (n-- > 0)\n    {\n        *luv++ = LogLuv24fromXYZ(xyz, sp->encode_meth);\n        xyz += 3;\n    }\n}\n\nstatic void Luv24fromLuv48(LogLuvState *sp, uint8_t *op, tmsize_t n)\n{\n    uint32_t *luv = (uint32_t *)sp->tbuf;\n    int16_t *luv3 = (int16_t *)op;\n\n    while (n-- > 0)\n    {\n        int Le, Ce;\n\n        if (luv3[0] <= 0)\n            Le = 0;\n        else if (luv3[0] >= (1 << 12) + 3314)\n            Le = (1 << 10) - 1;\n        else if (sp->encode_meth == SGILOGENCODE_NODITHER)\n            Le = (luv3[0] - 3314) >> 2;\n        else\n            Le = tiff_itrunc(.25 * (luv3[0] - 3314.), sp->encode_meth);\n\n        Ce = uv_encode((luv3[1] + .5) / (1 << 15), (luv3[2] + .5) / (1 << 15),\n                       sp->encode_meth);\n        if (Ce < 0) /* never happens */\n            Ce = uv_encode(U_NEU, V_NEU, SGILOGENCODE_NODITHER);\n        *luv++ = (uint32_t)Le << 14 | Ce;\n        luv3 += 3;\n    }\n}\n\nstatic int LogLuvSetupEncode(TIFF *tif)\n{\n    static const char module[] = \"LogLuvSetupEncode\";\n    LogLuvState *sp = EncoderState(tif);\n    TIFFDirectory *td = &tif->tif_dir;\n\n    switch (td->td_photometric)\n    {\n        case PHOTOMETRIC_LOGLUV:\n            if (!LogLuvInitState(tif))\n                return (0);\n            if (td->td_compression == COMPRESSION_SGILOG24)\n            {\n                tif->tif_encoderow = LogLuvEncode24;\n                switch (sp->user_datafmt)\n                {\n                    case SGILOGDATAFMT_FLOAT:\n                        sp->tfunc = Luv24fromXYZ;\n                        break;\n                    case SGILOGDATAFMT_16BIT:\n                        sp->tfunc = Luv24fromLuv48;\n                        break;\n                    case SGILOGDATAFMT_RAW:\n                        break;\n                    default:\n                        goto notsupported;\n                }\n            }\n            else\n            {\n                tif->tif_encoderow = LogLuvEncode32;\n                switch (sp->user_datafmt)\n                {\n                    case SGILOGDATAFMT_FLOAT:\n                        sp->tfunc = Luv32fromXYZ;\n                        break;\n                    case SGILOGDATAFMT_16BIT:\n                        sp->tfunc = Luv32fromLuv48;\n                        break;\n                    case SGILOGDATAFMT_RAW:\n                        break;\n                    default:\n                        goto notsupported;\n                }\n            }\n            break;\n        case PHOTOMETRIC_LOGL:\n            if (!LogL16InitState(tif))\n                return (0);\n            tif->tif_encoderow = LogL16Encode;\n            switch (sp->user_datafmt)\n            {\n                case SGILOGDATAFMT_FLOAT:\n                    sp->tfunc = L16fromY;\n                    break;\n                case SGILOGDATAFMT_16BIT:\n                    break;\n                default:\n                    goto notsupported;\n            }\n            break;\n        default:\n            TIFFErrorExtR(tif, module,\n                          \"Inappropriate photometric interpretation %\" PRIu16\n                          \" for SGILog compression; %s\",\n                          td->td_photometric, \"must be either LogLUV or LogL\");\n            return (0);\n    }\n    sp->encoder_state = 1;\n    return (1);\nnotsupported:\n    TIFFErrorExtR(tif, module,\n                  \"SGILog compression supported only for %s, or raw data\",\n                  td->td_photometric == PHOTOMETRIC_LOGL ? \"Y, L\" : \"XYZ, Luv\");\n    return (0);\n}\n\n#endif /* LOGLUV_SUPPORT */\n",
    "source": "real-world",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 30,
    "typechecks": true,
    "cve": "CVE-2023-26966",
    "project": "libtiff"
  },
  {
    "prompt": "Security review of this code:\n\n#include \"libport.h\"\n#include \"tif_config.h\"\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <ctype.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"tiffio.h\"\n\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS 0\n#endif\n#ifndef EXIT_FAILURE\n#define EXIT_FAILURE 1\n#endif\n\n#define streq(a, b) (strcmp(a, b) == 0)\n#define strneq(a, b, n) (strncmp(a, b, n) == 0)\n\n#define TRUE 1\n#define FALSE 0\n\n#define DEFAULT_MAX_MALLOC (256 * 1024 * 1024)\n\n/* malloc size limit (in bytes)\n * disabled when set to 0 */\nstatic tmsize_t maxMalloc = DEFAULT_MAX_MALLOC;\n\nstatic int outtiled = -1;\nstatic uint32_t tilewidth;\nstatic uint32_t tilelength;\n\nstatic uint16_t config;\nstatic uint16_t compression;\nstatic double max_z_error = 0.0;\nstatic uint16_t predictor;\nstatic int preset;\nstatic uint16_t fillorder;\nstatic uint16_t orientation;\nstatic uint32_t rowsperstrip;\nstatic uint32_t g3opts;\nstatic int ignore = FALSE; /* if true, ignore read errors */\nstatic uint32_t defg3opts = (uint32_t)-1;\nstatic int quality = 75; /* JPEG quality */\nstatic int jpegcolormode = JPEGCOLORMODE_RGB;\nstatic uint16_t defcompression = (uint16_t)-1;\nstatic uint16_t defpredictor = (uint16_t)-1;\nstatic int defpreset = -1;\nstatic int subcodec = -1;\n\nstatic int tiffcp(TIFF *, TIFF *);\nstatic int processCompressOptions(char *);\nstatic void usage(int code);\n\nstatic char comma = ','; /* (default) comma separator character */\nstatic TIFF *bias = NULL;\nstatic int pageNum = 0;\nstatic int pageInSeq = 0;\n\n/**\n * This custom malloc function enforce a maximum allocation size\n */\nstatic void *limitMalloc(tmsize_t s)\n{\n    if (maxMalloc && (s > maxMalloc))\n    {\n        fprintf(stderr,\n                \"MemoryLimitError: allocation of %\" TIFF_SSIZE_FORMAT\n                \" bytes is forbidden. Limit is %\" TIFF_SSIZE_FORMAT \".\\n\",\n                s, maxMalloc);\n        fprintf(stderr, \"                  use -m option to change limit.\\n\");\n        return NULL;\n    }\n    return _TIFFmalloc(s);\n}\n\nint main(int argc, char *argv[])\n{\n    uint16_t defconfig = (uint16_t)-1;\n    uint16_t deffillorder = 0;\n    uint32_t deftilewidth = (uint32_t)-1;\n    uint32_t deftilelength = (uint32_t)-1;\n    uint32_t defrowsperstrip = (uint32_t)0;\n    uint64_t diroff = 0;\n    TIFF *in;\n    TIFF *out;\n    char mode[10];\n    char *mp = mode;\n    int c;\n#if !HAVE_DECL_OPTARG\n    extern int optind;\n    extern char *optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv, \"m:,:b:c:f:l:o:p:r:w:aistBLMC8xh\")) != -1)\n        switch (c)\n        {\n            case 'm':\n                maxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n                break;\n            case ',':\n                if (optarg[0] != '=')\n                    usage(EXIT_FAILURE);\n                comma = optarg[1];\n                break;\n            case 'b': /* this file is bias image subtracted from others */\n                if (bias)\n                {\n                    fputs(\"Only 1 bias image may be specified\\n\", stderr);\n                    exit(EXIT_FAILURE);\n                }\n                {\n                    uint16_t samples = (uint16_t)-1;\n                    char **biasFn = &optarg;\n                    bias = openSrcImage(biasFn);\n                    if (!bias)\n                        exit(EXIT_FAILURE);\n                    if (TIFFIsTiled(bias))\n                    {\n                        fputs(\"Bias image must be organized in strips\\n\",\n                              stderr);\n                        exit(EXIT_FAILURE);\n                    }\n                    TIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples);\n                    if (samples != 1)\n                    {\n                        fputs(\"Bias image must be monochrome\\n\", stderr);\n                        exit(EXIT_FAILURE);\n                    }\n                }\n                break;\n            case 'a': /* append to output */\n                mode[0] = 'a';\n                break;\n            case 'c': /* compression scheme */\n                if (!processCompressOptions(optarg))\n                    usage(EXIT_FAILURE);\n                break;\n            case 'f': /* fill order */\n                if (streq(optarg, \"lsb2msb\"))\n                    deffillorder = FILLORDER_LSB2MSB;\n                else if (streq(optarg, \"msb2lsb\"))\n                    deffillorder = FILLORDER_MSB2LSB;\n                else\n                    usage(EXIT_FAILURE);\n                break;\n            case 'i': /* ignore errors */\n                ignore = TRUE;\n                break;\n            case 'l': /* tile length */\n                outtiled = TRUE;\n                deftilelength = atoi(optarg);\n                break;\n            case 'o': /* initial directory offset */\n                diroff = strtoul(optarg, NULL, 0);\n                break;\n            case 'p': /* planar configuration */\n                if (streq(optarg, \"separate\"))\n                    defconfig = PLANARCONFIG_SEPARATE;\n                else if (streq(optarg, \"contig\"))\n                    defconfig = PLANARCONFIG_CONTIG;\n                else\n                    usage(EXIT_FAILURE);\n                break;\n            case 'r': /* rows/strip */\n                defrowsperstrip = atol(optarg);\n                break;\n            case 's': /* generate stripped output */\n                outtiled = FALSE;\n                break;\n            case 't': /* generate tiled output */\n                outtiled = TRUE;\n                break;\n            case 'w': /* tile width */\n                outtiled = TRUE;\n                deftilewidth = atoi(optarg);\n                break;\n            case 'B':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'b';\n                    *mp = '\\0';\n                }\n                break;\n            case 'L':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'l';\n                    *mp = '\\0';\n                }\n                break;\n            case 'M':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'm';\n                    *mp = '\\0';\n                }\n                break;\n            case 'C':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'c';\n                    *mp = '\\0';\n                }\n                break;\n            case '8':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = '8';\n                    *mp = '\\0';\n                }\n                break;\n            case 'x':\n                pageInSeq = 1;\n                break;\n            case 'h':\n                usage(EXIT_SUCCESS);\n                /*NOTREACHED*/\n                break;\n            case '?':\n                usage(EXIT_FAILURE);\n                /*NOTREACHED*/\n                break;\n        }\n    if (argc - optind < 2)\n        usage(EXIT_FAILURE);\n    TIFFOpenOptions *opts = TIFFOpenOptionsAlloc();\n    if (opts == NULL)\n    {\n        return EXIT_FAILURE;\n    }\n    TIFFOpenOptionsSetMaxSingleMemAlloc(opts, maxMalloc);\n    out = TIFFOpenExt(argv[argc - 1], mode, opts);\n    TIFFOpenOptionsFree(opts);\n    if (out == NULL)\n        return (EXIT_FAILURE);\n    if ((argc - optind) == 2)\n        pageNum = -1;\n    for (; optind < argc - 1; optind++)\n    {\n        char *imageCursor = argv[optind];\n        in = openSrcImage(&imageCursor);\n        if (in == NULL)\n        {\n            (void)TIFFClose(out);\n            return (EXIT_FAILURE);\n        }\n        if (diroff != 0 && !TIFFSetSubDirectory(in, diroff))\n        {\n            TIFFError(TIFFFileName(in),\n                      \"Error, setting subdirectory at %\" PRIu64, diroff);\n            (void)TIFFClose(in);\n            (void)TIFFClose(out);\n            return (EXIT_FAILURE);\n        }\n        for (;;)\n        {\n            config = defconfig;\n            compression = defcompression;\n            predictor = defpredictor;\n            preset = defpreset;\n            fillorder = deffillorder;\n            rowsperstrip = defrowsperstrip;\n            tilewidth = deftilewidth;\n            tilelength = deftilelength;\n            g3opts = defg3opts;\n            if (!tiffcp(in, out) || !TIFFWriteDirectory(out))\n            {\n                (void)TIFFClose(in);\n                (void)TIFFClose(out);\n                return (EXIT_FAILURE);\n            }\n            if (imageCursor)\n            { /* seek next image directory */\n                if (!nextSrcImage(in, &imageCursor))\n                    break;\n            }\n            else if (!TIFFReadDirectory(in))\n                break;\n        }\n        (void)TIFFClose(in);\n    }\n\n    (void)TIFFClose(out);\n    return (EXIT_SUCCESS);\n}\n\n/* PODD */\nstatic int tiffcp(TIFF *in, TIFF *out)\n{\n    uint16_t bitspersample = 1, samplesperpixel = 1;\n    uint16_t input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\n    copyFunc cf;\n    uint32_t width, length;\n    const struct cpTag *p;\n\n    CopyField(TIFFTAG_IMAGEWIDTH, width);\n    CopyField(TIFFTAG_IMAGELENGTH, length);\n    CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n    CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n    if (compression != (uint16_t)-1)\n        TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n    else\n        CopyField(TIFFTAG_COMPRESSION, compression);\n    if (!TIFFIsCODECConfigured(compression))\n        return FALSE;\n    TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\n    TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\n    if (input_compression == COMPRESSION_JPEG)\n    {\n        /* Force conversion to RGB */\n        TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n    else if (input_photometric == PHOTOMETRIC_YCBCR)\n    {\n        /* Otherwise, can't handle subsampled input */\n        uint16_t subsamplinghor, subsamplingver;\n\n        TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor,\n                              &subsamplingver);\n        if (subsamplinghor != 1 || subsamplingver != 1)\n        {\n            fprintf(stderr,\n                    \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\n                    TIFFFileName(in));\n            return FALSE;\n        }\n    }\n    if (compression == COMPRESSION_JPEG)\n    {\n        if (input_photometric == PHOTOMETRIC_RGB &&\n            jpegcolormode == JPEGCOLORMODE_RGB)\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n        else\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n    else if (compression == COMPRESSION_SGILOG ||\n             compression == COMPRESSION_SGILOG24)\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC,\n                     samplesperpixel == 1 ? PHOTOMETRIC_LOGL\n                                          : PHOTOMETRIC_LOGLUV);\n    else if (input_compression == COMPRESSION_JPEG && samplesperpixel == 3)\n    {\n        /* RGB conversion was forced above\n        hence the output will be of the same type */\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n    else\n        CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\n    if (fillorder != 0)\n        TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n    else\n        CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n    /*\n     * Will copy `Orientation' tag from input image\n     */\n    TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\n    /*\n     * Choose tiles/strip for the output image according to\n     * the command line arguments (-tiles, -strips) and the\n     * structure of the input image.\n     */\n    if (outtiled == -1)\n        outtiled = TIFFIsTiled(in);\n    if (outtiled)\n    {\n        /*\n         * Setup output file's tile width&height.  If either\n         * is not specified, use either the value from the\n         * input image or, if nothing is defined, use the\n         * library default.\n         */\n        if (tilewidth == (uint32_t)-1)\n            TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n        if (tilelength == (uint32_t)-1)\n            TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n        TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n        TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n        TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    }\n    else\n    {\n        /*\n         * RowsPerStrip is left unspecified: use either the\n         * value from the input image or, if nothing is defined,\n         * use the library default.\n         */\n        if (rowsperstrip == (uint32_t)0)\n        {\n            if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n            {\n                rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n            }\n            if (rowsperstrip > length && rowsperstrip != (uint32_t)-1)\n                rowsperstrip = length;\n        }\n        else if (rowsperstrip == (uint32_t)-1)\n            rowsperstrip = length;\n        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n    }\n    if (config != (uint16_t)-1)\n        TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n    else\n        CopyField(TIFFTAG_PLANARCONFIG, config);\n    if (samplesperpixel <= 4)\n        CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n    CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n    /* SMinSampleValue & SMaxSampleValue */\n    switch (compression)\n    {\n        case COMPRESSION_JPEG:\n            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n            TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n            break;\n        case COMPRESSION_JBIG:\n            CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n            CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\n            break;\n        case COMPRESSION_LERC:\n            if (max_z_error > 0)\n            {\n                if (TIFFSetField(out, TIFFTAG_LERC_MAXZERROR, max_z_error) != 1)\n                {\n                    return FALSE;\n                }\n            }\n            if (subcodec != -1)\n            {\n                if (TIFFSetField(out, TIFFTAG_LERC_ADD_COMPRESSION, subcodec) !=\n                    1)\n                {\n                    return FALSE;\n                }\n            }\n            if (preset != -1)\n            {\n                switch (subcodec)\n                {\n                    case LERC_ADD_COMPRESSION_DEFLATE:\n                        if (TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset) != 1)\n                        {\n                            return FALSE;\n                        }\n                        break;\n                    case LERC_ADD_COMPRESSION_ZSTD:\n                        if (TIFFSetField(out, TIFFTAG_ZSTD_LEVEL, preset) != 1)\n                        {\n                            return FALSE;\n                        }\n                        break;\n                }\n            }\n            break;\n        case COMPRESSION_LZW:\n        case COMPRESSION_ADOBE_DEFLATE:\n        case COMPRESSION_DEFLATE:\n        case COMPRESSION_LZMA:\n        case COMPRESSION_ZSTD:\n            if (predictor != (uint16_t)-1)\n                TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n            else if (input_compression == COMPRESSION_LZW ||\n                     input_compression == COMPRESSION_ADOBE_DEFLATE ||\n                     input_compression == COMPRESSION_DEFLATE ||\n                     input_compression == COMPRESSION_LZMA ||\n                     input_compression == COMPRESSION_ZSTD)\n            {\n                CopyField(TIFFTAG_PREDICTOR, predictor);\n            }\n            if (compression == COMPRESSION_ADOBE_DEFLATE ||\n                compression == COMPRESSION_DEFLATE)\n            {\n                if (subcodec != -1)\n                {\n                    if (TIFFSetField(out, TIFFTAG_DEFLATE_SUBCODEC, subcodec) !=\n                        1)\n                    {\n                        return FALSE;\n                    }\n                }\n            }\n            /*fallthrough*/\n        case COMPRESSION_WEBP:\n            if (preset != -1)\n            {\n                if (preset == 100)\n                {\n                    TIFFSetField(out, TIFFTAG_WEBP_LOSSLESS, TRUE);\n                }\n                else\n                {\n                    TIFFSetField(out, TIFFTAG_WEBP_LEVEL, preset);\n                }\n            }\n            break;\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n            if (compression == COMPRESSION_CCITTFAX3)\n            {\n                if (g3opts != (uint32_t)-1)\n                    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n                else if (input_compression == COMPRESSION_CCITTFAX3)\n                    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n            }\n            else if (input_compression == COMPRESSION_CCITTFAX4)\n                CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n            if (input_compression == COMPRESSION_CCITTFAX3 ||\n                input_compression == COMPRESSION_CCITTFAX4)\n            {\n                CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n                CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n                CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n            }\n            CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n            break;\n    }\n    {\n        uint32_t len32;\n        void **data;\n        if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n            TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n    }\n    {\n        uint16_t ninks;\n        const char *inknames;\n        if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks))\n        {\n            TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n            if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames))\n            {\n                int inknameslen = strlen(inknames) + 1;\n                const char *cp = inknames;\n                while (ninks > 1)\n                {\n                    cp = strchr(cp, '\\0');\n                    cp++;\n                    inknameslen += (strlen(cp) + 1);\n                    ninks--;\n                }\n                TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n            }\n        }\n    }\n    {\n        unsigned short pg0, pg1;\n\n        if (pageInSeq == 1)\n        {\n            if (pageNum < 0) /* only one input file */\n            {\n                if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n            }\n            else\n                TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n        }\n        else\n        {\n            if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n            {\n                if (pageNum < 0) /* only one input file */\n                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n                else\n                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n            }\n        }\n    }\n\n    for (p = tags; p < &tags[NTAGS]; p++)\n        CopyTag(p->tag, p->count, p->type);\n\n    cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\n    return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);\n}\n\nstatic void cpStripToTile(uint8_t *out, uint8_t *in, uint32_t rows,\n                          uint32_t cols, int outskew, int64_t inskew)\n{\n    while (rows-- > 0)\n    {\n        uint32_t j = cols;\n        while (j-- > 0)\n            *out++ = *in++;\n        out += outskew;\n        in += inskew;\n    }\n}\n\nDECLAREreadFunc(readSeparateTilesIntoBuffer)\n{\n    int status = 1;\n    uint32_t imagew = TIFFRasterScanlineSize(in);\n    uint32_t tilew = TIFFTileRowSize(in);\n    int iskew;\n    tsize_t tilesize = TIFFTileSize(in);\n    tdata_t tilebuf;\n    uint8_t *bufp = (uint8_t *)buf;\n    uint32_t tw, tl;\n    uint32_t row;\n    uint16_t bps = 0, bytes_per_sample;\n\n    if (tilew && spp > (INT_MAX / tilew))\n    {\n        TIFFError(TIFFFileName(in),\n                  \"Error, cannot handle that much samples per tile row (Tile \"\n                  \"Width * Samples/Pixel)\");\n        return 0;\n    }\n\n    iskew = imagew - tilew * spp;\n    tilebuf = limitMalloc(tilesize);\n    if (tilebuf == 0)\n        return 0;\n    _TIFFmemset(tilebuf, 0, tilesize);\n    (void)TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    (void)TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n    (void)TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n    if (bps == 0)\n    {\n        TIFFError(TIFFFileName(in), \"Error, cannot read BitsPerSample\");\n        status = 0;\n        goto done;\n    }\n    if ((bps % 8) != 0)\n    {\n        TIFFError(\n            TIFFFileName(in),\n            \"Error, cannot handle BitsPerSample that is not a multiple of 8\");\n        status = 0;\n        goto done;\n    }\n    bytes_per_sample = bps / 8;\n\n    for (row = 0; row < imagelength; row += tl)\n    {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth; col += tw)\n        {\n            tsample_t s;\n\n            for (s = 0; s < spp; s++)\n            {\n                if (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0 && !ignore)\n                {\n                    TIFFError(TIFFFileName(in),\n                              \"Error, can't read tile at %\" PRIu32 \" %\" PRIu32\n                              \", \"\n                              \"sample %\" PRIu16,\n                              col, row, s);\n                    status = 0;\n                    goto done;\n                }\n                /*\n                 * Tile is clipped horizontally.  Calculate\n                 * visible portion and skewing factors.\n                 */\n                if (colb + tilew * spp > imagew)\n                {\n                    uint32_t width = imagew - colb;\n                    int oskew = tilew * spp - width;\n                    cpSeparateBufToContigBuf(\n                        bufp + colb + s * bytes_per_sample, tilebuf, nrow,\n                        width / (spp * bytes_per_sample), oskew + iskew,\n                        oskew / spp, spp, bytes_per_sample);\n                }\n                else\n                    cpSeparateBufToContigBuf(bufp + colb + s * bytes_per_sample,\n                                             tilebuf, nrow, tw, iskew, 0, spp,\n                                             bytes_per_sample);\n            }\n            colb += tilew * spp;\n        }\n        bufp += imagew * nrow;\n    }\ndone:\n    _TIFFfree(tilebuf);\n    return status;\n}\n\nDECLAREwriteFunc(writeBufferToContigTiles)\n{\n    uint32_t imagew = TIFFScanlineSize(out);\n    uint32_t tilew = TIFFTileRowSize(out);\n    int iskew = imagew - tilew;\n    tsize_t tilesize = TIFFTileSize(out);\n    tdata_t obuf;\n    uint8_t *bufp = (uint8_t *)buf;\n    uint32_t tl, tw;\n    uint32_t row;\n\n    (void)spp;\n\n    obuf = limitMalloc(TIFFTileSize(out));\n    if (obuf == NULL)\n        return 0;\n    _TIFFmemset(obuf, 0, tilesize);\n    (void)TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n    (void)TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n    for (row = 0; row < imagelength; row += tilelength)\n    {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth && colb < imagew; col += tw)\n        {\n            /*\n             * Tile is clipped horizontally.  Calculate\n             * visible portion and skewing factors.\n             */\n            if (colb + tilew > imagew)\n            {\n                uint32_t width = imagew - colb;\n                int oskew = tilew - width;\n                cpStripToTile(obuf, bufp + colb, nrow, width, oskew,\n                              oskew + iskew);\n            }\n            else\n                cpStripToTile(obuf, bufp + colb, nrow, tilew, 0, iskew);\n            if (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0)\n            {\n                TIFFError(TIFFFileName(out),\n                          \"Error, can't write tile at %\" PRIu32 \" %\" PRIu32,\n                          col, row);\n                _TIFFfree(obuf);\n                return 0;\n            }\n            colb += tilew;\n        }\n        bufp += nrow * imagew;\n    }\n    _TIFFfree(obuf);\n    return 1;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include \"libport.h\"\n#include \"tif_config.h\"\n\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <ctype.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#include \"tiffio.h\"\n\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS 0\n#endif\n#ifndef EXIT_FAILURE\n#define EXIT_FAILURE 1\n#endif\n\n#define streq(a, b) (strcmp(a, b) == 0)\n#define strneq(a, b, n) (strncmp(a, b, n) == 0)\n\n#define TRUE 1\n#define FALSE 0\n\n#define DEFAULT_MAX_MALLOC (256 * 1024 * 1024)\n\n/* malloc size limit (in bytes)\n * disabled when set to 0 */\nstatic tmsize_t maxMalloc = DEFAULT_MAX_MALLOC;\n\nstatic int outtiled = -1;\nstatic uint32_t tilewidth;\nstatic uint32_t tilelength;\n\nstatic uint16_t config;\nstatic uint16_t compression;\nstatic double max_z_error = 0.0;\nstatic uint16_t predictor;\nstatic int preset;\nstatic uint16_t fillorder;\nstatic uint16_t orientation;\nstatic uint32_t rowsperstrip;\nstatic uint32_t g3opts;\nstatic int ignore = FALSE; /* if true, ignore read errors */\nstatic uint32_t defg3opts = (uint32_t)-1;\nstatic int quality = 75; /* JPEG quality */\nstatic int jpegcolormode = JPEGCOLORMODE_RGB;\nstatic uint16_t defcompression = (uint16_t)-1;\nstatic uint16_t defpredictor = (uint16_t)-1;\nstatic int defpreset = -1;\nstatic int subcodec = -1;\n\nstatic int tiffcp(TIFF *, TIFF *);\nstatic int processCompressOptions(char *);\nstatic void usage(int code);\n\nstatic char comma = ','; /* (default) comma separator character */\nstatic TIFF *bias = NULL;\nstatic int pageNum = 0;\nstatic int pageInSeq = 0;\n\n/**\n * This custom malloc function enforce a maximum allocation size\n */\nstatic void *limitMalloc(tmsize_t s)\n{\n    if (maxMalloc && (s > maxMalloc))\n    {\n        fprintf(stderr,\n                \"MemoryLimitError: allocation of %\" TIFF_SSIZE_FORMAT\n                \" bytes is forbidden. Limit is %\" TIFF_SSIZE_FORMAT \".\\n\",\n                s, maxMalloc);\n        fprintf(stderr, \"                  use -m option to change limit.\\n\");\n        return NULL;\n    }\n    return _TIFFmalloc(s);\n}\n\nint main(int argc, char *argv[])\n{\n    uint16_t defconfig = (uint16_t)-1;\n    uint16_t deffillorder = 0;\n    uint32_t deftilewidth = (uint32_t)-1;\n    uint32_t deftilelength = (uint32_t)-1;\n    uint32_t defrowsperstrip = (uint32_t)0;\n    uint64_t diroff = 0;\n    TIFF *in;\n    TIFF *out;\n    char mode[10];\n    char *mp = mode;\n    int c;\n#if !HAVE_DECL_OPTARG\n    extern int optind;\n    extern char *optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv, \"m:,:b:c:f:l:o:p:r:w:aistBLMC8xh\")) != -1)\n        switch (c)\n        {\n            case 'm':\n                maxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n                break;\n            case ',':\n                if (optarg[0] != '=')\n                    usage(EXIT_FAILURE);\n                comma = optarg[1];\n                break;\n            case 'b': /* this file is bias image subtracted from others */\n                if (bias)\n                {\n                    fputs(\"Only 1 bias image may be specified\\n\", stderr);\n                    exit(EXIT_FAILURE);\n                }\n                {\n                    uint16_t samples = (uint16_t)-1;\n                    char **biasFn = &optarg;\n                    bias = openSrcImage(biasFn);\n                    if (!bias)\n                        exit(EXIT_FAILURE);\n                    if (TIFFIsTiled(bias))\n                    {\n                        fputs(\"Bias image must be organized in strips\\n\",\n                              stderr);\n                        exit(EXIT_FAILURE);\n                    }\n                    TIFFGetField(bias, TIFFTAG_SAMPLESPERPIXEL, &samples);\n                    if (samples != 1)\n                    {\n                        fputs(\"Bias image must be monochrome\\n\", stderr);\n                        exit(EXIT_FAILURE);\n                    }\n                }\n                break;\n            case 'a': /* append to output */\n                mode[0] = 'a';\n                break;\n            case 'c': /* compression scheme */\n                if (!processCompressOptions(optarg))\n                    usage(EXIT_FAILURE);\n                break;\n            case 'f': /* fill order */\n                if (streq(optarg, \"lsb2msb\"))\n                    deffillorder = FILLORDER_LSB2MSB;\n                else if (streq(optarg, \"msb2lsb\"))\n                    deffillorder = FILLORDER_MSB2LSB;\n                else\n                    usage(EXIT_FAILURE);\n                break;\n            case 'i': /* ignore errors */\n                ignore = TRUE;\n                break;\n            case 'l': /* tile length */\n                outtiled = TRUE;\n                deftilelength = atoi(optarg);\n                break;\n            case 'o': /* initial directory offset */\n                diroff = strtoul(optarg, NULL, 0);\n                break;\n            case 'p': /* planar configuration */\n                if (streq(optarg, \"separate\"))\n                    defconfig = PLANARCONFIG_SEPARATE;\n                else if (streq(optarg, \"contig\"))\n                    defconfig = PLANARCONFIG_CONTIG;\n                else\n                    usage(EXIT_FAILURE);\n                break;\n            case 'r': /* rows/strip */\n                defrowsperstrip = atol(optarg);\n                break;\n            case 's': /* generate stripped output */\n                outtiled = FALSE;\n                break;\n            case 't': /* generate tiled output */\n                outtiled = TRUE;\n                break;\n            case 'w': /* tile width */\n                outtiled = TRUE;\n                deftilewidth = atoi(optarg);\n                break;\n            case 'B':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'b';\n                    *mp = '\\0';\n                }\n                break;\n            case 'L':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'l';\n                    *mp = '\\0';\n                }\n                break;\n            case 'M':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'm';\n                    *mp = '\\0';\n                }\n                break;\n            case 'C':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = 'c';\n                    *mp = '\\0';\n                }\n                break;\n            case '8':\n                if (strlen(mode) < (sizeof(mode) - 1))\n                {\n                    *mp++ = '8';\n                    *mp = '\\0';\n                }\n                break;\n            case 'x':\n                pageInSeq = 1;\n                break;\n            case 'h':\n                usage(EXIT_SUCCESS);\n                /*NOTREACHED*/\n                break;\n            case '?':\n                usage(EXIT_FAILURE);\n                /*NOTREACHED*/\n                break;\n        }\n    if (argc - optind < 2)\n        usage(EXIT_FAILURE);\n    TIFFOpenOptions *opts = TIFFOpenOptionsAlloc();\n    if (opts == NULL)\n    {\n        return EXIT_FAILURE;\n    }\n    TIFFOpenOptionsSetMaxSingleMemAlloc(opts, maxMalloc);\n    out = TIFFOpenExt(argv[argc - 1], mode, opts);\n    TIFFOpenOptionsFree(opts);\n    if (out == NULL)\n        return (EXIT_FAILURE);\n    if ((argc - optind) == 2)\n        pageNum = -1;\n    for (; optind < argc - 1; optind++)\n    {\n        char *imageCursor = argv[optind];\n        in = openSrcImage(&imageCursor);\n        if (in == NULL)\n        {\n            (void)TIFFClose(out);\n            return (EXIT_FAILURE);\n        }\n        if (diroff != 0 && !TIFFSetSubDirectory(in, diroff))\n        {\n            TIFFError(TIFFFileName(in),\n                      \"Error, setting subdirectory at %\" PRIu64, diroff);\n            (void)TIFFClose(in);\n            (void)TIFFClose(out);\n            return (EXIT_FAILURE);\n        }\n        for (;;)\n        {\n            config = defconfig;\n            compression = defcompression;\n            predictor = defpredictor;\n            preset = defpreset;\n            fillorder = deffillorder;\n            rowsperstrip = defrowsperstrip;\n            tilewidth = deftilewidth;\n            tilelength = deftilelength;\n            g3opts = defg3opts;\n            if (!tiffcp(in, out) || !TIFFWriteDirectory(out))\n            {\n                (void)TIFFClose(in);\n                (void)TIFFClose(out);\n                return (EXIT_FAILURE);\n            }\n            if (imageCursor)\n            { /* seek next image directory */\n                if (!nextSrcImage(in, &imageCursor))\n                    break;\n            }\n            else if (!TIFFReadDirectory(in))\n                break;\n        }\n        (void)TIFFClose(in);\n    }\n\n    (void)TIFFClose(out);\n    return (EXIT_SUCCESS);\n}\n\n/* PODD */\nstatic int tiffcp(TIFF *in, TIFF *out)\n{\n    uint16_t bitspersample = 1, samplesperpixel = 1;\n    uint16_t input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;\n    copyFunc cf;\n    uint32_t width, length;\n    const struct cpTag *p;\n\n    CopyField(TIFFTAG_IMAGEWIDTH, width);\n    CopyField(TIFFTAG_IMAGELENGTH, length);\n    CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);\n    CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);\n    if (compression != (uint16_t)-1)\n        TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n    else\n        CopyField(TIFFTAG_COMPRESSION, compression);\n    if (!TIFFIsCODECConfigured(compression))\n        return FALSE;\n    TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);\n    TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);\n    if (input_compression == COMPRESSION_JPEG)\n    {\n        /* Force conversion to RGB */\n        TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);\n    }\n    else if (input_photometric == PHOTOMETRIC_YCBCR)\n    {\n        /* Otherwise, can't handle subsampled input */\n        uint16_t subsamplinghor, subsamplingver;\n\n        TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING, &subsamplinghor,\n                              &subsamplingver);\n        if (subsamplinghor != 1 || subsamplingver != 1)\n        {\n            fprintf(stderr,\n                    \"tiffcp: %s: Can't copy/convert subsampled image.\\n\",\n                    TIFFFileName(in));\n            return FALSE;\n        }\n    }\n    if (compression == COMPRESSION_JPEG)\n    {\n        if (input_photometric == PHOTOMETRIC_RGB &&\n            jpegcolormode == JPEGCOLORMODE_RGB)\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);\n        else\n            TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);\n    }\n    else if (compression == COMPRESSION_SGILOG ||\n             compression == COMPRESSION_SGILOG24)\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC,\n                     samplesperpixel == 1 ? PHOTOMETRIC_LOGL\n                                          : PHOTOMETRIC_LOGLUV);\n    else if (input_compression == COMPRESSION_JPEG && samplesperpixel == 3)\n    {\n        /* RGB conversion was forced above\n        hence the output will be of the same type */\n        TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);\n    }\n    else\n        CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);\n    if (fillorder != 0)\n        TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n    else\n        CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);\n    /*\n     * Will copy `Orientation' tag from input image\n     */\n    TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);\n    /*\n     * Choose tiles/strip for the output image according to\n     * the command line arguments (-tiles, -strips) and the\n     * structure of the input image.\n     */\n    if (outtiled == -1)\n        outtiled = TIFFIsTiled(in);\n    if (outtiled)\n    {\n        /*\n         * Setup output file's tile width&height.  If either\n         * is not specified, use either the value from the\n         * input image or, if nothing is defined, use the\n         * library default.\n         */\n        if (tilewidth == (uint32_t)-1)\n            TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);\n        if (tilelength == (uint32_t)-1)\n            TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);\n        TIFFDefaultTileSize(out, &tilewidth, &tilelength);\n        TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);\n        TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);\n    }\n    else\n    {\n        /*\n         * RowsPerStrip is left unspecified: use either the\n         * value from the input image or, if nothing is defined,\n         * use the library default.\n         */\n        if (rowsperstrip == (uint32_t)0)\n        {\n            if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip))\n            {\n                rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n            }\n            if (rowsperstrip > length && rowsperstrip != (uint32_t)-1)\n                rowsperstrip = length;\n        }\n        else if (rowsperstrip == (uint32_t)-1)\n            rowsperstrip = length;\n        TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n    }\n    if (config != (uint16_t)-1)\n        TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n    else\n        CopyField(TIFFTAG_PLANARCONFIG, config);\n    if (samplesperpixel <= 4)\n        CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);\n    CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);\n    /* SMinSampleValue & SMaxSampleValue */\n    switch (compression)\n    {\n        case COMPRESSION_JPEG:\n            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n            TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n            break;\n        case COMPRESSION_JBIG:\n            CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n            CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);\n            break;\n        case COMPRESSION_LERC:\n            if (max_z_error > 0)\n            {\n                if (TIFFSetField(out, TIFFTAG_LERC_MAXZERROR, max_z_error) != 1)\n                {\n                    return FALSE;\n                }\n            }\n            if (subcodec != -1)\n            {\n                if (TIFFSetField(out, TIFFTAG_LERC_ADD_COMPRESSION, subcodec) !=\n                    1)\n                {\n                    return FALSE;\n                }\n            }\n            if (preset != -1)\n            {\n                switch (subcodec)\n                {\n                    case LERC_ADD_COMPRESSION_DEFLATE:\n                        if (TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset) != 1)\n                        {\n                            return FALSE;\n                        }\n                        break;\n                    case LERC_ADD_COMPRESSION_ZSTD:\n                        if (TIFFSetField(out, TIFFTAG_ZSTD_LEVEL, preset) != 1)\n                        {\n                            return FALSE;\n                        }\n                        break;\n                }\n            }\n            break;\n        case COMPRESSION_LZW:\n        case COMPRESSION_ADOBE_DEFLATE:\n        case COMPRESSION_DEFLATE:\n        case COMPRESSION_LZMA:\n        case COMPRESSION_ZSTD:\n            if (predictor != (uint16_t)-1)\n                TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n            else if (input_compression == COMPRESSION_LZW ||\n                     input_compression == COMPRESSION_ADOBE_DEFLATE ||\n                     input_compression == COMPRESSION_DEFLATE ||\n                     input_compression == COMPRESSION_LZMA ||\n                     input_compression == COMPRESSION_ZSTD)\n            {\n                CopyField(TIFFTAG_PREDICTOR, predictor);\n            }\n            if (compression == COMPRESSION_ADOBE_DEFLATE ||\n                compression == COMPRESSION_DEFLATE)\n            {\n                if (subcodec != -1)\n                {\n                    if (TIFFSetField(out, TIFFTAG_DEFLATE_SUBCODEC, subcodec) !=\n                        1)\n                    {\n                        return FALSE;\n                    }\n                }\n            }\n            /*fallthrough*/\n        case COMPRESSION_WEBP:\n            if (preset != -1)\n            {\n                if (preset == 100)\n                {\n                    TIFFSetField(out, TIFFTAG_WEBP_LOSSLESS, TRUE);\n                }\n                else\n                {\n                    TIFFSetField(out, TIFFTAG_WEBP_LEVEL, preset);\n                }\n            }\n            break;\n        case COMPRESSION_CCITTFAX3:\n        case COMPRESSION_CCITTFAX4:\n            if (compression == COMPRESSION_CCITTFAX3)\n            {\n                if (g3opts != (uint32_t)-1)\n                    TIFFSetField(out, TIFFTAG_GROUP3OPTIONS, g3opts);\n                else if (input_compression == COMPRESSION_CCITTFAX3)\n                    CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);\n            }\n            else if (input_compression == COMPRESSION_CCITTFAX4)\n                CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);\n            if (input_compression == COMPRESSION_CCITTFAX3 ||\n                input_compression == COMPRESSION_CCITTFAX4)\n            {\n                CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);\n                CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);\n                CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);\n            }\n            CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);\n            CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);\n            break;\n    }\n    {\n        uint32_t len32;\n        void **data;\n        if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))\n            TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);\n    }\n    {\n        uint16_t ninks;\n        const char *inknames;\n        if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks))\n        {\n            TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);\n            if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames))\n            {\n                int inknameslen = strlen(inknames) + 1;\n                const char *cp = inknames;\n                while (ninks > 1)\n                {\n                    cp = strchr(cp, '\\0');\n                    cp++;\n                    inknameslen += (strlen(cp) + 1);\n                    ninks--;\n                }\n                TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);\n            }\n        }\n    }\n    {\n        unsigned short pg0, pg1;\n\n        if (pageInSeq == 1)\n        {\n            if (pageNum < 0) /* only one input file */\n            {\n                if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n            }\n            else\n                TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n        }\n        else\n        {\n            if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))\n            {\n                if (pageNum < 0) /* only one input file */\n                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);\n                else\n                    TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);\n            }\n        }\n    }\n\n    for (p = tags; p < &tags[NTAGS]; p++)\n        CopyTag(p->tag, p->count, p->type);\n\n    cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);\n    return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);\n}\n\nstatic void cpStripToTile(uint8_t *out, uint8_t *in, uint32_t rows,\n                          uint32_t cols, int outskew, int64_t inskew)\n{\n    while (rows-- > 0)\n    {\n        uint32_t j = cols;\n        while (j-- > 0)\n            *out++ = *in++;\n        out += outskew;\n        in += inskew;\n    }\n}\n\nDECLAREreadFunc(readSeparateTilesIntoBuffer)\n{\n    int status = 1;\n    uint32_t imagew = TIFFRasterScanlineSize(in);\n    uint32_t tilew = TIFFTileRowSize(in);\n    int iskew;\n    tsize_t tilesize = TIFFTileSize(in);\n    tdata_t tilebuf;\n    uint8_t *bufp = (uint8_t *)buf;\n    uint32_t tw, tl;\n    uint32_t row;\n    uint16_t bps = 0, bytes_per_sample;\n\n    if (tilew && spp > (INT_MAX / tilew))\n    {\n        TIFFError(TIFFFileName(in),\n                  \"Error, cannot handle that much samples per tile row (Tile \"\n                  \"Width * Samples/Pixel)\");\n        return 0;\n    }\n\n    iskew = imagew - tilew * spp;\n    if ( iskew > INT_MAX ){\n        TIFFError(TIFFFileName(in),\n                  \"Error, image raster scan line size is too large\");\n        return 0;       \n    } \n    tilebuf = limitMalloc(tilesize);\n    if (tilebuf == 0)\n        return 0;\n    _TIFFmemset(tilebuf, 0, tilesize);\n    (void)TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);\n    (void)TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);\n    (void)TIFFGetField(in, TIFFTAG_BITSPERSAMPLE, &bps);\n    if (bps == 0)\n    {\n        TIFFError(TIFFFileName(in), \"Error, cannot read BitsPerSample\");\n        status = 0;\n        goto done;\n    }\n    if ((bps % 8) != 0)\n    {\n        TIFFError(\n            TIFFFileName(in),\n            \"Error, cannot handle BitsPerSample that is not a multiple of 8\");\n        status = 0;\n        goto done;\n    }\n    bytes_per_sample = bps / 8;\n\n    for (row = 0; row < imagelength; row += tl)\n    {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth; col += tw)\n        {\n            tsample_t s;\n\n            for (s = 0; s < spp; s++)\n            {\n                if (TIFFReadTile(in, tilebuf, col, row, 0, s) < 0 && !ignore)\n                {\n                    TIFFError(TIFFFileName(in),\n                              \"Error, can't read tile at %\" PRIu32 \" %\" PRIu32\n                              \", \"\n                              \"sample %\" PRIu16,\n                              col, row, s);\n                    status = 0;\n                    goto done;\n                }\n                /*\n                 * Tile is clipped horizontally.  Calculate\n                 * visible portion and skewing factors.\n                 */\n                if (colb + tilew * spp > imagew)\n                {\n                    uint32_t width = imagew - colb;\n                    int oskew = tilew * spp - width;\n                    cpSeparateBufToContigBuf(\n                        bufp + colb + s * bytes_per_sample, tilebuf, nrow,\n                        width / (spp * bytes_per_sample), oskew + iskew,\n                        oskew / spp, spp, bytes_per_sample);\n                }\n                else\n                    cpSeparateBufToContigBuf(bufp + colb + s * bytes_per_sample,\n                                             tilebuf, nrow, tw, iskew, 0, spp,\n                                             bytes_per_sample);\n            }\n            colb += tilew * spp;\n        }\n        bufp += imagew * nrow;\n    }\ndone:\n    _TIFFfree(tilebuf);\n    return status;\n}\n\nDECLAREwriteFunc(writeBufferToContigTiles)\n{\n    uint32_t imagew = TIFFScanlineSize(out);\n    uint32_t tilew = TIFFTileRowSize(out);\n    int iskew = imagew - tilew;\n    tsize_t tilesize = TIFFTileSize(out);\n    tdata_t obuf;\n    uint8_t *bufp = (uint8_t *)buf;\n    uint32_t tl, tw;\n    uint32_t row;\n\n    (void)spp;\n\n    obuf = limitMalloc(TIFFTileSize(out));\n    if (obuf == NULL)\n        return 0;\n    _TIFFmemset(obuf, 0, tilesize);\n    (void)TIFFGetField(out, TIFFTAG_TILELENGTH, &tl);\n    (void)TIFFGetField(out, TIFFTAG_TILEWIDTH, &tw);\n    for (row = 0; row < imagelength; row += tilelength)\n    {\n        uint32_t nrow = (row + tl > imagelength) ? imagelength - row : tl;\n        uint32_t colb = 0;\n        uint32_t col;\n\n        for (col = 0; col < imagewidth && colb < imagew; col += tw)\n        {\n            /*\n             * Tile is clipped horizontally.  Calculate\n             * visible portion and skewing factors.\n             */\n            if (colb + tilew > imagew)\n            {\n                uint32_t width = imagew - colb;\n                int oskew = tilew - width;\n                cpStripToTile(obuf, bufp + colb, nrow, width, oskew,\n                              oskew + iskew);\n            }\n            else\n                cpStripToTile(obuf, bufp + colb, nrow, tilew, 0, iskew);\n            if (TIFFWriteTile(out, obuf, col, row, 0, 0) < 0)\n            {\n                TIFFError(TIFFFileName(out),\n                          \"Error, can't write tile at %\" PRIu32 \" %\" PRIu32,\n                          col, row);\n                _TIFFfree(obuf);\n                return 0;\n            }\n            colb += tilew;\n        }\n        bufp += nrow * imagew;\n    }\n    _TIFFfree(obuf);\n    return 1;\n}\n",
    "source": "real-world",
    "cwe": "CWE-190",
    "vulnerability_type": "integer_overflow",
    "idx": 31,
    "typechecks": true,
    "cve": "CVE-2023-40745",
    "project": "libtiff"
  },
  {
    "prompt": "Security review of this code:\n\n#include \"libport.h\"\n#include \"tif_config.h\"\n\n#include <ctype.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#if HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#if HAVE_IO_H\n#include <io.h>\n#endif\n\n#include \"tiffio.h\"\n#include \"tiffiop.h\"\n\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS 0\n#endif\n#ifndef EXIT_FAILURE\n#define EXIT_FAILURE 1\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\ntypedef enum\n{\n    PIXEL,\n    BAND\n} InterleavingType;\n\nstatic uint16_t compression = (uint16_t)-1;\nstatic int jpegcolormode = JPEGCOLORMODE_RGB;\nstatic int quality = 75; /* JPEG quality */\nstatic uint16_t predictor = 0;\n\nstatic void swapBytesInScanline(void *, uint32_t, TIFFDataType);\nstatic int guessSize(int, TIFFDataType, _TIFF_off_t, uint32_t, int, uint32_t *,\n                     uint32_t *);\nstatic double correlation(void *, void *, uint32_t, TIFFDataType);\nstatic void usage(int);\nstatic int processCompressOptions(char *);\n\nint main(int argc, char *argv[])\n{\n    uint32_t width = 0, length = 0, linebytes, bufsize;\n    uint32_t nbands = 1;      /* number of bands in input image*/\n    _TIFF_off_t hdr_size = 0; /* size of the header to skip */\n    TIFFDataType dtype = TIFF_BYTE;\n    int16_t depth = 1;                 /* bytes per pixel in input image */\n    int swab = 0;                      /* byte swapping flag */\n    InterleavingType interleaving = 0; /* interleaving type flag */\n    uint32_t rowsperstrip = (uint32_t)-1;\n    uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n    uint16_t config = PLANARCONFIG_CONTIG;\n    uint16_t fillorder = FILLORDER_LSB2MSB;\n    int fd;\n    char *outfilename = NULL;\n    TIFF *out;\n\n    uint32_t row, col, band;\n    int c;\n    unsigned char *buf = NULL, *buf1 = NULL;\n#if !HAVE_DECL_OPTARG\n    extern int optind;\n    extern char *optarg;\n#endif\n\n    while ((c = getopt(argc, argv, \"c:r:H:w:l:b:d:LMp:si:o:h\")) != -1)\n    {\n        switch (c)\n        {\n            case 'c': /* compression scheme */\n                if (!processCompressOptions(optarg))\n                    usage(EXIT_FAILURE);\n                break;\n            case 'r': /* rows/strip */\n                rowsperstrip = atoi(optarg);\n                break;\n            case 'H': /* size of input image file header */\n                hdr_size = atoi(optarg);\n                break;\n            case 'w': /* input image width */\n                width = atoi(optarg);\n                break;\n            case 'l': /* input image length */\n                length = atoi(optarg);\n                break;\n            case 'b': /* number of bands in input image */\n                nbands = atoi(optarg);\n                break;\n            case 'd': /* type of samples in input image */\n                if (strncmp(optarg, \"byte\", 4) == 0)\n                    dtype = TIFF_BYTE;\n                else if (strncmp(optarg, \"short\", 5) == 0)\n                    dtype = TIFF_SHORT;\n                else if (strncmp(optarg, \"long\", 4) == 0)\n                    dtype = TIFF_LONG;\n                else if (strncmp(optarg, \"sbyte\", 5) == 0)\n                    dtype = TIFF_SBYTE;\n                else if (strncmp(optarg, \"sshort\", 6) == 0)\n                    dtype = TIFF_SSHORT;\n                else if (strncmp(optarg, \"slong\", 5) == 0)\n                    dtype = TIFF_SLONG;\n                else if (strncmp(optarg, \"float\", 5) == 0)\n                    dtype = TIFF_FLOAT;\n                else if (strncmp(optarg, \"double\", 6) == 0)\n                    dtype = TIFF_DOUBLE;\n                else\n                    dtype = TIFF_BYTE;\n                depth = TIFFDataWidth(dtype);\n                break;\n            case 'L': /* input has lsb-to-msb fillorder */\n                fillorder = FILLORDER_LSB2MSB;\n                break;\n            case 'M': /* input has msb-to-lsb fillorder */\n                fillorder = FILLORDER_MSB2LSB;\n                break;\n            case 'p': /* photometric interpretation */\n                if (strncmp(optarg, \"miniswhite\", 10) == 0)\n                    photometric = PHOTOMETRIC_MINISWHITE;\n                else if (strncmp(optarg, \"minisblack\", 10) == 0)\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                else if (strncmp(optarg, \"rgb\", 3) == 0)\n                    photometric = PHOTOMETRIC_RGB;\n                else if (strncmp(optarg, \"cmyk\", 4) == 0)\n                    photometric = PHOTOMETRIC_SEPARATED;\n                else if (strncmp(optarg, \"ycbcr\", 5) == 0)\n                    photometric = PHOTOMETRIC_YCBCR;\n                else if (strncmp(optarg, \"cielab\", 6) == 0)\n                    photometric = PHOTOMETRIC_CIELAB;\n                else if (strncmp(optarg, \"icclab\", 6) == 0)\n                    photometric = PHOTOMETRIC_ICCLAB;\n                else if (strncmp(optarg, \"itulab\", 6) == 0)\n                    photometric = PHOTOMETRIC_ITULAB;\n                else\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                break;\n            case 's': /* do we need to swap bytes? */\n                swab = 1;\n                break;\n            case 'i': /* type of interleaving */\n                if (strncmp(optarg, \"pixel\", 4) == 0)\n                    interleaving = PIXEL;\n                else if (strncmp(optarg, \"band\", 6) == 0)\n                    interleaving = BAND;\n                else\n                    interleaving = 0;\n                break;\n            case 'o':\n                outfilename = optarg;\n                break;\n            case 'h':\n                usage(EXIT_SUCCESS);\n            default:\n                break;\n        }\n    }\n\n    if (argc - optind < 2)\n        usage(EXIT_FAILURE);\n\n    fd = open(argv[optind], O_RDONLY | O_BINARY, 0);\n    if (fd < 0)\n    {\n        fprintf(stderr, \"%s: %s: Cannot open input file.\\n\", argv[0],\n                argv[optind]);\n        return (EXIT_FAILURE);\n    }\n\n    if (nbands == 0)\n    {\n        fprintf(stderr, \"The number of bands is illegal.\\n\");\n        return (-1);\n    }\n\n    if (guessSize(fd, dtype, hdr_size, nbands, swab, &width, &length) < 0)\n        return EXIT_FAILURE;\n\n    if (outfilename == NULL)\n        outfilename = argv[optind + 1];\n    out = TIFFOpen(outfilename, \"w\");\n    if (out == NULL)\n    {\n        fprintf(stderr, \"%s: %s: Cannot open file for output.\\n\", argv[0],\n                outfilename);\n        return (EXIT_FAILURE);\n    }\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands);\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth * 8);\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n    switch (dtype)\n    {\n        case TIFF_BYTE:\n        case TIFF_SHORT:\n        case TIFF_LONG:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        case TIFF_SBYTE:\n        case TIFF_SSHORT:\n        case TIFF_SLONG:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n            break;\n        case TIFF_FLOAT:\n        case TIFF_DOUBLE:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n        default:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_VOID);\n            break;\n    }\n    if (compression == (uint16_t)-1)\n        compression = COMPRESSION_PACKBITS;\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n    switch (compression)\n    {\n        case COMPRESSION_JPEG:\n            if (photometric == PHOTOMETRIC_RGB &&\n                jpegcolormode == JPEGCOLORMODE_RGB)\n                photometric = PHOTOMETRIC_YCBCR;\n            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n            TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n            break;\n        case COMPRESSION_LZW:\n        case COMPRESSION_ADOBE_DEFLATE:\n        case COMPRESSION_DEFLATE:\n            if (predictor != 0)\n                TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n            break;\n    }\n    switch (interleaving)\n    {\n        case BAND: /* band interleaved data */\n            linebytes = width * depth;\n            buf = (unsigned char *)_TIFFmalloc(linebytes);\n            break;\n        case PIXEL: /* pixel interleaved data */\n        default:\n            linebytes = width * nbands * depth;\n            break;\n    }\n    bufsize = width * nbands * depth;\n    buf1 = (unsigned char *)_TIFFmalloc(bufsize);\n\n    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n    if (rowsperstrip > length)\n    {\n        rowsperstrip = length;\n    }\n    TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n    _TIFF_lseek_f(fd, hdr_size, SEEK_SET); /* Skip the file header */\n    for (row = 0; row < length; row++)\n    {\n        switch (interleaving)\n        {\n            case BAND: /* band interleaved data */\n                for (band = 0; band < nbands; band++)\n                {\n                    if (_TIFF_lseek_f(\n                            fd, hdr_size + (length * band + row) * linebytes,\n                            SEEK_SET) == (_TIFF_off_t)-1)\n                    {\n                        fprintf(stderr,\n                                \"%s: %s: scanline %\" PRIu32 \": seek error.\\n\",\n                                argv[0], argv[optind], row);\n                        break;\n                    }\n                    if (read(fd, buf, linebytes) < 0)\n                    {\n                        fprintf(stderr,\n                                \"%s: %s: scanline %\" PRIu32 \": Read error.\\n\",\n                                argv[0], argv[optind], row);\n                        break;\n                    }\n                    if (swab) /* Swap bytes if needed */\n                        swapBytesInScanline(buf, width, dtype);\n                    for (col = 0; col < width; col++)\n                        memcpy(buf1 + (col * nbands + band) * depth,\n                               buf + col * depth, depth);\n                }\n                break;\n            case PIXEL: /* pixel interleaved data */\n            default:\n                if (read(fd, buf1, bufsize) < 0)\n                {\n                    fprintf(stderr,\n                            \"%s: %s: scanline %\" PRIu32 \": Read error.\\n\",\n                            argv[0], argv[optind], row);\n                    break;\n                }\n                if (swab) /* Swap bytes if needed */\n                    swapBytesInScanline(buf1, width, dtype);\n                break;\n        }\n\n        if (TIFFWriteScanline(out, buf1, row, 0) < 0)\n        {\n            fprintf(stderr, \"%s: %s: scanline %\" PRIu32 \": Write error.\\n\",\n                    argv[0], outfilename, row);\n            break;\n        }\n    }\n    if (buf)\n        _TIFFfree(buf);\n    if (buf1)\n        _TIFFfree(buf1);\n    TIFFClose(out);\n    return (EXIT_SUCCESS);\n}\n\nstatic void swapBytesInScanline(void *buf, uint32_t width, TIFFDataType dtype)\n{\n    switch (dtype)\n    {\n        case TIFF_SHORT:\n        case TIFF_SSHORT:\n            TIFFSwabArrayOfShort((uint16_t *)buf, (unsigned long)width);\n            break;\n        case TIFF_LONG:\n        case TIFF_SLONG:\n            TIFFSwabArrayOfLong((uint32_t *)buf, (unsigned long)width);\n            break;\n        /* case TIFF_FLOAT: */ /* FIXME */\n        case TIFF_DOUBLE:\n            TIFFSwabArrayOfDouble((double *)buf, (unsigned long)width);\n            break;\n        default:\n            break;\n    }\n}\n\nstatic int guessSize(int fd, TIFFDataType dtype, _TIFF_off_t hdr_size,\n                     uint32_t nbands, int swab, uint32_t *width,\n                     uint32_t *length)\n{\n    const float longt = 40.0; /* maximum possible height/width ratio */\n    char *buf1, *buf2;\n    _TIFF_stat_s filestat;\n    uint32_t w, h, scanlinesize, imagesize;\n    uint32_t depth = TIFFDataWidth(dtype);\n    double cor_coef = 0, tmp;\n\n    if (_TIFF_fstat_f(fd, &filestat) == -1)\n    {\n        fprintf(stderr, \"Failed to obtain file size.\\n\");\n        return -1;\n    }\n\n    if (filestat.st_size < hdr_size)\n    {\n        fprintf(stderr, \"Too large header size specified.\\n\");\n        return -1;\n    }\n\n    imagesize = (filestat.st_size - hdr_size) / nbands / depth;\n\n    if (*width != 0 && *length == 0)\n    {\n        fprintf(stderr, \"Image height is not specified.\\n\");\n\n        *length = imagesize / *width;\n\n        fprintf(stderr, \"Height is guessed as %\" PRIu32 \".\\n\", *length);\n\n        return 1;\n    }\n    else if (*width == 0 && *length != 0)\n    {\n        fprintf(stderr, \"Image width is not specified.\\n\");\n\n        *width = imagesize / *length;\n\n        fprintf(stderr, \"Width is guessed as %\" PRIu32 \".\\n\", *width);\n\n        return 1;\n    }\n    else if (*width == 0 && *length == 0)\n    {\n        unsigned int fail = 0;\n        fprintf(stderr, \"Image width and height are not specified.\\n\");\n        w = (uint32_t)sqrt(imagesize / longt);\n        if (w == 0)\n        {\n            fprintf(stderr, \"Too small image size.\\n\");\n            return -1;\n        }\n\n        for (; w < sqrt(imagesize * longt); w++)\n        {\n            if (imagesize % w == 0)\n            {\n                scanlinesize = w * depth;\n                h = imagesize / w;\n                if (h < 2)\n                    continue;\n                /* reads 2 lines at the middle of the image and calculate their\n                 * correlation. it works for h >= 2. (in this case it will\n                 * compare line 0 and line 1 */\n                buf1 = _TIFFmalloc(scanlinesize);\n                buf2 = _TIFFmalloc(scanlinesize);\n                do\n                {\n                    if (_TIFF_lseek_f(\n                            fd, hdr_size + (int)((h - 1) / 2) * scanlinesize,\n                            SEEK_SET) == (_TIFF_off_t)-1)\n                    {\n                        fprintf(stderr, \"seek error.\\n\");\n                        fail = 1;\n                        break;\n                    }\n                    /* read line (h-1)/2 */\n                    if (read(fd, buf1, scanlinesize) != (long)scanlinesize)\n                    {\n                        fprintf(stderr, \"read error.\\n\");\n                        fail = 1;\n                        break;\n                    }\n                    /* read line ((h-1)/2)+1 */\n                    if (read(fd, buf2, scanlinesize) != (long)scanlinesize)\n                    {\n                        fprintf(stderr, \"read error.\\n\");\n                        fail = 1;\n                        break;\n                    }\n                    if (swab)\n                    {\n                        swapBytesInScanline(buf1, w, dtype);\n                        swapBytesInScanline(buf2, w, dtype);\n                    }\n                    if (0 == memcmp(buf1, buf2, scanlinesize))\n                    {\n                        *width = w, *length = h;\n                    }\n                    else\n                    {\n                        tmp = fabs(correlation(buf1, buf2, w, dtype));\n                        if (tmp > cor_coef)\n                        {\n                            cor_coef = tmp;\n                            *width = w, *length = h;\n                        }\n                    }\n                } while (0);\n\n                _TIFFfree(buf1);\n                _TIFFfree(buf2);\n            }\n        }\n\n        if (fail)\n        {\n            return -1;\n        }\n\n        fprintf(stderr,\n                \"Width is guessed as %\" PRIu32 \", height is guessed as %\" PRIu32\n                \".\\n\",\n                *width, *length);\n\n        return 1;\n    }\n    else\n    {\n        if (filestat.st_size <\n            (_TIFF_off_t)(hdr_size + (*width) * (*length) * nbands * depth))\n        {\n            fprintf(stderr, \"Input file too small.\\n\");\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/* Calculate correlation coefficient between two numeric vectors */\nstatic double correlation(void *buf1, void *buf2, uint32_t n_elem,\n                          TIFFDataType dtype)\n{\n    double X, Y, M1 = 0.0, M2 = 0.0, D1 = 0.0, D2 = 0.0, K = 0.0;\n    uint32_t i;\n\n    switch (dtype)\n    {\n        case TIFF_BYTE:\n        default:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((unsigned char *)buf1)[i];\n                Y = ((unsigned char *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SBYTE:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((signed char *)buf1)[i];\n                Y = ((signed char *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SHORT:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((uint16_t *)buf1)[i];\n                Y = ((uint16_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SSHORT:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((int16_t *)buf1)[i];\n                Y = ((int16_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_LONG:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((uint32_t *)buf1)[i];\n                Y = ((uint32_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SLONG:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((int32_t *)buf1)[i];\n                Y = ((int32_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_FLOAT:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((float *)buf1)[i];\n                Y = ((float *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_DOUBLE:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((double *)buf1)[i];\n                Y = ((double *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n    }\n\n    M1 /= n_elem;\n    M2 /= n_elem;\n    D1 -= M1 * M1 * n_elem;\n    D2 -= M2 * M2 * n_elem;\n    if (D1 * D2 == 0.0)\n        return 0.0; /* avoid divide by zero */\n    K = (K - M1 * M2 * n_elem) / sqrt(D1 * D2);\n\n    return K;\n}\n\nstatic int processCompressOptions(char *opt)\n{\n    if (strcmp(opt, \"none\") == 0)\n        compression = COMPRESSION_NONE;\n    else if (strcmp(opt, \"packbits\") == 0)\n        compression = COMPRESSION_PACKBITS;\n    else if (strncmp(opt, \"jpeg\", 4) == 0)\n    {\n        char *cp = strchr(opt, ':');\n\n        compression = COMPRESSION_JPEG;\n        while (cp)\n        {\n            if (isdigit((int)cp[1]))\n                quality = atoi(cp + 1);\n            else if (cp[1] == 'r')\n                jpegcolormode = JPEGCOLORMODE_RAW;\n            else\n                usage(EXIT_FAILURE);\n\n            cp = strchr(cp + 1, ':');\n        }\n    }\n    else if (strncmp(opt, \"lzw\", 3) == 0)\n    {\n        char *cp = strchr(opt, ':');\n        if (cp)\n            predictor = atoi(cp + 1);\n        compression = COMPRESSION_LZW;\n    }\n    else if (strncmp(opt, \"zip\", 3) == 0)\n    {\n        char *cp = strchr(opt, ':');\n        if (cp)\n            predictor = atoi(cp + 1);\n        compression = COMPRESSION_ADOBE_DEFLATE;\n    }\n    else\n        return (0);\n    return (1);\n}\n\nstatic const char usage_info[] =\n    \"Create a TIFF file from raw data\\n\\n\"\n    \"usage: raw2tiff [options] input.raw output.tif\\n\"\n    \"where options are:\\n\"\n    \" -L\t\tinput data has LSB2MSB bit order (default)\\n\"\n    \" -M\t\tinput data has MSB2LSB bit order\\n\"\n    \" -r #\t\tmake each strip have no more than # rows\\n\"\n    \" -H #\t\tsize of input image file header in bytes (0 by \"\n    \"default)\\n\"\n    \" -w #\t\twidth of input image in pixels\\n\"\n    \" -l #\t\tlength of input image in lines\\n\"\n    \" -b #\t\tnumber of bands in input image (1 by default)\\n\"\n    \"\\n\"\n    \" -d data_type\ttype of samples in input image\\n\"\n    \"where data_type may be:\\n\"\n    \" byte\t\t8-bit unsigned integer (default)\\n\"\n    \" short\t\t16-bit unsigned integer\\n\"\n    \" long\t\t32-bit unsigned integer\\n\"\n    \" sbyte\t\t8-bit signed integer\\n\"\n    \" sshort\t\t16-bit signed integer\\n\"\n    \" slong\t\t32-bit signed integer\\n\"\n    \" float\t\t32-bit IEEE floating point\\n\"\n    \" double\t\t64-bit IEEE floating point\\n\"\n    \"\\n\"\n    \" -p photo\tphotometric interpretation (color space) of the input image\\n\"\n    \"where photo may be:\\n\"\n    \" miniswhite\twhite color represented with 0 value\\n\"\n    \" minisblack\tblack color represented with 0 value (default)\\n\"\n    \" rgb\t\timage has RGB color model\\n\"\n    \" cmyk\t\timage has CMYK (separated) color model\\n\"\n    \" ycbcr\t\timage has YCbCr color model\\n\"\n    \" cielab\t\timage has CIE L*a*b color model\\n\"\n    \" icclab\t\timage has ICC L*a*b color model\\n\"\n    \" itulab\t\timage has ITU L*a*b color model\\n\"\n    \"\\n\"\n    \" -s\t\tswap bytes fetched from input file\\n\"\n    \"\\n\"\n    \" -i config\ttype of samples interleaving in input image\\n\"\n    \"where config may be:\\n\"\n    \" pixel\t\tpixel interleaved data (default)\\n\"\n    \" band\t\tband interleaved data\\n\"\n    \"\\n\"\n#ifdef LZW_SUPPORT\n    \" -c lzw[:opts]\tcompress output with Lempel-Ziv & Welch encoding\\n\"\n    /* \"    LZW options:\\n\" */\n    \"    #  set predictor value\\n\"\n    \"    For example, -c lzw:2 for LZW-encoded data with horizontal \"\n    \"differencing\\n\"\n#endif\n#ifdef ZIP_SUPPORT\n    \" -c zip[:opts]\tcompress output with deflate encoding\\n\"\n    /* \"    Deflate (ZIP) options:\\n\" */\n    \"    #  set predictor value\\n\"\n#endif\n#ifdef JPEG_SUPPORT\n    \" -c jpeg[:opts]\tcompress output with JPEG encoding\\n\"\n    /* \"    JPEG options:\\n\" */\n    \"    #  set compression quality level (0-100, default 75)\\n\"\n    \"    r  output color image as RGB rather than YCbCr\\n\"\n    \"    For example, -c jpeg:r:50 for JPEG-encoded RGB data with 50% comp. \"\n    \"quality\\n\"\n#endif\n#ifdef PACKBITS_SUPPORT\n    \" -c packbits\tcompress output with packbits encoding\\n\"\n#endif\n#if defined(LZW_SUPPORT) || defined(ZIP_SUPPORT) || defined(JPEG_SUPPORT) ||   \\\n    defined(PACKBITS_SUPPORT)\n    \" -c none\tuse no compression algorithm on output\\n\"\n#endif\n    \"\\n\"\n    \" -o out.tif\twrite output to out.tif\\n\"\n    \" -h\t\tthis help message\\n\";\n\nstatic void usage(int code)\n{\n    FILE *out = (code == EXIT_SUCCESS) ? stdout : stderr;\n\n    fprintf(out, \"%s\\n\\n\", TIFFGetVersion());\n    fprintf(out, \"%s\", usage_info);\n    exit(code);\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include \"libport.h\"\n#include \"tif_config.h\"\n\n#include <ctype.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if HAVE_FCNTL_H\n#include <fcntl.h>\n#endif\n\n#if HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#if HAVE_IO_H\n#include <io.h>\n#endif\n\n#include \"tiffio.h\"\n#include \"tiffiop.h\"\n\n#ifndef EXIT_SUCCESS\n#define EXIT_SUCCESS 0\n#endif\n#ifndef EXIT_FAILURE\n#define EXIT_FAILURE 1\n#endif\n\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n\ntypedef enum\n{\n    PIXEL,\n    BAND\n} InterleavingType;\n\nstatic uint16_t compression = (uint16_t)-1;\nstatic int jpegcolormode = JPEGCOLORMODE_RGB;\nstatic int quality = 75; /* JPEG quality */\nstatic uint16_t predictor = 0;\n\nstatic void swapBytesInScanline(void *, uint32_t, TIFFDataType);\nstatic int guessSize(int, TIFFDataType, _TIFF_off_t, uint32_t, int, uint32_t *,\n                     uint32_t *);\nstatic double correlation(void *, void *, uint32_t, TIFFDataType);\nstatic void usage(int);\nstatic int processCompressOptions(char *);\n\nint main(int argc, char *argv[])\n{\n    uint32_t width = 0, length = 0, linebytes, bufsize;\n    uint32_t nbands = 1;      /* number of bands in input image*/\n    _TIFF_off_t hdr_size = 0; /* size of the header to skip */\n    TIFFDataType dtype = TIFF_BYTE;\n    int16_t depth = 1;                 /* bytes per pixel in input image */\n    int swab = 0;                      /* byte swapping flag */\n    InterleavingType interleaving = 0; /* interleaving type flag */\n    uint32_t rowsperstrip = (uint32_t)-1;\n    uint16_t photometric = PHOTOMETRIC_MINISBLACK;\n    uint16_t config = PLANARCONFIG_CONTIG;\n    uint16_t fillorder = FILLORDER_LSB2MSB;\n    int fd;\n    char *outfilename = NULL;\n    TIFF *out;\n    uint32_t temp_limit_check = 0;\n\n    uint32_t row, col, band;\n    int c;\n    unsigned char *buf = NULL, *buf1 = NULL;\n#if !HAVE_DECL_OPTARG\n    extern int optind;\n    extern char *optarg;\n#endif\n\n    while ((c = getopt(argc, argv, \"c:r:H:w:l:b:d:LMp:si:o:h\")) != -1)\n    {\n        switch (c)\n        {\n            case 'c': /* compression scheme */\n                if (!processCompressOptions(optarg))\n                    usage(EXIT_FAILURE);\n                break;\n            case 'r': /* rows/strip */\n                rowsperstrip = atoi(optarg);\n                break;\n            case 'H': /* size of input image file header */\n                hdr_size = atoi(optarg);\n                break;\n            case 'w': /* input image width */\n                width = atoi(optarg);\n                break;\n            case 'l': /* input image length */\n                length = atoi(optarg);\n                break;\n            case 'b': /* number of bands in input image */\n                nbands = atoi(optarg);\n                break;\n            case 'd': /* type of samples in input image */\n                if (strncmp(optarg, \"byte\", 4) == 0)\n                    dtype = TIFF_BYTE;\n                else if (strncmp(optarg, \"short\", 5) == 0)\n                    dtype = TIFF_SHORT;\n                else if (strncmp(optarg, \"long\", 4) == 0)\n                    dtype = TIFF_LONG;\n                else if (strncmp(optarg, \"sbyte\", 5) == 0)\n                    dtype = TIFF_SBYTE;\n                else if (strncmp(optarg, \"sshort\", 6) == 0)\n                    dtype = TIFF_SSHORT;\n                else if (strncmp(optarg, \"slong\", 5) == 0)\n                    dtype = TIFF_SLONG;\n                else if (strncmp(optarg, \"float\", 5) == 0)\n                    dtype = TIFF_FLOAT;\n                else if (strncmp(optarg, \"double\", 6) == 0)\n                    dtype = TIFF_DOUBLE;\n                else\n                    dtype = TIFF_BYTE;\n                depth = TIFFDataWidth(dtype);\n                break;\n            case 'L': /* input has lsb-to-msb fillorder */\n                fillorder = FILLORDER_LSB2MSB;\n                break;\n            case 'M': /* input has msb-to-lsb fillorder */\n                fillorder = FILLORDER_MSB2LSB;\n                break;\n            case 'p': /* photometric interpretation */\n                if (strncmp(optarg, \"miniswhite\", 10) == 0)\n                    photometric = PHOTOMETRIC_MINISWHITE;\n                else if (strncmp(optarg, \"minisblack\", 10) == 0)\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                else if (strncmp(optarg, \"rgb\", 3) == 0)\n                    photometric = PHOTOMETRIC_RGB;\n                else if (strncmp(optarg, \"cmyk\", 4) == 0)\n                    photometric = PHOTOMETRIC_SEPARATED;\n                else if (strncmp(optarg, \"ycbcr\", 5) == 0)\n                    photometric = PHOTOMETRIC_YCBCR;\n                else if (strncmp(optarg, \"cielab\", 6) == 0)\n                    photometric = PHOTOMETRIC_CIELAB;\n                else if (strncmp(optarg, \"icclab\", 6) == 0)\n                    photometric = PHOTOMETRIC_ICCLAB;\n                else if (strncmp(optarg, \"itulab\", 6) == 0)\n                    photometric = PHOTOMETRIC_ITULAB;\n                else\n                    photometric = PHOTOMETRIC_MINISBLACK;\n                break;\n            case 's': /* do we need to swap bytes? */\n                swab = 1;\n                break;\n            case 'i': /* type of interleaving */\n                if (strncmp(optarg, \"pixel\", 4) == 0)\n                    interleaving = PIXEL;\n                else if (strncmp(optarg, \"band\", 6) == 0)\n                    interleaving = BAND;\n                else\n                    interleaving = 0;\n                break;\n            case 'o':\n                outfilename = optarg;\n                break;\n            case 'h':\n                usage(EXIT_SUCCESS);\n            default:\n                break;\n        }\n    }\n\n    if (argc - optind < 2)\n        usage(EXIT_FAILURE);\n\n    fd = open(argv[optind], O_RDONLY | O_BINARY, 0);\n    if (fd < 0)\n    {\n        fprintf(stderr, \"%s: %s: Cannot open input file.\\n\", argv[0],\n                argv[optind]);\n        return (EXIT_FAILURE);\n    }\n\n    if (nbands == 0)\n    {\n        fprintf(stderr, \"The number of bands is illegal.\\n\");\n        return (-1);\n    }\n\n    if (guessSize(fd, dtype, hdr_size, nbands, swab, &width, &length) < 0)\n        return EXIT_FAILURE;\n\n    if ((width == 0) || (length == 0) ){\n        fprintf(stderr, \"Too large nbands value specified.\\n\");\n        return (EXIT_FAILURE);\n    }\n    \n    temp_limit_check = nbands * depth;\n\n    if ( !temp_limit_check || length > ( UINT_MAX / temp_limit_check ) )  {\n        fprintf(stderr, \"Too large length size specified.\\n\");\n        return (EXIT_FAILURE);\n    }\n    temp_limit_check = temp_limit_check * length;\n\n    if ( !temp_limit_check || width > ( UINT_MAX / temp_limit_check ) )  {\n        fprintf(stderr, \"Too large width size specified.\\n\");\n        return (EXIT_FAILURE);\n    }\n    temp_limit_check = temp_limit_check * width;\n\n    if ( !temp_limit_check || hdr_size > ( UINT_MAX - temp_limit_check ) )  {\n        fprintf(stderr, \"Too large header size specified.\\n\");\n        return (EXIT_FAILURE);\n    }\n\n    if (outfilename == NULL)\n        outfilename = argv[optind + 1];\n    out = TIFFOpen(outfilename, \"w\");\n    if (out == NULL)\n    {\n        fprintf(stderr, \"%s: %s: Cannot open file for output.\\n\", argv[0],\n                outfilename);\n        return (EXIT_FAILURE);\n    }\n    TIFFSetField(out, TIFFTAG_IMAGEWIDTH, width);\n    TIFFSetField(out, TIFFTAG_IMAGELENGTH, length);\n    TIFFSetField(out, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);\n    TIFFSetField(out, TIFFTAG_SAMPLESPERPIXEL, nbands);\n    TIFFSetField(out, TIFFTAG_BITSPERSAMPLE, depth * 8);\n    TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);\n    TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);\n    TIFFSetField(out, TIFFTAG_PHOTOMETRIC, photometric);\n    switch (dtype)\n    {\n        case TIFF_BYTE:\n        case TIFF_SHORT:\n        case TIFF_LONG:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_UINT);\n            break;\n        case TIFF_SBYTE:\n        case TIFF_SSHORT:\n        case TIFF_SLONG:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_INT);\n            break;\n        case TIFF_FLOAT:\n        case TIFF_DOUBLE:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_IEEEFP);\n            break;\n        default:\n            TIFFSetField(out, TIFFTAG_SAMPLEFORMAT, SAMPLEFORMAT_VOID);\n            break;\n    }\n    if (compression == (uint16_t)-1)\n        compression = COMPRESSION_PACKBITS;\n    TIFFSetField(out, TIFFTAG_COMPRESSION, compression);\n    switch (compression)\n    {\n        case COMPRESSION_JPEG:\n            if (photometric == PHOTOMETRIC_RGB &&\n                jpegcolormode == JPEGCOLORMODE_RGB)\n                photometric = PHOTOMETRIC_YCBCR;\n            TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);\n            TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);\n            break;\n        case COMPRESSION_LZW:\n        case COMPRESSION_ADOBE_DEFLATE:\n        case COMPRESSION_DEFLATE:\n            if (predictor != 0)\n                TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);\n            break;\n    }\n    switch (interleaving)\n    {\n        case BAND: /* band interleaved data */\n            linebytes = width * depth;\n            buf = (unsigned char *)_TIFFmalloc(linebytes);\n            break;\n        case PIXEL: /* pixel interleaved data */\n        default:\n            linebytes = width * nbands * depth;\n            break;\n    }\n    bufsize = width * nbands * depth;\n    buf1 = (unsigned char *)_TIFFmalloc(bufsize);\n\n    rowsperstrip = TIFFDefaultStripSize(out, rowsperstrip);\n    if (rowsperstrip > length)\n    {\n        rowsperstrip = length;\n    }\n    TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);\n\n    _TIFF_lseek_f(fd, hdr_size, SEEK_SET); /* Skip the file header */\n    for (row = 0; row < length; row++)\n    {\n        switch (interleaving)\n        {\n            case BAND: /* band interleaved data */\n                for (band = 0; band < nbands; band++)\n                {\n                    if (_TIFF_lseek_f(\n                            fd, hdr_size + (length * band + row) * linebytes,\n                            SEEK_SET) == (_TIFF_off_t)-1)\n                    {\n                        fprintf(stderr,\n                                \"%s: %s: scanline %\" PRIu32 \": seek error.\\n\",\n                                argv[0], argv[optind], row);\n                        break;\n                    }\n                    if (read(fd, buf, linebytes) < 0)\n                    {\n                        fprintf(stderr,\n                                \"%s: %s: scanline %\" PRIu32 \": Read error.\\n\",\n                                argv[0], argv[optind], row);\n                        break;\n                    }\n                    if (swab) /* Swap bytes if needed */\n                        swapBytesInScanline(buf, width, dtype);\n                    for (col = 0; col < width; col++)\n                        memcpy(buf1 + (col * nbands + band) * depth,\n                               buf + col * depth, depth);\n                }\n                break;\n            case PIXEL: /* pixel interleaved data */\n            default:\n                if (read(fd, buf1, bufsize) < 0)\n                {\n                    fprintf(stderr,\n                            \"%s: %s: scanline %\" PRIu32 \": Read error.\\n\",\n                            argv[0], argv[optind], row);\n                    break;\n                }\n                if (swab) /* Swap bytes if needed */\n                    swapBytesInScanline(buf1, width, dtype);\n                break;\n        }\n\n        if (TIFFWriteScanline(out, buf1, row, 0) < 0)\n        {\n            fprintf(stderr, \"%s: %s: scanline %\" PRIu32 \": Write error.\\n\",\n                    argv[0], outfilename, row);\n            break;\n        }\n    }\n    if (buf)\n        _TIFFfree(buf);\n    if (buf1)\n        _TIFFfree(buf1);\n    TIFFClose(out);\n    return (EXIT_SUCCESS);\n}\n\nstatic void swapBytesInScanline(void *buf, uint32_t width, TIFFDataType dtype)\n{\n    switch (dtype)\n    {\n        case TIFF_SHORT:\n        case TIFF_SSHORT:\n            TIFFSwabArrayOfShort((uint16_t *)buf, (unsigned long)width);\n            break;\n        case TIFF_LONG:\n        case TIFF_SLONG:\n            TIFFSwabArrayOfLong((uint32_t *)buf, (unsigned long)width);\n            break;\n        /* case TIFF_FLOAT: */ /* FIXME */\n        case TIFF_DOUBLE:\n            TIFFSwabArrayOfDouble((double *)buf, (unsigned long)width);\n            break;\n        default:\n            break;\n    }\n}\n\nstatic int guessSize(int fd, TIFFDataType dtype, _TIFF_off_t hdr_size,\n                     uint32_t nbands, int swab, uint32_t *width,\n                     uint32_t *length)\n{\n    const float longt = 40.0; /* maximum possible height/width ratio */\n    char *buf1, *buf2;\n    _TIFF_stat_s filestat;\n    uint32_t w, h, scanlinesize, imagesize;\n    uint32_t depth = TIFFDataWidth(dtype);\n    double cor_coef = 0, tmp;\n\n    if (_TIFF_fstat_f(fd, &filestat) == -1)\n    {\n        fprintf(stderr, \"Failed to obtain file size.\\n\");\n        return -1;\n    }\n\n    if (filestat.st_size < hdr_size)\n    {\n        fprintf(stderr, \"Too large header size specified.\\n\");\n        return -1;\n    }\n\n    imagesize = (filestat.st_size - hdr_size) / nbands / depth;\n\n    if (*width != 0 && *length == 0)\n    {\n        fprintf(stderr, \"Image height is not specified.\\n\");\n\n        *length = imagesize / *width;\n\n        fprintf(stderr, \"Height is guessed as %\" PRIu32 \".\\n\", *length);\n\n        return 1;\n    }\n    else if (*width == 0 && *length != 0)\n    {\n        fprintf(stderr, \"Image width is not specified.\\n\");\n\n        *width = imagesize / *length;\n\n        fprintf(stderr, \"Width is guessed as %\" PRIu32 \".\\n\", *width);\n\n        return 1;\n    }\n    else if (*width == 0 && *length == 0)\n    {\n        unsigned int fail = 0;\n        fprintf(stderr, \"Image width and height are not specified.\\n\");\n        w = (uint32_t)sqrt(imagesize / longt);\n        if (w == 0)\n        {\n            fprintf(stderr, \"Too small image size.\\n\");\n            return -1;\n        }\n\n        for (; w < sqrt(imagesize * longt); w++)\n        {\n            if (imagesize % w == 0)\n            {\n                scanlinesize = w * depth;\n                h = imagesize / w;\n                if (h < 2)\n                    continue;\n                /* reads 2 lines at the middle of the image and calculate their\n                 * correlation. it works for h >= 2. (in this case it will\n                 * compare line 0 and line 1 */\n                buf1 = _TIFFmalloc(scanlinesize);\n                buf2 = _TIFFmalloc(scanlinesize);\n                do\n                {\n                    if (_TIFF_lseek_f(\n                            fd, hdr_size + (int)((h - 1) / 2) * scanlinesize,\n                            SEEK_SET) == (_TIFF_off_t)-1)\n                    {\n                        fprintf(stderr, \"seek error.\\n\");\n                        fail = 1;\n                        break;\n                    }\n                    /* read line (h-1)/2 */\n                    if (read(fd, buf1, scanlinesize) != (long)scanlinesize)\n                    {\n                        fprintf(stderr, \"read error.\\n\");\n                        fail = 1;\n                        break;\n                    }\n                    /* read line ((h-1)/2)+1 */\n                    if (read(fd, buf2, scanlinesize) != (long)scanlinesize)\n                    {\n                        fprintf(stderr, \"read error.\\n\");\n                        fail = 1;\n                        break;\n                    }\n                    if (swab)\n                    {\n                        swapBytesInScanline(buf1, w, dtype);\n                        swapBytesInScanline(buf2, w, dtype);\n                    }\n                    if (0 == memcmp(buf1, buf2, scanlinesize))\n                    {\n                        *width = w, *length = h;\n                    }\n                    else\n                    {\n                        tmp = fabs(correlation(buf1, buf2, w, dtype));\n                        if (tmp > cor_coef)\n                        {\n                            cor_coef = tmp;\n                            *width = w, *length = h;\n                        }\n                    }\n                } while (0);\n\n                _TIFFfree(buf1);\n                _TIFFfree(buf2);\n            }\n        }\n\n        if (fail)\n        {\n            return -1;\n        }\n\n        fprintf(stderr,\n                \"Width is guessed as %\" PRIu32 \", height is guessed as %\" PRIu32\n                \".\\n\",\n                *width, *length);\n\n        return 1;\n    }\n    else\n    {\n        if (filestat.st_size <\n            (_TIFF_off_t)(hdr_size + (*width) * (*length) * nbands * depth))\n        {\n            fprintf(stderr, \"Input file too small.\\n\");\n            return -1;\n        }\n    }\n\n    return 1;\n}\n\n/* Calculate correlation coefficient between two numeric vectors */\nstatic double correlation(void *buf1, void *buf2, uint32_t n_elem,\n                          TIFFDataType dtype)\n{\n    double X, Y, M1 = 0.0, M2 = 0.0, D1 = 0.0, D2 = 0.0, K = 0.0;\n    uint32_t i;\n\n    switch (dtype)\n    {\n        case TIFF_BYTE:\n        default:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((unsigned char *)buf1)[i];\n                Y = ((unsigned char *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SBYTE:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((signed char *)buf1)[i];\n                Y = ((signed char *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SHORT:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((uint16_t *)buf1)[i];\n                Y = ((uint16_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SSHORT:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((int16_t *)buf1)[i];\n                Y = ((int16_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_LONG:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((uint32_t *)buf1)[i];\n                Y = ((uint32_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_SLONG:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((int32_t *)buf1)[i];\n                Y = ((int32_t *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_FLOAT:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((float *)buf1)[i];\n                Y = ((float *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n        case TIFF_DOUBLE:\n            for (i = 0; i < n_elem; i++)\n            {\n                X = ((double *)buf1)[i];\n                Y = ((double *)buf2)[i];\n                M1 += X, M2 += Y;\n                D1 += X * X, D2 += Y * Y;\n                K += X * Y;\n            }\n            break;\n    }\n\n    M1 /= n_elem;\n    M2 /= n_elem;\n    D1 -= M1 * M1 * n_elem;\n    D2 -= M2 * M2 * n_elem;\n    if (D1 * D2 == 0.0)\n        return 0.0; /* avoid divide by zero */\n    K = (K - M1 * M2 * n_elem) / sqrt(D1 * D2);\n\n    return K;\n}\n\nstatic int processCompressOptions(char *opt)\n{\n    if (strcmp(opt, \"none\") == 0)\n        compression = COMPRESSION_NONE;\n    else if (strcmp(opt, \"packbits\") == 0)\n        compression = COMPRESSION_PACKBITS;\n    else if (strncmp(opt, \"jpeg\", 4) == 0)\n    {\n        char *cp = strchr(opt, ':');\n\n        compression = COMPRESSION_JPEG;\n        while (cp)\n        {\n            if (isdigit((int)cp[1]))\n                quality = atoi(cp + 1);\n            else if (cp[1] == 'r')\n                jpegcolormode = JPEGCOLORMODE_RAW;\n            else\n                usage(EXIT_FAILURE);\n\n            cp = strchr(cp + 1, ':');\n        }\n    }\n    else if (strncmp(opt, \"lzw\", 3) == 0)\n    {\n        char *cp = strchr(opt, ':');\n        if (cp)\n            predictor = atoi(cp + 1);\n        compression = COMPRESSION_LZW;\n    }\n    else if (strncmp(opt, \"zip\", 3) == 0)\n    {\n        char *cp = strchr(opt, ':');\n        if (cp)\n            predictor = atoi(cp + 1);\n        compression = COMPRESSION_ADOBE_DEFLATE;\n    }\n    else\n        return (0);\n    return (1);\n}\n\nstatic const char usage_info[] =\n    \"Create a TIFF file from raw data\\n\\n\"\n    \"usage: raw2tiff [options] input.raw output.tif\\n\"\n    \"where options are:\\n\"\n    \" -L\t\tinput data has LSB2MSB bit order (default)\\n\"\n    \" -M\t\tinput data has MSB2LSB bit order\\n\"\n    \" -r #\t\tmake each strip have no more than # rows\\n\"\n    \" -H #\t\tsize of input image file header in bytes (0 by \"\n    \"default)\\n\"\n    \" -w #\t\twidth of input image in pixels\\n\"\n    \" -l #\t\tlength of input image in lines\\n\"\n    \" -b #\t\tnumber of bands in input image (1 by default)\\n\"\n    \"\\n\"\n    \" -d data_type\ttype of samples in input image\\n\"\n    \"where data_type may be:\\n\"\n    \" byte\t\t8-bit unsigned integer (default)\\n\"\n    \" short\t\t16-bit unsigned integer\\n\"\n    \" long\t\t32-bit unsigned integer\\n\"\n    \" sbyte\t\t8-bit signed integer\\n\"\n    \" sshort\t\t16-bit signed integer\\n\"\n    \" slong\t\t32-bit signed integer\\n\"\n    \" float\t\t32-bit IEEE floating point\\n\"\n    \" double\t\t64-bit IEEE floating point\\n\"\n    \"\\n\"\n    \" -p photo\tphotometric interpretation (color space) of the input image\\n\"\n    \"where photo may be:\\n\"\n    \" miniswhite\twhite color represented with 0 value\\n\"\n    \" minisblack\tblack color represented with 0 value (default)\\n\"\n    \" rgb\t\timage has RGB color model\\n\"\n    \" cmyk\t\timage has CMYK (separated) color model\\n\"\n    \" ycbcr\t\timage has YCbCr color model\\n\"\n    \" cielab\t\timage has CIE L*a*b color model\\n\"\n    \" icclab\t\timage has ICC L*a*b color model\\n\"\n    \" itulab\t\timage has ITU L*a*b color model\\n\"\n    \"\\n\"\n    \" -s\t\tswap bytes fetched from input file\\n\"\n    \"\\n\"\n    \" -i config\ttype of samples interleaving in input image\\n\"\n    \"where config may be:\\n\"\n    \" pixel\t\tpixel interleaved data (default)\\n\"\n    \" band\t\tband interleaved data\\n\"\n    \"\\n\"\n#ifdef LZW_SUPPORT\n    \" -c lzw[:opts]\tcompress output with Lempel-Ziv & Welch encoding\\n\"\n    /* \"    LZW options:\\n\" */\n    \"    #  set predictor value\\n\"\n    \"    For example, -c lzw:2 for LZW-encoded data with horizontal \"\n    \"differencing\\n\"\n#endif\n#ifdef ZIP_SUPPORT\n    \" -c zip[:opts]\tcompress output with deflate encoding\\n\"\n    /* \"    Deflate (ZIP) options:\\n\" */\n    \"    #  set predictor value\\n\"\n#endif\n#ifdef JPEG_SUPPORT\n    \" -c jpeg[:opts]\tcompress output with JPEG encoding\\n\"\n    /* \"    JPEG options:\\n\" */\n    \"    #  set compression quality level (0-100, default 75)\\n\"\n    \"    r  output color image as RGB rather than YCbCr\\n\"\n    \"    For example, -c jpeg:r:50 for JPEG-encoded RGB data with 50% comp. \"\n    \"quality\\n\"\n#endif\n#ifdef PACKBITS_SUPPORT\n    \" -c packbits\tcompress output with packbits encoding\\n\"\n#endif\n#if defined(LZW_SUPPORT) || defined(ZIP_SUPPORT) || defined(JPEG_SUPPORT) ||   \\\n    defined(PACKBITS_SUPPORT)\n    \" -c none\tuse no compression algorithm on output\\n\"\n#endif\n    \"\\n\"\n    \" -o out.tif\twrite output to out.tif\\n\"\n    \" -h\t\tthis help message\\n\";\n\nstatic void usage(int code)\n{\n    FILE *out = (code == EXIT_SUCCESS) ? stdout : stderr;\n\n    fprintf(out, \"%s\\n\\n\", TIFFGetVersion());\n    fprintf(out, \"%s\", usage_info);\n    exit(code);\n}\n",
    "source": "real-world",
    "cwe": "CWE-190",
    "vulnerability_type": "integer_overflow",
    "idx": 32,
    "typechecks": true,
    "cve": "CVE-2023-41175",
    "project": "libtiff"
  },
  {
    "prompt": "Security review of this code:\n\n#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/filter.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n\nstatic struct bt_sock_list l2cap_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)\n};\n\nstatic const struct proto_ops l2cap_sock_ops;\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent);\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern);\n\nbool l2cap_is_socket(struct socket *sock)\n{\n\treturn sock && sock->ops == &l2cap_sock_ops;\n}\nEXPORT_SYMBOL(l2cap_is_socket);\n\nstatic int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p state %s\", parent,\n\t       state_to_string(parent->sk_state));\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\t\tBT_DBG(\"child chan %p state %s\", chan,\n\t\t       state_to_string(chan->state));\n\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\t__clear_chan_timer(chan);\n\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\tl2cap_sock_kill(sk);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n}\n\nstatic void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\t/* This callback can be called both for server (BT_LISTEN)\n\t * sockets as well as \"normal\" ones. To avoid lockdep warnings\n\t * with child socket locking (through l2cap_sock_cleanup_listen)\n\t * we need separation into separate nesting levels. The simplest\n\t * way to accomplish this is to inherit the nesting level used\n\t * for the channel.\n\t */\n\tlock_sock_nested(sk, atomic_read(&chan->nesting));\n\n\tparent = bt_sk(sk)->parent;\n\n\tswitch (chan->state) {\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\tcase BT_CLOSED:\n\t\tbreak;\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tsk->sk_err = err;\n\n\t\tif (parent) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tparent->sk_data_ready(parent);\n\t\t} else {\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\t/* Only zap after cleanup to avoid use after free race */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n}\n\nstatic void l2cap_sock_state_change_cb(struct l2cap_chan *chan, int state,\n\t\t\t\t       int err)\n{\n\tstruct sock *sk = chan->data;\n\n\tsk->sk_state = state;\n\n\tif (err)\n\t\tsk->sk_err = err;\n}\n\nstatic struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\t       unsigned long hdr_len,\n\t\t\t\t\t       unsigned long len, int nb)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tl2cap_chan_unlock(chan);\n\tskb = bt_skb_send_alloc(sk, hdr_len + len, nb, &err);\n\tl2cap_chan_lock(chan);\n\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\t/* Channel lock is released before requesting new skb and then\n\t * reacquired thus we need to recheck channel state.\n\t */\n\tif (chan->state != BT_CONNECTED) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOTCONN);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\n\tbt_cb(skb)->l2cap.chan = chan;\n\n\treturn skb;\n}\n\nstatic void l2cap_sock_ready_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\n\tBT_DBG(\"sk %p, parent %p\", sk, parent);\n\n\tsk->sk_state = BT_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_defer_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *parent, *sk = chan->data;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_resume_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (test_and_clear_bit(FLAG_PENDING_SECURITY, &chan->flags)) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tchan->state = BT_CONNECTED;\n\t}\n\n\tclear_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic void l2cap_sock_set_shutdown_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\trelease_sock(sk);\n}\n\nstatic long l2cap_sock_get_sndtimeo_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_sndtimeo;\n}\n\nstatic struct pid *l2cap_sock_get_peer_pid_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_peer_pid;\n}\n\nstatic void l2cap_sock_suspend_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic int l2cap_sock_filter(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn sk_filter(sk, skb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct l2cap_ops l2cap_chan_ops = {\n\t.name\t\t\t= \"L2CAP Socket Interface\",\n\t.new_connection\t\t= l2cap_sock_new_connection_cb,\n\t.recv\t\t\t= l2cap_sock_recv_cb,\n\t.close\t\t\t= l2cap_sock_close_cb,\n\t.teardown\t\t= l2cap_sock_teardown_cb,\n\t.state_change\t\t= l2cap_sock_state_change_cb,\n\t.ready\t\t\t= l2cap_sock_ready_cb,\n\t.defer\t\t\t= l2cap_sock_defer_cb,\n\t.resume\t\t\t= l2cap_sock_resume_cb,\n\t.suspend\t\t= l2cap_sock_suspend_cb,\n\t.set_shutdown\t\t= l2cap_sock_set_shutdown_cb,\n\t.get_sndtimeo\t\t= l2cap_sock_get_sndtimeo_cb,\n\t.get_peer_pid\t\t= l2cap_sock_get_peer_pid_cb,\n\t.alloc_skb\t\t= l2cap_sock_alloc_skb_cb,\n\t.filter\t\t\t= l2cap_sock_filter,\n};\n\nstatic void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (l2cap_pi(sk)->chan) {\n\t\tl2cap_pi(sk)->chan->data = NULL;\n\t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\t}\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);\n\t\tl2cap_pi(sk)->rx_busy_skb = NULL;\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void l2cap_skb_msg_name(struct sk_buff *skb, void *msg_name,\n\t\t\t       int *msg_namelen)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_l2 *, la, msg_name);\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\tla->l2_family = AF_BLUETOOTH;\n\tla->l2_psm = bt_cb(skb)->l2cap.psm;\n\tbacpy(&la->l2_bdaddr, &bt_cb(skb)->l2cap.bdaddr);\n\n\t*msg_namelen = sizeof(struct sockaddr_l2);\n}\n\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tstruct l2cap_chan *pchan = l2cap_pi(parent)->chan;\n\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\n\t\tchan->chan_type = pchan->chan_type;\n\t\tchan->imtu = pchan->imtu;\n\t\tchan->omtu = pchan->omtu;\n\t\tchan->conf_state = pchan->conf_state;\n\t\tchan->mode = pchan->mode;\n\t\tchan->fcs  = pchan->fcs;\n\t\tchan->max_tx = pchan->max_tx;\n\t\tchan->tx_win = pchan->tx_win;\n\t\tchan->tx_win_max = pchan->tx_win_max;\n\t\tchan->sec_level = pchan->sec_level;\n\t\tchan->flags = pchan->flags;\n\t\tchan->tx_credits = pchan->tx_credits;\n\t\tchan->rx_credits = pchan->rx_credits;\n\n\t\tif (chan->chan_type == L2CAP_CHAN_FIXED) {\n\t\t\tchan->scid = pchan->scid;\n\t\t\tchan->dcid = pchan->scid;\n\t\t}\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tswitch (sk->sk_type) {\n\t\tcase SOCK_RAW:\n\t\t\tchan->chan_type = L2CAP_CHAN_RAW;\n\t\t\tbreak;\n\t\tcase SOCK_DGRAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_LESS;\n\t\t\tbt_sk(sk)->skb_msg_name = l2cap_skb_msg_name;\n\t\t\tbreak;\n\t\tcase SOCK_SEQPACKET:\n\t\tcase SOCK_STREAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_ORIENTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->imtu = L2CAP_DEFAULT_MTU;\n\t\tchan->omtu = 0;\n\t\tif (!disable_ertm && sk->sk_type == SOCK_STREAM) {\n\t\t\tchan->mode = L2CAP_MODE_ERTM;\n\t\t\tset_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t} else {\n\t\t\tchan->mode = L2CAP_MODE_BASIC;\n\t\t}\n\n\t\tl2cap_chan_set_defaults(chan);\n\t}\n\n\t/* Default config options */\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\n\tchan->data = sk;\n\tchan->ops = &l2cap_chan_ops;\n}\n\nstatic struct proto l2cap_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct l2cap_pinfo)\n};\n\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\tstruct l2cap_chan *chan;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = l2cap_sock_destruct;\n\tsk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state = BT_OPEN;\n\n\tchan = l2cap_chan_create();\n\tif (!chan) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tl2cap_chan_hold(chan);\n\n\tl2cap_pi(sk)->chan = chan;\n\n\treturn sk;\n}\n\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t     int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsock->ops = &l2cap_sock_ops;\n\n\tsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tl2cap_sock_init(sk, NULL);\n\tbt_sock_link(&l2cap_sk_list, sk);\n\treturn 0;\n}\n\nstatic const struct proto_ops l2cap_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= l2cap_sock_release,\n\t.bind\t\t= l2cap_sock_bind,\n\t.connect\t= l2cap_sock_connect,\n\t.listen\t\t= l2cap_sock_listen,\n\t.accept\t\t= l2cap_sock_accept,\n\t.getname\t= l2cap_sock_getname,\n\t.sendmsg\t= l2cap_sock_sendmsg,\n\t.recvmsg\t= l2cap_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= l2cap_sock_shutdown,\n\t.setsockopt\t= l2cap_sock_setsockopt,\n\t.getsockopt\t= l2cap_sock_getsockopt\n};\n\nstatic const struct net_proto_family l2cap_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= l2cap_sock_create,\n};\n\nint __init l2cap_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_l2) > sizeof(struct sockaddr));\n\n\terr = proto_register(&l2cap_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"l2cap\", &l2cap_sk_list,\n\t\t\t     NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create L2CAP proc file\");\n\t\tbt_sock_unregister(BTPROTO_L2CAP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"L2CAP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&l2cap_proto);\n\treturn err;\n}\n\nvoid l2cap_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"l2cap\");\n\tbt_sock_unregister(BTPROTO_L2CAP);\n\tproto_unregister(&l2cap_proto);\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <linux/module.h>\n#include <linux/export.h>\n#include <linux/filter.h>\n#include <linux/sched/signal.h>\n\n#include <net/bluetooth/bluetooth.h>\n#include <net/bluetooth/hci_core.h>\n#include <net/bluetooth/l2cap.h>\n\n#include \"smp.h\"\n\nstatic struct bt_sock_list l2cap_sk_list = {\n\t.lock = __RW_LOCK_UNLOCKED(l2cap_sk_list.lock)\n};\n\nstatic const struct proto_ops l2cap_sock_ops;\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent);\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern);\nstatic void l2cap_sock_cleanup_listen(struct sock *parent);\n\nbool l2cap_is_socket(struct socket *sock)\n{\n\treturn sock && sock->ops == &l2cap_sock_ops;\n}\nEXPORT_SYMBOL(l2cap_is_socket);\n\nstatic int l2cap_sock_release(struct socket *sock)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\tstruct l2cap_chan *chan;\n\n\tBT_DBG(\"sock %p, sk %p\", sock, sk);\n\n\tif (!sk)\n\t\treturn 0;\n\n\tl2cap_sock_cleanup_listen(sk);\n\tbt_sock_unlink(&l2cap_sk_list, sk);\n\n\terr = l2cap_sock_shutdown(sock, SHUT_RDWR);\n\tchan = l2cap_pi(sk)->chan;\n\n\tl2cap_chan_hold(chan);\n\tl2cap_chan_lock(chan);\n\n\tsock_orphan(sk);\n\tl2cap_sock_kill(sk);\n\n\tl2cap_chan_unlock(chan);\n\tl2cap_chan_put(chan);\n\n\treturn err;\n}\n\nstatic void l2cap_sock_cleanup_listen(struct sock *parent)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"parent %p state %s\", parent,\n\t       state_to_string(parent->sk_state));\n\n\t/* Close not yet accepted channels */\n\twhile ((sk = bt_accept_dequeue(parent, NULL))) {\n\t\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\t\tBT_DBG(\"child chan %p state %s\", chan,\n\t\t       state_to_string(chan->state));\n\n\t\tl2cap_chan_hold(chan);\n\t\tl2cap_chan_lock(chan);\n\n\t\t__clear_chan_timer(chan);\n\t\tl2cap_chan_close(chan, ECONNRESET);\n\t\tl2cap_sock_kill(sk);\n\n\t\tl2cap_chan_unlock(chan);\n\t\tl2cap_chan_put(chan);\n\t}\n}\n\nstatic void l2cap_sock_teardown_cb(struct l2cap_chan *chan, int err)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tif (!sk)\n\t\treturn;\n\n\tBT_DBG(\"chan %p state %s\", chan, state_to_string(chan->state));\n\n\t/* This callback can be called both for server (BT_LISTEN)\n\t * sockets as well as \"normal\" ones. To avoid lockdep warnings\n\t * with child socket locking (through l2cap_sock_cleanup_listen)\n\t * we need separation into separate nesting levels. The simplest\n\t * way to accomplish this is to inherit the nesting level used\n\t * for the channel.\n\t */\n\tlock_sock_nested(sk, atomic_read(&chan->nesting));\n\n\tparent = bt_sk(sk)->parent;\n\n\tswitch (chan->state) {\n\tcase BT_OPEN:\n\tcase BT_BOUND:\n\tcase BT_CLOSED:\n\t\tbreak;\n\tcase BT_LISTEN:\n\t\tl2cap_sock_cleanup_listen(sk);\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tbreak;\n\tdefault:\n\t\tsk->sk_state = BT_CLOSED;\n\t\tchan->state = BT_CLOSED;\n\n\t\tsk->sk_err = err;\n\n\t\tif (parent) {\n\t\t\tbt_accept_unlink(sk);\n\t\t\tparent->sk_data_ready(parent);\n\t\t} else {\n\t\t\tsk->sk_state_change(sk);\n\t\t}\n\n\t\tbreak;\n\t}\n\trelease_sock(sk);\n\n\t/* Only zap after cleanup to avoid use after free race */\n\tsock_set_flag(sk, SOCK_ZAPPED);\n\n}\n\nstatic void l2cap_sock_state_change_cb(struct l2cap_chan *chan, int state,\n\t\t\t\t       int err)\n{\n\tstruct sock *sk = chan->data;\n\n\tsk->sk_state = state;\n\n\tif (err)\n\t\tsk->sk_err = err;\n}\n\nstatic struct sk_buff *l2cap_sock_alloc_skb_cb(struct l2cap_chan *chan,\n\t\t\t\t\t       unsigned long hdr_len,\n\t\t\t\t\t       unsigned long len, int nb)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tl2cap_chan_unlock(chan);\n\tskb = bt_skb_send_alloc(sk, hdr_len + len, nb, &err);\n\tl2cap_chan_lock(chan);\n\n\tif (!skb)\n\t\treturn ERR_PTR(err);\n\n\t/* Channel lock is released before requesting new skb and then\n\t * reacquired thus we need to recheck channel state.\n\t */\n\tif (chan->state != BT_CONNECTED) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(-ENOTCONN);\n\t}\n\n\tskb->priority = sk->sk_priority;\n\n\tbt_cb(skb)->l2cap.chan = chan;\n\n\treturn skb;\n}\n\nstatic void l2cap_sock_ready_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\tstruct sock *parent;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\n\tBT_DBG(\"sk %p, parent %p\", sk, parent);\n\n\tsk->sk_state = BT_CONNECTED;\n\tsk->sk_state_change(sk);\n\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_defer_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *parent, *sk = chan->data;\n\n\tlock_sock(sk);\n\n\tparent = bt_sk(sk)->parent;\n\tif (parent)\n\t\tparent->sk_data_ready(parent);\n\n\trelease_sock(sk);\n}\n\nstatic void l2cap_sock_resume_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tif (test_and_clear_bit(FLAG_PENDING_SECURITY, &chan->flags)) {\n\t\tsk->sk_state = BT_CONNECTED;\n\t\tchan->state = BT_CONNECTED;\n\t}\n\n\tclear_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic void l2cap_sock_set_shutdown_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tlock_sock(sk);\n\tsk->sk_shutdown = SHUTDOWN_MASK;\n\trelease_sock(sk);\n}\n\nstatic long l2cap_sock_get_sndtimeo_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_sndtimeo;\n}\n\nstatic struct pid *l2cap_sock_get_peer_pid_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\treturn sk->sk_peer_pid;\n}\n\nstatic void l2cap_sock_suspend_cb(struct l2cap_chan *chan)\n{\n\tstruct sock *sk = chan->data;\n\n\tset_bit(BT_SK_SUSPEND, &bt_sk(sk)->flags);\n\tsk->sk_state_change(sk);\n}\n\nstatic int l2cap_sock_filter(struct l2cap_chan *chan, struct sk_buff *skb)\n{\n\tstruct sock *sk = chan->data;\n\n\tswitch (chan->mode) {\n\tcase L2CAP_MODE_ERTM:\n\tcase L2CAP_MODE_STREAMING:\n\t\treturn sk_filter(sk, skb);\n\t}\n\n\treturn 0;\n}\n\nstatic const struct l2cap_ops l2cap_chan_ops = {\n\t.name\t\t\t= \"L2CAP Socket Interface\",\n\t.new_connection\t\t= l2cap_sock_new_connection_cb,\n\t.recv\t\t\t= l2cap_sock_recv_cb,\n\t.close\t\t\t= l2cap_sock_close_cb,\n\t.teardown\t\t= l2cap_sock_teardown_cb,\n\t.state_change\t\t= l2cap_sock_state_change_cb,\n\t.ready\t\t\t= l2cap_sock_ready_cb,\n\t.defer\t\t\t= l2cap_sock_defer_cb,\n\t.resume\t\t\t= l2cap_sock_resume_cb,\n\t.suspend\t\t= l2cap_sock_suspend_cb,\n\t.set_shutdown\t\t= l2cap_sock_set_shutdown_cb,\n\t.get_sndtimeo\t\t= l2cap_sock_get_sndtimeo_cb,\n\t.get_peer_pid\t\t= l2cap_sock_get_peer_pid_cb,\n\t.alloc_skb\t\t= l2cap_sock_alloc_skb_cb,\n\t.filter\t\t\t= l2cap_sock_filter,\n};\n\nstatic void l2cap_sock_destruct(struct sock *sk)\n{\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (l2cap_pi(sk)->chan) {\n\t\tl2cap_pi(sk)->chan->data = NULL;\n\t\tl2cap_chan_put(l2cap_pi(sk)->chan);\n\t}\n\n\tif (l2cap_pi(sk)->rx_busy_skb) {\n\t\tkfree_skb(l2cap_pi(sk)->rx_busy_skb);\n\t\tl2cap_pi(sk)->rx_busy_skb = NULL;\n\t}\n\n\tskb_queue_purge(&sk->sk_receive_queue);\n\tskb_queue_purge(&sk->sk_write_queue);\n}\n\nstatic void l2cap_skb_msg_name(struct sk_buff *skb, void *msg_name,\n\t\t\t       int *msg_namelen)\n{\n\tDECLARE_SOCKADDR(struct sockaddr_l2 *, la, msg_name);\n\n\tmemset(la, 0, sizeof(struct sockaddr_l2));\n\tla->l2_family = AF_BLUETOOTH;\n\tla->l2_psm = bt_cb(skb)->l2cap.psm;\n\tbacpy(&la->l2_bdaddr, &bt_cb(skb)->l2cap.bdaddr);\n\n\t*msg_namelen = sizeof(struct sockaddr_l2);\n}\n\nstatic void l2cap_sock_init(struct sock *sk, struct sock *parent)\n{\n\tstruct l2cap_chan *chan = l2cap_pi(sk)->chan;\n\n\tBT_DBG(\"sk %p\", sk);\n\n\tif (parent) {\n\t\tstruct l2cap_chan *pchan = l2cap_pi(parent)->chan;\n\n\t\tsk->sk_type = parent->sk_type;\n\t\tbt_sk(sk)->flags = bt_sk(parent)->flags;\n\n\t\tchan->chan_type = pchan->chan_type;\n\t\tchan->imtu = pchan->imtu;\n\t\tchan->omtu = pchan->omtu;\n\t\tchan->conf_state = pchan->conf_state;\n\t\tchan->mode = pchan->mode;\n\t\tchan->fcs  = pchan->fcs;\n\t\tchan->max_tx = pchan->max_tx;\n\t\tchan->tx_win = pchan->tx_win;\n\t\tchan->tx_win_max = pchan->tx_win_max;\n\t\tchan->sec_level = pchan->sec_level;\n\t\tchan->flags = pchan->flags;\n\t\tchan->tx_credits = pchan->tx_credits;\n\t\tchan->rx_credits = pchan->rx_credits;\n\n\t\tif (chan->chan_type == L2CAP_CHAN_FIXED) {\n\t\t\tchan->scid = pchan->scid;\n\t\t\tchan->dcid = pchan->scid;\n\t\t}\n\n\t\tsecurity_sk_clone(parent, sk);\n\t} else {\n\t\tswitch (sk->sk_type) {\n\t\tcase SOCK_RAW:\n\t\t\tchan->chan_type = L2CAP_CHAN_RAW;\n\t\t\tbreak;\n\t\tcase SOCK_DGRAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_LESS;\n\t\t\tbt_sk(sk)->skb_msg_name = l2cap_skb_msg_name;\n\t\t\tbreak;\n\t\tcase SOCK_SEQPACKET:\n\t\tcase SOCK_STREAM:\n\t\t\tchan->chan_type = L2CAP_CHAN_CONN_ORIENTED;\n\t\t\tbreak;\n\t\t}\n\n\t\tchan->imtu = L2CAP_DEFAULT_MTU;\n\t\tchan->omtu = 0;\n\t\tif (!disable_ertm && sk->sk_type == SOCK_STREAM) {\n\t\t\tchan->mode = L2CAP_MODE_ERTM;\n\t\t\tset_bit(CONF_STATE2_DEVICE, &chan->conf_state);\n\t\t} else {\n\t\t\tchan->mode = L2CAP_MODE_BASIC;\n\t\t}\n\n\t\tl2cap_chan_set_defaults(chan);\n\t}\n\n\t/* Default config options */\n\tchan->flush_to = L2CAP_DEFAULT_FLUSH_TO;\n\n\tchan->data = sk;\n\tchan->ops = &l2cap_chan_ops;\n}\n\nstatic struct proto l2cap_proto = {\n\t.name\t\t= \"L2CAP\",\n\t.owner\t\t= THIS_MODULE,\n\t.obj_size\t= sizeof(struct l2cap_pinfo)\n};\n\nstatic struct sock *l2cap_sock_alloc(struct net *net, struct socket *sock,\n\t\t\t\t     int proto, gfp_t prio, int kern)\n{\n\tstruct sock *sk;\n\tstruct l2cap_chan *chan;\n\n\tsk = sk_alloc(net, PF_BLUETOOTH, prio, &l2cap_proto, kern);\n\tif (!sk)\n\t\treturn NULL;\n\n\tsock_init_data(sock, sk);\n\tINIT_LIST_HEAD(&bt_sk(sk)->accept_q);\n\n\tsk->sk_destruct = l2cap_sock_destruct;\n\tsk->sk_sndtimeo = L2CAP_CONN_TIMEOUT;\n\n\tsock_reset_flag(sk, SOCK_ZAPPED);\n\n\tsk->sk_protocol = proto;\n\tsk->sk_state = BT_OPEN;\n\n\tchan = l2cap_chan_create();\n\tif (!chan) {\n\t\tsk_free(sk);\n\t\treturn NULL;\n\t}\n\n\tl2cap_chan_hold(chan);\n\n\tl2cap_pi(sk)->chan = chan;\n\n\treturn sk;\n}\n\nstatic int l2cap_sock_create(struct net *net, struct socket *sock, int protocol,\n\t\t\t     int kern)\n{\n\tstruct sock *sk;\n\n\tBT_DBG(\"sock %p\", sock);\n\n\tsock->state = SS_UNCONNECTED;\n\n\tif (sock->type != SOCK_SEQPACKET && sock->type != SOCK_STREAM &&\n\t    sock->type != SOCK_DGRAM && sock->type != SOCK_RAW)\n\t\treturn -ESOCKTNOSUPPORT;\n\n\tif (sock->type == SOCK_RAW && !kern && !capable(CAP_NET_RAW))\n\t\treturn -EPERM;\n\n\tsock->ops = &l2cap_sock_ops;\n\n\tsk = l2cap_sock_alloc(net, sock, protocol, GFP_ATOMIC, kern);\n\tif (!sk)\n\t\treturn -ENOMEM;\n\n\tl2cap_sock_init(sk, NULL);\n\tbt_sock_link(&l2cap_sk_list, sk);\n\treturn 0;\n}\n\nstatic const struct proto_ops l2cap_sock_ops = {\n\t.family\t\t= PF_BLUETOOTH,\n\t.owner\t\t= THIS_MODULE,\n\t.release\t= l2cap_sock_release,\n\t.bind\t\t= l2cap_sock_bind,\n\t.connect\t= l2cap_sock_connect,\n\t.listen\t\t= l2cap_sock_listen,\n\t.accept\t\t= l2cap_sock_accept,\n\t.getname\t= l2cap_sock_getname,\n\t.sendmsg\t= l2cap_sock_sendmsg,\n\t.recvmsg\t= l2cap_sock_recvmsg,\n\t.poll\t\t= bt_sock_poll,\n\t.ioctl\t\t= bt_sock_ioctl,\n\t.gettstamp\t= sock_gettstamp,\n\t.mmap\t\t= sock_no_mmap,\n\t.socketpair\t= sock_no_socketpair,\n\t.shutdown\t= l2cap_sock_shutdown,\n\t.setsockopt\t= l2cap_sock_setsockopt,\n\t.getsockopt\t= l2cap_sock_getsockopt\n};\n\nstatic const struct net_proto_family l2cap_sock_family_ops = {\n\t.family\t= PF_BLUETOOTH,\n\t.owner\t= THIS_MODULE,\n\t.create\t= l2cap_sock_create,\n};\n\nint __init l2cap_init_sockets(void)\n{\n\tint err;\n\n\tBUILD_BUG_ON(sizeof(struct sockaddr_l2) > sizeof(struct sockaddr));\n\n\terr = proto_register(&l2cap_proto, 0);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = bt_sock_register(BTPROTO_L2CAP, &l2cap_sock_family_ops);\n\tif (err < 0) {\n\t\tBT_ERR(\"L2CAP socket registration failed\");\n\t\tgoto error;\n\t}\n\n\terr = bt_procfs_init(&init_net, \"l2cap\", &l2cap_sk_list,\n\t\t\t     NULL);\n\tif (err < 0) {\n\t\tBT_ERR(\"Failed to create L2CAP proc file\");\n\t\tbt_sock_unregister(BTPROTO_L2CAP);\n\t\tgoto error;\n\t}\n\n\tBT_INFO(\"L2CAP socket layer initialized\");\n\n\treturn 0;\n\nerror:\n\tproto_unregister(&l2cap_proto);\n\treturn err;\n}\n\nvoid l2cap_cleanup_sockets(void)\n{\n\tbt_procfs_cleanup(&init_net, \"l2cap\");\n\tbt_sock_unregister(BTPROTO_L2CAP);\n\tproto_unregister(&l2cap_proto);\n}",
    "source": "real-world",
    "cwe": "CWE-416",
    "vulnerability_type": "use_after_free",
    "idx": 33,
    "typechecks": true,
    "cve": "CVE-2023-40283",
    "project": "linux"
  },
  {
    "prompt": "Security review of this code:\n\n#include <linux/jhash.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/netlink.h>\n#include <net/tcp.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/ipset/pfxlen.h>\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_getport.h>\n#include <linux/netfilter/ipset/ip_set_hash.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n/*\t\t\t\t0    Comments support added */\n/*\t\t\t\t1    Forceadd support added */\n/*\t\t\t\t2    skbinfo support added */\n#define IPSET_TYPE_REV_MAX\t3 /* bucketsize, initval support added */\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oliver Smith <oliver@8.c.9.b.0.7.4.0.1.0.0.2.ip6.arpa>\");\nIP_SET_MODULE_DESC(\"hash:net,port,net\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_hash:net,port,net\");\n\n/* Type specific function prefix */\n#define HTYPE\t\thash_netportnet\n#define IP_SET_HASH_WITH_PROTO\n#define IP_SET_HASH_WITH_NETS\n#define IPSET_NET_COUNT 2\n\n/* IPv4 variant */\n\n/* Member elements */\nstruct hash_netportnet4_elem {\n\tunion {\n\t\t__be32 ip[2];\n\t\t__be64 ipcmp;\n\t};\n\t__be16 port;\n\tunion {\n\t\tu8 cidr[2];\n\t\tu16 ccmp;\n\t};\n\tu16 padding;\n\tu8 nomatch;\n\tu8 proto;\n};\n\n/* Common functions */\n\nstatic bool\nhash_netportnet4_data_equal(const struct hash_netportnet4_elem *ip1,\n\t\t\t    const struct hash_netportnet4_elem *ip2,\n\t\t\t    u32 *multi)\n{\n\treturn ip1->ipcmp == ip2->ipcmp &&\n\t       ip1->ccmp == ip2->ccmp &&\n\t       ip1->port == ip2->port &&\n\t       ip1->proto == ip2->proto;\n}\n\nstatic int\nhash_netportnet4_do_data_match(const struct hash_netportnet4_elem *elem)\n{\n\treturn elem->nomatch ? -ENOTEMPTY : 1;\n}\n\nstatic void\nhash_netportnet4_data_set_flags(struct hash_netportnet4_elem *elem, u32 flags)\n{\n\telem->nomatch = !!((flags >> 16) & IPSET_FLAG_NOMATCH);\n}\n\nstatic void\nhash_netportnet4_data_reset_flags(struct hash_netportnet4_elem *elem, u8 *flags)\n{\n\tswap(*flags, elem->nomatch);\n}\n\nstatic void\nhash_netportnet4_data_reset_elem(struct hash_netportnet4_elem *elem,\n\t\t\t\t struct hash_netportnet4_elem *orig)\n{\n\telem->ip[1] = orig->ip[1];\n}\n\nstatic void\nhash_netportnet4_data_netmask(struct hash_netportnet4_elem *elem,\n\t\t\t      u8 cidr, bool inner)\n{\n\tif (inner) {\n\t\telem->ip[1] &= ip_set_netmask(cidr);\n\t\telem->cidr[1] = cidr;\n\t} else {\n\t\telem->ip[0] &= ip_set_netmask(cidr);\n\t\telem->cidr[0] = cidr;\n\t}\n}\n\nstatic bool\nhash_netportnet4_data_list(struct sk_buff *skb,\n\t\t\t   const struct hash_netportnet4_elem *data)\n{\n\tu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\n\n\tif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip[0]) ||\n\t    nla_put_ipaddr4(skb, IPSET_ATTR_IP2, data->ip[1]) ||\n\t    nla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_PROTO, data->proto) ||\n\t    (flags &&\n\t     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_netportnet4_data_next(struct hash_netportnet4_elem *next,\n\t\t\t   const struct hash_netportnet4_elem *d)\n{\n\tnext->ipcmp = d->ipcmp;\n\tnext->port = d->port;\n}\n\n#define MTYPE\t\thash_netportnet4\n#define HOST_MASK\t32\n#include \"ip_set_hash_gen.h\"\n\nstatic void\nhash_netportnet4_init(struct hash_netportnet4_elem *e)\n{\n\te->cidr[0] = HOST_MASK;\n\te->cidr[1] = HOST_MASK;\n}\n\nstatic int\nhash_netportnet4_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tconst struct hash_netportnet4 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet4_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\te.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\n\te.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\n\tif (adt == IPSET_TEST)\n\t\te.ccmp = (HOST_MASK << (sizeof(e.cidr[0]) * 8)) | HOST_MASK;\n\n\tif (!ip_set_get_ip4_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\n\t\t\t\t &e.port, &e.proto))\n\t\treturn -EINVAL;\n\n\tip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0]);\n\tip4addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip[1]);\n\te.ip[0] &= ip_set_netmask(e.cidr[0]);\n\te.ip[1] &= ip_set_netmask(e.cidr[1]);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic u32\nhash_netportnet4_range_to_cidr(u32 from, u32 to, u8 *cidr)\n{\n\tif (from == 0 && to == UINT_MAX) {\n\t\t*cidr = 0;\n\t\treturn to;\n\t}\n\treturn ip_set_range_to_cidr(from, to, cidr);\n}\n\nstatic int\nhash_netportnet4_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tstruct hash_netportnet4 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet4_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 ip = 0, ip_to = 0, p = 0, port, port_to;\n\tu32 ip2_from = 0, ip2_to = 0, ip2, i = 0;\n\tbool with_ports = false;\n\tint ret;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\thash_netportnet4_init(&e);\n\tif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2], &ip2_from);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_CIDR]) {\n\t\te.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\t\tif (e.cidr[0] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tif (tb[IPSET_ATTR_CIDR2]) {\n\t\te.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\n\t\tif (e.cidr[1] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\te.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\n\n\tif (tb[IPSET_ATTR_PROTO]) {\n\t\te.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\n\t\twith_ports = ip_set_proto_with_ports(e.proto);\n\n\t\tif (e.proto == 0)\n\t\t\treturn -IPSET_ERR_INVALID_PROTO;\n\t} else {\n\t\treturn -IPSET_ERR_MISSING_PROTO;\n\t}\n\n\tif (!(with_ports || e.proto == IPPROTO_ICMP))\n\t\te.port = 0;\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS]) {\n\t\tu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\n\t\tif (cadt_flags & IPSET_FLAG_NOMATCH)\n\t\t\tflags |= (IPSET_FLAG_NOMATCH << 16);\n\t}\n\n\twith_ports = with_ports && tb[IPSET_ATTR_PORT_TO];\n\tif (adt == IPSET_TEST ||\n\t    !(tb[IPSET_ATTR_IP_TO] || with_ports || tb[IPSET_ATTR_IP2_TO])) {\n\t\te.ip[0] = htonl(ip & ip_set_hostmask(e.cidr[0]));\n\t\te.ip[1] = htonl(ip2_from & ip_set_hostmask(e.cidr[1]));\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\treturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\n\t\t       ip_set_eexist(ret, flags) ? 0 : ret;\n\t}\n\n\tip_to = ip;\n\tif (tb[IPSET_ATTR_IP_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ip > ip_to)\n\t\t\tswap(ip, ip_to);\n\t\tif (unlikely(ip + UINT_MAX == ip_to))\n\t\t\treturn -IPSET_ERR_HASH_RANGE;\n\t} else {\n\t\tip_set_mask_from_to(ip, ip_to, e.cidr[0]);\n\t}\n\n\tport_to = port = ntohs(e.port);\n\tif (tb[IPSET_ATTR_PORT_TO]) {\n\t\tport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\t\tif (port > port_to)\n\t\t\tswap(port, port_to);\n\t}\n\n\tip2_to = ip2_from;\n\tif (tb[IPSET_ATTR_IP2_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2_TO], &ip2_to);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ip2_from > ip2_to)\n\t\t\tswap(ip2_from, ip2_to);\n\t\tif (unlikely(ip2_from + UINT_MAX == ip2_to))\n\t\t\treturn -IPSET_ERR_HASH_RANGE;\n\t} else {\n\t\tip_set_mask_from_to(ip2_from, ip2_to, e.cidr[1]);\n\t}\n\n\tif (retried) {\n\t\tip = ntohl(h->next.ip[0]);\n\t\tp = ntohs(h->next.port);\n\t\tip2 = ntohl(h->next.ip[1]);\n\t} else {\n\t\tp = port;\n\t\tip2 = ip2_from;\n\t}\n\n\tdo {\n\t\te.ip[0] = htonl(ip);\n\t\tip = hash_netportnet4_range_to_cidr(ip, ip_to, &e.cidr[0]);\n\t\tfor (; p <= port_to; p++) {\n\t\t\te.port = htons(p);\n\t\t\tdo {\n\t\t\t\ti++;\n\t\t\t\te.ip[1] = htonl(ip2);\n\t\t\t\tif (i > IPSET_MAX_RANGE) {\n\t\t\t\t\thash_netportnet4_data_next(&h->next,\n\t\t\t\t\t\t\t\t   &e);\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\t}\n\t\t\t\tip2 = hash_netportnet4_range_to_cidr(ip2,\n\t\t\t\t\t\t\tip2_to, &e.cidr[1]);\n\t\t\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\t\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\t\t\treturn ret;\n\n\t\t\t\tret = 0;\n\t\t\t} while (ip2++ < ip2_to);\n\t\t\tip2 = ip2_from;\n\t\t}\n\t\tp = port;\n\t} while (ip++ < ip_to);\n\treturn ret;\n}\n\n/* IPv6 variant */\n\nstruct hash_netportnet6_elem {\n\tunion nf_inet_addr ip[2];\n\t__be16 port;\n\tunion {\n\t\tu8 cidr[2];\n\t\tu16 ccmp;\n\t};\n\tu16 padding;\n\tu8 nomatch;\n\tu8 proto;\n};\n\n/* Common functions */\n\nstatic bool\nhash_netportnet6_data_equal(const struct hash_netportnet6_elem *ip1,\n\t\t\t    const struct hash_netportnet6_elem *ip2,\n\t\t\t    u32 *multi)\n{\n\treturn ipv6_addr_equal(&ip1->ip[0].in6, &ip2->ip[0].in6) &&\n\t       ipv6_addr_equal(&ip1->ip[1].in6, &ip2->ip[1].in6) &&\n\t       ip1->ccmp == ip2->ccmp &&\n\t       ip1->port == ip2->port &&\n\t       ip1->proto == ip2->proto;\n}\n\nstatic int\nhash_netportnet6_do_data_match(const struct hash_netportnet6_elem *elem)\n{\n\treturn elem->nomatch ? -ENOTEMPTY : 1;\n}\n\nstatic void\nhash_netportnet6_data_set_flags(struct hash_netportnet6_elem *elem, u32 flags)\n{\n\telem->nomatch = !!((flags >> 16) & IPSET_FLAG_NOMATCH);\n}\n\nstatic void\nhash_netportnet6_data_reset_flags(struct hash_netportnet6_elem *elem, u8 *flags)\n{\n\tswap(*flags, elem->nomatch);\n}\n\nstatic void\nhash_netportnet6_data_reset_elem(struct hash_netportnet6_elem *elem,\n\t\t\t\t struct hash_netportnet6_elem *orig)\n{\n\telem->ip[1] = orig->ip[1];\n}\n\nstatic void\nhash_netportnet6_data_netmask(struct hash_netportnet6_elem *elem,\n\t\t\t      u8 cidr, bool inner)\n{\n\tif (inner) {\n\t\tip6_netmask(&elem->ip[1], cidr);\n\t\telem->cidr[1] = cidr;\n\t} else {\n\t\tip6_netmask(&elem->ip[0], cidr);\n\t\telem->cidr[0] = cidr;\n\t}\n}\n\nstatic bool\nhash_netportnet6_data_list(struct sk_buff *skb,\n\t\t\t   const struct hash_netportnet6_elem *data)\n{\n\tu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\n\n\tif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &data->ip[0].in6) ||\n\t    nla_put_ipaddr6(skb, IPSET_ATTR_IP2, &data->ip[1].in6) ||\n\t    nla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_PROTO, data->proto) ||\n\t    (flags &&\n\t     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_netportnet6_data_next(struct hash_netportnet6_elem *next,\n\t\t\t   const struct hash_netportnet6_elem *d)\n{\n\tnext->port = d->port;\n}\n\n#undef MTYPE\n#undef HOST_MASK\n\n#define MTYPE\t\thash_netportnet6\n#define HOST_MASK\t128\n#define IP_SET_EMIT_CREATE\n#include \"ip_set_hash_gen.h\"\n\nstatic void\nhash_netportnet6_init(struct hash_netportnet6_elem *e)\n{\n\te->cidr[0] = HOST_MASK;\n\te->cidr[1] = HOST_MASK;\n}\n\nstatic int\nhash_netportnet6_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tconst struct hash_netportnet6 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet6_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\te.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\n\te.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\n\tif (adt == IPSET_TEST)\n\t\te.ccmp = (HOST_MASK << (sizeof(u8) * 8)) | HOST_MASK;\n\n\tif (!ip_set_get_ip6_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\n\t\t\t\t &e.port, &e.proto))\n\t\treturn -EINVAL;\n\n\tip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0].in6);\n\tip6addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip[1].in6);\n\tip6_netmask(&e.ip[0], e.cidr[0]);\n\tip6_netmask(&e.ip[1], e.cidr[1]);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nhash_netportnet6_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tconst struct hash_netportnet6 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet6_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 port, port_to;\n\tbool with_ports = false;\n\tint ret;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\thash_netportnet6_init(&e);\n\tif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\tif (unlikely(tb[IPSET_ATTR_IP_TO] || tb[IPSET_ATTR_IP2_TO]))\n\t\treturn -IPSET_ERR_HASH_RANGE_UNSUPPORTED;\n\n\tret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &e.ip[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP2], &e.ip[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_CIDR]) {\n\t\te.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\t\tif (e.cidr[0] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tif (tb[IPSET_ATTR_CIDR2]) {\n\t\te.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\n\t\tif (e.cidr[1] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tip6_netmask(&e.ip[0], e.cidr[0]);\n\tip6_netmask(&e.ip[1], e.cidr[1]);\n\n\te.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\n\n\tif (tb[IPSET_ATTR_PROTO]) {\n\t\te.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\n\t\twith_ports = ip_set_proto_with_ports(e.proto);\n\n\t\tif (e.proto == 0)\n\t\t\treturn -IPSET_ERR_INVALID_PROTO;\n\t} else {\n\t\treturn -IPSET_ERR_MISSING_PROTO;\n\t}\n\n\tif (!(with_ports || e.proto == IPPROTO_ICMPV6))\n\t\te.port = 0;\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS]) {\n\t\tu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\n\t\tif (cadt_flags & IPSET_FLAG_NOMATCH)\n\t\t\tflags |= (IPSET_FLAG_NOMATCH << 16);\n\t}\n\n\tif (adt == IPSET_TEST || !with_ports || !tb[IPSET_ATTR_PORT_TO]) {\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\treturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\n\t\t       ip_set_eexist(ret, flags) ? 0 : ret;\n\t}\n\n\tport = ntohs(e.port);\n\tport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\tif (port > port_to)\n\t\tswap(port, port_to);\n\n\tif (retried)\n\t\tport = ntohs(h->next.port);\n\tfor (; port <= port_to; port++) {\n\t\te.port = htons(port);\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\n\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\treturn ret;\n\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic struct ip_set_type hash_netportnet_type __read_mostly = {\n\t.name\t\t= \"hash:net,port,net\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_IP | IPSET_TYPE_PORT | IPSET_TYPE_IP2 |\n\t\t\t  IPSET_TYPE_NOMATCH,\n\t.dimension\t= IPSET_DIM_THREE,\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create_flags[IPSET_TYPE_REV_MAX] = IPSET_CREATE_FLAG_BUCKETSIZE,\n\t.create\t\t= hash_netportnet_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_HASHSIZE]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_MAXELEM]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_INITVAL]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BUCKETSIZE]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_RESIZE]\t= { .type = NLA_U8  },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP2]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP2_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_PORT]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_PORT_TO]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_CIDR]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_CIDR2]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_PROTO]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len  = IPSET_MAX_COMMENT_SIZE },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nhash_netportnet_init(void)\n{\n\treturn ip_set_type_register(&hash_netportnet_type);\n}\n\nstatic void __exit\nhash_netportnet_fini(void)\n{\n\trcu_barrier();\n\tip_set_type_unregister(&hash_netportnet_type);\n}\n\nmodule_init(hash_netportnet_init);\nmodule_exit(hash_netportnet_fini);",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <linux/jhash.h>\n#include <linux/module.h>\n#include <linux/ip.h>\n#include <linux/skbuff.h>\n#include <linux/errno.h>\n#include <linux/random.h>\n#include <net/ip.h>\n#include <net/ipv6.h>\n#include <net/netlink.h>\n#include <net/tcp.h>\n\n#include <linux/netfilter.h>\n#include <linux/netfilter/ipset/pfxlen.h>\n#include <linux/netfilter/ipset/ip_set.h>\n#include <linux/netfilter/ipset/ip_set_getport.h>\n#include <linux/netfilter/ipset/ip_set_hash.h>\n\n#define IPSET_TYPE_REV_MIN\t0\n/*\t\t\t\t0    Comments support added */\n/*\t\t\t\t1    Forceadd support added */\n/*\t\t\t\t2    skbinfo support added */\n#define IPSET_TYPE_REV_MAX\t3 /* bucketsize, initval support added */\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Oliver Smith <oliver@8.c.9.b.0.7.4.0.1.0.0.2.ip6.arpa>\");\nIP_SET_MODULE_DESC(\"hash:net,port,net\", IPSET_TYPE_REV_MIN, IPSET_TYPE_REV_MAX);\nMODULE_ALIAS(\"ip_set_hash:net,port,net\");\n\n/* Type specific function prefix */\n#define HTYPE\t\thash_netportnet\n#define IP_SET_HASH_WITH_PROTO\n#define IP_SET_HASH_WITH_NETS\n#define IPSET_NET_COUNT 2\n#define IP_SET_HASH_WITH_NET0\n\n/* IPv4 variant */\n\n/* Member elements */\nstruct hash_netportnet4_elem {\n\tunion {\n\t\t__be32 ip[2];\n\t\t__be64 ipcmp;\n\t};\n\t__be16 port;\n\tunion {\n\t\tu8 cidr[2];\n\t\tu16 ccmp;\n\t};\n\tu16 padding;\n\tu8 nomatch;\n\tu8 proto;\n};\n\n/* Common functions */\n\nstatic bool\nhash_netportnet4_data_equal(const struct hash_netportnet4_elem *ip1,\n\t\t\t    const struct hash_netportnet4_elem *ip2,\n\t\t\t    u32 *multi)\n{\n\treturn ip1->ipcmp == ip2->ipcmp &&\n\t       ip1->ccmp == ip2->ccmp &&\n\t       ip1->port == ip2->port &&\n\t       ip1->proto == ip2->proto;\n}\n\nstatic int\nhash_netportnet4_do_data_match(const struct hash_netportnet4_elem *elem)\n{\n\treturn elem->nomatch ? -ENOTEMPTY : 1;\n}\n\nstatic void\nhash_netportnet4_data_set_flags(struct hash_netportnet4_elem *elem, u32 flags)\n{\n\telem->nomatch = !!((flags >> 16) & IPSET_FLAG_NOMATCH);\n}\n\nstatic void\nhash_netportnet4_data_reset_flags(struct hash_netportnet4_elem *elem, u8 *flags)\n{\n\tswap(*flags, elem->nomatch);\n}\n\nstatic void\nhash_netportnet4_data_reset_elem(struct hash_netportnet4_elem *elem,\n\t\t\t\t struct hash_netportnet4_elem *orig)\n{\n\telem->ip[1] = orig->ip[1];\n}\n\nstatic void\nhash_netportnet4_data_netmask(struct hash_netportnet4_elem *elem,\n\t\t\t      u8 cidr, bool inner)\n{\n\tif (inner) {\n\t\telem->ip[1] &= ip_set_netmask(cidr);\n\t\telem->cidr[1] = cidr;\n\t} else {\n\t\telem->ip[0] &= ip_set_netmask(cidr);\n\t\telem->cidr[0] = cidr;\n\t}\n}\n\nstatic bool\nhash_netportnet4_data_list(struct sk_buff *skb,\n\t\t\t   const struct hash_netportnet4_elem *data)\n{\n\tu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\n\n\tif (nla_put_ipaddr4(skb, IPSET_ATTR_IP, data->ip[0]) ||\n\t    nla_put_ipaddr4(skb, IPSET_ATTR_IP2, data->ip[1]) ||\n\t    nla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_PROTO, data->proto) ||\n\t    (flags &&\n\t     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_netportnet4_data_next(struct hash_netportnet4_elem *next,\n\t\t\t   const struct hash_netportnet4_elem *d)\n{\n\tnext->ipcmp = d->ipcmp;\n\tnext->port = d->port;\n}\n\n#define MTYPE\t\thash_netportnet4\n#define HOST_MASK\t32\n#include \"ip_set_hash_gen.h\"\n\nstatic void\nhash_netportnet4_init(struct hash_netportnet4_elem *e)\n{\n\te->cidr[0] = HOST_MASK;\n\te->cidr[1] = HOST_MASK;\n}\n\nstatic int\nhash_netportnet4_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tconst struct hash_netportnet4 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet4_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\te.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\n\te.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\n\tif (adt == IPSET_TEST)\n\t\te.ccmp = (HOST_MASK << (sizeof(e.cidr[0]) * 8)) | HOST_MASK;\n\n\tif (!ip_set_get_ip4_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\n\t\t\t\t &e.port, &e.proto))\n\t\treturn -EINVAL;\n\n\tip4addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0]);\n\tip4addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip[1]);\n\te.ip[0] &= ip_set_netmask(e.cidr[0]);\n\te.ip[1] &= ip_set_netmask(e.cidr[1]);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic u32\nhash_netportnet4_range_to_cidr(u32 from, u32 to, u8 *cidr)\n{\n\tif (from == 0 && to == UINT_MAX) {\n\t\t*cidr = 0;\n\t\treturn to;\n\t}\n\treturn ip_set_range_to_cidr(from, to, cidr);\n}\n\nstatic int\nhash_netportnet4_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tstruct hash_netportnet4 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet4_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 ip = 0, ip_to = 0, p = 0, port, port_to;\n\tu32 ip2_from = 0, ip2_to = 0, ip2, i = 0;\n\tbool with_ports = false;\n\tint ret;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\thash_netportnet4_init(&e);\n\tif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP], &ip);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2], &ip2_from);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_CIDR]) {\n\t\te.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\t\tif (e.cidr[0] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tif (tb[IPSET_ATTR_CIDR2]) {\n\t\te.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\n\t\tif (e.cidr[1] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\te.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\n\n\tif (tb[IPSET_ATTR_PROTO]) {\n\t\te.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\n\t\twith_ports = ip_set_proto_with_ports(e.proto);\n\n\t\tif (e.proto == 0)\n\t\t\treturn -IPSET_ERR_INVALID_PROTO;\n\t} else {\n\t\treturn -IPSET_ERR_MISSING_PROTO;\n\t}\n\n\tif (!(with_ports || e.proto == IPPROTO_ICMP))\n\t\te.port = 0;\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS]) {\n\t\tu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\n\t\tif (cadt_flags & IPSET_FLAG_NOMATCH)\n\t\t\tflags |= (IPSET_FLAG_NOMATCH << 16);\n\t}\n\n\twith_ports = with_ports && tb[IPSET_ATTR_PORT_TO];\n\tif (adt == IPSET_TEST ||\n\t    !(tb[IPSET_ATTR_IP_TO] || with_ports || tb[IPSET_ATTR_IP2_TO])) {\n\t\te.ip[0] = htonl(ip & ip_set_hostmask(e.cidr[0]));\n\t\te.ip[1] = htonl(ip2_from & ip_set_hostmask(e.cidr[1]));\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\treturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\n\t\t       ip_set_eexist(ret, flags) ? 0 : ret;\n\t}\n\n\tip_to = ip;\n\tif (tb[IPSET_ATTR_IP_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP_TO], &ip_to);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ip > ip_to)\n\t\t\tswap(ip, ip_to);\n\t\tif (unlikely(ip + UINT_MAX == ip_to))\n\t\t\treturn -IPSET_ERR_HASH_RANGE;\n\t} else {\n\t\tip_set_mask_from_to(ip, ip_to, e.cidr[0]);\n\t}\n\n\tport_to = port = ntohs(e.port);\n\tif (tb[IPSET_ATTR_PORT_TO]) {\n\t\tport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\t\tif (port > port_to)\n\t\t\tswap(port, port_to);\n\t}\n\n\tip2_to = ip2_from;\n\tif (tb[IPSET_ATTR_IP2_TO]) {\n\t\tret = ip_set_get_hostipaddr4(tb[IPSET_ATTR_IP2_TO], &ip2_to);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tif (ip2_from > ip2_to)\n\t\t\tswap(ip2_from, ip2_to);\n\t\tif (unlikely(ip2_from + UINT_MAX == ip2_to))\n\t\t\treturn -IPSET_ERR_HASH_RANGE;\n\t} else {\n\t\tip_set_mask_from_to(ip2_from, ip2_to, e.cidr[1]);\n\t}\n\n\tif (retried) {\n\t\tip = ntohl(h->next.ip[0]);\n\t\tp = ntohs(h->next.port);\n\t\tip2 = ntohl(h->next.ip[1]);\n\t} else {\n\t\tp = port;\n\t\tip2 = ip2_from;\n\t}\n\n\tdo {\n\t\te.ip[0] = htonl(ip);\n\t\tip = hash_netportnet4_range_to_cidr(ip, ip_to, &e.cidr[0]);\n\t\tfor (; p <= port_to; p++) {\n\t\t\te.port = htons(p);\n\t\t\tdo {\n\t\t\t\ti++;\n\t\t\t\te.ip[1] = htonl(ip2);\n\t\t\t\tif (i > IPSET_MAX_RANGE) {\n\t\t\t\t\thash_netportnet4_data_next(&h->next,\n\t\t\t\t\t\t\t\t   &e);\n\t\t\t\t\treturn -ERANGE;\n\t\t\t\t}\n\t\t\t\tip2 = hash_netportnet4_range_to_cidr(ip2,\n\t\t\t\t\t\t\tip2_to, &e.cidr[1]);\n\t\t\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\t\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\t\t\treturn ret;\n\n\t\t\t\tret = 0;\n\t\t\t} while (ip2++ < ip2_to);\n\t\t\tip2 = ip2_from;\n\t\t}\n\t\tp = port;\n\t} while (ip++ < ip_to);\n\treturn ret;\n}\n\n/* IPv6 variant */\n\nstruct hash_netportnet6_elem {\n\tunion nf_inet_addr ip[2];\n\t__be16 port;\n\tunion {\n\t\tu8 cidr[2];\n\t\tu16 ccmp;\n\t};\n\tu16 padding;\n\tu8 nomatch;\n\tu8 proto;\n};\n\n/* Common functions */\n\nstatic bool\nhash_netportnet6_data_equal(const struct hash_netportnet6_elem *ip1,\n\t\t\t    const struct hash_netportnet6_elem *ip2,\n\t\t\t    u32 *multi)\n{\n\treturn ipv6_addr_equal(&ip1->ip[0].in6, &ip2->ip[0].in6) &&\n\t       ipv6_addr_equal(&ip1->ip[1].in6, &ip2->ip[1].in6) &&\n\t       ip1->ccmp == ip2->ccmp &&\n\t       ip1->port == ip2->port &&\n\t       ip1->proto == ip2->proto;\n}\n\nstatic int\nhash_netportnet6_do_data_match(const struct hash_netportnet6_elem *elem)\n{\n\treturn elem->nomatch ? -ENOTEMPTY : 1;\n}\n\nstatic void\nhash_netportnet6_data_set_flags(struct hash_netportnet6_elem *elem, u32 flags)\n{\n\telem->nomatch = !!((flags >> 16) & IPSET_FLAG_NOMATCH);\n}\n\nstatic void\nhash_netportnet6_data_reset_flags(struct hash_netportnet6_elem *elem, u8 *flags)\n{\n\tswap(*flags, elem->nomatch);\n}\n\nstatic void\nhash_netportnet6_data_reset_elem(struct hash_netportnet6_elem *elem,\n\t\t\t\t struct hash_netportnet6_elem *orig)\n{\n\telem->ip[1] = orig->ip[1];\n}\n\nstatic void\nhash_netportnet6_data_netmask(struct hash_netportnet6_elem *elem,\n\t\t\t      u8 cidr, bool inner)\n{\n\tif (inner) {\n\t\tip6_netmask(&elem->ip[1], cidr);\n\t\telem->cidr[1] = cidr;\n\t} else {\n\t\tip6_netmask(&elem->ip[0], cidr);\n\t\telem->cidr[0] = cidr;\n\t}\n}\n\nstatic bool\nhash_netportnet6_data_list(struct sk_buff *skb,\n\t\t\t   const struct hash_netportnet6_elem *data)\n{\n\tu32 flags = data->nomatch ? IPSET_FLAG_NOMATCH : 0;\n\n\tif (nla_put_ipaddr6(skb, IPSET_ATTR_IP, &data->ip[0].in6) ||\n\t    nla_put_ipaddr6(skb, IPSET_ATTR_IP2, &data->ip[1].in6) ||\n\t    nla_put_net16(skb, IPSET_ATTR_PORT, data->port) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR, data->cidr[0]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_CIDR2, data->cidr[1]) ||\n\t    nla_put_u8(skb, IPSET_ATTR_PROTO, data->proto) ||\n\t    (flags &&\n\t     nla_put_net32(skb, IPSET_ATTR_CADT_FLAGS, htonl(flags))))\n\t\tgoto nla_put_failure;\n\treturn false;\n\nnla_put_failure:\n\treturn true;\n}\n\nstatic void\nhash_netportnet6_data_next(struct hash_netportnet6_elem *next,\n\t\t\t   const struct hash_netportnet6_elem *d)\n{\n\tnext->port = d->port;\n}\n\n#undef MTYPE\n#undef HOST_MASK\n\n#define MTYPE\t\thash_netportnet6\n#define HOST_MASK\t128\n#define IP_SET_EMIT_CREATE\n#include \"ip_set_hash_gen.h\"\n\nstatic void\nhash_netportnet6_init(struct hash_netportnet6_elem *e)\n{\n\te->cidr[0] = HOST_MASK;\n\te->cidr[1] = HOST_MASK;\n}\n\nstatic int\nhash_netportnet6_kadt(struct ip_set *set, const struct sk_buff *skb,\n\t\t      const struct xt_action_param *par,\n\t\t      enum ipset_adt adt, struct ip_set_adt_opt *opt)\n{\n\tconst struct hash_netportnet6 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet6_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_KEXT(skb, opt, set);\n\n\te.cidr[0] = INIT_CIDR(h->nets[0].cidr[0], HOST_MASK);\n\te.cidr[1] = INIT_CIDR(h->nets[0].cidr[1], HOST_MASK);\n\tif (adt == IPSET_TEST)\n\t\te.ccmp = (HOST_MASK << (sizeof(u8) * 8)) | HOST_MASK;\n\n\tif (!ip_set_get_ip6_port(skb, opt->flags & IPSET_DIM_TWO_SRC,\n\t\t\t\t &e.port, &e.proto))\n\t\treturn -EINVAL;\n\n\tip6addrptr(skb, opt->flags & IPSET_DIM_ONE_SRC, &e.ip[0].in6);\n\tip6addrptr(skb, opt->flags & IPSET_DIM_THREE_SRC, &e.ip[1].in6);\n\tip6_netmask(&e.ip[0], e.cidr[0]);\n\tip6_netmask(&e.ip[1], e.cidr[1]);\n\n\treturn adtfn(set, &e, &ext, &opt->ext, opt->cmdflags);\n}\n\nstatic int\nhash_netportnet6_uadt(struct ip_set *set, struct nlattr *tb[],\n\t\t      enum ipset_adt adt, u32 *lineno, u32 flags, bool retried)\n{\n\tconst struct hash_netportnet6 *h = set->data;\n\tipset_adtfn adtfn = set->variant->adt[adt];\n\tstruct hash_netportnet6_elem e = { };\n\tstruct ip_set_ext ext = IP_SET_INIT_UEXT(set);\n\tu32 port, port_to;\n\tbool with_ports = false;\n\tint ret;\n\n\tif (tb[IPSET_ATTR_LINENO])\n\t\t*lineno = nla_get_u32(tb[IPSET_ATTR_LINENO]);\n\n\thash_netportnet6_init(&e);\n\tif (unlikely(!tb[IPSET_ATTR_IP] || !tb[IPSET_ATTR_IP2] ||\n\t\t     !ip_set_attr_netorder(tb, IPSET_ATTR_PORT) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_PORT_TO) ||\n\t\t     !ip_set_optattr_netorder(tb, IPSET_ATTR_CADT_FLAGS)))\n\t\treturn -IPSET_ERR_PROTOCOL;\n\tif (unlikely(tb[IPSET_ATTR_IP_TO] || tb[IPSET_ATTR_IP2_TO]))\n\t\treturn -IPSET_ERR_HASH_RANGE_UNSUPPORTED;\n\n\tret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP], &e.ip[0]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_ipaddr6(tb[IPSET_ATTR_IP2], &e.ip[1]);\n\tif (ret)\n\t\treturn ret;\n\n\tret = ip_set_get_extensions(set, tb, &ext);\n\tif (ret)\n\t\treturn ret;\n\n\tif (tb[IPSET_ATTR_CIDR]) {\n\t\te.cidr[0] = nla_get_u8(tb[IPSET_ATTR_CIDR]);\n\t\tif (e.cidr[0] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tif (tb[IPSET_ATTR_CIDR2]) {\n\t\te.cidr[1] = nla_get_u8(tb[IPSET_ATTR_CIDR2]);\n\t\tif (e.cidr[1] > HOST_MASK)\n\t\t\treturn -IPSET_ERR_INVALID_CIDR;\n\t}\n\n\tip6_netmask(&e.ip[0], e.cidr[0]);\n\tip6_netmask(&e.ip[1], e.cidr[1]);\n\n\te.port = nla_get_be16(tb[IPSET_ATTR_PORT]);\n\n\tif (tb[IPSET_ATTR_PROTO]) {\n\t\te.proto = nla_get_u8(tb[IPSET_ATTR_PROTO]);\n\t\twith_ports = ip_set_proto_with_ports(e.proto);\n\n\t\tif (e.proto == 0)\n\t\t\treturn -IPSET_ERR_INVALID_PROTO;\n\t} else {\n\t\treturn -IPSET_ERR_MISSING_PROTO;\n\t}\n\n\tif (!(with_ports || e.proto == IPPROTO_ICMPV6))\n\t\te.port = 0;\n\n\tif (tb[IPSET_ATTR_CADT_FLAGS]) {\n\t\tu32 cadt_flags = ip_set_get_h32(tb[IPSET_ATTR_CADT_FLAGS]);\n\n\t\tif (cadt_flags & IPSET_FLAG_NOMATCH)\n\t\t\tflags |= (IPSET_FLAG_NOMATCH << 16);\n\t}\n\n\tif (adt == IPSET_TEST || !with_ports || !tb[IPSET_ATTR_PORT_TO]) {\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\t\treturn ip_set_enomatch(ret, flags, adt, set) ? -ret :\n\t\t       ip_set_eexist(ret, flags) ? 0 : ret;\n\t}\n\n\tport = ntohs(e.port);\n\tport_to = ip_set_get_h16(tb[IPSET_ATTR_PORT_TO]);\n\tif (port > port_to)\n\t\tswap(port, port_to);\n\n\tif (retried)\n\t\tport = ntohs(h->next.port);\n\tfor (; port <= port_to; port++) {\n\t\te.port = htons(port);\n\t\tret = adtfn(set, &e, &ext, &ext, flags);\n\n\t\tif (ret && !ip_set_eexist(ret, flags))\n\t\t\treturn ret;\n\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nstatic struct ip_set_type hash_netportnet_type __read_mostly = {\n\t.name\t\t= \"hash:net,port,net\",\n\t.protocol\t= IPSET_PROTOCOL,\n\t.features\t= IPSET_TYPE_IP | IPSET_TYPE_PORT | IPSET_TYPE_IP2 |\n\t\t\t  IPSET_TYPE_NOMATCH,\n\t.dimension\t= IPSET_DIM_THREE,\n\t.family\t\t= NFPROTO_UNSPEC,\n\t.revision_min\t= IPSET_TYPE_REV_MIN,\n\t.revision_max\t= IPSET_TYPE_REV_MAX,\n\t.create_flags[IPSET_TYPE_REV_MAX] = IPSET_CREATE_FLAG_BUCKETSIZE,\n\t.create\t\t= hash_netportnet_create,\n\t.create_policy\t= {\n\t\t[IPSET_ATTR_HASHSIZE]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_MAXELEM]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_INITVAL]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BUCKETSIZE]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_RESIZE]\t= { .type = NLA_U8  },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t},\n\t.adt_policy\t= {\n\t\t[IPSET_ATTR_IP]\t\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP2]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_IP2_TO]\t= { .type = NLA_NESTED },\n\t\t[IPSET_ATTR_PORT]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_PORT_TO]\t= { .type = NLA_U16 },\n\t\t[IPSET_ATTR_CIDR]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_CIDR2]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_PROTO]\t= { .type = NLA_U8 },\n\t\t[IPSET_ATTR_CADT_FLAGS]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_TIMEOUT]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_LINENO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_BYTES]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_PACKETS]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_COMMENT]\t= { .type = NLA_NUL_STRING,\n\t\t\t\t\t    .len  = IPSET_MAX_COMMENT_SIZE },\n\t\t[IPSET_ATTR_SKBMARK]\t= { .type = NLA_U64 },\n\t\t[IPSET_ATTR_SKBPRIO]\t= { .type = NLA_U32 },\n\t\t[IPSET_ATTR_SKBQUEUE]\t= { .type = NLA_U16 },\n\t},\n\t.me\t\t= THIS_MODULE,\n};\n\nstatic int __init\nhash_netportnet_init(void)\n{\n\treturn ip_set_type_register(&hash_netportnet_type);\n}\n\nstatic void __exit\nhash_netportnet_fini(void)\n{\n\trcu_barrier();\n\tip_set_type_unregister(&hash_netportnet_type);\n}\n\nmodule_init(hash_netportnet_init);\nmodule_exit(hash_netportnet_fini);",
    "source": "real-world",
    "cwe": "CWE-190",
    "vulnerability_type": "integer_overflow",
    "idx": 34,
    "typechecks": true,
    "cve": "CVE-2023-42753",
    "project": "linux"
  },
  {
    "prompt": "Security review of this code:\n\n#define pr_fmt(fmt) \"IPv4: \" fmt\n\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/memblock.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/pkt_sched.h>\n#include <linux/mroute.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <net/dst.h>\n#include <net/dst_metadata.h>\n#include <net/inet_dscp.h>\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/inetpeer.h>\n#include <net/sock.h>\n#include <net/ip_fib.h>\n#include <net/nexthop.h>\n#include <net/tcp.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/lwtunnel.h>\n#include <net/netevent.h>\n#include <net/rtnetlink.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n#include <net/secure_seq.h>\n#include <net/ip_tunnels.h>\n\n#include \"fib_lookup.h\"\n\n#define RT_FL_TOS(oldflp4) \\\n\t((oldflp4)->flowi4_tos & (IPTOS_RT_MASK | RTO_ONLINK))\n\n#define RT_GC_TIMEOUT (300*HZ)\n\n#define DEFAULT_MIN_PMTU (512 + 20 + 20)\n#define DEFAULT_MTU_EXPIRES (10 * 60 * HZ)\n#define DEFAULT_MIN_ADVMSS 256\nstatic int ip_rt_max_size;\nstatic int ip_rt_redirect_number __read_mostly\t= 9;\nstatic int ip_rt_redirect_load __read_mostly\t= HZ / 50;\nstatic int ip_rt_redirect_silence __read_mostly\t= ((HZ / 50) << (9 + 1));\nstatic int ip_rt_error_cost __read_mostly\t= HZ;\nstatic int ip_rt_error_burst __read_mostly\t= 5 * HZ;\n\nstatic int ip_rt_gc_timeout __read_mostly\t= RT_GC_TIMEOUT;\n\n/*\n *\tInterface to generic destination cache.\n */\n\nINDIRECT_CALLABLE_SCOPE\nstruct dst_entry\t*ipv4_dst_check(struct dst_entry *dst, u32 cookie);\nstatic unsigned int\t ipv4_default_advmss(const struct dst_entry *dst);\nINDIRECT_CALLABLE_SCOPE\nunsigned int\t\tipv4_mtu(const struct dst_entry *dst);\nstatic struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);\nstatic void\t\t ipv4_link_failure(struct sk_buff *skb);\nstatic void\t\t ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\t   struct sk_buff *skb, u32 mtu,\n\t\t\t\t\t   bool confirm_neigh);\nstatic void\t\t ip_do_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\tstruct sk_buff *skb);\nstatic void\t\tipv4_dst_destroy(struct dst_entry *dst);\n\nstatic u32 *ipv4_cow_metrics(struct dst_entry *dst, unsigned long old)\n{\n\tWARN_ON(1);\n\treturn NULL;\n}\n\nstatic struct neighbour *ipv4_neigh_lookup(const struct dst_entry *dst,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const void *daddr);\nstatic void ipv4_confirm_neigh(const struct dst_entry *dst, const void *daddr);\n\nstatic struct dst_ops ipv4_dst_ops = {\n\t.family =\t\tAF_INET,\n\t.check =\t\tipv4_dst_check,\n\t.default_advmss =\tipv4_default_advmss,\n\t.mtu =\t\t\tipv4_mtu,\n\t.cow_metrics =\t\tipv4_cow_metrics,\n\t.destroy =\t\tipv4_dst_destroy,\n\t.negative_advice =\tipv4_negative_advice,\n\t.link_failure =\t\tipv4_link_failure,\n\t.update_pmtu =\t\tip_rt_update_pmtu,\n\t.redirect =\t\tip_do_redirect,\n\t.local_out =\t\t__ip_local_out,\n\t.neigh_lookup =\t\tipv4_neigh_lookup,\n\t.confirm_neigh =\tipv4_confirm_neigh,\n};\n\n#define ECN_OR_COST(class)\tTC_PRIO_##class\n\nconst __u8 ip_tos2prio[16] = {\n\tTC_PRIO_BESTEFFORT,\n\tECN_OR_COST(BESTEFFORT),\n\tTC_PRIO_BESTEFFORT,\n\tECN_OR_COST(BESTEFFORT),\n\tTC_PRIO_BULK,\n\tECN_OR_COST(BULK),\n\tTC_PRIO_BULK,\n\tECN_OR_COST(BULK),\n\tTC_PRIO_INTERACTIVE,\n\tECN_OR_COST(INTERACTIVE),\n\tTC_PRIO_INTERACTIVE,\n\tECN_OR_COST(INTERACTIVE),\n\tTC_PRIO_INTERACTIVE_BULK,\n\tECN_OR_COST(INTERACTIVE_BULK),\n\tTC_PRIO_INTERACTIVE_BULK,\n\tECN_OR_COST(INTERACTIVE_BULK)\n};\nEXPORT_SYMBOL(ip_tos2prio);\n\nstatic DEFINE_PER_CPU(struct rt_cache_stat, rt_cache_stat);\n#define RT_CACHE_STAT_INC(field) raw_cpu_inc(rt_cache_stat.field)\n\n#ifdef CONFIG_PROC_FS\n\nstatic void ipv4_send_dest_unreach(struct sk_buff *skb)\n{\n\tstruct ip_options opt;\n\tint res;\n\n\t/* Recompile ip options since IPCB may not be valid anymore.\n\t * Also check we have a reasonable ipv4 header.\n\t */\n\tif (!pskb_network_may_pull(skb, sizeof(struct iphdr)) ||\n\t    ip_hdr(skb)->version != 4 || ip_hdr(skb)->ihl < 5)\n\t\treturn;\n\n\tmemset(&opt, 0, sizeof(opt));\n\tif (ip_hdr(skb)->ihl > 5) {\n\t\tif (!pskb_network_may_pull(skb, ip_hdr(skb)->ihl * 4))\n\t\t\treturn;\n\t\topt.optlen = ip_hdr(skb)->ihl * 4 - sizeof(struct iphdr);\n\n\t\trcu_read_lock();\n\t\tres = __ip_options_compile(dev_net(skb->dev), &opt, skb, NULL);\n\t\trcu_read_unlock();\n\n\t\tif (res)\n\t\t\treturn;\n\t}\n\t__icmp_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0, &opt);\n}\n\nstatic void ipv4_link_failure(struct sk_buff *skb)\n{\n\tstruct rtable *rt;\n\n\tipv4_send_dest_unreach(skb);\n\n\trt = skb_rtable(skb);\n\tif (rt)\n\t\tdst_set_expires(&rt->dst, 0);\n}",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#define pr_fmt(fmt) \"IPv4: \" fmt\n\n#include <linux/module.h>\n#include <linux/bitops.h>\n#include <linux/kernel.h>\n#include <linux/mm.h>\n#include <linux/memblock.h>\n#include <linux/socket.h>\n#include <linux/errno.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/init.h>\n#include <linux/skbuff.h>\n#include <linux/inetdevice.h>\n#include <linux/igmp.h>\n#include <linux/pkt_sched.h>\n#include <linux/mroute.h>\n#include <linux/netfilter_ipv4.h>\n#include <linux/random.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <net/dst.h>\n#include <net/dst_metadata.h>\n#include <net/inet_dscp.h>\n#include <net/net_namespace.h>\n#include <net/ip.h>\n#include <net/route.h>\n#include <net/inetpeer.h>\n#include <net/sock.h>\n#include <net/ip_fib.h>\n#include <net/nexthop.h>\n#include <net/tcp.h>\n#include <net/icmp.h>\n#include <net/xfrm.h>\n#include <net/lwtunnel.h>\n#include <net/netevent.h>\n#include <net/rtnetlink.h>\n#ifdef CONFIG_SYSCTL\n#include <linux/sysctl.h>\n#endif\n#include <net/secure_seq.h>\n#include <net/ip_tunnels.h>\n\n#include \"fib_lookup.h\"\n\n#define RT_FL_TOS(oldflp4) \\\n\t((oldflp4)->flowi4_tos & (IPTOS_RT_MASK | RTO_ONLINK))\n\n#define RT_GC_TIMEOUT (300*HZ)\n\n#define DEFAULT_MIN_PMTU (512 + 20 + 20)\n#define DEFAULT_MTU_EXPIRES (10 * 60 * HZ)\n#define DEFAULT_MIN_ADVMSS 256\nstatic int ip_rt_max_size;\nstatic int ip_rt_redirect_number __read_mostly\t= 9;\nstatic int ip_rt_redirect_load __read_mostly\t= HZ / 50;\nstatic int ip_rt_redirect_silence __read_mostly\t= ((HZ / 50) << (9 + 1));\nstatic int ip_rt_error_cost __read_mostly\t= HZ;\nstatic int ip_rt_error_burst __read_mostly\t= 5 * HZ;\n\nstatic int ip_rt_gc_timeout __read_mostly\t= RT_GC_TIMEOUT;\n\n/*\n *\tInterface to generic destination cache.\n */\n\nINDIRECT_CALLABLE_SCOPE\nstruct dst_entry\t*ipv4_dst_check(struct dst_entry *dst, u32 cookie);\nstatic unsigned int\t ipv4_default_advmss(const struct dst_entry *dst);\nINDIRECT_CALLABLE_SCOPE\nunsigned int\t\tipv4_mtu(const struct dst_entry *dst);\nstatic struct dst_entry *ipv4_negative_advice(struct dst_entry *dst);\nstatic void\t\t ipv4_link_failure(struct sk_buff *skb);\nstatic void\t\t ip_rt_update_pmtu(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\t   struct sk_buff *skb, u32 mtu,\n\t\t\t\t\t   bool confirm_neigh);\nstatic void\t\t ip_do_redirect(struct dst_entry *dst, struct sock *sk,\n\t\t\t\t\tstruct sk_buff *skb);\nstatic void\t\tipv4_dst_destroy(struct dst_entry *dst);\n\nstatic u32 *ipv4_cow_metrics(struct dst_entry *dst, unsigned long old)\n{\n\tWARN_ON(1);\n\treturn NULL;\n}\n\nstatic struct neighbour *ipv4_neigh_lookup(const struct dst_entry *dst,\n\t\t\t\t\t   struct sk_buff *skb,\n\t\t\t\t\t   const void *daddr);\nstatic void ipv4_confirm_neigh(const struct dst_entry *dst, const void *daddr);\n\nstatic struct dst_ops ipv4_dst_ops = {\n\t.family =\t\tAF_INET,\n\t.check =\t\tipv4_dst_check,\n\t.default_advmss =\tipv4_default_advmss,\n\t.mtu =\t\t\tipv4_mtu,\n\t.cow_metrics =\t\tipv4_cow_metrics,\n\t.destroy =\t\tipv4_dst_destroy,\n\t.negative_advice =\tipv4_negative_advice,\n\t.link_failure =\t\tipv4_link_failure,\n\t.update_pmtu =\t\tip_rt_update_pmtu,\n\t.redirect =\t\tip_do_redirect,\n\t.local_out =\t\t__ip_local_out,\n\t.neigh_lookup =\t\tipv4_neigh_lookup,\n\t.confirm_neigh =\tipv4_confirm_neigh,\n};\n\n#define ECN_OR_COST(class)\tTC_PRIO_##class\n\nconst __u8 ip_tos2prio[16] = {\n\tTC_PRIO_BESTEFFORT,\n\tECN_OR_COST(BESTEFFORT),\n\tTC_PRIO_BESTEFFORT,\n\tECN_OR_COST(BESTEFFORT),\n\tTC_PRIO_BULK,\n\tECN_OR_COST(BULK),\n\tTC_PRIO_BULK,\n\tECN_OR_COST(BULK),\n\tTC_PRIO_INTERACTIVE,\n\tECN_OR_COST(INTERACTIVE),\n\tTC_PRIO_INTERACTIVE,\n\tECN_OR_COST(INTERACTIVE),\n\tTC_PRIO_INTERACTIVE_BULK,\n\tECN_OR_COST(INTERACTIVE_BULK),\n\tTC_PRIO_INTERACTIVE_BULK,\n\tECN_OR_COST(INTERACTIVE_BULK)\n};\nEXPORT_SYMBOL(ip_tos2prio);\n\nstatic DEFINE_PER_CPU(struct rt_cache_stat, rt_cache_stat);\n#define RT_CACHE_STAT_INC(field) raw_cpu_inc(rt_cache_stat.field)\n\n#ifdef CONFIG_PROC_FS\n\nstatic void ipv4_send_dest_unreach(struct sk_buff *skb)\n{\n\tstruct net_device *dev;\n\tstruct ip_options opt;\n\tint res;\n\n\t/* Recompile ip options since IPCB may not be valid anymore.\n\t * Also check we have a reasonable ipv4 header.\n\t */\n\tif (!pskb_network_may_pull(skb, sizeof(struct iphdr)) ||\n\t    ip_hdr(skb)->version != 4 || ip_hdr(skb)->ihl < 5)\n\t\treturn;\n\n\tmemset(&opt, 0, sizeof(opt));\n\tif (ip_hdr(skb)->ihl > 5) {\n\t\tif (!pskb_network_may_pull(skb, ip_hdr(skb)->ihl * 4))\n\t\t\treturn;\n\t\topt.optlen = ip_hdr(skb)->ihl * 4 - sizeof(struct iphdr);\n\n\t\trcu_read_lock();\n\t\tdev = skb->dev ? skb->dev : skb_rtable(skb)->dst.dev;\n\t\tres = __ip_options_compile(dev_net(dev), &opt, skb, NULL);\n\t\trcu_read_unlock();\n\n\t\tif (res)\n\t\t\treturn;\n\t}\n\t__icmp_send(skb, ICMP_DEST_UNREACH, ICMP_HOST_UNREACH, 0, &opt);\n}\n\nstatic void ipv4_link_failure(struct sk_buff *skb)\n{\n\tstruct rtable *rt;\n\n\tipv4_send_dest_unreach(skb);\n\n\trt = skb_rtable(skb);\n\tif (rt)\n\t\tdst_set_expires(&rt->dst, 0);\n}",
    "source": "real-world",
    "cwe": "CWE-476",
    "vulnerability_type": "null_pointer_dereference",
    "idx": 35,
    "typechecks": true,
    "cve": "CVE-2023-42754",
    "project": "linux"
  },
  {
    "prompt": "Security review of this code:\n\n#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n\n/**\n * kobject_namespace() - Return @kobj's namespace tag.\n * @kobj: kobject in question\n *\n * Returns namespace tag of @kobj if its parent has namespace ops enabled\n * and thus @kobj should have a namespace tag associated with it.  Returns\n * %NULL otherwise.\n */\nconst void *kobject_namespace(const struct kobject *kobj)\n{\n\tconst struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);\n\n\tif (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)\n\t\treturn NULL;\n\n\treturn kobj->ktype->namespace(kobj);\n}\n\n/**\n * kobject_get_ownership() - Get sysfs ownership data for @kobj.\n * @kobj: kobject in question\n * @uid: kernel user ID for sysfs objects\n * @gid: kernel group ID for sysfs objects\n *\n * Returns initial uid/gid pair that should be used when creating sysfs\n * representation of given kobject. Normally used to adjust ownership of\n * objects in a container.\n */\nvoid kobject_get_ownership(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)\n{\n\t*uid = GLOBAL_ROOT_UID;\n\t*gid = GLOBAL_ROOT_GID;\n\n\tif (kobj->ktype->get_ownership)\n\t\tkobj->ktype->get_ownership(kobj, uid, gid);\n}\n\nstatic int create_dir(struct kobject *kobj)\n{\n\tconst struct kobj_type *ktype = get_ktype(kobj);\n\tconst struct kobj_ns_type_operations *ops;\n\tint error;\n\n\terror = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));\n\tif (error)\n\t\treturn error;\n\n\tif (ktype) {\n\t\terror = sysfs_create_groups(kobj, ktype->default_groups);\n\t\tif (error) {\n\t\t\tsysfs_remove_dir(kobj);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/*\n\t * @kobj->sd may be deleted by an ancestor going away.  Hold an\n\t * extra reference so that it stays until @kobj is gone.\n\t */\n\tsysfs_get(kobj->sd);\n\n\t/*\n\t * If @kobj has ns_ops, its children need to be filtered based on\n\t * their namespace tags.  Enable namespace support on @kobj->sd.\n\t */\n\tops = kobj_child_ns_ops(kobj);\n\tif (ops) {\n\t\tBUG_ON(ops->type <= KOBJ_NS_TYPE_NONE);\n\t\tBUG_ON(ops->type >= KOBJ_NS_TYPES);\n\t\tBUG_ON(!kobj_ns_type_registered(ops->type));\n\n\t\tsysfs_enable_ns(kobj->sd);\n\t}\n\n\treturn 0;\n}\n\nstatic int get_kobj_path_length(const struct kobject *kobj)\n{\n\tint length = 1;\n\tconst struct kobject *parent = kobj;\n\n\t/* walk up the ancestors until we hit the one pointing to the\n\t * root.\n\t * Add 1 to strlen for leading '/' of each level.\n\t */\n\tdo {\n\t\tif (kobject_name(parent) == NULL)\n\t\t\treturn 0;\n\t\tlength += strlen(kobject_name(parent)) + 1;\n\t\tparent = parent->parent;\n\t} while (parent);\n\treturn length;\n}\n\nstatic void fill_kobj_path(const struct kobject *kobj, char *path, int length)\n{\n\tconst struct kobject *parent;\n\n\t--length;\n\tfor (parent = kobj; parent; parent = parent->parent) {\n\t\tint cur = strlen(kobject_name(parent));\n\t\t/* back up enough to print this name with '/' */\n\t\tlength -= cur;\n\t\tmemcpy(path + length, kobject_name(parent), cur);\n\t\t*(path + --length) = '/';\n\t}\n\n\tpr_debug(\"kobject: '%s' (%p): %s: path = '%s'\\n\", kobject_name(kobj),\n\t\t kobj, __func__, path);\n}\n\n/**\n * kobject_get_path() - Allocate memory and fill in the path for @kobj.\n * @kobj:\tkobject in question, with which to build the path\n * @gfp_mask:\tthe allocation type used to allocate the path\n *\n * Return: The newly allocated memory, caller must free with kfree().\n */\nchar *kobject_get_path(const struct kobject *kobj, gfp_t gfp_mask)\n{\n\tchar *path;\n\tint len;\n\n\tlen = get_kobj_path_length(kobj);\n\tif (len == 0)\n\t\treturn NULL;\n\tpath = kzalloc(len, gfp_mask);\n\tif (!path)\n\t\treturn NULL;\n\tfill_kobj_path(kobj, path, len)\n\n\treturn path;\n}\nEXPORT_SYMBOL_GPL(kobject_get_path);\n\n/* add the kobject to its kset's list */\nstatic void kobj_kset_join(struct kobject *kobj)\n{\n\tif (!kobj->kset)\n\t\treturn;\n\n\tkset_get(kobj->kset);\n\tspin_lock(&kobj->kset->list_lock);\n\tlist_add_tail(&kobj->entry, &kobj->kset->list);\n\tspin_unlock(&kobj->kset->list_lock);\n}\n\n/* remove the kobject from its kset's list */\nstatic void kobj_kset_leave(struct kobject *kobj)\n{\n\tif (!kobj->kset)\n\t\treturn;\n\n\tspin_lock(&kobj->kset->list_lock);\n\tlist_del_init(&kobj->entry);\n\tspin_unlock(&kobj->kset->list_lock);\n\tkset_put(kobj->kset);\n}\n\nstatic void kobject_init_internal(struct kobject *kobj)\n{\n\tif (!kobj)\n\t\treturn;\n\tkref_init(&kobj->kref);\n\tINIT_LIST_HEAD(&kobj->entry);\n\tkobj->state_in_sysfs = 0;\n\tkobj->state_add_uevent_sent = 0;\n\tkobj->state_remove_uevent_sent = 0;\n\tkobj->state_initialized = 1;\n}\n\n\nstatic int kobject_add_internal(struct kobject *kobj)\n{\n\tint error = 0;\n\tstruct kobject *parent;\n\n\tif (!kobj)\n\t\treturn -ENOENT;\n\n\tif (!kobj->name || !kobj->name[0]) {\n\t\tWARN(1,\n\t\t     \"kobject: (%p): attempted to be registered with empty name!\\n\",\n\t\t     kobj);\n\t\treturn -EINVAL;\n\t}\n\n\tparent = kobject_get(kobj->parent);\n\n\t/* join kset if set, use it as parent if we do not already have one */\n\tif (kobj->kset) {\n\t\tif (!parent)\n\t\t\tparent = kobject_get(&kobj->kset->kobj);\n\t\tkobj_kset_join(kobj);\n\t\tkobj->parent = parent;\n\t}\n\n\tpr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\",\n\t\t kobject_name(kobj), kobj, __func__,\n\t\t parent ? kobject_name(parent) : \"<NULL>\",\n\t\t kobj->kset ? kobject_name(&kobj->kset->kobj) : \"<NULL>\");\n\n\terror = create_dir(kobj);\n\tif (error) {\n\t\tkobj_kset_leave(kobj);\n\t\tkobject_put(parent);\n\t\tkobj->parent = NULL;\n\n\t\t/* be noisy on error issues */\n\t\tif (error == -EEXIST)\n\t\t\tpr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\",\n\t\t\t       __func__, kobject_name(kobj));\n\t\telse\n\t\t\tpr_err(\"%s failed for %s (error: %d parent: %s)\\n\",\n\t\t\t       __func__, kobject_name(kobj), error,\n\t\t\t       parent ? kobject_name(parent) : \"'none'\");\n\t} else\n\t\tkobj->state_in_sysfs = 1;\n\n\treturn error;\n}\n\n/**\n * kobject_set_name_vargs() - Set the name of a kobject.\n * @kobj: struct kobject to set the name of\n * @fmt: format string used to build the name\n * @vargs: vargs to format the string.\n */\nint kobject_set_name_vargs(struct kobject *kobj, const char *fmt,\n\t\t\t\t  va_list vargs)\n{\n\tconst char *s;\n\n\tif (kobj->name && !fmt)\n\t\treturn 0;\n\n\ts = kvasprintf_const(GFP_KERNEL, fmt, vargs);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * ewww... some of these buggers have '/' in the name ... If\n\t * that's the case, we need to make sure we have an actual\n\t * allocated copy to modify, since kvasprintf_const may have\n\t * returned something from .rodata.\n\t */\n\tif (strchr(s, '/')) {\n\t\tchar *t;\n\n\t\tt = kstrdup(s, GFP_KERNEL);\n\t\tkfree_const(s);\n\t\tif (!t)\n\t\t\treturn -ENOMEM;\n\t\tstrreplace(t, '/', '!');\n\t\ts = t;\n\t}\n\tkfree_const(kobj->name);\n\tkobj->name = s;\n\n\treturn 0;\n}\n\n/**\n * kobject_set_name() - Set the name of a kobject.\n * @kobj: struct kobject to set the name of\n * @fmt: format string used to build the name\n *\n * This sets the name of the kobject.  If you have already added the\n * kobject to the system, you must call kobject_rename() in order to\n * change the name of the kobject.\n */\nint kobject_set_name(struct kobject *kobj, const char *fmt, ...)\n{\n\tva_list vargs;\n\tint retval;\n\n\tva_start(vargs, fmt);\n\tretval = kobject_set_name_vargs(kobj, fmt, vargs);\n\tva_end(vargs);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(kobject_set_name);\n\n/**\n * kobject_init() - Initialize a kobject structure.\n * @kobj: pointer to the kobject to initialize\n * @ktype: pointer to the ktype for this kobject.\n *\n * This function will properly initialize a kobject such that it can then\n * be passed to the kobject_add() call.\n *\n * After this function is called, the kobject MUST be cleaned up by a call\n * to kobject_put(), not by a call to kfree directly to ensure that all of\n * the memory is cleaned up properly.\n */\nvoid kobject_init(struct kobject *kobj, const struct kobj_type *ktype)\n{\n\tchar *err_str;\n\n\tif (!kobj) {\n\t\terr_str = \"invalid kobject pointer!\";\n\t\tgoto error;\n\t}\n\tif (!ktype) {\n\t\terr_str = \"must have a ktype to be initialized properly!\\n\";\n\t\tgoto error;\n\t}\n\tif (kobj->state_initialized) {\n\t\t/* do not error out as sometimes we can recover */\n\t\tpr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\",\n\t\t       kobj);\n\t\tdump_stack();\n\t}\n\n\tkobject_init_internal(kobj);\n\tkobj->ktype = ktype;\n\treturn;\n\nerror:\n\tpr_err(\"kobject (%p): %s\\n\", kobj, err_str);\n\tdump_stack();\n}\nEXPORT_SYMBOL(kobject_init);\n\nstatic __printf(3, 0) int kobject_add_varg(struct kobject *kobj,\n\t\t\t\t\t   struct kobject *parent,\n\t\t\t\t\t   const char *fmt, va_list vargs)\n{\n\tint retval;\n\n\tretval = kobject_set_name_vargs(kobj, fmt, vargs);\n\tif (retval) {\n\t\tpr_err(\"kobject: can not set name properly!\\n\");\n\t\treturn retval;\n\t}\n\tkobj->parent = parent;\n\treturn kobject_add_internal(kobj);\n}\n\n/**\n * kobject_add() - The main kobject add function.\n * @kobj: the kobject to add\n * @parent: pointer to the parent of the kobject.\n * @fmt: format to name the kobject with.\n *\n * The kobject name is set and added to the kobject hierarchy in this\n * function.\n *\n * If @parent is set, then the parent of the @kobj will be set to it.\n * If @parent is NULL, then the parent of the @kobj will be set to the\n * kobject associated with the kset assigned to this kobject.  If no kset\n * is assigned to the kobject, then the kobject will be located in the\n * root of the sysfs tree.\n *\n * Note, no \"add\" uevent will be created with this call, the caller should set\n * up all of the necessary sysfs files for the object and then call\n * kobject_uevent() with the UEVENT_ADD parameter to ensure that\n * userspace is properly notified of this kobject's creation.\n *\n * Return: If this function returns an error, kobject_put() must be\n *         called to properly clean up the memory associated with the\n *         object.  Under no instance should the kobject that is passed\n *         to this function be directly freed with a call to kfree(),\n *         that can leak memory.\n *\n *         If this function returns success, kobject_put() must also be called\n *         in order to properly clean up the memory associated with the object.\n *\n *         In short, once this function is called, kobject_put() MUST be called\n *         when the use of the object is finished in order to properly free\n *         everything.\n */\nint kobject_add(struct kobject *kobj, struct kobject *parent,\n\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tint retval;\n\n\tif (!kobj)\n\t\treturn -EINVAL;\n\n\tif (!kobj->state_initialized) {\n\t\tpr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\",\n\t\t       kobject_name(kobj), kobj);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\tva_start(args, fmt);\n\tretval = kobject_add_varg(kobj, parent, fmt, args);\n\tva_end(args);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(kobject_add);\n\n/**\n * kobject_init_and_add() - Initialize a kobject structure and add it to\n *                          the kobject hierarchy.\n * @kobj: pointer to the kobject to initialize\n * @ktype: pointer to the ktype for this kobject.\n * @parent: pointer to the parent of this kobject.\n * @fmt: the name of the kobject.\n *\n * This function combines the call to kobject_init() and kobject_add().\n *\n * If this function returns an error, kobject_put() must be called to\n * properly clean up the memory associated with the object.  This is the\n * same type of error handling after a call to kobject_add() and kobject\n * lifetime rules are the same here.\n */\nint kobject_init_and_add(struct kobject *kobj, const struct kobj_type *ktype,\n\t\t\t struct kobject *parent, const char *fmt, ...)\n{\n\tva_list args;\n\tint retval;\n\n\tkobject_init(kobj, ktype);\n\n\tva_start(args, fmt);\n\tretval = kobject_add_varg(kobj, parent, fmt, args);\n\tva_end(args);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(kobject_init_and_add);\n\n/**\n * kobject_rename() - Change the name of an object.\n * @kobj: object in question.\n * @new_name: object's new name\n *\n * It is the responsibility of the caller to provide mutual\n * exclusion between two different calls of kobject_rename\n * on the same kobject and to ensure that new_name is valid and\n * won't conflict with other kobjects.\n */\nint kobject_rename(struct kobject *kobj, const char *new_name)\n{\n\tint error = 0;\n\tconst char *devpath = NULL;\n\tconst char *dup_name = NULL, *name;\n\tchar *devpath_string = NULL;\n\tchar *envp[2];\n\n\tkobj = kobject_get(kobj);\n\tif (!kobj)\n\t\treturn -EINVAL;\n\tif (!kobj->parent) {\n\t\tkobject_put(kobj);\n\t\treturn -EINVAL;\n\t}\n\n\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\tif (!devpath) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\n\tif (!devpath_string) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsprintf(devpath_string, \"DEVPATH_OLD=%s\", devpath);\n\tenvp[0] = devpath_string;\n\tenvp[1] = NULL;\n\n\tname = dup_name = kstrdup_const(new_name, GFP_KERNEL);\n\tif (!name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = sysfs_rename_dir_ns(kobj, new_name, kobject_namespace(kobj));\n\tif (error)\n\t\tgoto out;\n\n\t/* Install the new kobject name */\n\tdup_name = kobj->name;\n\tkobj->name = name;\n\n\t/* This function is mostly/only used for network interface.\n\t * Some hotplug package track interfaces by their name and\n\t * therefore want to know when the name is changed by the user. */\n\tkobject_uevent_env(kobj, KOBJ_MOVE, envp);\n\nout:\n\tkfree_const(dup_name);\n\tkfree(devpath_string);\n\tkfree(devpath);\n\tkobject_put(kobj);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(kobject_rename);\n\n/**\n * kobject_move() - Move object to another parent.\n * @kobj: object in question.\n * @new_parent: object's new parent (can be NULL)\n */\nint kobject_move(struct kobject *kobj, struct kobject *new_parent)\n{\n\tint error;\n\tstruct kobject *old_parent;\n\tconst char *devpath = NULL;\n\tchar *devpath_string = NULL;\n\tchar *envp[2];\n\n\tkobj = kobject_get(kobj);\n\tif (!kobj)\n\t\treturn -EINVAL;\n\tnew_parent = kobject_get(new_parent);\n\tif (!new_parent) {\n\t\tif (kobj->kset)\n\t\t\tnew_parent = kobject_get(&kobj->kset->kobj);\n\t}\n\n\t/* old object path */\n\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\tif (!devpath) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\n\tif (!devpath_string) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsprintf(devpath_string, \"DEVPATH_OLD=%s\", devpath);\n\tenvp[0] = devpath_string;\n\tenvp[1] = NULL;\n\terror = sysfs_move_dir_ns(kobj, new_parent, kobject_namespace(kobj));\n\tif (error)\n\t\tgoto out;\n\told_parent = kobj->parent;\n\tkobj->parent = new_parent;\n\tnew_parent = NULL;\n\tkobject_put(old_parent);\n\tkobject_uevent_env(kobj, KOBJ_MOVE, envp);\nout:\n\tkobject_put(new_parent);\n\tkobject_put(kobj);\n\tkfree(devpath_string);\n\tkfree(devpath);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(kobject_move);\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <linux/kobject.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/stat.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n\n/**\n * kobject_namespace() - Return @kobj's namespace tag.\n * @kobj: kobject in question\n *\n * Returns namespace tag of @kobj if its parent has namespace ops enabled\n * and thus @kobj should have a namespace tag associated with it.  Returns\n * %NULL otherwise.\n */\nconst void *kobject_namespace(const struct kobject *kobj)\n{\n\tconst struct kobj_ns_type_operations *ns_ops = kobj_ns_ops(kobj);\n\n\tif (!ns_ops || ns_ops->type == KOBJ_NS_TYPE_NONE)\n\t\treturn NULL;\n\n\treturn kobj->ktype->namespace(kobj);\n}\n\n/**\n * kobject_get_ownership() - Get sysfs ownership data for @kobj.\n * @kobj: kobject in question\n * @uid: kernel user ID for sysfs objects\n * @gid: kernel group ID for sysfs objects\n *\n * Returns initial uid/gid pair that should be used when creating sysfs\n * representation of given kobject. Normally used to adjust ownership of\n * objects in a container.\n */\nvoid kobject_get_ownership(const struct kobject *kobj, kuid_t *uid, kgid_t *gid)\n{\n\t*uid = GLOBAL_ROOT_UID;\n\t*gid = GLOBAL_ROOT_GID;\n\n\tif (kobj->ktype->get_ownership)\n\t\tkobj->ktype->get_ownership(kobj, uid, gid);\n}\n\nstatic int create_dir(struct kobject *kobj)\n{\n\tconst struct kobj_type *ktype = get_ktype(kobj);\n\tconst struct kobj_ns_type_operations *ops;\n\tint error;\n\n\terror = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));\n\tif (error)\n\t\treturn error;\n\n\tif (ktype) {\n\t\terror = sysfs_create_groups(kobj, ktype->default_groups);\n\t\tif (error) {\n\t\t\tsysfs_remove_dir(kobj);\n\t\t\treturn error;\n\t\t}\n\t}\n\n\t/*\n\t * @kobj->sd may be deleted by an ancestor going away.  Hold an\n\t * extra reference so that it stays until @kobj is gone.\n\t */\n\tsysfs_get(kobj->sd);\n\n\t/*\n\t * If @kobj has ns_ops, its children need to be filtered based on\n\t * their namespace tags.  Enable namespace support on @kobj->sd.\n\t */\n\tops = kobj_child_ns_ops(kobj);\n\tif (ops) {\n\t\tBUG_ON(ops->type <= KOBJ_NS_TYPE_NONE);\n\t\tBUG_ON(ops->type >= KOBJ_NS_TYPES);\n\t\tBUG_ON(!kobj_ns_type_registered(ops->type));\n\n\t\tsysfs_enable_ns(kobj->sd);\n\t}\n\n\treturn 0;\n}\n\nstatic int get_kobj_path_length(const struct kobject *kobj)\n{\n\tint length = 1;\n\tconst struct kobject *parent = kobj;\n\n\t/* walk up the ancestors until we hit the one pointing to the\n\t * root.\n\t * Add 1 to strlen for leading '/' of each level.\n\t */\n\tdo {\n\t\tif (kobject_name(parent) == NULL)\n\t\t\treturn 0;\n\t\tlength += strlen(kobject_name(parent)) + 1;\n\t\tparent = parent->parent;\n\t} while (parent);\n\treturn length;\n}\n\nstatic int fill_kobj_path(const struct kobject *kobj, char *path, int length)\n{\n\tconst struct kobject *parent;\n\n\t--length;\n\tfor (parent = kobj; parent; parent = parent->parent) {\n\t\tint cur = strlen(kobject_name(parent));\n\t\t/* back up enough to print this name with '/' */\n\t\tlength -= cur;\n\t\tif (length <= 0)\n\t\t\treturn -EINVAL;\n\t\tmemcpy(path + length, kobject_name(parent), cur);\n\t\t*(path + --length) = '/';\n\t}\n\n\tpr_debug(\"kobject: '%s' (%p): %s: path = '%s'\\n\", kobject_name(kobj),\n\t\t kobj, __func__, path);\n\n\treturn 0;\n}\n\n/**\n * kobject_get_path() - Allocate memory and fill in the path for @kobj.\n * @kobj:\tkobject in question, with which to build the path\n * @gfp_mask:\tthe allocation type used to allocate the path\n *\n * Return: The newly allocated memory, caller must free with kfree().\n */\nchar *kobject_get_path(const struct kobject *kobj, gfp_t gfp_mask)\n{\n\tchar *path;\n\tint len;\n\nretry:\n\tlen = get_kobj_path_length(kobj);\n\tif (len == 0)\n\t\treturn NULL;\n\tpath = kzalloc(len, gfp_mask);\n\tif (!path)\n\t\treturn NULL;\n\tif (fill_kobj_path(kobj, path, len)) {\n\t\tkfree(path);\n\t\tgoto retry;\n\t}\n\n\treturn path;\n}\nEXPORT_SYMBOL_GPL(kobject_get_path);\n\n/* add the kobject to its kset's list */\nstatic void kobj_kset_join(struct kobject *kobj)\n{\n\tif (!kobj->kset)\n\t\treturn;\n\n\tkset_get(kobj->kset);\n\tspin_lock(&kobj->kset->list_lock);\n\tlist_add_tail(&kobj->entry, &kobj->kset->list);\n\tspin_unlock(&kobj->kset->list_lock);\n}\n\n/* remove the kobject from its kset's list */\nstatic void kobj_kset_leave(struct kobject *kobj)\n{\n\tif (!kobj->kset)\n\t\treturn;\n\n\tspin_lock(&kobj->kset->list_lock);\n\tlist_del_init(&kobj->entry);\n\tspin_unlock(&kobj->kset->list_lock);\n\tkset_put(kobj->kset);\n}\n\nstatic void kobject_init_internal(struct kobject *kobj)\n{\n\tif (!kobj)\n\t\treturn;\n\tkref_init(&kobj->kref);\n\tINIT_LIST_HEAD(&kobj->entry);\n\tkobj->state_in_sysfs = 0;\n\tkobj->state_add_uevent_sent = 0;\n\tkobj->state_remove_uevent_sent = 0;\n\tkobj->state_initialized = 1;\n}\n\n\nstatic int kobject_add_internal(struct kobject *kobj)\n{\n\tint error = 0;\n\tstruct kobject *parent;\n\n\tif (!kobj)\n\t\treturn -ENOENT;\n\n\tif (!kobj->name || !kobj->name[0]) {\n\t\tWARN(1,\n\t\t     \"kobject: (%p): attempted to be registered with empty name!\\n\",\n\t\t     kobj);\n\t\treturn -EINVAL;\n\t}\n\n\tparent = kobject_get(kobj->parent);\n\n\t/* join kset if set, use it as parent if we do not already have one */\n\tif (kobj->kset) {\n\t\tif (!parent)\n\t\t\tparent = kobject_get(&kobj->kset->kobj);\n\t\tkobj_kset_join(kobj);\n\t\tkobj->parent = parent;\n\t}\n\n\tpr_debug(\"kobject: '%s' (%p): %s: parent: '%s', set: '%s'\\n\",\n\t\t kobject_name(kobj), kobj, __func__,\n\t\t parent ? kobject_name(parent) : \"<NULL>\",\n\t\t kobj->kset ? kobject_name(&kobj->kset->kobj) : \"<NULL>\");\n\n\terror = create_dir(kobj);\n\tif (error) {\n\t\tkobj_kset_leave(kobj);\n\t\tkobject_put(parent);\n\t\tkobj->parent = NULL;\n\n\t\t/* be noisy on error issues */\n\t\tif (error == -EEXIST)\n\t\t\tpr_err(\"%s failed for %s with -EEXIST, don't try to register things with the same name in the same directory.\\n\",\n\t\t\t       __func__, kobject_name(kobj));\n\t\telse\n\t\t\tpr_err(\"%s failed for %s (error: %d parent: %s)\\n\",\n\t\t\t       __func__, kobject_name(kobj), error,\n\t\t\t       parent ? kobject_name(parent) : \"'none'\");\n\t} else\n\t\tkobj->state_in_sysfs = 1;\n\n\treturn error;\n}\n\n/**\n * kobject_set_name_vargs() - Set the name of a kobject.\n * @kobj: struct kobject to set the name of\n * @fmt: format string used to build the name\n * @vargs: vargs to format the string.\n */\nint kobject_set_name_vargs(struct kobject *kobj, const char *fmt,\n\t\t\t\t  va_list vargs)\n{\n\tconst char *s;\n\n\tif (kobj->name && !fmt)\n\t\treturn 0;\n\n\ts = kvasprintf_const(GFP_KERNEL, fmt, vargs);\n\tif (!s)\n\t\treturn -ENOMEM;\n\n\t/*\n\t * ewww... some of these buggers have '/' in the name ... If\n\t * that's the case, we need to make sure we have an actual\n\t * allocated copy to modify, since kvasprintf_const may have\n\t * returned something from .rodata.\n\t */\n\tif (strchr(s, '/')) {\n\t\tchar *t;\n\n\t\tt = kstrdup(s, GFP_KERNEL);\n\t\tkfree_const(s);\n\t\tif (!t)\n\t\t\treturn -ENOMEM;\n\t\tstrreplace(t, '/', '!');\n\t\ts = t;\n\t}\n\tkfree_const(kobj->name);\n\tkobj->name = s;\n\n\treturn 0;\n}\n\n/**\n * kobject_set_name() - Set the name of a kobject.\n * @kobj: struct kobject to set the name of\n * @fmt: format string used to build the name\n *\n * This sets the name of the kobject.  If you have already added the\n * kobject to the system, you must call kobject_rename() in order to\n * change the name of the kobject.\n */\nint kobject_set_name(struct kobject *kobj, const char *fmt, ...)\n{\n\tva_list vargs;\n\tint retval;\n\n\tva_start(vargs, fmt);\n\tretval = kobject_set_name_vargs(kobj, fmt, vargs);\n\tva_end(vargs);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(kobject_set_name);\n\n/**\n * kobject_init() - Initialize a kobject structure.\n * @kobj: pointer to the kobject to initialize\n * @ktype: pointer to the ktype for this kobject.\n *\n * This function will properly initialize a kobject such that it can then\n * be passed to the kobject_add() call.\n *\n * After this function is called, the kobject MUST be cleaned up by a call\n * to kobject_put(), not by a call to kfree directly to ensure that all of\n * the memory is cleaned up properly.\n */\nvoid kobject_init(struct kobject *kobj, const struct kobj_type *ktype)\n{\n\tchar *err_str;\n\n\tif (!kobj) {\n\t\terr_str = \"invalid kobject pointer!\";\n\t\tgoto error;\n\t}\n\tif (!ktype) {\n\t\terr_str = \"must have a ktype to be initialized properly!\\n\";\n\t\tgoto error;\n\t}\n\tif (kobj->state_initialized) {\n\t\t/* do not error out as sometimes we can recover */\n\t\tpr_err(\"kobject (%p): tried to init an initialized object, something is seriously wrong.\\n\",\n\t\t       kobj);\n\t\tdump_stack();\n\t}\n\n\tkobject_init_internal(kobj);\n\tkobj->ktype = ktype;\n\treturn;\n\nerror:\n\tpr_err(\"kobject (%p): %s\\n\", kobj, err_str);\n\tdump_stack();\n}\nEXPORT_SYMBOL(kobject_init);\n\nstatic __printf(3, 0) int kobject_add_varg(struct kobject *kobj,\n\t\t\t\t\t   struct kobject *parent,\n\t\t\t\t\t   const char *fmt, va_list vargs)\n{\n\tint retval;\n\n\tretval = kobject_set_name_vargs(kobj, fmt, vargs);\n\tif (retval) {\n\t\tpr_err(\"kobject: can not set name properly!\\n\");\n\t\treturn retval;\n\t}\n\tkobj->parent = parent;\n\treturn kobject_add_internal(kobj);\n}\n\n/**\n * kobject_add() - The main kobject add function.\n * @kobj: the kobject to add\n * @parent: pointer to the parent of the kobject.\n * @fmt: format to name the kobject with.\n *\n * The kobject name is set and added to the kobject hierarchy in this\n * function.\n *\n * If @parent is set, then the parent of the @kobj will be set to it.\n * If @parent is NULL, then the parent of the @kobj will be set to the\n * kobject associated with the kset assigned to this kobject.  If no kset\n * is assigned to the kobject, then the kobject will be located in the\n * root of the sysfs tree.\n *\n * Note, no \"add\" uevent will be created with this call, the caller should set\n * up all of the necessary sysfs files for the object and then call\n * kobject_uevent() with the UEVENT_ADD parameter to ensure that\n * userspace is properly notified of this kobject's creation.\n *\n * Return: If this function returns an error, kobject_put() must be\n *         called to properly clean up the memory associated with the\n *         object.  Under no instance should the kobject that is passed\n *         to this function be directly freed with a call to kfree(),\n *         that can leak memory.\n *\n *         If this function returns success, kobject_put() must also be called\n *         in order to properly clean up the memory associated with the object.\n *\n *         In short, once this function is called, kobject_put() MUST be called\n *         when the use of the object is finished in order to properly free\n *         everything.\n */\nint kobject_add(struct kobject *kobj, struct kobject *parent,\n\t\tconst char *fmt, ...)\n{\n\tva_list args;\n\tint retval;\n\n\tif (!kobj)\n\t\treturn -EINVAL;\n\n\tif (!kobj->state_initialized) {\n\t\tpr_err(\"kobject '%s' (%p): tried to add an uninitialized object, something is seriously wrong.\\n\",\n\t\t       kobject_name(kobj), kobj);\n\t\tdump_stack();\n\t\treturn -EINVAL;\n\t}\n\tva_start(args, fmt);\n\tretval = kobject_add_varg(kobj, parent, fmt, args);\n\tva_end(args);\n\n\treturn retval;\n}\nEXPORT_SYMBOL(kobject_add);\n\n/**\n * kobject_init_and_add() - Initialize a kobject structure and add it to\n *                          the kobject hierarchy.\n * @kobj: pointer to the kobject to initialize\n * @ktype: pointer to the ktype for this kobject.\n * @parent: pointer to the parent of this kobject.\n * @fmt: the name of the kobject.\n *\n * This function combines the call to kobject_init() and kobject_add().\n *\n * If this function returns an error, kobject_put() must be called to\n * properly clean up the memory associated with the object.  This is the\n * same type of error handling after a call to kobject_add() and kobject\n * lifetime rules are the same here.\n */\nint kobject_init_and_add(struct kobject *kobj, const struct kobj_type *ktype,\n\t\t\t struct kobject *parent, const char *fmt, ...)\n{\n\tva_list args;\n\tint retval;\n\n\tkobject_init(kobj, ktype);\n\n\tva_start(args, fmt);\n\tretval = kobject_add_varg(kobj, parent, fmt, args);\n\tva_end(args);\n\n\treturn retval;\n}\nEXPORT_SYMBOL_GPL(kobject_init_and_add);\n\n/**\n * kobject_rename() - Change the name of an object.\n * @kobj: object in question.\n * @new_name: object's new name\n *\n * It is the responsibility of the caller to provide mutual\n * exclusion between two different calls of kobject_rename\n * on the same kobject and to ensure that new_name is valid and\n * won't conflict with other kobjects.\n */\nint kobject_rename(struct kobject *kobj, const char *new_name)\n{\n\tint error = 0;\n\tconst char *devpath = NULL;\n\tconst char *dup_name = NULL, *name;\n\tchar *devpath_string = NULL;\n\tchar *envp[2];\n\n\tkobj = kobject_get(kobj);\n\tif (!kobj)\n\t\treturn -EINVAL;\n\tif (!kobj->parent) {\n\t\tkobject_put(kobj);\n\t\treturn -EINVAL;\n\t}\n\n\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\tif (!devpath) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\n\tif (!devpath_string) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsprintf(devpath_string, \"DEVPATH_OLD=%s\", devpath);\n\tenvp[0] = devpath_string;\n\tenvp[1] = NULL;\n\n\tname = dup_name = kstrdup_const(new_name, GFP_KERNEL);\n\tif (!name) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\terror = sysfs_rename_dir_ns(kobj, new_name, kobject_namespace(kobj));\n\tif (error)\n\t\tgoto out;\n\n\t/* Install the new kobject name */\n\tdup_name = kobj->name;\n\tkobj->name = name;\n\n\t/* This function is mostly/only used for network interface.\n\t * Some hotplug package track interfaces by their name and\n\t * therefore want to know when the name is changed by the user. */\n\tkobject_uevent_env(kobj, KOBJ_MOVE, envp);\n\nout:\n\tkfree_const(dup_name);\n\tkfree(devpath_string);\n\tkfree(devpath);\n\tkobject_put(kobj);\n\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(kobject_rename);\n\n/**\n * kobject_move() - Move object to another parent.\n * @kobj: object in question.\n * @new_parent: object's new parent (can be NULL)\n */\nint kobject_move(struct kobject *kobj, struct kobject *new_parent)\n{\n\tint error;\n\tstruct kobject *old_parent;\n\tconst char *devpath = NULL;\n\tchar *devpath_string = NULL;\n\tchar *envp[2];\n\n\tkobj = kobject_get(kobj);\n\tif (!kobj)\n\t\treturn -EINVAL;\n\tnew_parent = kobject_get(new_parent);\n\tif (!new_parent) {\n\t\tif (kobj->kset)\n\t\t\tnew_parent = kobject_get(&kobj->kset->kobj);\n\t}\n\n\t/* old object path */\n\tdevpath = kobject_get_path(kobj, GFP_KERNEL);\n\tif (!devpath) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tdevpath_string = kmalloc(strlen(devpath) + 15, GFP_KERNEL);\n\tif (!devpath_string) {\n\t\terror = -ENOMEM;\n\t\tgoto out;\n\t}\n\tsprintf(devpath_string, \"DEVPATH_OLD=%s\", devpath);\n\tenvp[0] = devpath_string;\n\tenvp[1] = NULL;\n\terror = sysfs_move_dir_ns(kobj, new_parent, kobject_namespace(kobj));\n\tif (error)\n\t\tgoto out;\n\told_parent = kobj->parent;\n\tkobj->parent = new_parent;\n\tnew_parent = NULL;\n\tkobject_put(old_parent);\n\tkobject_uevent_env(kobj, KOBJ_MOVE, envp);\nout:\n\tkobject_put(new_parent);\n\tkobject_put(kobj);\n\tkfree(devpath_string);\n\tkfree(devpath);\n\treturn error;\n}\nEXPORT_SYMBOL_GPL(kobject_move);\n",
    "source": "real-world",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 36,
    "typechecks": true,
    "cve": "CVE-2023-45863",
    "project": "linux"
  },
  {
    "prompt": "Security review of this code:\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/netdevice.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <linux/net_tstamp.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/sctp.h>\n#include <linux/if_ether.h>\n#include <linux/prefetch.h>\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n#include <linux/pm_runtime.h>\n#include <linux/etherdevice.h>\n#ifdef CONFIG_IGB_DCA\n#include <linux/dca.h>\n#endif\n#include <linux/i2c.h>\n#include \"igb.h\"\n\nenum queue_mode {\n\tQUEUE_MODE_STRICT_PRIORITY,\n\tQUEUE_MODE_STREAM_RESERVATION,\n};\n\nenum tx_queue_prio {\n\tTX_QUEUE_PRIO_HIGH,\n\tTX_QUEUE_PRIO_LOW,\n};\n\nchar igb_driver_name[] = \"igb\";\nstatic const char igb_driver_string[] =\n\t\t\t\t\"Intel(R) Gigabit Ethernet Network Driver\";\nstatic const char igb_copyright[] =\n\t\t\t\t\"Copyright (c) 2007-2014 Intel Corporation.\";\n\nstatic const struct e1000_info *igb_info_tbl[] = {\n\t[board_82575] = &e1000_82575_info,\n};\n\nstatic const struct pci_device_id igb_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_1GBPS) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_SGMII) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_2_5GBPS) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I211_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER_FLASHLESS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES_FLASHLESS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_QUAD_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER_DUAL), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_BACKPLANE), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SFP), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES_QUAD), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER_ET2), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_FIBER_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575GB_QUAD_COPPER), board_82575 },\n\t/* required last entry */\n\t{0, }\n};\n\nMODULE_DEVICE_TABLE(pci, igb_pci_tbl);\n\nstatic int igb_setup_all_tx_resources(struct igb_adapter *);\nstatic int igb_setup_all_rx_resources(struct igb_adapter *);\nstatic void igb_free_all_tx_resources(struct igb_adapter *);\nstatic void igb_free_all_rx_resources(struct igb_adapter *);\nstatic void igb_setup_mrqc(struct igb_adapter *);\nstatic int igb_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void igb_remove(struct pci_dev *pdev);\nstatic void igb_init_queue_configuration(struct igb_adapter *adapter);\nstatic int igb_sw_init(struct igb_adapter *);\nint igb_open(struct net_device *);\nint igb_close(struct net_device *);\nstatic void igb_configure(struct igb_adapter *);\nstatic void igb_configure_tx(struct igb_adapter *);\nstatic void igb_configure_rx(struct igb_adapter *);\nstatic void igb_clean_all_tx_rings(struct igb_adapter *);\nstatic void igb_clean_all_rx_rings(struct igb_adapter *);\nstatic void igb_clean_tx_ring(struct igb_ring *);\nstatic void igb_clean_rx_ring(struct igb_ring *);\nstatic void igb_set_rx_mode(struct net_device *);\nstatic void igb_update_phy_info(struct timer_list *);\nstatic void igb_watchdog(struct timer_list *);\nstatic void igb_watchdog_task(struct work_struct *);\nstatic netdev_tx_t igb_xmit_frame(struct sk_buff *skb, struct net_device *);\nstatic void igb_get_stats64(struct net_device *dev,\n\t\t\t    struct rtnl_link_stats64 *stats);\nstatic int igb_change_mtu(struct net_device *, int);\nstatic int igb_set_mac(struct net_device *, void *);\nstatic void igb_set_uta(struct igb_adapter *adapter, bool set);\nstatic irqreturn_t igb_intr(int irq, void *);\nstatic irqreturn_t igb_intr_msi(int irq, void *);\nstatic irqreturn_t igb_msix_other(int irq, void *);\nstatic irqreturn_t igb_msix_ring(int irq, void *);\n#ifdef CONFIG_IGB_DCA\nstatic void igb_update_dca(struct igb_q_vector *);\nstatic void igb_setup_dca(struct igb_adapter *);\n#endif /* CONFIG_IGB_DCA */\nstatic int igb_poll(struct napi_struct *, int);\nstatic bool igb_clean_tx_irq(struct igb_q_vector *, int);\nstatic int igb_clean_rx_irq(struct igb_q_vector *, int);\nstatic int igb_ioctl(struct net_device *, struct ifreq *, int cmd);\nstatic void igb_tx_timeout(struct net_device *, unsigned int txqueue);\nstatic void igb_reset_task(struct work_struct *);\nstatic void igb_vlan_mode(struct net_device *netdev,\n\t\t\t  netdev_features_t features);\nstatic int igb_vlan_rx_add_vid(struct net_device *, __be16, u16);\nstatic int igb_vlan_rx_kill_vid(struct net_device *, __be16, u16);\nstatic void igb_restore_vlan(struct igb_adapter *);\nstatic void igb_rar_set_index(struct igb_adapter *, u32);\nstatic void igb_ping_all_vfs(struct igb_adapter *);\nstatic void igb_msg_task(struct igb_adapter *);\nstatic void igb_vmm_control(struct igb_adapter *);\nstatic int igb_set_vf_mac(struct igb_adapter *, int, unsigned char *);\nstatic void igb_flush_mac_table(struct igb_adapter *);\nstatic int igb_available_rars(struct igb_adapter *, u8);\nstatic void igb_set_default_mac_filter(struct igb_adapter *);\nstatic int igb_uc_sync(struct net_device *, const unsigned char *);\nstatic int igb_uc_unsync(struct net_device *, const unsigned char *);\nstatic void igb_restore_vf_multicasts(struct igb_adapter *adapter);\nstatic int igb_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac);\nstatic int igb_ndo_set_vf_vlan(struct net_device *netdev,\n\t\t\t       int vf, u16 vlan, u8 qos, __be16 vlan_proto);\nstatic int igb_ndo_set_vf_bw(struct net_device *, int, int, int);\nstatic int igb_ndo_set_vf_spoofchk(struct net_device *netdev, int vf,\n\t\t\t\t   bool setting);\nstatic int igb_ndo_set_vf_trust(struct net_device *netdev, int vf,\n\t\t\t\tbool setting);\nstatic int igb_ndo_get_vf_config(struct net_device *netdev, int vf,\n\t\t\t\t struct ifla_vf_info *ivi);\nstatic void igb_check_vf_rate_limit(struct igb_adapter *);\nstatic void igb_nfc_filter_exit(struct igb_adapter *adapter);\nstatic void igb_nfc_filter_restore(struct igb_adapter *adapter);\n\n#ifdef CONFIG_PCI_IOV\nstatic int igb_vf_configure(struct igb_adapter *adapter, int vf);\nstatic int igb_disable_sriov(struct pci_dev *dev, bool reinit);\n#endif\n\nstatic int igb_suspend(struct device *);\nstatic int igb_resume(struct device *);\nstatic int igb_runtime_suspend(struct device *dev);\nstatic int igb_runtime_resume(struct device *dev);\nstatic int igb_runtime_idle(struct device *dev);\n#ifdef CONFIG_PM\nstatic const struct dev_pm_ops igb_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(igb_suspend, igb_resume)\n\tSET_RUNTIME_PM_OPS(igb_runtime_suspend, igb_runtime_resume,\n\t\t\tigb_runtime_idle)\n};\n#endif\nstatic void igb_shutdown(struct pci_dev *);\nstatic int igb_pci_sriov_configure(struct pci_dev *dev, int num_vfs);\n#ifdef CONFIG_IGB_DCA\nstatic int igb_notify_dca(struct notifier_block *, unsigned long, void *);\nstatic struct notifier_block dca_notifier = {\n\t.notifier_call\t= igb_notify_dca,\n\t.next\t\t= NULL,\n\t.priority\t= 0\n};\n#endif\n#ifdef CONFIG_PCI_IOV\nstatic unsigned int max_vfs;\nmodule_param(max_vfs, uint, 0);\nMODULE_PARM_DESC(max_vfs, \"Maximum number of virtual functions to allocate per physical function\");\n#endif /* CONFIG_PCI_IOV */\n\nstatic pci_ers_result_t igb_io_error_detected(struct pci_dev *,\n\t\t     pci_channel_state_t);\nstatic pci_ers_result_t igb_io_slot_reset(struct pci_dev *);\nstatic void igb_io_resume(struct pci_dev *);\n\nstatic const struct pci_error_handlers igb_err_handler = {\n\t.error_detected = igb_io_error_detected,\n\t.slot_reset = igb_io_slot_reset,\n\t.resume = igb_io_resume,\n};\n\nstatic void igb_init_dmac(struct igb_adapter *adapter, u32 pba);\n\nstatic struct pci_driver igb_driver = {\n\t.name     = igb_driver_name,\n\t.id_table = igb_pci_tbl,\n\t.probe    = igb_probe,\n\t.remove   = igb_remove,\n#ifdef CONFIG_PM\n\t.driver.pm = &igb_pm_ops,\n#endif\n\t.shutdown = igb_shutdown,\n\t.sriov_configure = igb_pci_sriov_configure,\n\t.err_handler = &igb_err_handler\n};\n\nMODULE_AUTHOR(\"Intel Corporation, <e1000-devel@lists.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Intel(R) Gigabit Ethernet Network Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\nstruct igb_reg_info {\n\tu32 ofs;\n\tchar *name;\n};\n\nstatic const struct igb_reg_info igb_reg_info_tbl[] = {\n\n\t/* General Registers */\n\t{E1000_CTRL, \"CTRL\"},\n\t{E1000_STATUS, \"STATUS\"},\n\t{E1000_CTRL_EXT, \"CTRL_EXT\"},\n\n\t/* Interrupt Registers */\n\t{E1000_ICR, \"ICR\"},\n\n\t/* RX Registers */\n\t{E1000_RCTL, \"RCTL\"},\n\t{E1000_RDLEN(0), \"RDLEN\"},\n\t{E1000_RDH(0), \"RDH\"},\n\t{E1000_RDT(0), \"RDT\"},\n\t{E1000_RXDCTL(0), \"RXDCTL\"},\n\t{E1000_RDBAL(0), \"RDBAL\"},\n\t{E1000_RDBAH(0), \"RDBAH\"},\n\n\t/* TX Registers */\n\t{E1000_TCTL, \"TCTL\"},\n\t{E1000_TDBAL(0), \"TDBAL\"},\n\t{E1000_TDBAH(0), \"TDBAH\"},\n\t{E1000_TDLEN(0), \"TDLEN\"},\n\t{E1000_TDH(0), \"TDH\"},\n\t{E1000_TDT(0), \"TDT\"},\n\t{E1000_TXDCTL(0), \"TXDCTL\"},\n\t{E1000_TDFH, \"TDFH\"},\n\t{E1000_TDFT, \"TDFT\"},\n\t{E1000_TDFHS, \"TDFHS\"},\n\t{E1000_TDFPC, \"TDFPC\"},\n\n\t/* List Terminator */\n\t{}\n};\n\n/**\n *  igb_configure_rx_ring - Configure a receive ring after Reset\n *  @adapter: board private structure\n *  @ring: receive ring to be configured\n *\n *  Configure the Rx unit of the MAC after a reset.\n **/\nvoid igb_configure_rx_ring(struct igb_adapter *adapter,\n\t\t\t   struct igb_ring *ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunion e1000_adv_rx_desc *rx_desc;\n\tu64 rdba = ring->dma;\n\tint reg_idx = ring->reg_idx;\n\tu32 rxdctl = 0;\n\n\txdp_rxq_info_unreg_mem_model(&ring->xdp_rxq);\n\tWARN_ON(xdp_rxq_info_reg_mem_model(&ring->xdp_rxq,\n\t\t\t\t\t   MEM_TYPE_PAGE_SHARED, NULL));\n\n\t/* disable the queue */\n\twr32(E1000_RXDCTL(reg_idx), 0);\n\n\t/* Set DMA base address registers */\n\twr32(E1000_RDBAL(reg_idx),\n\t     rdba & 0x00000000ffffffffULL);\n\twr32(E1000_RDBAH(reg_idx), rdba >> 32);\n\twr32(E1000_RDLEN(reg_idx),\n\t     ring->count * sizeof(union e1000_adv_rx_desc));\n\n\t/* initialize head and tail */\n\tring->tail = adapter->io_addr + E1000_RDT(reg_idx);\n\twr32(E1000_RDH(reg_idx), 0);\n\twritel(0, ring->tail);\n\n\t/* set descriptor configuration */\n\tigb_setup_srrctl(adapter, ring);\n\n\t/* set filtering for VMDQ pools */\n\tigb_set_vmolr(adapter, reg_idx & 0x7, true);\n\n\trxdctl |= IGB_RX_PTHRESH;\n\trxdctl |= IGB_RX_HTHRESH << 8;\n\trxdctl |= IGB_RX_WTHRESH << 16;\n\n\t/* initialize rx_buffer_info */\n\tmemset(ring->rx_buffer_info, 0,\n\t       sizeof(struct igb_rx_buffer) * ring->count);\n\n\t/* initialize Rx descriptor 0 */\n\trx_desc = IGB_RX_DESC(ring, 0);\n\trx_desc->wb.upper.length = 0;\n\n\t/* enable receive descriptor fetching */\n\trxdctl |= E1000_RXDCTL_QUEUE_ENABLE;\n\twr32(E1000_RXDCTL(reg_idx), rxdctl);\n}\n\nstatic void igb_set_rx_buffer_len(struct igb_adapter *adapter,\n\t\t\t\t  struct igb_ring *rx_ring)\n{\n\t/* set build_skb and buffer size flags */\n\tclear_ring_build_skb_enabled(rx_ring);\n\tclear_ring_uses_large_buffer(rx_ring);\n\n\tif (adapter->flags & IGB_FLAG_RX_LEGACY)\n\t\treturn;\n\n\tset_ring_build_skb_enabled(rx_ring);\n\n#if (PAGE_SIZE < 8192)\n\tif (adapter->max_frame_size <= IGB_MAX_FRAME_BUILD_SKB)\n        return;\n    \n    set_ring_uses_large_buffer(rx_ring);\n#endif\n}\n\n/**\n *  igb_configure_rx - Configure receive Unit after Reset\n *  @adapter: board private structure\n *\n *  Configure the Rx unit of the MAC after a reset.\n **/\nstatic void igb_configure_rx(struct igb_adapter *adapter)\n{\n\tint i;\n\n\t/* set the correct pool for the PF default MAC address in entry 0 */\n\tigb_set_default_mac_filter(adapter);\n\n\t/* Setup the HW Rx Head and Tail Descriptor Pointers and\n\t * the Base and Length of the Rx Descriptor Ring\n\t */\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct igb_ring *rx_ring = adapter->rx_ring[i];\n\n\t\tigb_set_rx_buffer_len(adapter, rx_ring);\n\t\tigb_configure_rx_ring(adapter, rx_ring);\n\t}\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/bitops.h>\n#include <linux/vmalloc.h>\n#include <linux/pagemap.h>\n#include <linux/netdevice.h>\n#include <linux/ipv6.h>\n#include <linux/slab.h>\n#include <net/checksum.h>\n#include <net/ip6_checksum.h>\n#include <net/pkt_sched.h>\n#include <net/pkt_cls.h>\n#include <linux/net_tstamp.h>\n#include <linux/mii.h>\n#include <linux/ethtool.h>\n#include <linux/if.h>\n#include <linux/if_vlan.h>\n#include <linux/pci.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/ip.h>\n#include <linux/tcp.h>\n#include <linux/sctp.h>\n#include <linux/if_ether.h>\n#include <linux/prefetch.h>\n#include <linux/bpf.h>\n#include <linux/bpf_trace.h>\n#include <linux/pm_runtime.h>\n#include <linux/etherdevice.h>\n#ifdef CONFIG_IGB_DCA\n#include <linux/dca.h>\n#endif\n#include <linux/i2c.h>\n#include \"igb.h\"\n\nenum queue_mode {\n\tQUEUE_MODE_STRICT_PRIORITY,\n\tQUEUE_MODE_STREAM_RESERVATION,\n};\n\nenum tx_queue_prio {\n\tTX_QUEUE_PRIO_HIGH,\n\tTX_QUEUE_PRIO_LOW,\n};\n\nchar igb_driver_name[] = \"igb\";\nstatic const char igb_driver_string[] =\n\t\t\t\t\"Intel(R) Gigabit Ethernet Network Driver\";\nstatic const char igb_copyright[] =\n\t\t\t\t\"Copyright (c) 2007-2014 Intel Corporation.\";\n\nstatic const struct e1000_info *igb_info_tbl[] = {\n\t[board_82575] = &e1000_82575_info,\n};\n\nstatic const struct pci_device_id igb_pci_tbl[] = {\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_1GBPS) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_SGMII) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I354_BACKPLANE_2_5GBPS) },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I211_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_COPPER_FLASHLESS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I210_SERDES_FLASHLESS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_I350_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_QUAD_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82580_COPPER_DUAL), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SGMII), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_BACKPLANE), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_DH89XXCC_SFP), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_NS_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_FIBER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_SERDES_QUAD), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER_ET2), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82576_QUAD_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_COPPER), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575EB_FIBER_SERDES), board_82575 },\n\t{ PCI_VDEVICE(INTEL, E1000_DEV_ID_82575GB_QUAD_COPPER), board_82575 },\n\t/* required last entry */\n\t{0, }\n};\n\nMODULE_DEVICE_TABLE(pci, igb_pci_tbl);\n\nstatic int igb_setup_all_tx_resources(struct igb_adapter *);\nstatic int igb_setup_all_rx_resources(struct igb_adapter *);\nstatic void igb_free_all_tx_resources(struct igb_adapter *);\nstatic void igb_free_all_rx_resources(struct igb_adapter *);\nstatic void igb_setup_mrqc(struct igb_adapter *);\nstatic int igb_probe(struct pci_dev *, const struct pci_device_id *);\nstatic void igb_remove(struct pci_dev *pdev);\nstatic void igb_init_queue_configuration(struct igb_adapter *adapter);\nstatic int igb_sw_init(struct igb_adapter *);\nint igb_open(struct net_device *);\nint igb_close(struct net_device *);\nstatic void igb_configure(struct igb_adapter *);\nstatic void igb_configure_tx(struct igb_adapter *);\nstatic void igb_configure_rx(struct igb_adapter *);\nstatic void igb_clean_all_tx_rings(struct igb_adapter *);\nstatic void igb_clean_all_rx_rings(struct igb_adapter *);\nstatic void igb_clean_tx_ring(struct igb_ring *);\nstatic void igb_clean_rx_ring(struct igb_ring *);\nstatic void igb_set_rx_mode(struct net_device *);\nstatic void igb_update_phy_info(struct timer_list *);\nstatic void igb_watchdog(struct timer_list *);\nstatic void igb_watchdog_task(struct work_struct *);\nstatic netdev_tx_t igb_xmit_frame(struct sk_buff *skb, struct net_device *);\nstatic void igb_get_stats64(struct net_device *dev,\n\t\t\t    struct rtnl_link_stats64 *stats);\nstatic int igb_change_mtu(struct net_device *, int);\nstatic int igb_set_mac(struct net_device *, void *);\nstatic void igb_set_uta(struct igb_adapter *adapter, bool set);\nstatic irqreturn_t igb_intr(int irq, void *);\nstatic irqreturn_t igb_intr_msi(int irq, void *);\nstatic irqreturn_t igb_msix_other(int irq, void *);\nstatic irqreturn_t igb_msix_ring(int irq, void *);\n#ifdef CONFIG_IGB_DCA\nstatic void igb_update_dca(struct igb_q_vector *);\nstatic void igb_setup_dca(struct igb_adapter *);\n#endif /* CONFIG_IGB_DCA */\nstatic int igb_poll(struct napi_struct *, int);\nstatic bool igb_clean_tx_irq(struct igb_q_vector *, int);\nstatic int igb_clean_rx_irq(struct igb_q_vector *, int);\nstatic int igb_ioctl(struct net_device *, struct ifreq *, int cmd);\nstatic void igb_tx_timeout(struct net_device *, unsigned int txqueue);\nstatic void igb_reset_task(struct work_struct *);\nstatic void igb_vlan_mode(struct net_device *netdev,\n\t\t\t  netdev_features_t features);\nstatic int igb_vlan_rx_add_vid(struct net_device *, __be16, u16);\nstatic int igb_vlan_rx_kill_vid(struct net_device *, __be16, u16);\nstatic void igb_restore_vlan(struct igb_adapter *);\nstatic void igb_rar_set_index(struct igb_adapter *, u32);\nstatic void igb_ping_all_vfs(struct igb_adapter *);\nstatic void igb_msg_task(struct igb_adapter *);\nstatic void igb_vmm_control(struct igb_adapter *);\nstatic int igb_set_vf_mac(struct igb_adapter *, int, unsigned char *);\nstatic void igb_flush_mac_table(struct igb_adapter *);\nstatic int igb_available_rars(struct igb_adapter *, u8);\nstatic void igb_set_default_mac_filter(struct igb_adapter *);\nstatic int igb_uc_sync(struct net_device *, const unsigned char *);\nstatic int igb_uc_unsync(struct net_device *, const unsigned char *);\nstatic void igb_restore_vf_multicasts(struct igb_adapter *adapter);\nstatic int igb_ndo_set_vf_mac(struct net_device *netdev, int vf, u8 *mac);\nstatic int igb_ndo_set_vf_vlan(struct net_device *netdev,\n\t\t\t       int vf, u16 vlan, u8 qos, __be16 vlan_proto);\nstatic int igb_ndo_set_vf_bw(struct net_device *, int, int, int);\nstatic int igb_ndo_set_vf_spoofchk(struct net_device *netdev, int vf,\n\t\t\t\t   bool setting);\nstatic int igb_ndo_set_vf_trust(struct net_device *netdev, int vf,\n\t\t\t\tbool setting);\nstatic int igb_ndo_get_vf_config(struct net_device *netdev, int vf,\n\t\t\t\t struct ifla_vf_info *ivi);\nstatic void igb_check_vf_rate_limit(struct igb_adapter *);\nstatic void igb_nfc_filter_exit(struct igb_adapter *adapter);\nstatic void igb_nfc_filter_restore(struct igb_adapter *adapter);\n\n#ifdef CONFIG_PCI_IOV\nstatic int igb_vf_configure(struct igb_adapter *adapter, int vf);\nstatic int igb_disable_sriov(struct pci_dev *dev, bool reinit);\n#endif\n\nstatic int igb_suspend(struct device *);\nstatic int igb_resume(struct device *);\nstatic int igb_runtime_suspend(struct device *dev);\nstatic int igb_runtime_resume(struct device *dev);\nstatic int igb_runtime_idle(struct device *dev);\n#ifdef CONFIG_PM\nstatic const struct dev_pm_ops igb_pm_ops = {\n\tSET_SYSTEM_SLEEP_PM_OPS(igb_suspend, igb_resume)\n\tSET_RUNTIME_PM_OPS(igb_runtime_suspend, igb_runtime_resume,\n\t\t\tigb_runtime_idle)\n};\n#endif\nstatic void igb_shutdown(struct pci_dev *);\nstatic int igb_pci_sriov_configure(struct pci_dev *dev, int num_vfs);\n#ifdef CONFIG_IGB_DCA\nstatic int igb_notify_dca(struct notifier_block *, unsigned long, void *);\nstatic struct notifier_block dca_notifier = {\n\t.notifier_call\t= igb_notify_dca,\n\t.next\t\t= NULL,\n\t.priority\t= 0\n};\n#endif\n#ifdef CONFIG_PCI_IOV\nstatic unsigned int max_vfs;\nmodule_param(max_vfs, uint, 0);\nMODULE_PARM_DESC(max_vfs, \"Maximum number of virtual functions to allocate per physical function\");\n#endif /* CONFIG_PCI_IOV */\n\nstatic pci_ers_result_t igb_io_error_detected(struct pci_dev *,\n\t\t     pci_channel_state_t);\nstatic pci_ers_result_t igb_io_slot_reset(struct pci_dev *);\nstatic void igb_io_resume(struct pci_dev *);\n\nstatic const struct pci_error_handlers igb_err_handler = {\n\t.error_detected = igb_io_error_detected,\n\t.slot_reset = igb_io_slot_reset,\n\t.resume = igb_io_resume,\n};\n\nstatic void igb_init_dmac(struct igb_adapter *adapter, u32 pba);\n\nstatic struct pci_driver igb_driver = {\n\t.name     = igb_driver_name,\n\t.id_table = igb_pci_tbl,\n\t.probe    = igb_probe,\n\t.remove   = igb_remove,\n#ifdef CONFIG_PM\n\t.driver.pm = &igb_pm_ops,\n#endif\n\t.shutdown = igb_shutdown,\n\t.sriov_configure = igb_pci_sriov_configure,\n\t.err_handler = &igb_err_handler\n};\n\nMODULE_AUTHOR(\"Intel Corporation, <e1000-devel@lists.sourceforge.net>\");\nMODULE_DESCRIPTION(\"Intel(R) Gigabit Ethernet Network Driver\");\nMODULE_LICENSE(\"GPL v2\");\n\n#define DEFAULT_MSG_ENABLE (NETIF_MSG_DRV|NETIF_MSG_PROBE|NETIF_MSG_LINK)\nstatic int debug = -1;\nmodule_param(debug, int, 0);\nMODULE_PARM_DESC(debug, \"Debug level (0=none,...,16=all)\");\n\nstruct igb_reg_info {\n\tu32 ofs;\n\tchar *name;\n};\n\nstatic const struct igb_reg_info igb_reg_info_tbl[] = {\n\n\t/* General Registers */\n\t{E1000_CTRL, \"CTRL\"},\n\t{E1000_STATUS, \"STATUS\"},\n\t{E1000_CTRL_EXT, \"CTRL_EXT\"},\n\n\t/* Interrupt Registers */\n\t{E1000_ICR, \"ICR\"},\n\n\t/* RX Registers */\n\t{E1000_RCTL, \"RCTL\"},\n\t{E1000_RDLEN(0), \"RDLEN\"},\n\t{E1000_RDH(0), \"RDH\"},\n\t{E1000_RDT(0), \"RDT\"},\n\t{E1000_RXDCTL(0), \"RXDCTL\"},\n\t{E1000_RDBAL(0), \"RDBAL\"},\n\t{E1000_RDBAH(0), \"RDBAH\"},\n\n\t/* TX Registers */\n\t{E1000_TCTL, \"TCTL\"},\n\t{E1000_TDBAL(0), \"TDBAL\"},\n\t{E1000_TDBAH(0), \"TDBAH\"},\n\t{E1000_TDLEN(0), \"TDLEN\"},\n\t{E1000_TDH(0), \"TDH\"},\n\t{E1000_TDT(0), \"TDT\"},\n\t{E1000_TXDCTL(0), \"TXDCTL\"},\n\t{E1000_TDFH, \"TDFH\"},\n\t{E1000_TDFT, \"TDFT\"},\n\t{E1000_TDFHS, \"TDFHS\"},\n\t{E1000_TDFPC, \"TDFPC\"},\n\n\t/* List Terminator */\n\t{}\n};\n\n/**\n *  igb_configure_rx_ring - Configure a receive ring after Reset\n *  @adapter: board private structure\n *  @ring: receive ring to be configured\n *\n *  Configure the Rx unit of the MAC after a reset.\n **/\nvoid igb_configure_rx_ring(struct igb_adapter *adapter,\n\t\t\t   struct igb_ring *ring)\n{\n\tstruct e1000_hw *hw = &adapter->hw;\n\tunion e1000_adv_rx_desc *rx_desc;\n\tu64 rdba = ring->dma;\n\tint reg_idx = ring->reg_idx;\n\tu32 rxdctl = 0;\n\n\txdp_rxq_info_unreg_mem_model(&ring->xdp_rxq);\n\tWARN_ON(xdp_rxq_info_reg_mem_model(&ring->xdp_rxq,\n\t\t\t\t\t   MEM_TYPE_PAGE_SHARED, NULL));\n\n\t/* disable the queue */\n\twr32(E1000_RXDCTL(reg_idx), 0);\n\n\t/* Set DMA base address registers */\n\twr32(E1000_RDBAL(reg_idx),\n\t     rdba & 0x00000000ffffffffULL);\n\twr32(E1000_RDBAH(reg_idx), rdba >> 32);\n\twr32(E1000_RDLEN(reg_idx),\n\t     ring->count * sizeof(union e1000_adv_rx_desc));\n\n\t/* initialize head and tail */\n\tring->tail = adapter->io_addr + E1000_RDT(reg_idx);\n\twr32(E1000_RDH(reg_idx), 0);\n\twritel(0, ring->tail);\n\n\t/* set descriptor configuration */\n\tigb_setup_srrctl(adapter, ring);\n\n\t/* set filtering for VMDQ pools */\n\tigb_set_vmolr(adapter, reg_idx & 0x7, true);\n\n\trxdctl |= IGB_RX_PTHRESH;\n\trxdctl |= IGB_RX_HTHRESH << 8;\n\trxdctl |= IGB_RX_WTHRESH << 16;\n\n\t/* initialize rx_buffer_info */\n\tmemset(ring->rx_buffer_info, 0,\n\t       sizeof(struct igb_rx_buffer) * ring->count);\n\n\t/* initialize Rx descriptor 0 */\n\trx_desc = IGB_RX_DESC(ring, 0);\n\trx_desc->wb.upper.length = 0;\n\n\t/* enable receive descriptor fetching */\n\trxdctl |= E1000_RXDCTL_QUEUE_ENABLE;\n\twr32(E1000_RXDCTL(reg_idx), rxdctl);\n}\n\nstatic void igb_set_rx_buffer_len(struct igb_adapter *adapter,\n\t\t\t\t  struct igb_ring *rx_ring)\n{\n#if (PAGE_SIZE < 8192)\n\tstruct e1000_hw *hw = &adapter->hw;\n#endif\n\n\t/* set build_skb and buffer size flags */\n\tclear_ring_build_skb_enabled(rx_ring);\n\tclear_ring_uses_large_buffer(rx_ring);\n\n\tif (adapter->flags & IGB_FLAG_RX_LEGACY)\n\t\treturn;\n\n\tset_ring_build_skb_enabled(rx_ring);\n\n#if (PAGE_SIZE < 8192)\n\tif (adapter->max_frame_size > IGB_MAX_FRAME_BUILD_SKB ||\n\t    rd32(E1000_RCTL) & E1000_RCTL_SBP)\n\t\tset_ring_uses_large_buffer(rx_ring);\n#endif\n}\n\n/**\n *  igb_configure_rx - Configure receive Unit after Reset\n *  @adapter: board private structure\n *\n *  Configure the Rx unit of the MAC after a reset.\n **/\nstatic void igb_configure_rx(struct igb_adapter *adapter)\n{\n\tint i;\n\n\t/* set the correct pool for the PF default MAC address in entry 0 */\n\tigb_set_default_mac_filter(adapter);\n\n\t/* Setup the HW Rx Head and Tail Descriptor Pointers and\n\t * the Base and Length of the Rx Descriptor Ring\n\t */\n\tfor (i = 0; i < adapter->num_rx_queues; i++) {\n\t\tstruct igb_ring *rx_ring = adapter->rx_ring[i];\n\n\t\tigb_set_rx_buffer_len(adapter, rx_ring);\n\t\tigb_configure_rx_ring(adapter, rx_ring);\n\t}\n}\n",
    "source": "real-world",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 37,
    "typechecks": true,
    "cve": "CVE-2023-45871",
    "project": "linux"
  },
  {
    "prompt": "Security review of this code:\n\n#include <pjlib-util/dns.h>\n#include <pjlib-util/errno.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/pool.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n\nPJ_DEF(const char *) pj_dns_get_type_name(int type)\n{\n    switch (type) {\n    case PJ_DNS_TYPE_A:     return \"A\";\n    case PJ_DNS_TYPE_AAAA:  return \"AAAA\";\n    case PJ_DNS_TYPE_SRV:   return \"SRV\";\n    case PJ_DNS_TYPE_NS:    return \"NS\";\n    case PJ_DNS_TYPE_CNAME: return \"CNAME\";\n    case PJ_DNS_TYPE_PTR:   return \"PTR\";\n    case PJ_DNS_TYPE_MX:    return \"MX\";\n    case PJ_DNS_TYPE_TXT:   return \"TXT\";\n    case PJ_DNS_TYPE_NAPTR: return \"NAPTR\";\n    }\n    return \"(Unknown)\";\n}\n\n\nstatic void write16(pj_uint8_t *p, pj_uint16_t val)\n{\n    p[0] = (pj_uint8_t)(val >> 8);\n    p[1] = (pj_uint8_t)(val & 0xFF);\n}\n\n\n/**\n * Initialize a DNS query transaction.\n */\nPJ_DEF(pj_status_t) pj_dns_make_query( void *packet,\n                                       unsigned *size,\n                                       pj_uint16_t id,\n                                       int qtype,\n                                       const pj_str_t *name)\n{\n    pj_uint8_t *p = (pj_uint8_t*)packet;\n    const char *startlabel, *endlabel, *endname;\n    pj_size_t d;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(packet && size && qtype && name, PJ_EINVAL);\n\n    /* Calculate total number of bytes required. */\n    d = sizeof(pj_dns_hdr) + name->slen + 4;\n\n    /* Check that size is sufficient. */\n    PJ_ASSERT_RETURN(*size >= d, PJLIB_UTIL_EDNSQRYTOOSMALL);\n\n    /* Initialize header */\n    pj_assert(sizeof(pj_dns_hdr)==12);\n    pj_bzero(p, sizeof(struct pj_dns_hdr));\n    write16(p+0, id);\n    write16(p+2, (pj_uint16_t)PJ_DNS_SET_RD(1));\n    write16(p+4, (pj_uint16_t)1);\n\n    /* Initialize query */\n    p = ((pj_uint8_t*)packet)+sizeof(pj_dns_hdr);\n\n    /* Tokenize name */\n    startlabel = endlabel = name->ptr;\n    endname = name->ptr + name->slen;\n    while (endlabel != endname) {\n        while (endlabel != endname && *endlabel != '.')\n            ++endlabel;\n        *p++ = (pj_uint8_t)(endlabel - startlabel);\n        pj_memcpy(p, startlabel, endlabel-startlabel);\n        p += (endlabel-startlabel);\n        if (endlabel != endname && *endlabel == '.')\n            ++endlabel;\n        startlabel = endlabel;\n    }\n    *p++ = '\\0';\n\n    /* Set type */\n    write16(p, (pj_uint16_t)qtype);\n    p += 2;\n\n    /* Set class (IN=1) */\n    write16(p, 1);\n    p += 2;\n\n    /* Done, calculate length */\n    *size = (unsigned)(p - (pj_uint8_t*)packet);\n\n    return 0;\n}\n\n\n/* Get a name length (note: name consists of multiple labels and\n * it may contain pointers when name compression is applied) \n */\nstatic pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Get the name length from that offset. */\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            *parsed_len += 2;\n            *name_len += ptr_len;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n\n            if (*p != 0)\n                ++label_len;\n            \n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse and copy name (note: name consists of multiple labels and\n * it may contain pointers when compression is applied).\n */\nstatic pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Retrieve the name from that offset. */\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse query records. */\nstatic pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n                               const pj_uint8_t *pkt, const pj_uint8_t *start,\n                               const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p + 4 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse RR records */\nstatic pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool,\n                            const pj_uint8_t *pkt,\n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    rr->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &rr->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p+10 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&rr->type, p, 2);\n    rr->type = pj_ntohs(rr->type);\n    p += 2;\n    \n    /* Get the class */\n    pj_memcpy(&rr->dnsclass, p, 2);\n    rr->dnsclass = pj_ntohs(rr->dnsclass);\n    p += 2;\n\n    /* Class MUST be IN */\n    if (rr->dnsclass != 1) {\n        /* Class is not IN, return error only if type is known (see #1889) */\n        if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  ||\n            rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    ||\n            rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV)\n        {\n            return PJLIB_UTIL_EDNSINCLASS;\n        }\n    }\n\n    /* Get TTL */\n    pj_memcpy(&rr->ttl, p, 4);\n    rr->ttl = pj_ntohl(rr->ttl);\n    p += 4;\n\n    /* Get rdlength */\n    pj_memcpy(&rr->rdlength, p, 2);\n    rr->rdlength = pj_ntohs(rr->rdlength);\n    p += 2;\n\n    /* Check that length is valid */\n    if (p + rr->rdlength > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Parse some well known records */\n    if (rr->type == PJ_DNS_TYPE_A) {\n        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n        p += 4;\n\n    } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n        pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n        p += 16;\n\n    } else if (rr->type == PJ_DNS_TYPE_CNAME ||\n               rr->type == PJ_DNS_TYPE_NS ||\n               rr->type == PJ_DNS_TYPE_PTR) \n    {\n\n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.cname.name.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.cname.name);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        p += name_part_len;\n\n    } else if (rr->type == PJ_DNS_TYPE_SRV) {\n\n        /* Priority */\n        pj_memcpy(&rr->rdata.srv.prio, p, 2);\n        rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio);\n        p += 2;\n\n        /* Weight */\n        pj_memcpy(&rr->rdata.srv.weight, p, 2);\n        rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight);\n        p += 2;\n\n        /* Port */\n        pj_memcpy(&rr->rdata.srv.port, p, 2);\n        rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port);\n        p += 2;\n        \n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.srv.target.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.srv.target);\n        if (status != PJ_SUCCESS)\n            return status;\n        p += name_part_len;\n\n    } else {\n        /* Copy the raw data */\n        rr->data = pj_pool_alloc(pool, rr->rdlength);\n        pj_memcpy(rr->data, p, rr->rdlength);\n\n        p += rr->rdlength;\n    }\n\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse raw DNS packet into DNS packet structure.\n */\nPJ_DEF(pj_status_t) pj_dns_parse_packet( pj_pool_t *pool,\n                                         const void *packet,\n                                         unsigned size,\n                                         pj_dns_parsed_packet **p_res)\n{\n    pj_dns_parsed_packet *res;\n    const pj_uint8_t *start, *end;\n    pj_status_t status;\n    unsigned i;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(pool && packet && size && p_res, PJ_EINVAL);\n\n    /* Packet size must be at least as big as the header */\n    if (size < sizeof(pj_dns_hdr))\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Create the structure */\n    res = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n\n    /* Copy the DNS header, and convert endianness to host byte order */\n    pj_memcpy(&res->hdr, packet, sizeof(pj_dns_hdr));\n    res->hdr.id       = pj_ntohs(res->hdr.id);\n    res->hdr.flags    = pj_ntohs(res->hdr.flags);\n    res->hdr.qdcount  = pj_ntohs(res->hdr.qdcount);\n    res->hdr.anscount = pj_ntohs(res->hdr.anscount);\n    res->hdr.nscount  = pj_ntohs(res->hdr.nscount);\n    res->hdr.arcount  = pj_ntohs(res->hdr.arcount);\n\n    /* Mark start and end of payload */\n    start = ((const pj_uint8_t*)packet) + sizeof(pj_dns_hdr);\n    end = ((const pj_uint8_t*)packet) + size;\n\n    /* Parse query records (if any).\n     */\n    if (res->hdr.qdcount) {\n        res->q = (pj_dns_parsed_query*)\n                 pj_pool_zalloc(pool, res->hdr.qdcount *\n                                      sizeof(pj_dns_parsed_query));\n        for (i=0; i<res->hdr.qdcount; ++i) {\n            int parsed_len = 0;\n            \n            status = parse_query(&res->q[i], pool, (const pj_uint8_t*)packet, \n                                 start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse answer, if any */\n    if (res->hdr.anscount) {\n        res->ans = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.anscount * \n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.anscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ans[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse authoritative NS records, if any */\n    if (res->hdr.nscount) {\n        res->ns = (pj_dns_parsed_rr*)\n                  pj_pool_zalloc(pool, res->hdr.nscount *\n                                       sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.nscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ns[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse additional RR answer, if any */\n    if (res->hdr.arcount) {\n        res->arr = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.arcount *\n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.arcount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->arr[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Looks like everything is okay */\n    *p_res = res;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Perform name compression scheme.\n * If a name is already in the nametable, when no need to duplicate\n * the string with the pool, but rather just use the pointer there.\n */\nstatic void apply_name_table( unsigned *count,\n                              pj_str_t nametable[],\n                              const pj_str_t *src,\n                              pj_pool_t *pool,\n                              pj_str_t *dst)\n{\n    unsigned i;\n\n    /* Scan strings in nametable */\n    for (i=0; i<*count; ++i) {\n        if (pj_stricmp(&nametable[i], src) == 0)\n            break;\n    }\n\n    /* If name is found in nametable, use the pointer in the nametable */\n    if (i != *count) {\n        dst->ptr = nametable[i].ptr;\n        dst->slen = nametable[i].slen;\n        return;\n    }\n\n    /* Otherwise duplicate the string, and insert new name in nametable */\n    pj_strdup(pool, dst, src);\n\n    if (*count < PJ_DNS_MAX_NAMES_IN_NAMETABLE) {\n        nametable[*count].ptr = dst->ptr;\n        nametable[*count].slen = dst->slen;\n\n        ++(*count);\n    }\n}\n\nstatic void copy_query(pj_pool_t *pool, pj_dns_parsed_query *dst,\n                       const pj_dns_parsed_query *src,\n                       unsigned *nametable_count,\n                       pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n}\n\n\nstatic void copy_rr(pj_pool_t *pool, pj_dns_parsed_rr *dst,\n                    const pj_dns_parsed_rr *src,\n                    unsigned *nametable_count,\n                    pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n\n    if (src->data) {\n        dst->data = pj_pool_alloc(pool, src->rdlength);\n        pj_memcpy(dst->data, src->data, src->rdlength);\n    }\n\n    if (src->type == PJ_DNS_TYPE_SRV) {\n        apply_name_table(nametable_count, nametable, &src->rdata.srv.target, \n                         pool, &dst->rdata.srv.target);\n    } else if (src->type == PJ_DNS_TYPE_A) {\n        dst->rdata.a.ip_addr.s_addr =  src->rdata.a.ip_addr.s_addr;\n    } else if (src->type == PJ_DNS_TYPE_AAAA) {\n        pj_memcpy(&dst->rdata.aaaa.ip_addr, &src->rdata.aaaa.ip_addr,\n                  sizeof(pj_in6_addr));\n    } else if (src->type == PJ_DNS_TYPE_CNAME) {\n        pj_strdup(pool, &dst->rdata.cname.name, &src->rdata.cname.name);\n    } else if (src->type == PJ_DNS_TYPE_NS) {\n        pj_strdup(pool, &dst->rdata.ns.name, &src->rdata.ns.name);\n    } else if (src->type == PJ_DNS_TYPE_PTR) {\n        pj_strdup(pool, &dst->rdata.ptr.name, &src->rdata.ptr.name);\n    }\n}\n\n/*\n * Duplicate DNS packet.\n */\nPJ_DEF(void) pj_dns_packet_dup(pj_pool_t *pool,\n                               const pj_dns_parsed_packet*p,\n                               unsigned options,\n                               pj_dns_parsed_packet **p_dst)\n{\n    pj_dns_parsed_packet *dst;\n    unsigned nametable_count = 0;\n#if PJ_DNS_MAX_NAMES_IN_NAMETABLE\n    pj_str_t nametable[PJ_DNS_MAX_NAMES_IN_NAMETABLE];\n#else\n    pj_str_t *nametable = NULL;\n#endif\n    unsigned i;\n\n    PJ_ASSERT_ON_FAIL(pool && p && p_dst, return);\n\n    /* Create packet and copy header */\n    *p_dst = dst = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n    pj_memcpy(&dst->hdr, &p->hdr, sizeof(p->hdr));\n\n    /* Initialize section counts in the target packet to zero.\n     * If memory allocation fails during copying process, the target packet\n     * should have a correct section counts.\n     */\n    dst->hdr.qdcount = 0;\n    dst->hdr.anscount = 0;\n    dst->hdr.nscount = 0;\n    dst->hdr.arcount = 0;\n        \n\n    /* Copy query section */\n    if (p->hdr.qdcount && (options & PJ_DNS_NO_QD)==0) {\n        dst->q = (pj_dns_parsed_query*)\n                 pj_pool_alloc(pool, p->hdr.qdcount * \n                                     sizeof(pj_dns_parsed_query));\n        for (i=0; i<p->hdr.qdcount; ++i) {\n            copy_query(pool, &dst->q[i], &p->q[i], \n                       &nametable_count, nametable);\n            ++dst->hdr.qdcount;\n        }\n    }\n\n    /* Copy answer section */\n    if (p->hdr.anscount && (options & PJ_DNS_NO_ANS)==0) {\n        dst->ans = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.anscount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.anscount; ++i) {\n            copy_rr(pool, &dst->ans[i], &p->ans[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.anscount;\n        }\n    }\n\n    /* Copy NS section */\n    if (p->hdr.nscount && (options & PJ_DNS_NO_NS)==0) {\n        dst->ns = (pj_dns_parsed_rr*)\n                  pj_pool_alloc(pool, p->hdr.nscount * \n                                      sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.nscount; ++i) {\n            copy_rr(pool, &dst->ns[i], &p->ns[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.nscount;\n        }\n    }\n\n    /* Copy additional info section */\n    if (p->hdr.arcount && (options & PJ_DNS_NO_AR)==0) {\n        dst->arr = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.arcount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.arcount; ++i) {\n            copy_rr(pool, &dst->arr[i], &p->arr[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.arcount;\n        }\n    }\n}\n\n\nPJ_DEF(void) pj_dns_init_srv_rr( pj_dns_parsed_rr *rec,\n                                 const pj_str_t *res_name,\n                                 unsigned dnsclass,\n                                 unsigned ttl,\n                                 unsigned prio,\n                                 unsigned weight,\n                                 unsigned port,\n                                 const pj_str_t *target)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_SRV;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.srv.prio = (pj_uint16_t) prio;\n    rec->rdata.srv.weight = (pj_uint16_t) weight;\n    rec->rdata.srv.port = (pj_uint16_t) port;\n    rec->rdata.srv.target = *target;\n}\n\n\nPJ_DEF(void) pj_dns_init_cname_rr( pj_dns_parsed_rr *rec,\n                                   const pj_str_t *res_name,\n                                   unsigned dnsclass,\n                                   unsigned ttl,\n                                   const pj_str_t *name)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_CNAME;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.cname.name = *name;\n}\n",
    "completion": "This code contains security vulnerabilities.",
    "mutated_program": "#include <pjlib-util/dns.h>\n#include <pjlib-util/errno.h>\n#include <pj/assert.h>\n#include <pj/errno.h>\n#include <pj/pool.h>\n#include <pj/sock.h>\n#include <pj/string.h>\n\n\nPJ_DEF(const char *) pj_dns_get_type_name(int type)\n{\n    switch (type) {\n    case PJ_DNS_TYPE_A:     return \"A\";\n    case PJ_DNS_TYPE_AAAA:  return \"AAAA\";\n    case PJ_DNS_TYPE_SRV:   return \"SRV\";\n    case PJ_DNS_TYPE_NS:    return \"NS\";\n    case PJ_DNS_TYPE_CNAME: return \"CNAME\";\n    case PJ_DNS_TYPE_PTR:   return \"PTR\";\n    case PJ_DNS_TYPE_MX:    return \"MX\";\n    case PJ_DNS_TYPE_TXT:   return \"TXT\";\n    case PJ_DNS_TYPE_NAPTR: return \"NAPTR\";\n    }\n    return \"(Unknown)\";\n}\n\n\nstatic void write16(pj_uint8_t *p, pj_uint16_t val)\n{\n    p[0] = (pj_uint8_t)(val >> 8);\n    p[1] = (pj_uint8_t)(val & 0xFF);\n}\n\n\n/**\n * Initialize a DNS query transaction.\n */\nPJ_DEF(pj_status_t) pj_dns_make_query( void *packet,\n                                       unsigned *size,\n                                       pj_uint16_t id,\n                                       int qtype,\n                                       const pj_str_t *name)\n{\n    pj_uint8_t *p = (pj_uint8_t*)packet;\n    const char *startlabel, *endlabel, *endname;\n    pj_size_t d;\n\n    /* Sanity check */\n    PJ_ASSERT_RETURN(packet && size && qtype && name, PJ_EINVAL);\n\n    /* Calculate total number of bytes required. */\n    d = sizeof(pj_dns_hdr) + name->slen + 4;\n\n    /* Check that size is sufficient. */\n    PJ_ASSERT_RETURN(*size >= d, PJLIB_UTIL_EDNSQRYTOOSMALL);\n\n    /* Initialize header */\n    pj_assert(sizeof(pj_dns_hdr)==12);\n    pj_bzero(p, sizeof(struct pj_dns_hdr));\n    write16(p+0, id);\n    write16(p+2, (pj_uint16_t)PJ_DNS_SET_RD(1));\n    write16(p+4, (pj_uint16_t)1);\n\n    /* Initialize query */\n    p = ((pj_uint8_t*)packet)+sizeof(pj_dns_hdr);\n\n    /* Tokenize name */\n    startlabel = endlabel = name->ptr;\n    endname = name->ptr + name->slen;\n    while (endlabel != endname) {\n        while (endlabel != endname && *endlabel != '.')\n            ++endlabel;\n        *p++ = (pj_uint8_t)(endlabel - startlabel);\n        pj_memcpy(p, startlabel, endlabel-startlabel);\n        p += (endlabel-startlabel);\n        if (endlabel != endname && *endlabel == '.')\n            ++endlabel;\n        startlabel = endlabel;\n    }\n    *p++ = '\\0';\n\n    /* Set type */\n    write16(p, (pj_uint16_t)qtype);\n    p += 2;\n\n    /* Set class (IN=1) */\n    write16(p, 1);\n    p += 2;\n\n    /* Done, calculate length */\n    *size = (unsigned)(p - (pj_uint8_t*)packet);\n\n    return 0;\n}\n\n\n/* Get a name length (note: name consists of multiple labels and\n * it may contain pointers when name compression is applied) \n */\nstatic pj_status_t get_name_len(int rec_counter, const pj_uint8_t *pkt, \n                                const pj_uint8_t *start, const pj_uint8_t *max, \n                                int *parsed_len, int *name_len)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n\n    *name_len = *parsed_len = 0;\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            int ptr_len = 0;\n            int dummy;\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Get the name length from that offset. */\n            status = get_name_len(rec_counter+1, pkt, pkt + offset, max, \n                                  &dummy, &ptr_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            *parsed_len += 2;\n            *name_len += ptr_len;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            p += (label_len + 1);\n            *parsed_len += (label_len + 1);\n\n            if (*p != 0)\n                ++label_len;\n            \n            *name_len += label_len;\n        }\n    }\n    ++p;\n    (*parsed_len)++;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse and copy name (note: name consists of multiple labels and\n * it may contain pointers when compression is applied).\n */\nstatic pj_status_t get_name(int rec_counter, const pj_uint8_t *pkt, \n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            pj_str_t *name)\n{\n    const pj_uint8_t *p;\n    pj_status_t status;\n\n    /* Limit the number of recursion */\n    if (rec_counter > 10) {\n        /* Too many name recursion */\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n    }\n\n    if (start >= max)\n        return PJLIB_UTIL_EDNSINNAMEPTR;\n\n    p = start;\n    while (*p) {\n        if ((*p & 0xc0) == 0xc0) {\n            /* Compression is found! */\n            pj_uint16_t offset;\n\n            /* Get the 14bit offset */\n            pj_memcpy(&offset, p, 2);\n            offset ^= pj_htons((pj_uint16_t)(0xc0 << 8));\n            offset = pj_ntohs(offset);\n\n            /* Check that offset is valid */\n            if (offset >= max - pkt)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            /* Retrieve the name from that offset. */\n            status = get_name(rec_counter+1, pkt, pkt + offset, max, name);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            return PJ_SUCCESS;\n        } else {\n            unsigned label_len = *p;\n\n            /* Check that label length is valid.\n             * Each label consists of an octet length (of size 1) followed\n             * by the octet of the specified length (label_len). Then it\n             * must be followed by either another label's octet length or\n             * a zero length octet (that terminates the sequence).\n             */\n            if (p+1+label_len+1 > max)\n                return PJLIB_UTIL_EDNSINNAMEPTR;\n\n            pj_memcpy(name->ptr + name->slen, p+1, label_len);\n            name->slen += label_len;\n\n            p += label_len + 1;\n            if (*p != 0) {\n                *(name->ptr + name->slen) = '.';\n                ++name->slen;\n            }\n        }\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse query records. */\nstatic pj_status_t parse_query(pj_dns_parsed_query *q, pj_pool_t *pool,\n                               const pj_uint8_t *pkt, const pj_uint8_t *start,\n                               const pj_uint8_t *max, int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    q->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    q->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &q->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p + 4 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&q->type, p, 2);\n    q->type = pj_ntohs(q->type);\n    p += 2;\n\n    /* Get the class */\n    pj_memcpy(&q->dnsclass, p, 2);\n    q->dnsclass = pj_ntohs(q->dnsclass);\n    p += 2;\n\n    *parsed_len = (int)(p - start);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Parse RR records */\nstatic pj_status_t parse_rr(pj_dns_parsed_rr *rr, pj_pool_t *pool,\n                            const pj_uint8_t *pkt,\n                            const pj_uint8_t *start, const pj_uint8_t *max,\n                            int *parsed_len)\n{\n    const pj_uint8_t *p = start;\n    int name_len, name_part_len;\n    pj_status_t status;\n\n    /* Get the length of the name */\n    status = get_name_len(0, pkt, start, max, &name_part_len, &name_len);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    /* Allocate memory for the name */\n    rr->name.ptr = (char*) pj_pool_alloc(pool, name_len+4);\n    rr->name.slen = 0;\n\n    /* Get the name */\n    status = get_name(0, pkt, start, max, &rr->name);\n    if (status != PJ_SUCCESS)\n        return status;\n\n    p = (start + name_part_len);\n\n    /* Check the size can accomodate next few fields. */\n    if (p+10 > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Get the type */\n    pj_memcpy(&rr->type, p, 2);\n    rr->type = pj_ntohs(rr->type);\n    p += 2;\n    \n    /* Get the class */\n    pj_memcpy(&rr->dnsclass, p, 2);\n    rr->dnsclass = pj_ntohs(rr->dnsclass);\n    p += 2;\n\n    /* Class MUST be IN */\n    if (rr->dnsclass != 1) {\n        /* Class is not IN, return error only if type is known (see #1889) */\n        if (rr->type == PJ_DNS_TYPE_A     || rr->type == PJ_DNS_TYPE_AAAA  ||\n            rr->type == PJ_DNS_TYPE_CNAME || rr->type == PJ_DNS_TYPE_NS    ||\n            rr->type == PJ_DNS_TYPE_PTR   || rr->type == PJ_DNS_TYPE_SRV)\n        {\n            return PJLIB_UTIL_EDNSINCLASS;\n        }\n    }\n\n    /* Get TTL */\n    pj_memcpy(&rr->ttl, p, 4);\n    rr->ttl = pj_ntohl(rr->ttl);\n    p += 4;\n\n    /* Get rdlength */\n    pj_memcpy(&rr->rdlength, p, 2);\n    rr->rdlength = pj_ntohs(rr->rdlength);\n    p += 2;\n\n    /* Check that length is valid */\n    if (p + rr->rdlength > max)\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Parse some well known records */\n    if (rr->type == PJ_DNS_TYPE_A) {\n        if (p + 4 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.a.ip_addr, p, 4);\n        p += 4;\n\n    } else if (rr->type == PJ_DNS_TYPE_AAAA) {\n        if (p + 16 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n        pj_memcpy(&rr->rdata.aaaa.ip_addr, p, 16);\n        p += 16;\n\n    } else if (rr->type == PJ_DNS_TYPE_CNAME ||\n               rr->type == PJ_DNS_TYPE_NS ||\n               rr->type == PJ_DNS_TYPE_PTR) \n    {\n\n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.cname.name.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.cname.name.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.cname.name);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        p += name_part_len;\n\n    } else if (rr->type == PJ_DNS_TYPE_SRV) {\n        if (p + 6 > max)\n            return PJLIB_UTIL_EDNSINSIZE;\n\n        /* Priority */\n        pj_memcpy(&rr->rdata.srv.prio, p, 2);\n        rr->rdata.srv.prio = pj_ntohs(rr->rdata.srv.prio);\n        p += 2;\n\n        /* Weight */\n        pj_memcpy(&rr->rdata.srv.weight, p, 2);\n        rr->rdata.srv.weight = pj_ntohs(rr->rdata.srv.weight);\n        p += 2;\n\n        /* Port */\n        pj_memcpy(&rr->rdata.srv.port, p, 2);\n        rr->rdata.srv.port = pj_ntohs(rr->rdata.srv.port);\n        p += 2;\n        \n        /* Get the length of the target name */\n        status = get_name_len(0, pkt, p, max, &name_part_len, &name_len);\n        if (status != PJ_SUCCESS)\n            return status;\n\n        /* Allocate memory for the name */\n        rr->rdata.srv.target.ptr = (char*) pj_pool_alloc(pool, name_len);\n        rr->rdata.srv.target.slen = 0;\n\n        /* Get the name */\n        status = get_name(0, pkt, p, max, &rr->rdata.srv.target);\n        if (status != PJ_SUCCESS)\n            return status;\n        p += name_part_len;\n\n    } else {\n        /* Copy the raw data */\n        rr->data = pj_pool_alloc(pool, rr->rdlength);\n        pj_memcpy(rr->data, p, rr->rdlength);\n\n        p += rr->rdlength;\n    }\n\n    *parsed_len = (int)(p - start);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Parse raw DNS packet into DNS packet structure.\n */\nPJ_DEF(pj_status_t) pj_dns_parse_packet( pj_pool_t *pool,\n                                         const void *packet,\n                                         unsigned size,\n                                         pj_dns_parsed_packet **p_res)\n{\n    pj_dns_parsed_packet *res;\n    const pj_uint8_t *start, *end;\n    pj_status_t status;\n    unsigned i;\n\n    /* Sanity checks */\n    PJ_ASSERT_RETURN(pool && packet && size && p_res, PJ_EINVAL);\n\n    /* Packet size must be at least as big as the header */\n    if (size < sizeof(pj_dns_hdr))\n        return PJLIB_UTIL_EDNSINSIZE;\n\n    /* Create the structure */\n    res = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n\n    /* Copy the DNS header, and convert endianness to host byte order */\n    pj_memcpy(&res->hdr, packet, sizeof(pj_dns_hdr));\n    res->hdr.id       = pj_ntohs(res->hdr.id);\n    res->hdr.flags    = pj_ntohs(res->hdr.flags);\n    res->hdr.qdcount  = pj_ntohs(res->hdr.qdcount);\n    res->hdr.anscount = pj_ntohs(res->hdr.anscount);\n    res->hdr.nscount  = pj_ntohs(res->hdr.nscount);\n    res->hdr.arcount  = pj_ntohs(res->hdr.arcount);\n\n    /* Mark start and end of payload */\n    start = ((const pj_uint8_t*)packet) + sizeof(pj_dns_hdr);\n    end = ((const pj_uint8_t*)packet) + size;\n\n    /* Parse query records (if any).\n     */\n    if (res->hdr.qdcount) {\n        res->q = (pj_dns_parsed_query*)\n                 pj_pool_zalloc(pool, res->hdr.qdcount *\n                                      sizeof(pj_dns_parsed_query));\n        for (i=0; i<res->hdr.qdcount; ++i) {\n            int parsed_len = 0;\n            \n            status = parse_query(&res->q[i], pool, (const pj_uint8_t*)packet, \n                                 start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse answer, if any */\n    if (res->hdr.anscount) {\n        res->ans = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.anscount * \n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.anscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ans[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse authoritative NS records, if any */\n    if (res->hdr.nscount) {\n        res->ns = (pj_dns_parsed_rr*)\n                  pj_pool_zalloc(pool, res->hdr.nscount *\n                                       sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.nscount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->ns[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Parse additional RR answer, if any */\n    if (res->hdr.arcount) {\n        res->arr = (pj_dns_parsed_rr*)\n                   pj_pool_zalloc(pool, res->hdr.arcount *\n                                        sizeof(pj_dns_parsed_rr));\n\n        for (i=0; i<res->hdr.arcount; ++i) {\n            int parsed_len;\n\n            status = parse_rr(&res->arr[i], pool, (const pj_uint8_t*)packet, \n                              start, end, &parsed_len);\n            if (status != PJ_SUCCESS)\n                return status;\n\n            start += parsed_len;\n        }\n    }\n\n    /* Looks like everything is okay */\n    *p_res = res;\n\n    return PJ_SUCCESS;\n}\n\n\n/* Perform name compression scheme.\n * If a name is already in the nametable, when no need to duplicate\n * the string with the pool, but rather just use the pointer there.\n */\nstatic void apply_name_table( unsigned *count,\n                              pj_str_t nametable[],\n                              const pj_str_t *src,\n                              pj_pool_t *pool,\n                              pj_str_t *dst)\n{\n    unsigned i;\n\n    /* Scan strings in nametable */\n    for (i=0; i<*count; ++i) {\n        if (pj_stricmp(&nametable[i], src) == 0)\n            break;\n    }\n\n    /* If name is found in nametable, use the pointer in the nametable */\n    if (i != *count) {\n        dst->ptr = nametable[i].ptr;\n        dst->slen = nametable[i].slen;\n        return;\n    }\n\n    /* Otherwise duplicate the string, and insert new name in nametable */\n    pj_strdup(pool, dst, src);\n\n    if (*count < PJ_DNS_MAX_NAMES_IN_NAMETABLE) {\n        nametable[*count].ptr = dst->ptr;\n        nametable[*count].slen = dst->slen;\n\n        ++(*count);\n    }\n}\n\nstatic void copy_query(pj_pool_t *pool, pj_dns_parsed_query *dst,\n                       const pj_dns_parsed_query *src,\n                       unsigned *nametable_count,\n                       pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n}\n\n\nstatic void copy_rr(pj_pool_t *pool, pj_dns_parsed_rr *dst,\n                    const pj_dns_parsed_rr *src,\n                    unsigned *nametable_count,\n                    pj_str_t nametable[])\n{\n    pj_memcpy(dst, src, sizeof(*src));\n    apply_name_table(nametable_count, nametable, &src->name, pool, &dst->name);\n\n    if (src->data) {\n        dst->data = pj_pool_alloc(pool, src->rdlength);\n        pj_memcpy(dst->data, src->data, src->rdlength);\n    }\n\n    if (src->type == PJ_DNS_TYPE_SRV) {\n        apply_name_table(nametable_count, nametable, &src->rdata.srv.target, \n                         pool, &dst->rdata.srv.target);\n    } else if (src->type == PJ_DNS_TYPE_A) {\n        dst->rdata.a.ip_addr.s_addr =  src->rdata.a.ip_addr.s_addr;\n    } else if (src->type == PJ_DNS_TYPE_AAAA) {\n        pj_memcpy(&dst->rdata.aaaa.ip_addr, &src->rdata.aaaa.ip_addr,\n                  sizeof(pj_in6_addr));\n    } else if (src->type == PJ_DNS_TYPE_CNAME) {\n        pj_strdup(pool, &dst->rdata.cname.name, &src->rdata.cname.name);\n    } else if (src->type == PJ_DNS_TYPE_NS) {\n        pj_strdup(pool, &dst->rdata.ns.name, &src->rdata.ns.name);\n    } else if (src->type == PJ_DNS_TYPE_PTR) {\n        pj_strdup(pool, &dst->rdata.ptr.name, &src->rdata.ptr.name);\n    }\n}\n\n/*\n * Duplicate DNS packet.\n */\nPJ_DEF(void) pj_dns_packet_dup(pj_pool_t *pool,\n                               const pj_dns_parsed_packet*p,\n                               unsigned options,\n                               pj_dns_parsed_packet **p_dst)\n{\n    pj_dns_parsed_packet *dst;\n    unsigned nametable_count = 0;\n#if PJ_DNS_MAX_NAMES_IN_NAMETABLE\n    pj_str_t nametable[PJ_DNS_MAX_NAMES_IN_NAMETABLE];\n#else\n    pj_str_t *nametable = NULL;\n#endif\n    unsigned i;\n\n    PJ_ASSERT_ON_FAIL(pool && p && p_dst, return);\n\n    /* Create packet and copy header */\n    *p_dst = dst = PJ_POOL_ZALLOC_T(pool, pj_dns_parsed_packet);\n    pj_memcpy(&dst->hdr, &p->hdr, sizeof(p->hdr));\n\n    /* Initialize section counts in the target packet to zero.\n     * If memory allocation fails during copying process, the target packet\n     * should have a correct section counts.\n     */\n    dst->hdr.qdcount = 0;\n    dst->hdr.anscount = 0;\n    dst->hdr.nscount = 0;\n    dst->hdr.arcount = 0;\n        \n\n    /* Copy query section */\n    if (p->hdr.qdcount && (options & PJ_DNS_NO_QD)==0) {\n        dst->q = (pj_dns_parsed_query*)\n                 pj_pool_alloc(pool, p->hdr.qdcount * \n                                     sizeof(pj_dns_parsed_query));\n        for (i=0; i<p->hdr.qdcount; ++i) {\n            copy_query(pool, &dst->q[i], &p->q[i], \n                       &nametable_count, nametable);\n            ++dst->hdr.qdcount;\n        }\n    }\n\n    /* Copy answer section */\n    if (p->hdr.anscount && (options & PJ_DNS_NO_ANS)==0) {\n        dst->ans = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.anscount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.anscount; ++i) {\n            copy_rr(pool, &dst->ans[i], &p->ans[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.anscount;\n        }\n    }\n\n    /* Copy NS section */\n    if (p->hdr.nscount && (options & PJ_DNS_NO_NS)==0) {\n        dst->ns = (pj_dns_parsed_rr*)\n                  pj_pool_alloc(pool, p->hdr.nscount * \n                                      sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.nscount; ++i) {\n            copy_rr(pool, &dst->ns[i], &p->ns[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.nscount;\n        }\n    }\n\n    /* Copy additional info section */\n    if (p->hdr.arcount && (options & PJ_DNS_NO_AR)==0) {\n        dst->arr = (pj_dns_parsed_rr*)\n                   pj_pool_alloc(pool, p->hdr.arcount * \n                                       sizeof(pj_dns_parsed_rr));\n        for (i=0; i<p->hdr.arcount; ++i) {\n            copy_rr(pool, &dst->arr[i], &p->arr[i],\n                    &nametable_count, nametable);\n            ++dst->hdr.arcount;\n        }\n    }\n}\n\n\nPJ_DEF(void) pj_dns_init_srv_rr( pj_dns_parsed_rr *rec,\n                                 const pj_str_t *res_name,\n                                 unsigned dnsclass,\n                                 unsigned ttl,\n                                 unsigned prio,\n                                 unsigned weight,\n                                 unsigned port,\n                                 const pj_str_t *target)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_SRV;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.srv.prio = (pj_uint16_t) prio;\n    rec->rdata.srv.weight = (pj_uint16_t) weight;\n    rec->rdata.srv.port = (pj_uint16_t) port;\n    rec->rdata.srv.target = *target;\n}\n\n\nPJ_DEF(void) pj_dns_init_cname_rr( pj_dns_parsed_rr *rec,\n                                   const pj_str_t *res_name,\n                                   unsigned dnsclass,\n                                   unsigned ttl,\n                                   const pj_str_t *name)\n{\n    pj_bzero(rec, sizeof(*rec));\n    rec->name = *res_name;\n    rec->type = PJ_DNS_TYPE_CNAME;\n    rec->dnsclass = (pj_uint16_t) dnsclass;\n    rec->ttl = ttl;\n    rec->rdata.cname.name = *name;\n}\n",
    "source": "real-world",
    "cwe": "CWE-787",
    "vulnerability_type": "out_of_bounds_write",
    "idx": 38,
    "typechecks": true,
    "cve": "CVE-2023-27585",
    "project": "pjsip"
  }
]