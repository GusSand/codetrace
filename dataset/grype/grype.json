{"hexsha": "1de17023db3dd839d67e3c887e3f8f7ca9330af7", "size": 5795, "ext": "ts", "lang": "TypeScript", "max_stars_repo_path": "lunatrace/bsl/backend/src/types/grypeCvss.ts", "max_stars_repo_name": "dropbox/lunasec", "max_stars_repo_head_hexsha": "ab43697e3b3582fd0bd327d5f9654511f727cb99", "max_stars_repo_licenses": ["Apache-2.0"], "max_stars_count": null, "max_stars_repo_stars_event_min_datetime": null, "max_stars_repo_stars_event_max_datetime": null, "max_issues_repo_path": "lunatrace/bsl/backend/src/types/grypeCvss.ts", "max_issues_repo_name": "dropbox/lunasec", "max_issues_repo_head_hexsha": "ab43697e3b3582fd0bd327d5f9654511f727cb99", "max_issues_repo_licenses": ["Apache-2.0"], "max_issues_count": null, "max_issues_repo_issues_event_min_datetime": null, "max_issues_repo_issues_event_max_datetime": null, "max_forks_repo_path": "lunatrace/bsl/backend/src/types/grypeCvss.ts", "max_forks_repo_name": "dropbox/lunasec", "max_forks_repo_head_hexsha": "ab43697e3b3582fd0bd327d5f9654511f727cb99", "max_forks_repo_licenses": ["Apache-2.0"], "max_forks_count": 1.0, "max_forks_repo_forks_event_min_datetime": "2022-02-25T06:10:05.000Z", "max_forks_repo_forks_event_max_datetime": "2022-02-25T06:10:05.000Z", "content": "/*\n * Copyright by LunaSec (owned by Refinery Labs, Inc)\n *\n * Licensed under the Business Source License v1.1\n * (the \"License\"); you may not use this file except in compliance with the\n * License. You may obtain a copy of the License at\n *\n * https://github.com/lunasec-io/lunasec/blob/master/licenses/BSL-LunaTrace.txt\n *\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n/* eslint-disable */\n\n// To parse this data:\n//\n//   import { Convert } from \"./file\";\n//\n//   const grypeCvss = Convert.toGrypeCvss(json);\n//\n// These functions will throw an error if the JSON doesn't\n// match the expected interface, even if the JSON is valid.\n\nexport interface GrypeCvss {\n  VendorMetadata: any;\n  Metrics: Metrics;\n  Vector: string;\n  Version: string;\n}\n\nexport interface Metrics {\n  BaseScore: number;\n  ExploitabilityScore: number;\n  ImpactScore: number;\n}\n\n// Converts JSON strings to/from your types\n// and asserts the results of JSON.parse at runtime\nexport class Convert {\n  public static toGrypeCvss(json: string): GrypeCvss[] {\n    return cast(JSON.parse(json), a(r('GrypeCvss')));\n  }\n\n  public static grypeCvssToJson(value: GrypeCvss[]): string {\n    return JSON.stringify(uncast(value, a(r('GrypeCvss'))), null, 2);\n  }\n}\n\nfunction invalidValue(typ: any, val: any, key: any = ''): never {\n  if (key) {\n    throw Error(`Invalid value for key \"${key}\". Expected type ${JSON.stringify(typ)} but got ${JSON.stringify(val)}`);\n  }\n  throw Error(`Invalid value ${JSON.stringify(val)} for type ${JSON.stringify(typ)}`);\n}\n\nfunction jsonToJSProps(typ: any): any {\n  if (typ.jsonToJS === undefined) {\n    const map: any = {};\n    typ.props.forEach((p: any) => (map[p.json] = { key: p.js, typ: p.typ }));\n    typ.jsonToJS = map;\n  }\n  return typ.jsonToJS;\n}\n\nfunction jsToJSONProps(typ: any): any {\n  if (typ.jsToJSON === undefined) {\n    const map: any = {};\n    typ.props.forEach((p: any) => (map[p.js] = { key: p.json, typ: p.typ }));\n    typ.jsToJSON = map;\n  }\n  return typ.jsToJSON;\n}\n\nfunction transform(val: any, typ: any, getProps: any, key: any = ''): any {\n  function transformPrimitive(typ: string, val: any): any {\n    if (typeof typ === typeof val) return val;\n    return invalidValue(typ, val, key);\n  }\n\n  function transformUnion(typs: any[], val: any): any {\n    // val must validate against one typ in typs\n    const l = typs.length;\n    for (let i = 0; i < l; i++) {\n      const typ = typs[i];\n      try {\n        return transform(val, typ, getProps);\n      } catch (_) {}\n    }\n    return invalidValue(typs, val);\n  }\n\n  function transformEnum(cases: string[], val: any): any {\n    if (cases.indexOf(val) !== -1) return val;\n    return invalidValue(cases, val);\n  }\n\n  function transformArray(typ: any, val: any): any {\n    // val must be an array with no invalid elements\n    if (!Array.isArray(val)) return invalidValue('array', val);\n    return val.map((el) => transform(el, typ, getProps));\n  }\n\n  function transformDate(val: any): any {\n    if (val === null) {\n      return null;\n    }\n    const d = new Date(val);\n    if (isNaN(d.valueOf())) {\n      return invalidValue('Date', val);\n    }\n    return d;\n  }\n\n  function transformObject(props: { [k: string]: any }, additional: any, val: any): any {\n    if (val === null || typeof val !== 'object' || Array.isArray(val)) {\n      return invalidValue('object', val);\n    }\n    const result: any = {};\n    Object.getOwnPropertyNames(props).forEach((key) => {\n      const prop = props[key];\n      const v = Object.prototype.hasOwnProperty.call(val, key) ? val[key] : undefined;\n      result[prop.key] = transform(v, prop.typ, getProps, prop.key);\n    });\n    Object.getOwnPropertyNames(val).forEach((key) => {\n      if (!Object.prototype.hasOwnProperty.call(props, key)) {\n        result[key] = transform(val[key], additional, getProps, key);\n      }\n    });\n    return result;\n  }\n\n  if (typ === 'any') return val;\n  if (typ === null) {\n    if (val === null) return val;\n    return invalidValue(typ, val);\n  }\n  if (typ === false) return invalidValue(typ, val);\n  while (typeof typ === 'object' && typ.ref !== undefined) {\n    typ = typeMap[typ.ref];\n  }\n  if (Array.isArray(typ)) return transformEnum(typ, val);\n  if (typeof typ === 'object') {\n    return typ.hasOwnProperty('unionMembers')\n      ? transformUnion(typ.unionMembers, val)\n      : typ.hasOwnProperty('arrayItems')\n      ? transformArray(typ.arrayItems, val)\n      : typ.hasOwnProperty('props')\n      ? transformObject(getProps(typ), typ.additional, val)\n      : invalidValue(typ, val);\n  }\n  // Numbers can be parsed by Date but shouldn't be.\n  if (typ === Date && typeof val !== 'number') return transformDate(val);\n  return transformPrimitive(typ, val);\n}\n\nfunction cast<T>(val: any, typ: any): T {\n  return transform(val, typ, jsonToJSProps);\n}\n\nfunction uncast<T>(val: T, typ: any): any {\n  return transform(val, typ, jsToJSONProps);\n}\n\nfunction a(typ: any) {\n  return { arrayItems: typ };\n}\n\nfunction u(...typs: any[]) {\n  return { unionMembers: typs };\n}\n\nfunction o(props: any[], additional: any) {\n  return { props, additional };\n}\n\nfunction m(additional: any) {\n  return { props: [], additional };\n}\n\nfunction r(name: string) {\n  return { ref: name };\n}\n\nconst typeMap: any = {\n  GrypeCvss: o(\n    [\n      { json: 'VendorMetadata', js: 'VendorMetadata', typ: 'any' },\n      { json: 'Metrics', js: 'Metrics', typ: r('Metrics') },\n      { json: 'Vector', js: 'Vector', typ: '' },\n      { json: 'Version', js: 'Version', typ: '' },\n    ],\n    false\n  ),\n  Metrics: o(\n    [\n      { json: 'BaseScore', js: 'BaseScore', typ: 3.14 },\n      { json: 'ExploitabilityScore', js: 'ExploitabilityScore', typ: 3.14 },\n      { json: 'ImpactScore', js: 'ImpactScore', typ: 3.14 },\n    ],\n    false\n  ),\n};\n", "avg_line_length": 28.4068627451, "max_line_length": 119, "alphanum_fraction": 0.6245038827, "annotation_sites": 72, "type_definitions": 2, "loc": 142, "functions": 24, "loc_per_function": 5.875, "estimated_tokens": 1737}